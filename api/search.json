[{"id":"0c16b31803bde874a26f731a30be8316","title":"126、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(三)","content":"Vue.js 3 是一个声明式的 UI 框架，意思是说用户在使用 Vue.js 3 开发页面时是声明式地描述 UI 的。如何设计一个声明式框架呢？\n\n\n一、声明式描述 UIvue.js 3 是一个声明式的 UI 框架，如何设计 UI 框架，需要明确前端页面涉及的内容：\n1、DOM 元素：例如标签；2、属性：例如 class、id、style、src 等；3、事件：例如 click、mouseover、keydown 等；4、元素层级结构：DOM 树的层级结构，既有子节点，又有父节点。\n如何声明式的描述上面前端页面涉及的内容呢？vue.js 3 解决方案：1、使用 HTML 标签一致的方式来描述 dom 元素，例如：&lt;div&gt;&lt;/div&gt;;2、使用 HTML 标签一致的方式来描述属性，例如：&lt;div class=&#39;app&#39;&gt;&lt;/div&gt;;v-bind 来描述动态绑定的属性，例如：&lt;div :id=&quot;wrapper&quot;&gt;&lt;/div&gt;;3、使用 v-on 来描述事件，例如：&lt;div @click=&quot;handleClick&quot;&gt;&lt;/div&gt;;4、使用 HTML 标签一致的方式来描述元素层级结构，例如：&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;;\njs 对象描述 UI 页面：\njsconst title = &#123;\n  // 标签名称\n  tag: &#39;h1&#39;,\n  // 标签属性\n  props: &#123;\n    onClick: handler\n  &#125;,\n  // 子节点\n  children: [&#123; tag: &#39;span&#39; &#125;]\n&#125;对应的 vue.js 模板就是：\nhtml&lt;h1 @click=&quot;handler&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;js 对象来描述 UI 更具灵活性\njs//模板表示： js对象描述h1~h6标签，标签对应的名字会随着level值改变而变化\nlet level = 3\nconst title = &#123;\n  tag: `h$&#123;level&#125;`\n&#125;vue.js 使用 JS 对象来描述 UI 的方式，其实就是所谓的虚拟 DOM。其实我们在 vue.js 组件中手写渲染函数就是使用虚拟 DOM 来描述 UI 的。\njsimport &#123; h &#125; from &#39;vue&#39;\nexport default &#123;\n  render() &#123;\n    return h(&#39;div&#39;, &#123; onClick: handler &#125;)\n  &#125;\n&#125;上面的 h 函数返回值就是一个对象，其作用是让我们编写虚拟 DOM 变的更加轻松。\n如果把上面的 h 函数调用嗲买改成 js 对象，就需要写更多内容了：\njsexport default &#123;\n  render() &#123;\n    return &#123;\n      tag: &#39;h1&#39;,\n      props: &#123;\n        onClick: handler\n      &#125;\n    &#125;\n  &#125;\n&#125;如果还有子节点，写的内容就更多了，所以 h 函数就是一个辅助创建虚拟 dom 的工具函数，仅此而已。\n什么是组件的渲染函数？\n一个组件要渲染的内容是通过渲染函数来描述的，就是上面的 render 函数，vue.js 会根据组件的 render 函数的返回值拿到虚拟 dom，然后就可以把组件的内容渲染出来了。\n二、渲染器我们知道了虚拟 DOM 其实就是用 js 对象来描述真实的 dom 结构，那么 vue.js 是如何把虚拟 DOM 渲染成真实的 DOM 呢？\n渲染器的作用就是把虚拟 DOM 渲染为真实 DOM。\n编写一个渲染器，实现点击 div 标签，alert hello 功能\njs// 假设一个虚拟DOM\nconst vnode = &#123;\n  tag: &#39;div&#39;,\n  props: &#123;\n    onClick: () =&gt; alert(&#39;hello&#39;)\n  &#125;,\n  children: &#39;click me&#39; // 用来描述标签的子节点\n&#125;渲染器将上面虚拟 DOM 渲染为真实 DOM：\njsfunction renderer(vnode, container) &#123;\n  // 使用vnode.tag作为标签名称创建DOM元素\n  const el = document.createElement(vnode.tag)\n\n  // 遍历vnode.props，把props中的属性、事件添加到el中\n  for (const key in vnode.props) &#123;\n    // 如果key以on开头，说明是事件\n    if (/^on/.test(key)) &#123;\n      el.addEventListener(\n        key.substr(2).toLowerCase(), // 事件名称\n        vnode.props[key] // 事件处理函数\n      )\n    &#125;\n  &#125;\n  // 处理children\n  // 如果vnode.children是字符串，说明是文本子节点\n  if (typeof vnode.children === &#39;string&#39;) &#123;\n    el.appendChild(document.createTextNode(vnode.children))\n  &#125; else if (Array.isArray(vnode.children)) &#123;\n    // 递归调用renderer函数渲染子节点，使用当前元素el作为挂载节点\n    vnode.children.forEach((child) =&gt; renderer(child, el))\n  &#125;\n  // 将元素添加到挂载点下\n  container.appendChild(el)\n&#125;\n\nrenderer(vnode, document.body)renderer 函数的 2 个参数说明：\n\nvnode：虚拟 DOM 对象\ncontainer：真实 DOM 元素，作为挂载点，渲染器会把虚拟 DOM 渲染到该挂载点下。\n\nrenderer 渲染器的实现思路：\n创建元素：把 vnode.tag 作为标签名称来创建 DOM 元素。\n为元素添加属性和事件：遍历 vnode.props 对象，如果 key 以 on 字符开头，说明它是一个事件，把字符 on 截取掉后再调用 toLowerCase 函数将事件名称小写化，最终得到合法的事件名称，例如 onClick 会变成 click，最后调用 addEventListener 绑定事件处理函数。\n处理 children：如果 children 是一个数组，就递归地调用 renderer 继续渲染，注意，此时我们要把刚刚创建的元素作为挂载点（父节点）；如果 children 是字符串，则使用createTextNode 函数创建一个文本节点，并将其添加到新创建的元素内。\n三、组件的本质1. 组件的定义组件就是一组 DOM 元素的封装，这组 DOM 元素就是组件要渲染的内容，因此我们可以定义一个函数来代表组件，而函数的返回值就代表组件要渲染的内容：\n","slug":"126-vue","date":"2023-03-17T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"75275657f6e5a42d4fcfa3105206bba2","title":"125、el-table触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller","content":"el-table 的在数据量比较大的情况下，会卡顿，因为数据量太大，渲染速度跟不上。可以通过触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller 这些方案解决。\n\n\n一、触底加载html&lt;template&gt;\n  &lt;!-- 触底加载 --&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;el-table\n      v-el-table-infinite-scroll=&quot;load&quot;\n      height=&quot;480&quot;\n      :data=&quot;tableData&quot;\n      border\n      style=&quot;width: 80%&quot;\n      v-loading=&quot;loading&quot;\n      element-loading-text=&quot;数据量太大啦，客官稍后...&quot;\n      element-loading-spinner=&quot;el-icon-loading&quot;\n      element-loading-background=&quot;rgba(255, 255, 255, 0.5)&quot;\n      :header-cell-style=&quot;&#123;\n        height: &#39;24px&#39;,\n        lineHeight: &#39;24px&#39;,\n        color: &#39;#606266&#39;,\n        background: &#39;#F5F5F5&#39;,\n        fontWeight: &#39;bold&#39;,\n      &#125;&quot;\n    &gt;\n      &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot;&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot;&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column prop=&quot;value&quot; label=&quot;对应值&quot;&gt;&lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script&gt;\nfunction averageFn(arr) &#123;\n  let i = 0;\n  let result = [];\n  while (i &lt; arr.length) &#123;\n    // 一次截取10个用于分堆\n    result.push(arr.slice(i, i + 10));\n    // 这10个截取完，再准备截取下10个\n    i = i + 10;\n  &#125;\n  return result;\n&#125;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      allTableData: [],\n      tableData: [],\n      loading: false,\n    &#125;;\n  &#125;,\n  // 第一步，请求大量数据时候，转成二维数组，分堆分组分块存储\n  async created() &#123;\n    this.loading = true;\n    const res = await axios.get(&quot;XXXX&quot;);\n    this.allTableData = averageFn(res.data.data);\n    // this.originalAllTableData = this.allTableData // 也可以存一份原始值，留作备用，都行的\n    this.loading = false;\n    this.load();\n  &#125;,\n  methods: &#123;\n    async load() &#123;\n      console.log(&quot;自动多次执行之，首次执行会根据高度去计算要执行几次合适&quot;);\n      // 第四步，触底加载相当于把二维数组的每一项取出来用，用完时return停止即可\n      if (this.allTableData.length == 0) &#123;\n        console.log(&quot;没数据啦&quot;);\n        return;\n      &#125;\n      // 第二步，加载的时候，把二维数组的第一项取出来，拼接到要展示的表格数据中去\n      let arr = this.allTableData[0];\n      this.tableData = this.tableData.concat(arr);\n      // 第三步，拼接展示以后，再把二维数组的第一项的数据删除即可\n      this.allTableData.shift();\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;二、 定时器请求动画帧html&lt;div v-if=&quot;activeName == &#39;aaa&#39;&quot;&gt;\n  &lt;el-button\n    style=&quot;margin-bottom: 12px&quot;\n    size=&quot;small&quot;\n    type=&quot;primary&quot;\n    :loading=&quot;loading&quot;\n    @click=&quot;plan&quot;\n    &gt;点击请求加载&lt;/el-button\n  &gt;\n  &lt;el-table\n    height=&quot;300&quot;\n    :data=&quot;arr&quot;\n    border\n    style=&quot;width: 80%&quot;\n    :header-cell-style=&quot;&#123;\n            height: &#39;24px&#39;,\n            lineHeight: &#39;24px&#39;,\n            color: &#39;#606266&#39;,\n            background: &#39;#F5F5F5&#39;,\n            fontWeight: &#39;bold&#39;,\n          &#125;&quot;\n  &gt;\n    &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt;\n    &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot;&gt;&lt;/el-table-column&gt;\n    &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot;&gt;&lt;/el-table-column&gt;\n    &lt;el-table-column prop=&quot;value&quot; label=&quot;对应值&quot;&gt;&lt;/el-table-column&gt;\n  &lt;/el-table&gt;\n&lt;/div&gt;jsfunction averageFn(arr) &#123;\n  let i = 0; // 从第0个开始\n  let result = []; // 定义结果，结果是二维数组\n  while (i &lt; arr.length) &#123;\n    // 从原始数组的第一项开始遍历\n    result.push(arr.slice(i, i + 10)); // 一次截取10个用于分堆\n    i = i + 10;\n  &#125;\n  return result;\n&#125;\n\n  async created() &#123;\n    await this.getData()\n  &#125;,\n  methods: &#123;\n    //\n    async getData() &#123;\n      for (let i = 0; i &lt; 100000; i++) &#123;\n        await this.list.push(&#123; name: &#39;aaa&#39;, index: i &#125;)\n      &#125;\n    &#125;,\n    /**\n     * 请求动画帧\n     * */\n    async plan() &#123;\n      this.loading = true;\n      const res = await axios.get(&quot;xxxxx&quot;);\n      this.loading = false;\n      // 1. 将大数据量分堆\n      let twoDArr = averageFn(res.data.data);\n      // 2. 定义一个函数，专门用来做赋值渲染（使用二维数组中的每一项）\n      const use2DArrItem = (page) =&gt; &#123;\n        // 4. 从第一项，取到最后一项\n        if (page &gt; twoDArr.length - 1) &#123;\n          console.log(&quot;每一项都获取完了&quot;);\n          return;\n        &#125;\n        // 5. 使用请求动画帧的方式\n        requestAnimationFrame(() =&gt; &#123;\n          // 6. 取出一项，就拼接一项（concat也行）\n          this.arr = [...this.arr, ...twoDArr[page]];\n          // 7. 这一项搞定，继续下一项\n          page = page + 1;\n          // 8. 直至完毕（递归调用，注意结束条件）\n          use2DArrItem(page);\n        &#125;);\n      &#125;;\n      // 3. 从二维数组中的第一项，第一堆开始获取并渲染（数组的第一项即索引为0）\n      use2DArrItem(0);\n    &#125;,\n  &#125;,三、虚拟列表html&lt;template&gt;\n  &lt;!-- 虚拟列表容器，类似“窗口”，窗口的高度取决于一次展示几条数据\n            比如窗口只能看到10条数据，一条40像素，10条400像素\n            故，窗口的高度为400像素，注意要开定位和滚动条 --&gt;\n  &lt;div\n    class=&quot;virtualListWrap&quot;\n    ref=&quot;virtualListWrap&quot;\n    @scroll=&quot;handleScroll&quot;\n    :style=&quot;&#123; height: itemHeight * count + &#39;px&#39; &#125;&quot;\n  &gt;\n    &lt;!-- 占位dom元素，其高度为所有的数据的总高度 --&gt;\n    &lt;div\n      class=&quot;placeholderDom&quot;\n      :style=&quot;&#123; height: allListData.length * itemHeight + &#39;px&#39; &#125;&quot;\n    &gt;&lt;/div&gt;\n    &lt;!-- 内容区，展示10条数据，注意其定位的top值是变化的 --&gt;\n    &lt;div class=&quot;contentList&quot; :style=&quot;&#123; top: topVal &#125;&quot;&gt;\n      &lt;!-- 每一条（项）数据 --&gt;\n      &lt;div\n        v-for=&quot;(item, index) in showListData&quot;\n        :key=&quot;index&quot;\n        class=&quot;itemClass&quot;\n        :style=&quot;&#123; height: itemHeight + &#39;px&#39; &#125;&quot;\n      &gt;\n        &#123;&#123; item.name &#125;&#125;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;!-- 加载中部分 --&gt;\n    &lt;div class=&quot;loadingBox&quot; v-show=&quot;loading&quot;&gt;\n      &lt;i class=&quot;el-icon-loading&quot;&gt;&lt;/i&gt;\n      &amp;nbsp;&amp;nbsp;&lt;span&gt;loading...........&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script&gt;\nfunction throttle(fn, wait) &#123;\n  var pre = Date.now();\n  return function () &#123;\n    var context = this;\n    var args = arguments;\n    var now = Date.now();\n    if (now - pre &gt;= wait) &#123;\n      fn.apply(context, args);\n      pre = Date.now();\n    &#125;\n  &#125;;\n&#125;\nimport axios from &quot;axios&quot;;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      allListData: [], // 所有的数据，比如这个数组存放了十万条数据\n      itemHeight: 40, // 每一条（项）的高度，比如40像素\n      count: 10, // 一屏展示几条数据\n      start: 0, // 开始位置的索引\n      end: 10, // 结束位置的索引\n      topVal: 0, // 父元素滚动条滚动，更改子元素对应top定位的值，确保联动\n      loading: false,\n    &#125;;\n  &#125;,\n  computed: &#123;\n    // 从所有的数据allListData中截取需要展示的数据showListData\n    showListData: function () &#123;\n      return this.allListData.slice(this.start, this.end);\n    &#125;,\n  &#125;,\n  async created() &#123;\n    this.loading = true;\n    const res = await axios.get(&quot;xxxxxx&quot;);\n    this.allListData = res.data.data;\n    this.loading = false;\n  &#125;,\n  methods: &#123;\n    handleScroll() &#123;\n      throttle(this.s(), 500);\n    &#125;,\n    s() &#123;\n      /**\n       * 获取在垂直方向上，滚动条滚动了多少像素距离Element.scrollTop\n       *\n       * 滚动的距离除以每一项的高度，即为滚动到了多少项，当然，要取个整数\n       * 例：滚动4米，一步长0.8米，滚动到第几步，4/0.8 = 第5步（取整好计算）\n       *\n       * 又因为我们一次要展示10项，所以知道了起始位置项，再加上结束位置项，\n       * 就能得出区间了【起始位置, 起始位置 + size项数】==【起始位置, 结束位置】\n       * */\n      const scrollTop = this.$refs.virtualListWrap.scrollTop;\n      this.start = Math.floor(scrollTop / this.itemHeight);\n      this.end = this.start + this.count;\n      /**\n       * 动态更改定位的top值，确保联动，动态展示相应内容\n       * */\n      this.topVal = this.$refs.virtualListWrap.scrollTop + &quot;px&quot;;\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;css&lt;style scoped lang=&quot;less&quot;&gt;\n// 虚拟列表容器盒子\n.virtualListWrap &#123;\n  box-sizing: border-box;\n  width: 240px;\n  border: solid 1px #000000;\n  // 开启滚动条\n  overflow-y: auto;\n  // 开启相对定位\n  position: relative;\n\n  .contentList &#123;\n    width: 100%;\n    height: auto;\n    // 搭配使用绝对定位\n    position: absolute;\n    top: 0;\n    left: 0;\n\n    .itemClass &#123;\n      box-sizing: border-box;\n      width: 100%;\n      height: 40px;\n      line-height: 40px;\n      text-align: center;\n    &#125;\n\n    // 奇偶行改一个颜色\n    .itemClass:nth-child(even) &#123;\n      background: #c7edcc;\n    &#125;\n\n    .itemClass:nth-child(odd) &#123;\n      background: pink;\n    &#125;\n  &#125;\n\n  .loadingBox &#123;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(255, 255, 255, 0.64);\n    color: green;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  &#125;\n&#125;\n&lt;/style&gt;四、vxe-tablehtml&lt;template&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;vxe-table\n      border\n      show-overflow\n      ref=&quot;xTable1&quot;\n      height=&quot;300&quot;\n      :row-config=&quot;&#123; isHover: true &#125;&quot;\n      :loading=&quot;loading&quot;\n    &gt;\n      &lt;vxe-column type=&quot;seq&quot;&gt;&lt;/vxe-column&gt;\n      &lt;vxe-column field=&quot;id&quot; title=&quot;ID&quot;&gt;&lt;/vxe-column&gt;\n      &lt;vxe-column field=&quot;name&quot; title=&quot;名字&quot;&gt;&lt;/vxe-column&gt;\n      &lt;vxe-column field=&quot;value&quot; title=&quot;对应值&quot;&gt;&lt;/vxe-column&gt;\n    &lt;/vxe-table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script&gt;\nimport axios from &quot;axios&quot;;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      loading: false,\n    &#125;;\n  &#125;,\n  async created() &#123;\n    this.loading = true;\n    const res = await axios.get(&quot;xxxxxxx&quot;);\n    this.loading = false;\n    this.render(res.data.data);\n  &#125;,\n  methods: &#123;\n    render(data) &#123;\n      this.$nextTick(() =&gt; &#123;\n        const $table = this.$refs.xTable1;\n        $table.loadData(data);\n      &#125;);\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;五、vue-virtual-scrollerhtml&lt;template&gt;\n  &lt;div class=&quot;main-container&quot;&gt;\n    &lt;DynamicScroller\n      class=&quot;scroller&quot;\n      :min-item-size=&quot;54&quot;\n      :items=&quot;list&quot;\n      :item-size=&quot;30&quot;\n      key-field=&quot;index&quot;\n      v-slot=&quot;&#123; item &#125;&quot;\n    &gt;\n      &lt;div class=&quot;user&quot;&gt;&#123;&#123; item.index + 1 &#125;&#125; -- &#123;&#123; item.name &#125;&#125;&lt;/div&gt;\n      &lt;!-- &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;\n        &lt;div class=&quot;user&quot;&gt;\n          &#123;&#123; item.index + 1 &#125;&#125; -- &#123;&#123; item.name &#125;&#125;\n        &lt;/div&gt;\n      &lt;/template&gt; --&gt;\n    &lt;/DynamicScroller&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script&gt;\nexport default &#123;\n  props: &#123;\n    list: Array,\n  &#125;,\n&#125;\n&lt;/script&gt;css&lt;style scoped&gt;\n/* .main-container &#123;\n  height: 200px;\n&#125; */\n\n.scroller &#123;\n  height: 300px;\n  overflow: scroll;\n&#125;\n\n.user &#123;\n  height: 30px;\n  padding: 0 12px;\n  display: flex;\n  align-items: center;\n&#125;\n&lt;/style&gt;父组件使用：\nhtml&lt;div\n  style=&quot;height: 200px;width: 300px;margin:20px;border: 1px solid #333;overflow: auto;&quot;\n&gt;\n  &lt;v-table :list=&quot;list&quot; v-if=&quot;activeName == &#39;eee&#39;&quot;&gt;&lt;/v-table&gt;\n&lt;/div&gt;","slug":"125-vue","date":"2023-03-16T12:00:00.000Z","categories_index":"","tags_index":"vue2","author_index":"Jude"},{"id":"38426d0770dc54cb711a330fd63320df","title":"124、vue2利用require.context批量引入实现自动注册","content":"使用 require.context 进行批量导入，不仅可以减少代码， 后期添加新的文件不用在挨个引入。如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。注意：全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。\n\n\n使用 require.context 进行批量导入，不仅可以减少代码， 后期添加新的文件不用在挨个引入，引入后回调一个方法 ， 该方法需传递一个文件的路径参数，得到相应的文件模块，其中有 keys 和 resovle 函数 keys 它返回一个数组，数组中所有子集都可以被 require。context 所返回的 webpackContext 函数处理 resolve 它返回 request 被解析后得到的模块 id，其中 webpack 还有闭包 map 函数 , 该函数接受一个函数参数， 函数中默认参数包含了所有匹配的子模块的路径。\nvue2 官方文档中，在应用入口文件 (比如 src&#x2F;main.js) 中全局导入基础组件的示例代码：\njsimport Vue from &quot;vue&quot;;\nimport upperFirst from &quot;lodash/upperFirst&quot;;\nimport camelCase from &quot;lodash/camelCase&quot;;\n\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  &quot;./components&quot;,\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n);\n\nrequireComponent.keys().forEach((fileName) =&gt; &#123;\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName);\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split(&quot;/&quot;)\n        .pop()\n        .replace(/\\.\\w+$/, &quot;&quot;)\n    )\n  );\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  );\n&#125;);vuex 自动引入 modules 文件夹下的所有 js 文件（无需一个个引入）\n示例：src&#x2F;store&#x2F;index.js\njsimport Vue from &quot;vue&quot;;\nimport Vuex from &quot;vuex&quot;;\nVue.use(Vuex);\nimport getters from &quot;./getters&quot;;\n// require.context函数接受三个参数 1.读取的文件路径  2.是否遍历文件的子目录  3.匹配文件的正则\n// 表示获取同级目录modules文件夹下的 所有 js文件（这样就不用一个个引入了）\n\nconst modulesFiles = require.context(&quot;./modules&quot;, true, /\\.js$/);\nconst modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; &#123;\n  const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, &quot;$1&quot;);\n  const value = modulesFiles(modulePath);\n  modules[moduleName] = value.default;\n  return modules;\n&#125;, &#123;&#125;);\n\n// console.log(&#39;modules&#39;, modules)\n\nconst store = new Vuex.Store(&#123;\n  modules, // 对象，key是文件名，value是相应内容\n  getters,\n&#125;);\n\nexport default store;","slug":"124-vue","date":"2023-03-12T12:00:00.000Z","categories_index":"","tags_index":"vue2","author_index":"Jude"},{"id":"00b982fc53c937e212d2a3973c72433c","title":"123、《Vuejs设计与实现》- 霍春阳：vue.js设计的核心要素(二)","content":"框架提供了哪些构建产物？产物的模块格式？没有按照预期使用框架的警告信息，如何快速定位问题？开发版本的构建和生成版本的构建有何区别？热更新 HMR 框架层面的支持？自主选择需要的功能，能否选择关闭其他功能从而减少打包体积？\n\n\n一、提升开发体验在 vue.js 3 中，我们打印一个 ref 数据时：\njsconst count = ref(0);\nconsole.log(count);控制台打印结果为：\njsRefImpl &#123; _rawValue:0,_shallow: false,__v_isRef:true, _value: 0 &#125;控制台打印的输出结果很不直观（当然我们可以选择打印 count.vlaue，输出的结果为 0），其实 Chrome 浏览器已经提供了 RefImpl 类的打印设置，打开 devtool 的设置，勾选“console” &#x3D;&gt; enable custom formatters 选项，浏览器的打印结果就会变成\njsRef&lt;0&gt;当然还包括错误提示。\n二、框架代码的体积在实现同样功能的情况下，当然是用的代码越少越好，这样体积就会越小，最后浏览器加载资源的时间也就越少。这时我们不禁会想，提供越完善的警告信息就意味着我们要编写更多的代码，这不是与控制代码体积相悖吗？\nvue.js3 的源码，我们会发现每一个 warn 函数的调用都会配合DEV常量的检查：\njsif (__DEV__ &amp;&amp; !res) &#123;\n  warn(`Fail to mount app:mount target selector &quot;$&#123;container&#125;&quot; returned null`);\n&#125;打印警告信息的前提是：DEV常量为 true，DEV常量就是达到目的的关键。vue.js 是使用 rollup.js 对项目进行构建的，这里的 DEV 常量实际上是通过 rollup.js 的插件配置来预定义的，其功能类似于 webpack 中的DefinePlugin 插件。vue.js 在输出资源时，会存在开发环境（vue.global.js）和生产环境(vue.global.prod.js)。开发环境时，DEV 常量值为 true，生产环境时，DEV 常量值为 false。可以看到，DEV常量替换为字面量 false 时，判断条件为 false，就不会打印警告信息了。不会执行的代码（dead code），不会被打包到生产环境。这样的目的就是，在开发环境中为用户提供友好的警告信息的 同时，不会增加生产环境代码的体积。\n三、Tree-ShakingDEV 常量只是控制了警告信息的打印，框架的代码量不会随警告信息的增加而增加。这样做还不够，vue.js 3 内建了很多组件，例如 Transition 组件，如果我们在项目中未使用该组件，那么打包时，该组件的代码不需要被打包到生产环境。这时候就需要 Tree-Shaking 了。\nTree-Shaking 是指在打包时，只保留用到的代码，未用到的代码不会被打包到生产环境。vue.js 3 使用了 rollup.js 进行打包，rollup.js 提供了 Tree-Shaking 功能。\n实现 Tree-Sharking 必须满足的条件：模块必须为 ES Module,因为 Tree-Sharking 依赖 ESM 的静态结构。\n举例分析：\njs-demo;\n--package.json;\n--input.js;\n--utils.js;首先安装 rollup.js\nshellyarn add rollup -D\n// 或者\nnpm i rollup -Dinput.js 和 utils.js\njs// input.js\nimport &#123; foo &#125; from &quot;./utils.js&quot;;\nfoo();\n// utils.js\nexport function foo(obj) &#123;\n  obj &amp;&amp; obj.foo;\n&#125;\nexport function bar(obj) &#123;\n  obj &amp;&amp; obj.bar;\n&#125;代码很简单，定义并导出 utils.js 中的 2 个函数，分别是 foo 函数和 bar 函数，然后在 input.js 中导入并调用 foo 函数（我们没有导入 bar 函数）。\n当我们执行构建命令：\nshellnpx rollup input.js -f esm -o bundle.jsbundle.js 中并未包含 bar 函数的代码，这就是 Tree-Shaking 的效果。这就是因为 bar 函数被作为 dead code 被删除了。\n但是，我们可以发现 foo 函数也没有什么意义（仅仅是读取对象的值），为什么 rollup.js 不把 foo 函数也删除呢？\n这里涉及 Tree-Sharking 的第二个关键点：副作用\n所谓副作用，是指在调用函数时，除了返回函数的返回值之外，还会对函数外的其他变量产生影响。\n上面的代码明显是读取对象的值，怎么会产生副作用呢？其实是有可能的，试想一下，如果 obj 对象是一个通过 Proxy 创建的代理对象，那么当我们读取对象属性时，就会触发代理对象的 get 夹子（trap），在 get 夹子中是可能产生副作用的，例如我们在 get 夹子中修改了某个全局变量。而到底会不会产生副作用，只有代码真正运行的时候才能知 JavaScript 本身是动态语言，因此想要静态地分析哪些代码是 dead code 很有难度。\nrollup.js 是如何知道代码不会产生副作用，可以放心移除呢？\njsimport &#123; foo &#125; from &quot;./utils.js&quot;;\n/*#__PURE__*/ foo();这里需要使用的是 /*#__PURE__*/,它的作用就是告诉 rollup.js,这段代码不会产生副作用，可以放心使用 Tree-Sharking。\n这里需要理解的是，通常产生副作用的代码都是模块内函数的顶级调用。\njsfoo(); // 顶级调用\nfunction bar() &#123;\n  foo(); // 函数内部调用\n&#125;\n\n\n\n\n\n\n\n\n\n对于顶级调用来说，是可能产生副作用的；但对于函数内调用来说，只要函数 bar 没有被调用，那么 foo 函数的调用自然不会产生副作用。\n\n四、小结\n\n\n\n\n\n\n\n\n\n预定义 DEV 常量，从而实现仅在开发环境中打印警告信息，而生产环境中则不包含这些用于提升开发体验的代码，从而实现线上代码体积的可控性。Tree-Shaking 是一种排除 dead code 的机制，Tree-Shaking 本身基于 ESM，并且 JavaScript 是一门动态语言，通过纯静态分析的手段进行 Tree-Shaking 难度较大，因此大部分工具能够识别&#x2F;#PURE&#x2F; 注释，在编写框架代码时，我们可以利用&#x2F;#PURE&#x2F; 来辅助构建工具进行 Tree-Shaking。\n\n","slug":"123-vue","date":"2023-02-20T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"4b07ee3e25002d191b46720119d53a07","title":"122、《Vuejs设计与实现》- 霍春阳：运行时和编译时(一)","content":"《Vue.js 设计与实现》-- 霍春阳 这本书并非是 vue.js 的源码解读，而是向开发人员由简入繁的介绍 vue.js 的各个功能模块。\n\n\n视图层框架通常分为命令式和声明式。早年间流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是关注过程。什么是声明式框架呢？与命令式框架更加关注过程不同，声明式框架更加关注结果。Vue.js 帮我们封装了过程，Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式。\n《Vue.js 设计与实现》-- 霍春阳 主要讨论一下内容：1、框架设计的核心要素以及框架设计过程中要做出的权衡；2、三种常见的虚拟 DOM 的 diff 算法3、组件化的视线与 vue.js 内建组件的原理4、服务端渲染、客户端渲染、同构渲染之间的差异，以及同构渲染的原理\n一、命令式框架和声明式框架的性能\n\n\n\n\n\n\n\n\n结论：声明式框架的性能不好于命令式框架。\n如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：\n\n\n\n\n\n\n\n\n\n命令式代码的更新性能消耗 &#x3D; A声明式代码的更新性能消耗 &#x3D; A + B\n声明式代码会比命令式代码多出找出差异的性能消耗，因此最理想的情况是，当找出差异的性能消耗为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，毕竟框架本身就是 封装了命令式代码才实现了面向用户的声明式。\n为什么 Vue.js 要选择声明式的设计方案呢？原因就在于声明式代码的可维护性更强。\n在采用命令式代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素的创建、更新、删除等工作。而声明式代码展示的就是我们要的结 果，看上去更加直观，至于做事儿的过程，并不需要我们关心，Vue.js 都为我们封装好了。\n（一）命令式框架特点：关注过程例如：1、获取 ID 为 app 的 div 标签2、它的文本内容为 hello world3、为其绑定点击事件4、点击弹出提示：OK\n翻译为对应的 jQuery 代码和 js 代码\njs$(&quot;#app&quot;)\n  .text(&quot;hello world&quot;)\n  .on(&quot;click&quot;, function () &#123;\n    alert(&quot;OK&quot;);\n  &#125;);\n// 原生js\nconst div = document.querySelector(&quot;#app&quot;);\ndiv.innerText = &quot;hello world&quot;;\ndiv.addEventListener(&quot;click&quot;, function () &#123;\n  alert(&quot;OK&quot;);\n&#125;);（二）声明式框架特点：关注结果例如：1、获取 ID 为 app 的 div 标签2、为它绑定点击事件3、点击弹出提示：OKvue.js 代码\njs&lt;div @click=&quot;()=&gt; alert(&#39;ok&#39;)&quot;&gt;hello world&lt;/div&gt;\n\n\n\n\n\n\n\n\n\n由此可以看出，vue.js 的内部实现一定是命令式的，而暴露给用户的却是声明式的。\n\n假设现在我们要将 div 标签的文本内容修改为 hello vue3，那么如何用命令式代码实现呢？\njsdiv.textContent = &quot;hello vue3&quot;;vue.js\njs&lt;div @click=&quot;() =&gt; alert(&#39;ok&#39;)&quot;&gt;hello vue3&lt;/div&gt;还有没有其他办法比上面这句代码的性能更好？答案是没有。命令式代码可以做到极致的性能优化，我们明确哪里做了变更，只做必要修改就行了。声明式代码不一定能做到这一点，它描述的是过程。\n声明式代码与命令式代码的性能相同，但是无法做到超越，毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式。为什么 Vue.js 要选择声明式的设计方案呢？原因就在于声明式代码的可维护性更强。\n二、虚拟 DOM 的性能声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能耗因此，如果我们能够最小化找出差异的性能消耗，就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。\n采用虚拟 dom 的更新技术性能理论上不可能比原生的 JS 操作 dom 更高。主要是在大部分情况下，我们很难写出绝对优化的命令式代码，尤其是在应用程序规模很大的时候，即使写出了极致优化的代码，也一定耗费了巨大的经理，投入产出比并不高。\n虚拟 DOM 解决的问题：写声明式代码，还能保证应用程序的性能下限，甚至逼近命令式代码的性能。\ninnerHTML 和虚拟 DOMinnerHTML 创建、更新页面的过程：\njsconst str = `&lt;div&gt;&lt;span&gt;i am text&lt;/span&gt;&lt;/div&gt;`;\nconst div = document.createElement(&quot;div&quot;);\ndiv.innerHTML = str;为了渲染出页面，首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算，涉及DOM的运算要远比js层面的计算性能差(不在一个数量级)。\n\n\n\n\n\n\n\n\n\n\ninnerHTML 创建页面的性能：HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量。\n\n虚拟 DOM 创建页面1、创建 js 对象，这个对象可以理解为真实 DOM 的描述2、递归地遍历虚拟 DOM 树并创建真实的 DOM。\n\n\n\n\n\n\n\n\n\n\n虚拟 DOM 创建页面的性能：js 对象创建的计算量 + 递归创建真实 DOM 的计算量。\n\n二者在创建页面的性能上，二者差距不大，虚拟 DOM 相比 innerHTML 没有优势可言。\n二者在更新页面的过程中会存在显著的差异，innerHTML 更新页面时，会直接重新构建 HTML 字符串，再重新设置 DOM 元素的 innerHTML 属性。可以理解为，哪怕我只修改了一个文字，也要重新设置 innerHTML 属性，而重现设置 innerHTML 就相当于销毁了所有旧的 DOM 元素，再全量创建新的 DOM 元素。\n而对于虚拟 DOM 而言，需要重新创建 js 对象（虚拟 DOM 树），然后比较新旧虚拟 DOM，找到变化元素并更新它。\n\n\n\n\n\n\n\n\n\n\n在更新页面时，虚拟 DOM 在 JavaScript 层面的运算要比创建页面时多出一个 Diff 的性能消耗，然而它毕竟也是 JavaScript 层面的运算，所以不会产生数量级的差异。再观察 DOM 层面的运算，可以发现虚拟 DOM 在更新页面时只会更新必要的元素，但 innerHTML 需要全量更新。这时虚拟 DOM 的优势就体现出来了。当更新页面时，影响虚拟 DOM 的性能因素与影响 innerHTML 的性能因素不同。对于虚拟 DOM 来说，无论页面多大，都只会更新变化的内容，而对于 innerHTML 来说，页面越大，就意味着更新时的性能消耗越大。\n\n三、运行时和编译时设计框架的三种选择：纯运行时、运行时 + 编译时、纯编译时框架。\n一、纯运行时框架假如我们设计的框架，提供了一个 render 函数，为该函数提供一个树形结构的数据对象，render 函数会根据该对象递归地将数据渲染成 DOM 元素。\njsconst obj = &#123;\n  tag: &quot;div&quot;,\n  children: [\n    &#123;\n      tag: &quot;span&quot;,\n      children: &quot;hello world&quot;,\n    &#125;,\n  ],\n&#125;;每个对象都有两个属性：tag 代表标签名称，children 既可以是一个数组（代表子节点），也可以直接是一段文本（代表文本子节点）。\njsfunction render(obj, root) &#123;\n  const el = document.createElement(obj.tag);\n  if (typeof obj.chidlren === &quot;string&quot;) &#123;\n    const text = document.createTextNode(obj.children);\n    el.appendChild(text);\n  &#125; else if (obj.children) &#123;\n    // 数组，递归调用render函数，使用el作为root参数\n    obj.children.forEach((child) =&gt; &#123;\n      render(child, el);\n    &#125;);\n  &#125;\n  // 将元素添加到root\n  root.appendChild(el);\n&#125;\n// 使用该render函数\nrender(obj, document.body);手写树形结构的数据对象太麻烦了，能不能引入编译手段，把 HTML 标签编译成树形结构的数据对象，这样不就可以继续使用 render 函数了吗?\njsconst str = `&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;`;\n// 调用compiler编译得到树形数据结构的数据对象\nconst obj = compile(str);\nrender(obj, document.body);这就是一个运行时编译的‘框架’，编译器可以将 HTML 字符串编译成数据对象，那么能不能直接编译成命令式代码，这样我们只需要一个 compiler 函数，不需要 render 函数，这其实就是纯编译时的框架。\n这三种框架设计层面的对比，有哪些优缺点?\n\n\n\n\n\n\n\n\n\n\n首先是纯运行时的框架。由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了。然而，假如我们设计的框架是纯编译时的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的 JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用。实际上，在这三个方向上业内都有探索，其中 Svelte 就是纯编译时的框架，但是它的真实性能可能达不到理论高度。Vue.js 3 仍然保持了运行时 + 编译时的架构，在保持灵活性的基础上能够尽可能地去优化。\n\n四、小结\n\n\n\n\n\n\n\n\n\n命令式框架在理论上可以做到极致优化，但是用户要承受巨大的心智负担；而声明式框架能够有效减轻用户的心智负担，但是性能上有一定的牺牲。\n\n\n\n\n\n\n\n\n\n\n\n虚拟 DOM 的意义就在于使找出差异的性能消耗最小化。用原生 JavaScript 操作 DOM 的方法（如document.createElement）、虚拟 DOM 和 innerHTML 三者操作页面的性能，不可以简单地下定论，这与页面大小、变更部分的大 小都有关系，除此之外，与创建页面还是更新页面也有关系\n\n\n\n\n\n\n\n\n\n\n\nvue.js 3 是编译时+运行时框架\n\n","slug":"122-vue","date":"2023-02-18T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"2dd584d4a47bcd058936ff2f6a30944b","title":"121、ProTable","content":"ProTable 是基于 Vue3.2 + Element-Plus 二次封装 el-table,首先我们在封装 ProTable 组件的时候，在不影响 el-table 原有的属性、事件、方法的前提下，然后在其基础上做二次封装。\n\n\n\n\n\n\n\n\n\n\n\nProTable 组件目前使用属性透传进行重构，支持 el-table &amp;&amp; el-table-column 所有属性、事件、方法的调用。ProTable 组件上的绑定的所有属性和事件都会通过 v-bind=&quot;$attrs&quot; 透传到 el-table 上。ProTable 组件内部暴露了 el-table DOM，可通过 proTable.value.element.方法名 调用其方法。\n思路把一个表格页面所有重复的功能 （表格多选、查询、重置、刷新、分页、数据操作二次确认、文件下载、文件上传） 都封装成 Hooks 函数钩子或组件，然后在 ProTable 组件中使用这些函数钩子或组件。在页面中使用的时，只需传给 ProTable 当前表格数据的请求 API、表格配置项 columns 就行了，数据传输都使用 作用域插槽 或 tsx 语法从 ProTable 传递给父组件就能在页面上获取到了。\n一、ProTable 功能1、表格内容自适应屏幕宽高，溢出内容表格内部滚动（flex 布局）2、表格搜索、重置、分页查询 Hooks 封装 （页面使用不会存在任何搜索、重置、分页查询逻辑）3、表格数据操作 Hooks 封装 （单条数据删除、批量删除、重置密码、状态切换等操作）4、表格数据多选 Hooks 封装 （支持现跨页勾选数据）5、表格数据导入组件、导出 Hooks 封装6、表格搜索区域使用 Grid 布局重构，支持自定义响应式配置7、表格分页组件封装（Pagination）8、表格数据刷新、列显隐、列排序、搜索区域显隐设置9、表格数据打印功能（可勾选行数据、隐藏列打印）10、表格配置支持多级 prop（示例 &#x3D;&#x3D;&gt; prop: user.detail.name）11、单元格内容格式化、tag 标签显示（有字典 enum 会根据字典 enum 自动格式化）12、支持多级表头、表头内容自定义渲染（支持作用域插槽、tsx 语法、h 函数）13、支持单元格内容自定义渲染（支持作用域插槽、tsx 语法、h 函数）14、配合 TreeFilter、SelectFilter 组件使用更佳\n二、ProTable 需求分析ProTable 主要分为五个模块：\n1、表格搜索区\n\n\n\n\n\n\n\n\n搜索区域的字段都是存在于表格当中的，并且每个页面的搜索、重置方法都是一样的逻辑，只是不同的查询参数而已。我们完全可以在传表格配置项 columns 时，直接指定某个 column 的 search 配置，就能把该项变为搜索项，然后使用 el 字段可以指定搜索框的类型，最后把表格的搜索方法都封装成 Hooks 钩子函数。页面上完全就不会存在任何搜索、重置逻辑了。\n通过 component :is 动态组件 &amp;&amp; v-bind 属性透传实现，将用户传递的参数全部透传到组件上，所以可以直接根据 element 官方文档在 props 中传递参数了。\nvue&lt;template&gt;\n  &lt;component\n    :is=&quot;column.search?.render ?? `el-$&#123;column.search?.el&#125;`&quot;\n    v-bind=&quot;&#123; ...handleSearchProps, ...placeholder, searchParam, clearable &#125;&quot;\n    v-model.trim=&quot;searchParam[column.search?.key ?? handleProp(column.prop!)]&quot;\n    :data=&quot;column.search?.el === &#39;tree-select&#39; ? columnEnum : []&quot;\n    :options=&quot;[&#39;cascader&#39;, &#39;select-v2&#39;].includes(column.search?.el!) ? columnEnum : []&quot;\n  &gt;\n    &lt;template #default=&quot;&#123; data &#125;&quot; v-if=&quot;column.search?.el === &#39;cascader&#39;&quot;&gt;\n      &lt;span&gt;&#123;&#123; data[fieldNames.label] &#125;&#125;&lt;/span&gt;\n    &lt;/template&gt;\n    &lt;template v-if=&quot;column.search?.el === &#39;select&#39;&quot;&gt;\n      &lt;component\n        :is=&quot;`el-option`&quot;\n        v-for=&quot;(col, index) in columnEnum&quot;\n        :key=&quot;index&quot;\n        :label=&quot;col[fieldNames.label]&quot;\n        :value=&quot;col[fieldNames.value]&quot;\n      &gt;&lt;/component&gt;\n    &lt;/template&gt;\n    &lt;slot v-else&gt;&lt;/slot&gt;\n  &lt;/component&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot; name=&quot;SearchFormItem&quot;&gt;\nimport &#123; computed, inject, ref &#125; from &quot;vue&quot;;\nimport &#123; handleProp &#125; from &quot;@/utils&quot;;\nimport &#123; ColumnProps &#125; from &quot;@/components/ProTable/interface&quot;;\n\ninterface SearchFormItem &#123;\n  column: ColumnProps;\n  searchParam: &#123; [key: string]: any &#125;;\n&#125;\nconst props = defineProps&lt;SearchFormItem&gt;();\n\n// 判断 fieldNames 设置 label &amp;&amp; value &amp;&amp; children 的 key 值\nconst fieldNames = computed(() =&gt; &#123;\n  return &#123;\n    label: props.column.fieldNames?.label ?? &quot;label&quot;,\n    value: props.column.fieldNames?.value ?? &quot;value&quot;,\n    children: props.column.fieldNames?.children ?? &quot;children&quot;,\n  &#125;;\n&#125;);\n\n// 接收 enumMap (el 为 select-v2 需单独处理 enumData)\nconst enumMap = inject(&quot;enumMap&quot;, ref(new Map()));\nconst columnEnum = computed(() =&gt; &#123;\n  let enumData = enumMap.value.get(props.column.prop);\n  if (!enumData) return [];\n  if (props.column.search?.el === &quot;select-v2&quot; &amp;&amp; props.column.fieldNames) &#123;\n    enumData = enumData.map((item: &#123; [key: string]: any &#125;) =&gt; &#123;\n      return &#123;\n        ...item,\n        label: item[fieldNames.value.label],\n        value: item[fieldNames.value.value],\n      &#125;;\n    &#125;);\n  &#125;\n  return enumData;\n&#125;);\n\n// 处理透传的 searchProps (el 为 tree-select、cascader 的时候需要给下默认 label &amp;&amp; value &amp;&amp; children)\nconst handleSearchProps = computed(() =&gt; &#123;\n  const label = fieldNames.value.label;\n  const value = fieldNames.value.value;\n  const children = fieldNames.value.children;\n  const searchEl = props.column.search?.el;\n  let searchProps = props.column.search?.props ?? &#123;&#125;;\n  if (searchEl === &quot;tree-select&quot;) &#123;\n    searchProps = &#123;\n      ...searchProps,\n      props: &#123; ...searchProps.props, label, children &#125;,\n      nodeKey: value,\n    &#125;;\n  &#125;\n  if (searchEl === &quot;cascader&quot;) &#123;\n    searchProps = &#123;\n      ...searchProps,\n      props: &#123; ...searchProps.props, label, value, children &#125;,\n    &#125;;\n  &#125;\n  return searchProps;\n&#125;);\n\n// 处理默认 placeholder\nconst placeholder = computed(() =&gt; &#123;\n  const search = props.column.search;\n  if (\n    [&quot;datetimerange&quot;, &quot;daterange&quot;, &quot;monthrange&quot;].includes(\n      search?.props?.type\n    ) ||\n    search?.props?.isRange\n  ) &#123;\n    return &#123;\n      rangeSeparator: &quot;至&quot;,\n      startPlaceholder: &quot;开始时间&quot;,\n      endPlaceholder: &quot;结束时间&quot;,\n    &#125;;\n  &#125;\n  const placeholder =\n    search?.props?.placeholder ??\n    (search?.el?.includes(&quot;input&quot;) ? &quot;请输入&quot; : &quot;请选择&quot;);\n  return &#123; placeholder &#125;;\n&#125;);\n\n// 是否有清除按钮 (当搜索项有默认值时，清除按钮不显示)\nconst clearable = computed(() =&gt; &#123;\n  const search = props.column.search;\n  return (\n    search?.props?.clearable ??\n    (search?.defaultValue == null || search?.defaultValue == undefined)\n  );\n&#125;);\n&lt;/script&gt;表格搜索项可以使用 tsx 组件自定义渲染\nvue&lt;script setup lang=&quot;tsx&quot;&gt;\nconst columns: ColumnProps[] = [\n  &#123;\n    prop: &quot;user.detail.age&quot;,\n    label: &quot;年龄&quot;,\n    search: &#123;\n      // 自定义 search 组件\n      render: (&#123; searchParam &#125;) =&gt; &#123;\n        return (\n          &lt;div class=&quot;flx-center&quot;&gt;\n            &lt;el-input\n              vModel_trim=&#123;searchParam.minAge&#125;\n              placeholder=&quot;最小年龄&quot;\n              style=&#123;&#123; width: \"50%\" &#125;&#125;\n            /&gt;\n            &lt;span class=&quot;mr10 ml10&quot;&gt;-&lt;/span&gt;\n            &lt;el-input\n              vModel_trim=&#123;searchParam.maxAge&#125;\n              placeholder=&quot;最大年龄&quot;\n              style=&#123;&#123; width: \"50%\" &#125;&#125;\n            /&gt;\n          &lt;/div&gt;\n        );\n      &#125;,\n    &#125;,\n  &#125;,\n];\n&lt;/script&gt;2、表格数据操作按钮\n\n\n\n\n\n\n\n\n表格数据操作按钮基本上每个页面都会不一样，所以我们直接使用 作用域插槽 来完成每个页面的数据操作按钮区域，作用域插槽 可以将表格多选数据信息从 ProTable 的 Hooks 多选钩子函数中传到页面上使用。scope 数据中包含：selectedList（当前选择的数据）、selectedListIds（当前选择的数据 id）、isSelected（当前是否选中的数据）\nvue&lt;!-- ProTable 中 tableHeader 插槽 --&gt;\n&lt;slot\n  name=&quot;tableHeader&quot;\n  :selectList=&quot;selectedList&quot;\n  :selectedListIds=&quot;selectedListIds&quot;\n  :isSelected=&quot;isSelected&quot;\n&gt;&lt;/slot&gt;\n\n&lt;!-- 页面使用 --&gt;\n&lt;template #tableHeader=&quot;scope&quot;&gt;\n  &lt;el-button type=&quot;primary&quot; :icon=&quot;CirclePlus&quot; @click=&quot;openDrawer(&#39;新增&#39;)&quot;\n    &gt;新增用户&lt;/el-button\n  &gt;\n  &lt;el-button type=&quot;primary&quot; :icon=&quot;Upload&quot; plain @click=&quot;batchAdd&quot;\n    &gt;批量添加用户&lt;/el-button\n  &gt;\n  &lt;el-button type=&quot;primary&quot; :icon=&quot;Download&quot; plain @click=&quot;downloadFile&quot;\n    &gt;导出用户数据&lt;/el-button\n  &gt;\n  &lt;el-button\n    type=&quot;danger&quot;\n    :icon=&quot;Delete&quot;\n    plain\n    @click=&quot;batchDelete(scope.selectedListIds)&quot;\n    :disabled=&quot;!scope.isSelected&quot;\n    &gt;批量删除用户&lt;/el-button\n  &gt;\n&lt;/template&gt;3、表格功能按钮\n\n\n\n\n\n\n\n\n表格功能按钮包括：表格数据刷新（一直会携带当前查询和分页条件）、表格数据打印、表格列设置（列显隐、列排序）、表格搜索区域显隐（方便展示更多的数据信息）。 可通过 toolButton 属性控制这块区域的显隐。表格打印基于 PrintJs 实现，因 PrintJs 不支持多级表头打印，所以当页面存在多级表头时，只会打印最后一级表头。表格打印功能可根据显示的列和勾选的数据动态打印，默认打印当前显示的所有数据。\n4、表格主体内容展示区域这里是最重要的数据展示区域，表头和单元格内容可以自定义渲染，表头支持 headerRender 方法（避免与 el-table-column 上的属性重名导致报错）、作用域插槽（column.prop + ‘Header’）两种方式自定义，单元格内容支持 render 方法和作用域插槽（column 上的 prop 属性）两种方式自定义。\n作用域插槽：\nvue&lt;!-- 使用作用域插槽自定义单元格内容 username --&gt;\n&lt;template #username=&quot;scope&quot;&gt;\n  &#123;&#123; scope.row.username &#125;&#125;\n&lt;/template&gt;\n\n&lt;!-- 使用作用域插槽自定义表头内容 username --&gt;\n&lt;template #usernameHeader=&quot;scope&quot;&gt;\n  &lt;el-button\n    type=&quot;primary&quot;\n    @click=&quot;ElMessage.success(&#39;我是通过作用域插槽渲染的表头&#39;)&quot;\n  &gt;\n    &#123;&#123; scope.column.label &#125;&#125;\n  &lt;/el-button&gt;\n&lt;/template&gt;tsx 语法：\nvue&lt;script setup lang=&quot;tsx&quot;&gt;\nconst columns: ColumnProps[] = [\n &#123;\n    prop: &quot;username&quot;,\n    label: &quot;用户姓名&quot;,\n    // 使用 headerRender 自定义表头\n    headerRender: scope =&gt; &#123;\n      return (\n        &lt;el-button\n          type=&quot;primary&quot;\n          onClick=&#123;() =&gt; &#123;\n            ElMessage.success(&quot;我是通过 tsx 语法渲染的表头&quot;);\n          &#125;&#125;\n        &gt;\n          &#123;scope.column.label&#125;\n        &lt;/el-button&gt;\n      );\n    &#125;\n  &#125;,\n  &#123;\n    prop: &quot;status&quot;,\n    label: &quot;用户状态&quot;,\n    // 使用 render 自定义表格内容\n    render: scope =&gt; &#123;\n      return (\n          &lt;el-switch\n            model-value=&#123;scope.row.status&#125;\n            active-text=&#123;scope.row.status ? &quot;启用&quot; : &quot;禁用&quot;&#125;\n            active-value=&#123;1&#125;\n            inactive-value=&#123;0&#125;\n            onClick=&#123;() =&gt; changeStatus(scope.row)&#125;\n          /&gt;\n        )\n      );\n    &#125;\n  &#125;,\n];\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n如果你想使用 el-table 的任何属性、事件，目前通过属性透传都能支持。\nvue&lt;template&gt;\n  &lt;el-table ref=&quot;tableRef&quot; v-bind=&quot;$attrs&quot;&gt; &lt;/el-table&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot; name=&quot;ProTable&quot;&gt;\nimport &#123; ref &#125; from &quot;vue&quot;;\nimport &#123; ElTable &#125; from &quot;element-plus&quot;;\n\nconst tableRef = ref&lt;InstanceType&lt;typeof ElTable&gt;&gt;();\n\ndefineExpose(&#123; element: tableRef &#125;);\n&lt;/script&gt;5、表格分页表格分页的封装可以使 ProTable 页面不存在分页逻辑。\nvue&lt;template&gt;\n  &lt;!-- 分页组件 --&gt;\n  &lt;el-pagination\n    :background=&quot;true&quot;\n    :current-page=&quot;pageable.pageNum&quot;\n    :page-size=&quot;pageable.pageSize&quot;\n    :page-sizes=&quot;[10, 25, 50, 100]&quot;\n    :total=&quot;pageable.total&quot;\n    layout=&quot;total, sizes, prev, pager, next, jumper&quot;\n    @size-change=&quot;handleSizeChange&quot;\n    @current-change=&quot;handleCurrentChange&quot;\n  &gt;&lt;/el-pagination&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot; name=&quot;Pagination&quot;&gt;\ninterface Pageable &#123;\n  pageNum: number;\n  pageSize: number;\n  total: number;\n&#125;\n\ninterface PaginationProps &#123;\n  pageable: Pageable;\n  handleSizeChange: (size: number) =&gt; void;\n  handleCurrentChange: (currentPage: number) =&gt; void;\n&#125;\n\ndefineProps&lt;PaginationProps&gt;();\n&lt;/script&gt;三、Hooks 函数1、useTabletsimport &#123; Table &#125; from &quot;./interface&quot;;\nimport &#123; reactive, computed, toRefs &#125; from &quot;vue&quot;;\n\n/**\n * @description table 页面操作方法封装\n * @param &#123;Function&#125; api 获取表格数据 api 方法 (必传)\n * @param &#123;Object&#125; initParam 获取数据初始化参数 (非必传，默认为&#123;&#125;)\n * @param &#123;Boolean&#125; isPageable 是否有分页 (非必传，默认为true)\n * @param &#123;Function&#125; dataCallBack 对后台返回的数据进行处理的方法 (非必传)\n * */\nexport const useTable = (\n  api?: (params: any) =&gt; Promise&lt;any&gt;,\n  initParam: object = &#123;&#125;,\n  isPageable: boolean = true,\n  dataCallBack?: (data: any) =&gt; any,\n  requestError?: (error: any) =&gt; void\n) =&gt; &#123;\n  const state = reactive&lt;Table.TableStateProps&gt;(&#123;\n    // 表格数据\n    tableData: [],\n    // 分页数据\n    pageable: &#123;\n      // 当前页数\n      pageNum: 1,\n      // 每页显示条数\n      pageSize: 10,\n      // 总条数\n      total: 0,\n    &#125;,\n    // 查询参数(只包括查询)\n    searchParam: &#123;&#125;,\n    // 初始化默认的查询参数\n    searchInitParam: &#123;&#125;,\n    // 总参数(包含分页和查询参数)\n    totalParam: &#123;&#125;,\n  &#125;);\n\n  /**\n   * @description 分页查询参数(只包括分页和表格字段排序,其他排序方式可自行配置)\n   * */\n  const pageParam = computed(&#123;\n    get: () =&gt; &#123;\n      return &#123;\n        pageNum: state.pageable.pageNum,\n        pageSize: state.pageable.pageSize,\n      &#125;;\n    &#125;,\n    set: (newVal: any) =&gt; &#123;\n      console.log(&quot;我是分页更新之后的值&quot;, newVal);\n    &#125;,\n  &#125;);\n\n  /**\n   * @description 获取表格数据\n   * @return void\n   * */\n  const getTableList = async () =&gt; &#123;\n    if (!api) return;\n    try &#123;\n      // 先把初始化参数和分页参数放到总参数里面\n      Object.assign(\n        state.totalParam,\n        initParam,\n        isPageable ? pageParam.value : &#123;&#125;\n      );\n      let &#123; data &#125; = await api(&#123;\n        ...state.searchInitParam,\n        ...state.totalParam,\n      &#125;);\n      dataCallBack &amp;&amp; (data = dataCallBack(data));\n      state.tableData = isPageable ? data.list : data;\n      // 解构后台返回的分页数据 (如果有分页更新分页信息)\n      const &#123; pageNum, pageSize, total &#125; = data;\n      isPageable &amp;&amp; updatePageable(&#123; pageNum, pageSize, total &#125;);\n    &#125; catch (error) &#123;\n      requestError &amp;&amp; requestError(error);\n    &#125;\n  &#125;;\n\n  /**\n   * @description 更新查询参数\n   * @return void\n   * */\n  const updatedTotalParam = () =&gt; &#123;\n    state.totalParam = &#123;&#125;;\n    // 处理查询参数，可以给查询参数加自定义前缀操作\n    let nowSearchParam: &#123; [key: string]: any &#125; = &#123;&#125;;\n    // 防止手动清空输入框携带参数（这里可以自定义查询参数前缀）\n    for (let key in state.searchParam) &#123;\n      // * 某些情况下参数为 false/0 也应该携带参数\n      if (\n        state.searchParam[key] ||\n        state.searchParam[key] === false ||\n        state.searchParam[key] === 0\n      ) &#123;\n        nowSearchParam[key] = state.searchParam[key];\n      &#125;\n    &#125;\n    Object.assign(\n      state.totalParam,\n      nowSearchParam,\n      isPageable ? pageParam.value : &#123;&#125;\n    );\n  &#125;;\n\n  /**\n   * @description 更新分页信息\n   * @param &#123;Object&#125; resPageable 后台返回的分页数据\n   * @return void\n   * */\n  const updatePageable = (resPageable: Table.Pageable) =&gt; &#123;\n    Object.assign(state.pageable, resPageable);\n  &#125;;\n\n  /**\n   * @description 表格数据查询\n   * @return void\n   * */\n  const search = () =&gt; &#123;\n    state.pageable.pageNum = 1;\n    updatedTotalParam();\n    getTableList();\n  &#125;;\n\n  /**\n   * @description 表格数据重置\n   * @return void\n   * */\n  const reset = () =&gt; &#123;\n    state.pageable.pageNum = 1;\n    state.searchParam = &#123;&#125;;\n    // 重置搜索表单的时，如果有默认搜索参数，则重置默认的搜索参数\n    Object.keys(state.searchInitParam).forEach((key) =&gt; &#123;\n      state.searchParam[key] = state.searchInitParam[key];\n    &#125;);\n    updatedTotalParam();\n    getTableList();\n  &#125;;\n\n  /**\n   * @description 每页条数改变\n   * @param &#123;Number&#125; val 当前条数\n   * @return void\n   * */\n  const handleSizeChange = (val: number) =&gt; &#123;\n    state.pageable.pageNum = 1;\n    state.pageable.pageSize = val;\n    getTableList();\n  &#125;;\n\n  /**\n   * @description 当前页改变\n   * @param &#123;Number&#125; val 当前页\n   * @return void\n   * */\n  const handleCurrentChange = (val: number) =&gt; &#123;\n    state.pageable.pageNum = val;\n    getTableList();\n  &#125;;\n\n  return &#123;\n    ...toRefs(state),\n    getTableList,\n    search,\n    reset,\n    handleSizeChange,\n    handleCurrentChange,\n    updatedTotalParam,\n  &#125;;\n&#125;;2、useSelectiontsimport &#123; ref, computed &#125; from &quot;vue&quot;;\n\n/**\n * @description 表格多选数据操作\n * @param &#123;String&#125; rowKey 当表格可以多选时，所指定的 id\n * */\nexport const useSelection = (rowKey: string = &quot;id&quot;) =&gt; &#123;\n  const isSelected = ref&lt;boolean&gt;(false);\n  const selectedList = ref&lt;&#123; [key: string]: any &#125;[]&gt;([]);\n\n  // 当前选中的所有 ids 数组\n  const selectedListIds = computed((): string[] =&gt; &#123;\n    let ids: string[] = [];\n    selectedList.value.forEach((item) =&gt; ids.push(item[rowKey]));\n    return ids;\n  &#125;);\n\n  /**\n   * @description 多选操作\n   * @param &#123;Array&#125; rowArr 当前选择的所有数据\n   * @return void\n   */\n  const selectionChange = (rowArr: &#123; [key: string]: any &#125;[]) =&gt; &#123;\n    rowArr.length ? (isSelected.value = true) : (isSelected.value = false);\n    selectedList.value = rowArr;\n  &#125;;\n\n  return &#123;\n    isSelected,\n    selectedList,\n    selectedListIds,\n    selectionChange,\n  &#125;;\n&#125;;3、useDownloadtsimport &#123; ElNotification &#125; from &quot;element-plus&quot;;\n\n/**\n * @description 接收数据流生成 blob，创建链接，下载文件\n * @param &#123;Function&#125; api 导出表格的api方法 (必传)\n * @param &#123;String&#125; tempName 导出的文件名 (必传)\n * @param &#123;Object&#125; params 导出的参数 (默认&#123;&#125;)\n * @param &#123;Boolean&#125; isNotify 是否有导出消息提示 (默认为 true)\n * @param &#123;String&#125; fileType 导出的文件格式 (默认为.xlsx)\n * */\nexport const useDownload = async (\n  api: (param: any) =&gt; Promise&lt;any&gt;,\n  tempName: string,\n  params: any = &#123;&#125;,\n  isNotify: boolean = true,\n  fileType: string = &quot;.xlsx&quot;\n) =&gt; &#123;\n  if (isNotify) &#123;\n    ElNotification(&#123;\n      title: &quot;温馨提示&quot;,\n      message: &quot;如果数据庞大会导致下载缓慢哦，请您耐心等待！&quot;,\n      type: &quot;info&quot;,\n      duration: 3000,\n    &#125;);\n  &#125;\n  try &#123;\n    const res = await api(params);\n    const blob = new Blob([res]);\n    // 兼容 edge 不支持 createObjectURL 方法\n    if (&quot;msSaveOrOpenBlob&quot; in navigator)\n      return window.navigator.msSaveOrOpenBlob(blob, tempName + fileType);\n    const blobUrl = window.URL.createObjectURL(blob);\n    const exportFile = document.createElement(&quot;a&quot;);\n    exportFile.style.display = &quot;none&quot;;\n    exportFile.download = `$&#123;tempName&#125;$&#123;fileType&#125;`;\n    exportFile.href = blobUrl;\n    document.body.appendChild(exportFile);\n    exportFile.click();\n    // 去除下载对 url 的影响\n    document.body.removeChild(exportFile);\n    window.URL.revokeObjectURL(blobUrl);\n  &#125; catch (error) &#123;\n    console.log(error);\n  &#125;\n&#125;;4、useHandledatatsimport &#123; ElMessageBox, ElMessage &#125; from &quot;element-plus&quot;;\nimport &#123; HandleData &#125; from &quot;./interface&quot;;\n\n/**\n * @description 操作单条数据信息 (二次确认【删除、禁用、启用、重置密码】)\n * @param &#123;Function&#125; api 操作数据接口的api方法 (必传)\n * @param &#123;Object&#125; params 携带的操作数据参数 &#123;id,params&#125; (必传)\n * @param &#123;String&#125; message 提示信息 (必传)\n * @param &#123;String&#125; confirmType icon类型 (不必传,默认为 warning)\n * @returns &#123;Promise&#125;\n */\nexport const useHandleData = (\n  api: (params: any) =&gt; Promise&lt;any&gt;,\n  params: any = &#123;&#125;,\n  message: string,\n  confirmType: HandleData.MessageType = &quot;warning&quot;\n) =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    ElMessageBox.confirm(`是否$&#123;message&#125;?`, &quot;温馨提示&quot;, &#123;\n      confirmButtonText: &quot;确定&quot;,\n      cancelButtonText: &quot;取消&quot;,\n      type: confirmType,\n      draggable: true,\n    &#125;).then(async () =&gt; &#123;\n      const res = await api(params);\n      if (!res) return reject(false);\n      ElMessage(&#123;\n        type: &quot;success&quot;,\n        message: `$&#123;message&#125;成功!`,\n      &#125;);\n      resolve(true);\n    &#125;);\n  &#125;);\n&#125;;四、ProTable 组件部分代码ProTable.vuevue&lt;template&gt;\n  &lt;!-- 查询表单 card --&gt;\n  &lt;SearchForm\n    :search=&quot;search&quot;\n    :reset=&quot;reset&quot;\n    :columns=&quot;searchColumns&quot;\n    :search-param=&quot;searchParam&quot;\n    :search-col=&quot;searchCol&quot;\n    v-show=&quot;isShowSearch&quot;\n  /&gt;\n\n  &lt;!-- 表格内容 card --&gt;\n  &lt;div class=&quot;card table-main&quot;&gt;\n    &lt;!-- 表格头部 操作按钮 --&gt;\n    &lt;div class=&quot;table-header&quot;&gt;\n      &lt;div class=&quot;header-button-lf&quot;&gt;\n        &lt;slot\n          name=&quot;tableHeader&quot;\n          :selectedListIds=&quot;selectedListIds&quot;\n          :selectedList=&quot;selectedList&quot;\n          :isSelected=&quot;isSelected&quot;\n        /&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;header-button-ri&quot; v-if=&quot;toolButton&quot;&gt;\n        &lt;slot name=&quot;toolButton&quot;&gt;\n          &lt;el-button :icon=&quot;Refresh&quot; circle @click=&quot;getTableList&quot; /&gt;\n          &lt;el-button\n            :icon=&quot;Printer&quot;\n            circle\n            v-if=&quot;columns.length&quot;\n            @click=&quot;print&quot;\n          /&gt;\n          &lt;el-button\n            :icon=&quot;Operation&quot;\n            circle\n            v-if=&quot;columns.length&quot;\n            @click=&quot;openColSetting&quot;\n          /&gt;\n          &lt;el-button\n            :icon=&quot;Search&quot;\n            circle\n            v-if=&quot;searchColumns.length&quot;\n            @click=&quot;isShowSearch = !isShowSearch&quot;\n          /&gt;\n        &lt;/slot&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;!-- 表格主体 --&gt;\n    &lt;el-table\n      ref=&quot;tableRef&quot;\n      v-bind=&quot;$attrs&quot;\n      :data=&quot;data ?? tableData&quot;\n      :border=&quot;border&quot;\n      :row-key=&quot;rowKey&quot;\n      @selection-change=&quot;selectionChange&quot;\n    &gt;\n      &lt;!-- 默认插槽 --&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n      &lt;template v-for=&quot;item in tableColumns&quot; :key=&quot;item&quot;&gt;\n        &lt;!-- selection || index || expand --&gt;\n        &lt;el-table-column\n          v-bind=&quot;item&quot;\n          :align=&quot;item.align ?? &#39;center&#39;&quot;\n          :reserve-selection=&quot;item.type == &#39;selection&#39;&quot;\n          v-if=&quot;\n            item.type &amp;&amp; [&#39;selection&#39;, &#39;index&#39;, &#39;expand&#39;].includes(item.type)\n          &quot;\n        &gt;\n          &lt;template #default=&quot;scope&quot; v-if=&quot;item.type == &#39;expand&#39;&quot;&gt;\n            &lt;component :is=&quot;item.render&quot; v-bind=&quot;scope&quot; v-if=&quot;item.render&quot;&gt;\n            &lt;/component&gt;\n            &lt;slot :name=&quot;item.type&quot; v-bind=&quot;scope&quot; v-else&gt;&lt;/slot&gt;\n          &lt;/template&gt;\n        &lt;/el-table-column&gt;\n        &lt;!-- other --&gt;\n        &lt;TableColumn\n          v-if=&quot;!item.type &amp;&amp; item.prop &amp;&amp; item.isShow&quot;\n          :column=&quot;item&quot;\n        &gt;\n          &lt;template v-for=&quot;slot in Object.keys($slots)&quot; #[slot]=&quot;scope&quot;&gt;\n            &lt;slot :name=&quot;slot&quot; v-bind=&quot;scope&quot;&gt;&lt;/slot&gt;\n          &lt;/template&gt;\n        &lt;/TableColumn&gt;\n      &lt;/template&gt;\n      &lt;!-- 插入表格最后一行之后的插槽 --&gt;\n      &lt;template #append&gt;\n        &lt;slot name=&quot;append&quot;&gt; &lt;/slot&gt;\n      &lt;/template&gt;\n      &lt;!-- 无数据 --&gt;\n      &lt;template #empty&gt;\n        &lt;div class=&quot;table-empty&quot;&gt;\n          &lt;slot name=&quot;empty&quot;&gt;\n            &lt;img src=&quot;@/assets/images/notData.png&quot; alt=&quot;notData&quot; /&gt;\n            &lt;div&gt;暂无数据&lt;/div&gt;\n          &lt;/slot&gt;\n        &lt;/div&gt;\n      &lt;/template&gt;\n    &lt;/el-table&gt;\n    &lt;!-- 分页组件 --&gt;\n    &lt;slot name=&quot;pagination&quot;&gt;\n      &lt;Pagination\n        v-if=&quot;pagination&quot;\n        :pageable=&quot;pageable&quot;\n        :handle-size-change=&quot;handleSizeChange&quot;\n        :handle-current-change=&quot;handleCurrentChange&quot;\n      /&gt;\n    &lt;/slot&gt;\n  &lt;/div&gt;\n  &lt;!-- 列设置 --&gt;\n  &lt;ColSetting v-if=&quot;toolButton&quot; ref=&quot;colRef&quot; v-model:col-setting=&quot;colSetting&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot; name=&quot;ProTable&quot;&gt;\nimport &#123; ref, watch, computed, provide, onMounted &#125; from &quot;vue&quot;;\nimport &#123; ElTable &#125; from &quot;element-plus&quot;;\nimport &#123; useTable &#125; from &quot;@/hooks/useTable&quot;;\nimport &#123; useSelection &#125; from &quot;@/hooks/useSelection&quot;;\nimport &#123; BreakPoint &#125; from &quot;@/components/Grid/interface&quot;;\nimport &#123; ColumnProps &#125; from &quot;@/components/ProTable/interface&quot;;\nimport &#123; Refresh, Printer, Operation, Search &#125; from &quot;@element-plus/icons-vue&quot;;\nimport &#123;\n  filterEnum,\n  formatValue,\n  handleProp,\n  handleRowAccordingToProp,\n&#125; from &quot;@/utils&quot;;\nimport SearchForm from &quot;@/components/SearchForm/index.vue&quot;;\nimport Pagination from &quot;./components/Pagination.vue&quot;;\nimport ColSetting from &quot;./components/ColSetting.vue&quot;;\nimport TableColumn from &quot;./components/TableColumn.vue&quot;;\nimport printJS from &quot;print-js&quot;;\n\nexport interface ProTableProps &#123;\n  columns: ColumnProps[]; // 列配置项  ==&gt; 必传\n  data?: any[]; // 静态 table data 数据，若存在则不会使用 requestApi 返回的 data ==&gt; 非必传\n  requestApi?: (params: any) =&gt; Promise&lt;any&gt;; // 请求表格数据的 api ==&gt; 非必传\n  requestAuto?: boolean; // 是否自动执行请求 api ==&gt; 非必传（默认为true）\n  requestError?: (params: any) =&gt; void; // 表格 api 请求错误监听 ==&gt; 非必传\n  dataCallback?: (data: any) =&gt; any; // 返回数据的回调函数，可以对数据进行处理 ==&gt; 非必传\n  title?: string; // 表格标题，目前只在打印的时候用到 ==&gt; 非必传\n  pagination?: boolean; // 是否需要分页组件 ==&gt; 非必传（默认为true）\n  initParam?: any; // 初始化请求参数 ==&gt; 非必传（默认为&#123;&#125;）\n  border?: boolean; // 是否带有纵向边框 ==&gt; 非必传（默认为true）\n  toolButton?: boolean; // 是否显示表格功能按钮 ==&gt; 非必传（默认为true）\n  rowKey?: string; // 行数据的 Key，用来优化 Table 的渲染，当表格数据多选时，所指定的 id ==&gt; 非必传（默认为 id）\n  searchCol?: number | Record&lt;BreakPoint, number&gt;; // 表格搜索项 每列占比配置 ==&gt; 非必传 &#123; xs: 1, sm: 2, md: 2, lg: 3, xl: 4 &#125;\n&#125;\n\n// 接受父组件参数，配置默认值\nconst props = withDefaults(defineProps&lt;ProTableProps&gt;(), &#123;\n  columns: () =&gt; [],\n  requestAuto: true,\n  pagination: true,\n  initParam: &#123;&#125;,\n  border: true,\n  toolButton: true,\n  rowKey: &quot;id&quot;,\n  searchCol: () =&gt; (&#123; xs: 1, sm: 2, md: 2, lg: 3, xl: 4 &#125;),\n&#125;);\n\n// 是否显示搜索模块\nconst isShowSearch = ref(true);\n\n// 表格 DOM 元素\nconst tableRef = ref&lt;InstanceType&lt;typeof ElTable&gt;&gt;();\n\n// 表格多选 Hooks\nconst &#123; selectionChange, selectedList, selectedListIds, isSelected &#125; =\n  useSelection(props.rowKey);\n\n// 表格操作 Hooks\nconst &#123;\n  tableData,\n  pageable,\n  searchParam,\n  searchInitParam,\n  getTableList,\n  search,\n  reset,\n  handleSizeChange,\n  handleCurrentChange,\n&#125; = useTable(\n  props.requestApi,\n  props.initParam,\n  props.pagination,\n  props.dataCallback,\n  props.requestError\n);\n\n// 清空选中数据列表\nconst clearSelection = () =&gt; tableRef.value!.clearSelection();\n\n// 初始化请求\nonMounted(() =&gt; props.requestAuto &amp;&amp; getTableList());\n\n// 监听页面 initParam 改化，重新获取表格数据\nwatch(() =&gt; props.initParam, getTableList, &#123; deep: true &#125;);\n\n// 接收 columns 并设置为响应式\nconst tableColumns = ref&lt;ColumnProps[]&gt;(props.columns);\n\n// 定义 enumMap 存储 enum 值（避免异步请求无法格式化单元格内容 || 无法填充搜索下拉选择）\nconst enumMap = ref(new Map&lt;string, &#123; [key: string]: any &#125;[]&gt;());\nprovide(&quot;enumMap&quot;, enumMap);\nconst setEnumMap = async (col: ColumnProps) =&gt; &#123;\n  if (!col.enum) return;\n  // 如果当前 enum 为后台数据需要请求数据，则调用该请求接口，并存储到 enumMap\n  if (typeof col.enum !== &quot;function&quot;)\n    return enumMap.value.set(col.prop!, col.enum!);\n  const &#123; data &#125; = await col.enum();\n  enumMap.value.set(col.prop!, data);\n&#125;;\n\n// 扁平化 columns\nconst flatColumnsFunc = (\n  columns: ColumnProps[],\n  flatArr: ColumnProps[] = []\n) =&gt; &#123;\n  columns.forEach(async (col) =&gt; &#123;\n    if (col._children?.length) flatArr.push(...flatColumnsFunc(col._children));\n    flatArr.push(col);\n\n    // 给每一项 column 添加 isShow &amp;&amp; isFilterEnum 默认属性\n    col.isShow = col.isShow ?? true;\n    col.isFilterEnum = col.isFilterEnum ?? true;\n\n    // 设置 enumMap\n    setEnumMap(col);\n  &#125;);\n  return flatArr.filter((item) =&gt; !item._children?.length);\n&#125;;\n\n// flatColumns\nconst flatColumns = ref&lt;ColumnProps[]&gt;();\nflatColumns.value = flatColumnsFunc(tableColumns.value);\n\n// 过滤需要搜索的配置项\nconst searchColumns = flatColumns.value.filter(\n  (item) =&gt; item.search?.el || item.search?.render\n);\n\n// 设置搜索表单排序默认值 &amp;&amp; 设置搜索表单项的默认值\nsearchColumns.forEach((column, index) =&gt; &#123;\n  column.search!.order = column.search!.order ?? index + 2;\n  if (\n    column.search?.defaultValue !== undefined &amp;&amp;\n    column.search?.defaultValue !== null\n  ) &#123;\n    searchInitParam.value[column.search.key ?? handleProp(column.prop!)] =\n      column.search?.defaultValue;\n    searchParam.value[column.search.key ?? handleProp(column.prop!)] =\n      column.search?.defaultValue;\n  &#125;\n&#125;);\n\n// 排序搜索表单项\nsearchColumns.sort((a, b) =&gt; a.search!.order! - b.search!.order!);\n\n// 列设置 ==&gt; 过滤掉不需要设置的列\nconst colRef = ref();\nconst colSetting = tableColumns.value!.filter(\n  (item) =&gt;\n    ![&quot;selection&quot;, &quot;index&quot;, &quot;expand&quot;].includes(item.type!) &amp;&amp;\n    item.prop !== &quot;operation&quot; &amp;&amp;\n    item.isShow\n);\nconst openColSetting = () =&gt; colRef.value.openColSetting();\n\n// 🙅‍♀️ 不需要打印可以把以下方法删除，打印功能目前存在很多 bug\n// 处理打印数据（把后台返回的值根据 enum 做转换）\nconst printData = computed(() =&gt; &#123;\n  const handleData = props.data ?? tableData.value;\n  const printDataList = JSON.parse(\n    JSON.stringify(selectedList.value.length ? selectedList.value : handleData)\n  );\n  // 找出需要转换数据的列（有 enum || 多级 prop &amp;&amp; 需要根据 enum 格式化）\n  const needTransformCol = flatColumns.value!.filter(\n    (item) =&gt;\n      (item.enum || (item.prop &amp;&amp; item.prop.split(&quot;.&quot;).length &gt; 1)) &amp;&amp;\n      item.isFilterEnum\n  );\n  needTransformCol.forEach((colItem) =&gt; &#123;\n    printDataList.forEach((tableItem: &#123; [key: string]: any &#125;) =&gt; &#123;\n      tableItem[handleProp(colItem.prop!)] =\n        colItem.prop!.split(&quot;.&quot;).length &gt; 1 &amp;&amp; !colItem.enum\n          ? formatValue(handleRowAccordingToProp(tableItem, colItem.prop!))\n          : filterEnum(\n              handleRowAccordingToProp(tableItem, colItem.prop!),\n              enumMap.value.get(colItem.prop!),\n              colItem.fieldNames\n            );\n      for (const key in tableItem) &#123;\n        if (tableItem[key] === null)\n          tableItem[key] = formatValue(tableItem[key]);\n      &#125;\n    &#125;);\n  &#125;);\n  return printDataList;\n&#125;);\n\n// 打印表格数据（💥 多级表头数据打印时，只能扁平化成一维数组，printJs 不支持多级表头打印）\nconst print = () =&gt; &#123;\n  const header = `&lt;div style=&quot;text-align: center&quot;&gt;&lt;h2&gt;$&#123;props.title&#125;&lt;/h2&gt;&lt;/div&gt;`;\n  const gridHeaderStyle =\n    &quot;border: 1px solid #ebeef5;height: 45px;color: #232425;text-align: center;background-color: #fafafa;&quot;;\n  const gridStyle =\n    &quot;border: 1px solid #ebeef5;height: 40px;color: #494b4e;text-align: center&quot;;\n  printJS(&#123;\n    printable: printData.value,\n    header: props.title &amp;&amp; header,\n    properties: flatColumns\n      .value!.filter(\n        (item) =&gt;\n          ![&quot;selection&quot;, &quot;index&quot;, &quot;expand&quot;].includes(item.type!) &amp;&amp;\n          item.isShow &amp;&amp;\n          item.prop !== &quot;operation&quot;\n      )\n      .map((item: ColumnProps) =&gt; (&#123;\n        field: handleProp(item.prop!),\n        displayName: item.label,\n      &#125;)),\n    type: &quot;json&quot;,\n    gridHeaderStyle,\n    gridStyle,\n  &#125;);\n&#125;;\n\n// 暴露给父组件的参数和方法(外部需要什么，都可以从这里暴露出去)\ndefineExpose(&#123;\n  element: tableRef,\n  tableData,\n  pageable,\n  searchParam,\n  searchInitParam,\n  getTableList,\n  search,\n  reset,\n  handleSizeChange,\n  handleCurrentChange,\n  clearSelection,\n  enumMap,\n  isSelected,\n  selectedList,\n  selectedListIds,\n&#125;);\n&lt;/script&gt;TableColumn.vuevue&lt;template&gt;\n  &lt;RenderTableColumn v-bind=&quot;column&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;tsx&quot; name=&quot;TableColumn&quot;&gt;\nimport &#123; inject, ref, useSlots &#125; from &quot;vue&quot;;\nimport &#123;\n  ColumnProps,\n  RenderScope,\n  HeaderRenderScope,\n&#125; from &quot;@/components/ProTable/interface&quot;;\nimport &#123;\n  filterEnum,\n  formatValue,\n  handleProp,\n  handleRowAccordingToProp,\n&#125; from &quot;@/utils&quot;;\n\ndefineProps&lt;&#123; column: ColumnProps &#125;&gt;();\n\nconst slots = useSlots();\n\nconst enumMap = inject(&quot;enumMap&quot;, ref(new Map()));\n\n// 渲染表格数据\nconst renderCellData = (item: ColumnProps, scope: RenderScope&lt;any&gt;) =&gt; &#123;\n  return enumMap.value.get(item.prop) &amp;&amp; item.isFilterEnum\n    ? filterEnum(\n        handleRowAccordingToProp(scope.row, item.prop!),\n        enumMap.value.get(item.prop)!,\n        item.fieldNames\n      )\n    : formatValue(handleRowAccordingToProp(scope.row, item.prop!));\n&#125;;\n\n// 获取 tag 类型\nconst getTagType = (item: ColumnProps, scope: RenderScope&lt;any&gt;) =&gt; &#123;\n  return filterEnum(\n    handleRowAccordingToProp(scope.row, item.prop!),\n    enumMap.value.get(item.prop),\n    item.fieldNames,\n    &quot;tag&quot;\n  );\n&#125;;\n\nconst RenderTableColumn = (item: ColumnProps) =&gt; &#123;\n  return (\n    &lt;&gt;\n      &#123;item.isShow &amp;&amp; (\n        &lt;el-table-column\n          &#123;...item&#125;\n          align=&#123;item.align ?? &quot;center&quot;&#125;\n          showOverflowTooltip=&#123;\n            item.showOverflowTooltip ?? item.prop !== &quot;operation&quot;\n          &#125;\n        &gt;\n          &#123;&#123;\n            default: (scope: RenderScope) => &#123;\n              if (item._children)\n                return item._children.map((child) => RenderTableColumn(child));\n              if (item.render) return item.render(scope);\n              if (slots[handleProp(item.prop!)])\n                return slots[handleProp(item.prop!)]!(scope);\n              if (item.tag)\n                return (\n                  \n                    &#123;renderCellData(item, scope)&#125;\n                  \n                );\n              return renderCellData(item, scope);\n            &#125;,\n            header: (scope: HeaderRenderScope) => &#123;\n              if (item.headerRender) return item.headerRender(scope);\n              if (slots[`$&#123;handleProp(item.prop!)&#125;Header`])\n                return slots[`$&#123;handleProp(item.prop!)&#125;Header`]!(scope);\n              return item.label;\n            &#125;,\n          &#125;&#125;\n        &lt;/el-table-column&gt;\n      )&#125;\n    &lt;/&gt;\n  );\n&#125;;\n&lt;/script&gt;使用 ProTable 组件vue&lt;template&gt;\n  &lt;div class=&quot;table-box&quot;&gt;\n    &lt;ProTable\n      ref=&quot;proTable&quot;\n      title=&quot;用户列表&quot;\n      :columns=&quot;columns&quot;\n      :request-api=&quot;getTableList&quot;\n      :init-param=&quot;initParam&quot;\n      :data-callback=&quot;dataCallback&quot;\n    &gt;\n      &lt;!-- 表格 header 按钮 --&gt;\n      &lt;template #tableHeader=&quot;scope&quot;&gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          :icon=&quot;CirclePlus&quot;\n          @click=&quot;openDrawer(&#39;新增&#39;)&quot;\n          v-auth=&quot;&#39;add&#39;&quot;\n          &gt;新增用户&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          :icon=&quot;Upload&quot;\n          plain\n          @click=&quot;batchAdd&quot;\n          v-auth=&quot;&#39;batchAdd&#39;&quot;\n          &gt;批量添加用户&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          :icon=&quot;Download&quot;\n          plain\n          @click=&quot;downloadFile&quot;\n          v-auth=&quot;&#39;export&#39;&quot;\n          &gt;导出用户数据&lt;/el-button\n        &gt;\n        &lt;el-button type=&quot;primary&quot; plain @click=&quot;toDetail&quot;\n          &gt;To 子集详情页面&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;danger&quot;\n          :icon=&quot;Delete&quot;\n          plain\n          @click=&quot;batchDelete(scope.selectedListIds)&quot;\n          :disabled=&quot;!scope.isSelected&quot;\n        &gt;\n          批量删除用户\n        &lt;/el-button&gt;\n      &lt;/template&gt;\n      &lt;!-- Expand --&gt;\n      &lt;template #expand=&quot;scope&quot;&gt;\n        &#123;&#123; scope.row &#125;&#125;\n      &lt;/template&gt;\n      &lt;!-- usernameHeader --&gt;\n      &lt;template #usernameHeader=&quot;scope&quot;&gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          @click=&quot;ElMessage.success(&#39;我是通过作用域插槽渲染的表头&#39;)&quot;\n        &gt;\n          &#123;&#123; scope.column.label &#125;&#125;\n        &lt;/el-button&gt;\n      &lt;/template&gt;\n      &lt;!-- createTime --&gt;\n      &lt;template #createTime=&quot;scope&quot;&gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          @click=&quot;ElMessage.success(&#39;我是通过作用域插槽渲染的内容&#39;)&quot;\n        &gt;\n          &#123;&#123; scope.row.createTime &#125;&#125;\n        &lt;/el-button&gt;\n      &lt;/template&gt;\n      &lt;!-- 表格操作 --&gt;\n      &lt;template #operation=&quot;scope&quot;&gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          :icon=&quot;View&quot;\n          @click=&quot;openDrawer(&#39;查看&#39;, scope.row)&quot;\n          &gt;查看&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          :icon=&quot;EditPen&quot;\n          @click=&quot;openDrawer(&#39;编辑&#39;, scope.row)&quot;\n          &gt;编辑&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          :icon=&quot;Refresh&quot;\n          @click=&quot;resetPass(scope.row)&quot;\n          &gt;重置密码&lt;/el-button\n        &gt;\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          :icon=&quot;Delete&quot;\n          @click=&quot;deleteAccount(scope.row)&quot;\n          &gt;删除&lt;/el-button\n        &gt;\n      &lt;/template&gt;\n    &lt;/ProTable&gt;\n    &lt;UserDrawer ref=&quot;drawerRef&quot; /&gt;\n    &lt;ImportExcel ref=&quot;dialogRef&quot; /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;tsx&quot; name=&quot;useProTable&quot;&gt;\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\nimport &#123; useRouter &#125; from &quot;vue-router&quot;;\nimport &#123; User &#125; from &quot;@/api/interface&quot;;\nimport &#123; useHandleData &#125; from &quot;@/hooks/useHandleData&quot;;\nimport &#123; useDownload &#125; from &quot;@/hooks/useDownload&quot;;\nimport &#123; useAuthButtons &#125; from &quot;@/hooks/useAuthButtons&quot;;\nimport &#123; ElMessage, ElMessageBox &#125; from &quot;element-plus&quot;;\nimport ProTable from &quot;@/components/ProTable/index.vue&quot;;\nimport ImportExcel from &quot;@/components/ImportExcel/index.vue&quot;;\nimport UserDrawer from &quot;@/views/proTable/components/UserDrawer.vue&quot;;\nimport &#123;\n  ProTableInstance,\n  ColumnProps,\n  HeaderRenderScope,\n&#125; from &quot;@/components/ProTable/interface&quot;;\nimport &#123;\n  CirclePlus,\n  Delete,\n  EditPen,\n  Download,\n  Upload,\n  View,\n  Refresh,\n&#125; from &quot;@element-plus/icons-vue&quot;;\nimport &#123;\n  getUserList,\n  deleteUser,\n  editUser,\n  addUser,\n  changeUserStatus,\n  resetUserPassWord,\n  exportUserInfo,\n  BatchAddUser,\n  getUserStatus,\n  getUserGender,\n&#125; from &quot;@/api/modules/user&quot;;\n\nconst router = useRouter();\n\n// 跳转详情页\nconst toDetail = () =&gt; &#123;\n  router.push(\n    `/proTable/useProTable/detail/$&#123;Math.random().toFixed(\n      3\n    )&#125;?params=detail-page`\n  );\n&#125;;\n\n// 获取 ProTable 元素，调用其获取刷新数据方法（还能获取到当前查询参数，方便导出携带参数）\nconst proTable = ref&lt;ProTableInstance&gt;();\n\n// 如果表格需要初始化请求参数，直接定义传给 ProTable(之后每次请求都会自动带上该参数，此参数更改之后也会一直带上，改变此参数会自动刷新表格数据)\nconst initParam = reactive(&#123; type: 1 &#125;);\n\n// dataCallback 是对于返回的表格数据做处理，如果你后台返回的数据不是 list &amp;&amp; total &amp;&amp; pageNum &amp;&amp; pageSize 这些字段，那么你可以在这里进行处理成这些字段\n// 或者直接去 hooks/useTable.ts 文件中把字段改为你后端对应的就行\nconst dataCallback = (data: any) =&gt; &#123;\n  return &#123;\n    list: data.list,\n    total: data.total,\n    pageNum: data.pageNum,\n    pageSize: data.pageSize,\n  &#125;;\n&#125;;\n\n// 如果你想在请求之前对当前请求参数做一些操作，可以自定义如下函数：params 为当前所有的请求参数（包括分页），最后返回请求列表接口\n// 默认不做操作就直接在 ProTable 组件上绑定\t:requestApi=&quot;getUserList&quot;\nconst getTableList = (params: any) =&gt; &#123;\n  let newParams = JSON.parse(JSON.stringify(params));\n  newParams.createTime &amp;&amp; (newParams.startTime = newParams.createTime[0]);\n  newParams.createTime &amp;&amp; (newParams.endTime = newParams.createTime[1]);\n  delete newParams.createTime;\n  return getUserList(newParams);\n&#125;;\n\n// 页面按钮权限（按钮权限既可以使用 hooks，也可以直接使用 v-auth 指令，指令适合直接绑定在按钮上，hooks 适合根据按钮权限显示不同的内容）\nconst &#123; BUTTONS &#125; = useAuthButtons();\n\n// 自定义渲染表头（使用tsx语法）\nconst headerRender = (scope: HeaderRenderScope&lt;User.ResUserList&gt;) =&gt; &#123;\n  return (\n    &lt;el-button\n      type=&quot;primary&quot;\n      onClick=&#123;() =&gt; ElMessage.success(&quot;我是通过 tsx 语法渲染的表头&quot;)&#125;\n    &gt;\n      &#123;scope.column.label&#125;\n    &lt;/el-button&gt;\n  );\n&#125;;\n\n// 表格配置项\nconst columns: ColumnProps&lt;User.ResUserList&gt;[] = [\n  &#123; type: &quot;selection&quot;, fixed: &quot;left&quot;, width: 80 &#125;,\n  &#123; type: &quot;index&quot;, label: &quot;#&quot;, width: 80 &#125;,\n  &#123; type: &quot;expand&quot;, label: &quot;Expand&quot;, width: 100 &#125;,\n  &#123;\n    prop: &quot;username&quot;,\n    label: &quot;用户姓名&quot;,\n    search: &#123; el: &quot;input&quot; &#125;,\n    render: (scope) =&gt; &#123;\n      return (\n        &lt;el-button\n          type=&quot;primary&quot;\n          link\n          onClick=&#123;() =&gt; ElMessage.success(&quot;我是通过 tsx 语法渲染的内容&quot;)&#125;\n        &gt;\n          &#123;scope.row.username&#125;\n        &lt;/el-button&gt;\n      );\n    &#125;,\n  &#125;,\n  &#123;\n    prop: &quot;gender&quot;,\n    label: &quot;性别&quot;,\n    // 字典数据\n    // enum: genderType,\n    // 字典请求不带参数\n    enum: getUserGender,\n    // 字典请求携带参数\n    // enum: () =&gt; getUserGender(&#123; id: 1 &#125;),\n    search: &#123; el: &quot;select&quot;, props: &#123; filterable: true &#125; &#125;,\n    fieldNames: &#123; label: &quot;genderLabel&quot;, value: &quot;genderValue&quot; &#125;,\n  &#125;,\n  &#123;\n    // 多级 prop\n    prop: &quot;user.detail.age&quot;,\n    label: &quot;年龄&quot;,\n    search: &#123;\n      // 自定义 search 显示内容\n      render: (&#123; searchParam &#125;) =&gt; &#123;\n        return (\n          &lt;div class=&quot;flx-center&quot;&gt;\n            &lt;el-input vModel_trim=&#123;searchParam.minAge&#125; placeholder=&quot;最小年龄&quot; /&gt;\n            &lt;span class=&quot;mr10 ml10&quot;&gt;-&lt;/span&gt;\n            &lt;el-input vModel_trim=&#123;searchParam.maxAge&#125; placeholder=&quot;最大年龄&quot; /&gt;\n          &lt;/div&gt;\n        );\n      &#125;,\n    &#125;,\n  &#125;,\n  &#123; prop: &quot;idCard&quot;, label: &quot;身份证号&quot;, search: &#123; el: &quot;input&quot; &#125; &#125;,\n  &#123; prop: &quot;email&quot;, label: &quot;邮箱&quot; &#125;,\n  &#123; prop: &quot;address&quot;, label: &quot;居住地址&quot; &#125;,\n  &#123;\n    prop: &quot;status&quot;,\n    label: &quot;用户状态&quot;,\n    enum: getUserStatus,\n    search: &#123; el: &quot;tree-select&quot;, props: &#123; filterable: true &#125; &#125;,\n    fieldNames: &#123; label: &quot;userLabel&quot;, value: &quot;userStatus&quot; &#125;,\n    render: (scope) =&gt; &#123;\n      return (\n        &lt;&gt;\n          &#123;BUTTONS.value.status ? (\n            &lt;el-switch\n              model-value=&#123;scope.row.status&#125;\n              active-text=&#123;scope.row.status ? &quot;启用&quot; : &quot;禁用&quot;&#125;\n              active-value=&#123;1&#125;\n              inactive-value=&#123;0&#125;\n              onClick=&#123;() =&gt; changeStatus(scope.row)&#125;\n            /&gt;\n          ) : (\n            &lt;el-tag type=&#123;scope.row.status ? &quot;success&quot; : &quot;danger&quot;&#125;&gt;\n              &#123;scope.row.status ? &quot;启用&quot; : &quot;禁用&quot;&#125;\n            &lt;/el-tag&gt;\n          )&#125;\n        &lt;/&gt;\n      );\n    &#125;,\n  &#125;,\n  &#123;\n    prop: &quot;createTime&quot;,\n    label: &quot;创建时间&quot;,\n    headerRender,\n    width: 180,\n    search: &#123;\n      el: &quot;date-picker&quot;,\n      span: 2,\n      props: &#123; type: &quot;datetimerange&quot;, valueFormat: &quot;YYYY-MM-DD HH:mm:ss&quot; &#125;,\n      defaultValue: [&quot;2022-11-12 11:35:00&quot;, &quot;2022-12-12 11:35:00&quot;],\n    &#125;,\n  &#125;,\n  &#123; prop: &quot;operation&quot;, label: &quot;操作&quot;, fixed: &quot;right&quot;, width: 330 &#125;,\n];\n\n// 删除用户信息\nconst deleteAccount = async (params: User.ResUserList) =&gt; &#123;\n  await useHandleData(\n    deleteUser,\n    &#123; id: [params.id] &#125;,\n    `删除【$&#123;params.username&#125;】用户`\n  );\n  proTable.value?.getTableList();\n&#125;;\n\n// 批量删除用户信息\nconst batchDelete = async (id: string[]) =&gt; &#123;\n  await useHandleData(deleteUser, &#123; id &#125;, &quot;删除所选用户信息&quot;);\n  proTable.value?.clearSelection();\n  proTable.value?.getTableList();\n&#125;;\n\n// 重置用户密码\nconst resetPass = async (params: User.ResUserList) =&gt; &#123;\n  await useHandleData(\n    resetUserPassWord,\n    &#123; id: params.id &#125;,\n    `重置【$&#123;params.username&#125;】用户密码`\n  );\n  proTable.value?.getTableList();\n&#125;;\n\n// 切换用户状态\nconst changeStatus = async (row: User.ResUserList) =&gt; &#123;\n  await useHandleData(\n    changeUserStatus,\n    &#123; id: row.id, status: row.status == 1 ? 0 : 1 &#125;,\n    `切换【$&#123;row.username&#125;】用户状态`\n  );\n  proTable.value?.getTableList();\n&#125;;\n\n// 导出用户列表\nconst downloadFile = async () =&gt; &#123;\n  ElMessageBox.confirm(&quot;确认导出用户数据?&quot;, &quot;温馨提示&quot;, &#123;\n    type: &quot;warning&quot;,\n  &#125;).then(() =&gt;\n    useDownload(exportUserInfo, &quot;用户列表&quot;, proTable.value?.searchParam)\n  );\n&#125;;\n\n// 批量添加用户\nconst dialogRef = ref&lt;InstanceType&lt;typeof ImportExcel&gt; | null&gt;(null);\nconst batchAdd = () =&gt; &#123;\n  const params = &#123;\n    title: &quot;用户&quot;,\n    tempApi: exportUserInfo,\n    importApi: BatchAddUser,\n    getTableList: proTable.value?.getTableList,\n  &#125;;\n  dialogRef.value?.acceptParams(params);\n&#125;;\n\n// 打开 drawer(新增、查看、编辑)\nconst drawerRef = ref&lt;InstanceType&lt;typeof UserDrawer&gt; | null&gt;(null);\nconst openDrawer = (title: string, row: Partial&lt;User.ResUserList&gt; = &#123;&#125;) =&gt; &#123;\n  const params = &#123;\n    title,\n    isView: title === &quot;查看&quot;,\n    row: &#123; ...row &#125;,\n    api: title === &quot;新增&quot; ? addUser : title === &quot;编辑&quot; ? editUser : undefined,\n    getTableList: proTable.value?.getTableList,\n  &#125;;\n  drawerRef.value?.acceptParams(params);\n&#125;;\n&lt;/script&gt;","slug":"121-proTable","date":"2023-02-08T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"8d2f1f12444e800d514adee8597c94e3","title":"120、git提交代码终端出现“Enter passphrase for key ‘/Users/yq/.ssh/id_rsa”","content":"\n\n解决方式1、打开终端\ntxtssh-add -K /Users/yq/.ssh/id_rsa根据终端提示，输入电脑开机密码；\n成功后会提示： Identity added: &#x2F;Users&#x2F;yq&#x2F;.ssh&#x2F;id_rsa (&#x31;&#x33;&#51;&#x34;&#51;&#x35;&#x32;&#x38;&#x30;&#56;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109;)\n之后在提交代码的时候，不会需要 enter 以下提交代码\n更改为：\ntxtssh-add --apple-use-keychain /Users/yq/.ssh/id_rsa\nssh-add --apple-load-keychain /Users/yq/.ssh/id_rsa","slug":"120-github","date":"2023-02-03T12:00:00.000Z","categories_index":"","tags_index":"git","author_index":"Jude"},{"id":"96542e34a2004a3f167df9f4ad0130b2","title":"119、稀土掘金小册-记账本（十） 个人中心 （完结）","content":"\n\n前言行文至此，万里长征已经快要走到头了。本章节带同学们来编写最后一个模块 —— 个人中心。\n\n个人中心模块分几个功能点，首先是头部的用户信息展示，包括头像、用户昵称、个人签名。其次是一些账号相关的操作，如用户信息修改、密码重置等。最后是退出登录，将其放置于页面底部，并且设置二次确认弹窗，避免误触。\n知识点\n图片资源上传格式处理。\n原生表单插件 rc-form 的使用。\n底部导航栏定位。\n\n正文头部信息展示修改 container/User/index.jsx 代码如下：\njsimport React from &quot;react&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst User = () =&gt; &#123;\n  return (\n    &lt;div className=&#123;s.user&#125;&gt;\n      &lt;div className=&#123;s.head&#125;&gt;\n        &lt;div className=&#123;s.info&#125;&gt;\n          &lt;span&gt;昵称：测试&lt;/span&gt;\n          &lt;span&gt;\n            &lt;img\n              style=&#123;&#123; width: 30, height: 30, verticalAlign: \"-10px\" &#125;&#125;\n              src=&quot;//s.yezgea02.com/1615973630132/geqian.png&quot;\n              alt=&quot;&quot;\n            /&gt;\n            &lt;b&gt;个性签名&lt;/b&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n        &lt;img\n          className=&#123;s.avatar&#125;\n          style=&#123;&#123; width: 60, height: 60, borderRadius: 8 &#125;&#125;\n          src=&#123;&quot;//s.yezgea02.com/1624959897466/avatar.jpeg&quot;&#125;\n          alt=&quot;&quot;\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default User;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n这里给 .head 一个背景图片，介绍一下顶部的布局思路，如下所示：\n\n在 .head 内通过 flex 实现左右布局，在 .info 内通过 flex 的 flex-direction 设置为 column 实现上下布局。\n.head 底部留出的位置，用于放置后续的操作。\n完成布局之后，将数据填上，通过 /api/user/get_userinfo 接口，获取用户信息，添加代码如下：\njsimport React, &#123; useState, useEffect &#125; from &quot;react&quot;;\nimport &#123; get &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst User = () =&gt; &#123;\n  const [user, setUser] = useState(&#123;&#125;);\n\n  useEffect(() =&gt; &#123;\n    getUserInfo();\n  &#125;, []);\n\n  // 获取用户信息\n  const getUserInfo = async () =&gt; &#123;\n    const &#123; data &#125; = await get(&quot;/api/user/get_userinfo&quot;);\n    setUser(data);\n    setAvatar(data.avatar);\n  &#125;;\n\n  return (\n    &lt;div className=&#123;s.user&#125;&gt;\n      &lt;div className=&#123;s.head&#125;&gt;\n        &lt;div className=&#123;s.info&#125;&gt;\n          &lt;span&gt;昵称：&#123;user.username || &quot;--&quot;&#125;&lt;/span&gt;\n          &lt;span&gt;\n            &lt;img\n              style=&#123;&#123; width: 30, height: 30, verticalAlign: \"-10px\" &#125;&#125;\n              src=&quot;//s.yezgea02.com/1615973630132/geqian.png&quot;\n              alt=&quot;&quot;\n            /&gt;\n            &lt;b&gt;&#123;user.signature || &quot;暂无个签&quot;&#125;&lt;/b&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n        &lt;img\n          className=&#123;s.avatar&#125;\n          style=&#123;&#123; width: 60, height: 60, borderRadius: 8 &#125;&#125;\n          src=&#123;user.avatar || &quot;&quot;&#125;\n          alt=&quot;&quot;\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default User;/api/user/get_userinfo 接口返回字段分析：\n\navatar：头像地址，这里要注意，我目前采用的线上接口，如果是本地开发的情况，需要修改你的 host。\nsignature：个性签名。\nusername：用户登录名称。\n\n浏览器展示如下所示：\n\n用户信息相关操作紧接着，我们需要布局用户相关操作的内容，在上述基础上添加如下代码：\njs...\nimport &#123; useNavigate &#125; from &#39;react-router-dom&#39;;\nimport &#123; Cell,  &#125; from &#39;zarm&#39;;\n\nconst User = () =&gt; &#123;\n  ...\n  const navigateTo = useNavigate();\n\n  return &lt;div className=&#123;s.user&#125;&gt;\n    ...\n    &lt;div className=&#123;s.content&#125;&gt;\n      &lt;Cell\n        hasArrow\n        title=&quot;用户信息修改&quot;\n        onClick=&#123;() =&gt; navigateTo(&#39;/userinfo&#39;)&#125;\n        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615974766264/gxqm.png&quot; alt=&quot;&quot; /&gt;&#125;\n      /&gt;\n      &lt;Cell\n        hasArrow\n        title=&quot;重制密码&quot;\n        onClick=&#123;() =&gt; navigateTo(&#39;/account&#39;)&#125;\n        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615974766264/zhaq.png&quot; alt=&quot;&quot; /&gt;&#125;\n      /&gt;\n      &lt;Cell\n        hasArrow\n        title=&quot;关于我们&quot;\n        onClick=&#123;() =&gt; navigateTo(&#39;/about&#39;)&#125;\n        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615975178434/lianxi.png&quot; alt=&quot;&quot; /&gt;&#125;\n      /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&#125;;添加样式：\ncss... .content &#123;\n  width: 90%;\n  position: absolute;\n  top: 120px;\n  left: 50%;\n  transform: translateX(-50%);\n  box-shadow: 3px 2px 20px 10px rgba(0, 0, 0, 0.1);\n  border-radius: 10px;\n  overflow: hidden;\n&#125;代码部分，直接采用 Zarm 组件库提供的 Cell 组件，它适用于列表布局，官方文档提供了很多列表布局的例子，可以直接在内部拷贝代码进行二次加工。能不用自己写样式，尽量就不要写。用组件库的目的，就是减少工作量，提高布局的效率。\n浏览器展示效果如下：\n\n这里有三个列表跳转项，分别是 userinfo、account、about。我们逐一击破。\n首先我们在 container 目录下新建一个 UserInfo 目录，如下所示：\n\n添加 index.js 和 style.module.less，并且在 router/index.js 内添加相对应的路由配置项。\n于是我们尝试点击「修改用户信息」，如下所示：\n\n成功之后，我们便可在 UserInfo 中编写编辑用户相关信息的操作，在编写正式代码之前，我们先对 Zarm 的上传组件进行分析，我们尝试编写如下代码：\njsimport React from &quot;react&quot;;\nimport &#123; FilePicker, Button &#125; from &quot;zarm&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst UserInfo = () =&gt; &#123;\n  const handleSelect = (file) =&gt; &#123;\n    console.log(&quot;file&quot;, file);\n  &#125;;\n  return (\n    &lt;div className=&#123;s.userinfo&#125;&gt;\n      &lt;FilePicker onChange=&#123;handleSelect&#125; accept=&quot;image/*&quot;&gt;\n        &lt;Button theme=&quot;primary&quot; size=&quot;xs&quot;&gt;\n          点击上传\n        &lt;/Button&gt;\n      &lt;/FilePicker&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default UserInfo;点击按钮，上传一张图片，我们查看回调函数 handleSelect 的执行结果：\n\n此时，我们需要的是上传资源的原始文件，在上述返回对象中，file 属性为 File 文件类型，它是浏览器返回的原生对象，我们需要通过下列代码，将其改造成一个 form-data 对象：\njsconst handleSelect = (file) =&gt; &#123;\n  console.log(&quot;file&quot;, file);\n  let formData = new FormData();\n  formData.append(&quot;file&quot;, file.file);\n&#125;;再将 formData 通过 axios 上传到服务器，服务端通过 ctx.request.files[0] 获取到前端上传的 文件原始对象，并将其读取，存入服务器内部。这样就完成了一套前端上传资源，服务端存储并返回路径的一个过程。\n接下来进行完整代码的编写，如下所示：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport &#123; Button, FilePicker, Input, Toast &#125; from &quot;zarm&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport Header from &quot;@/components/Header&quot;; // 由于是内页，使用到公用头部\nimport axios from &quot;axios&quot;; // // 由于采用 form-data 传递参数，所以直接只用 axios 进行请求\nimport &#123; get, post &#125; from &quot;@/utils&quot;;\nimport &#123; baseUrl &#125; from &quot;config&quot;; // 由于直接使用 axios 进行请求，统一封装了请求 baseUrl\nimport s from &quot;./style.module.less&quot;;\n\nconst UserInfo = () =&gt; &#123;\n  const navigateTo = useNavigate(); // 路由实例\n  const [user, setUser] = useState(&#123;&#125;); // 用户\n  const [avatar, setAvatar] = useState(&quot;&quot;); // 头像\n  const [signature, setSignature] = useState(&quot;&quot;); // 个签\n  const token = localStorage.getItem(&quot;token&quot;); // 登录令牌\n\n  useEffect(() =&gt; &#123;\n    getUserInfo(); // 初始化请求\n  &#125;, []);\n\n  // 获取用户信息\n  const getUserInfo = async () =&gt; &#123;\n    const &#123; data &#125; = await get(&quot;/api/user/get_userinfo&quot;);\n    setUser(data);\n    setAvatar(data.avatar);\n    setSignature(data.signature);\n  &#125;;\n\n  // 获取图片回调\n  const handleSelect = (file) =&gt; &#123;\n    console.log(&quot;file.file&quot;, file.file);\n    if (file &amp;&amp; file.file.size &gt; 200 * 1024) &#123;\n      Toast.show(&quot;上传头像不得超过 200 KB！！&quot;);\n      return;\n    &#125;\n    let formData = new FormData();\n    // 生成 form-data 数据类型\n    formData.append(&quot;file&quot;, file.file);\n    // 通过 axios 设置  &#39;Content-Type&#39;: &#39;multipart/form-data&#39;, 进行文件上传\n    axios(&#123;\n      method: &quot;post&quot;,\n      url: `$&#123;baseUrl&#125;/upload`,\n      data: formData,\n      headers: &#123;\n        &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,\n        Authorization: token,\n      &#125;,\n    &#125;).then((res) =&gt; &#123;\n      // 返回图片地址\n      setAvatar(res.data);\n    &#125;);\n  &#125;;\n\n  // 编辑用户信息方法\n  const save = async () =&gt; &#123;\n    const &#123; data &#125; = await post(&quot;/api/user/edit_userinfo&quot;, &#123;\n      signature,\n      avatar,\n    &#125;);\n\n    Toast.show(&quot;修改成功&quot;);\n    // 成功后回到个人中心页面\n    navigateTo(-1);\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;Header title=&quot;用户信息&quot; /&gt;\n      &lt;div className=&#123;s.userinfo&#125;&gt;\n        &lt;h1&gt;个人资料&lt;/h1&gt;\n        &lt;div className=&#123;s.item&#125;&gt;\n          &lt;div className=&#123;s.title&#125;&gt;头像&lt;/div&gt;\n          &lt;div className=&#123;s.avatar&#125;&gt;\n            &lt;img className=&#123;s.avatarUrl&#125; src=&#123;avatar&#125; alt=&quot;&quot; /&gt;\n            &lt;div className=&#123;s.desc&#125;&gt;\n              &lt;span&gt;支持 jpg、png、jpeg 格式大小 200KB 以内的图片&lt;/span&gt;\n              &lt;FilePicker\n                className=&#123;s.filePicker&#125;\n                onChange=&#123;handleSelect&#125;\n                accept=&quot;image/*&quot;\n              &gt;\n                &lt;Button className=&#123;s.upload&#125; theme=&quot;primary&quot; size=&quot;xs&quot;&gt;\n                  点击上传\n                &lt;/Button&gt;\n              &lt;/FilePicker&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.item&#125;&gt;\n          &lt;div className=&#123;s.title&#125;&gt;个性签名&lt;/div&gt;\n          &lt;div className=&#123;s.signature&#125;&gt;\n            &lt;Input\n              clearable\n              type=&quot;text&quot;\n              value=&#123;signature&#125;\n              placeholder=&quot;请输入个性签名&quot;\n              onChange=&#123;(value) =&gt; setSignature(value)&#125;\n            /&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;Button onClick=&#123;save&#125; style=&#123;&#123; marginTop: 50 &#125;&#125; block theme=&quot;primary&quot;&gt;\n          保存\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n&#125;;\n\nexport default UserInfo;详细的注释信息，已经在上述代码中表明，需要注意的是，本次请求直接使用了 axios 方法，所以我们需要将 baseUrl 单独封装到一个配置文件中，便于后续使用，在 src 目录下新建 config/index.js，添加如下代码：\njsconst MODE = import.meta.env.MODE; // 环境变量\n\nexport const baseUrl =\n  MODE == &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;MODE 作为 vite 运行时的环境变量，可以通过它来配置开发环境和生成环境的一些变量差异。\n然后需要在 vite.config.js 中修改如下：\njsresolve: &#123;\n    alias: &#123;\n      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;), // src 路径\n      &#39;utils&#39;: path.resolve(__dirname, &#39;src/utils&#39;), // src 路径\n      &#39;config&#39;: path.resolve(__dirname, &#39;src/config&#39;) // src 路径\n    &#125;\n  &#125;,配置好 config ，便可以直接在代码中通过：\njsimport &#123; baseUrl &#125; from &quot;config&quot;;上述形式来获取 config 中的变量信息。\n重启项目，浏览器展示效果如下：\n\n通过请求，得到的路径是这样的，因为我们在服务端返回的地址就是一个相对路径，所以我们需要给路径加上 host，要注意如果你是本地启动的服务端代码，这里的 host 就是你的服务端代码启动的 host，如 locahost:7001，而我目前使用的是在线接口，所以我们在 utils/index.js 下新增一个图片地址转换的方法，如下所示：\njs// utils/index.js\nimport &#123; baseUrl &#125; from &#39;config&#39;\nconst MODE = import.meta.env.MODE // 环境变量\n...\nexport const imgUrlTrans = (url) =&gt; &#123;\n  if (url &amp;&amp; url.startsWith(&#39;http&#39;)) &#123;\n    return url\n  &#125; else &#123;\n    url = `$&#123;MODE == &#39;development&#39; ? &#39;http://api.chennick.wang&#39; : baseUrl&#125;$&#123;url&#125;`\n    return url\n  &#125;\n&#125;然后在 UserInfo/index.jsx 中引入 imgUrlTrans 并如下使用：\njs// 获取用户信息\nconst getUserInfo = async () =&gt; &#123;\n  const &#123; data &#125; = await get(&#39;/api/user/get_userinfo&#39;);\n  setUser(data);\n  setAvatar(imgUrlTrans(data.avatar))\n  setSignature(data.signature)\n&#125;;\n\n...\n\n// 返回图片地址\nsetAvatar(imgUrlTrans(res.data))再次打开浏览器，点击选择图片如下：\n\n保存后，数据成功修改，我们如下所示：\n\n重置密码完成用户信息编辑之后，接下来实现重置密码部分，我们在 container 目录下新建 Account 目录，在内部分别新建 index.jsx 和 style.module.less。\n首先我们需要安装 rc-form 作为本次页面的表单组件，因为 Zarm 没有提供表单组件，包括 Antd Mobile 这样的组件，也没有提供表单相关的组件，所以这里我们需要使用 rc-form 自己编写表单相关验证方法，它也是 antd 官方使用的表单组件。\nbashnpm i rc-form -S我们为 Account/index.jsx 添加如下代码：\njs// Account/index.jsx\nimport React from &quot;react&quot;;\nimport &#123; Cell, Input, Button, Toast &#125; from &quot;zarm&quot;;\nimport &#123; createForm &#125; from &quot;rc-form&quot;;\nimport Header from &quot;@/components/Header&quot;;\nimport &#123; post &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Account = (props) =&gt; &#123;\n  // Account 通过 createForm 高阶组件包裹之后，可以在 props 中获取到 form 属性\n  const &#123; getFieldProps, getFieldError &#125; = props.form;\n\n  // 提交修改方法\n  const submit = () =&gt; &#123;\n    // validateFields 获取表单属性元素\n    props.form.validateFields(async (error, value) =&gt; &#123;\n      // error 表单验证全部通过，为 false，否则为 true\n      if (!error) &#123;\n        console.log(value);\n        if (value.newpass != value.newpass2) &#123;\n          Toast.show(&quot;新密码输入不一致&quot;);\n          return;\n        &#125;\n        await post(&quot;/api/user/modify_pass&quot;, &#123;\n          old_pass: value.oldpass,\n          new_pass: value.newpass,\n          new_pass2: value.newpass2,\n        &#125;);\n        Toast.show(&quot;修改成功&quot;);\n      &#125;\n    &#125;);\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;Header title=&quot;重制密码&quot; /&gt;\n      &lt;div className=&#123;s.account&#125;&gt;\n        &lt;div className=&#123;s.form&#125;&gt;\n          &lt;Cell title=&quot;原密码&quot;&gt;\n            &lt;Input\n              clearable\n              type=&quot;text&quot;\n              placeholder=&quot;请输入原密码&quot;\n              &#123;...getFieldProps(&quot;oldpass&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;\n            /&gt;\n          &lt;/Cell&gt;\n          &lt;Cell title=&quot;新密码&quot;&gt;\n            &lt;Input\n              clearable\n              type=&quot;text&quot;\n              placeholder=&quot;请输入新密码&quot;\n              &#123;...getFieldProps(&quot;newpass&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;\n            /&gt;\n          &lt;/Cell&gt;\n          &lt;Cell title=&quot;确认密码&quot;&gt;\n            &lt;Input\n              clearable\n              type=&quot;text&quot;\n              placeholder=&quot;请再此输入新密码确认&quot;\n              &#123;...getFieldProps(&quot;newpass2&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;\n            /&gt;\n          &lt;/Cell&gt;\n        &lt;/div&gt;\n        &lt;Button className=&#123;s.btn&#125; block theme=&quot;primary&quot; onClick=&#123;submit&#125;&gt;\n          提交\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n&#125;;\n\nexport default createForm()(Account);样式代码：\ncss.account &#123;\n  padding: 0 12px;\n  .form &#123;\n    :global &#123;\n      .za-cell:after &#123;\n        left: unset;\n        border-top: unset;\n        border-bottom: 1px solid #e9e9e9;\n      &#125;\n    &#125;\n  &#125;\n  .btn &#123;\n    margin-top: 50px;\n  &#125;\n&#125;这里要注意，Account 在抛出去的时候，需要用 createForm() 高阶组件进行包裹，这样在 Account 的内部能接收到 form 属性，它的内部提供了 getFieldProps 方法，对 Input 组件进行表单设置，Input 的 onChange 方法会被代理，最终可以通过 form.validateFields 以回到函数的形式拿到 Input 内的值，并且可以加以验证。\n别忘记在路由配置项中添加相应的路由：\njs// router/index.js\n...\nimport Account from &#39;@/container/Account&#39;\n\n...\n&#123;\n  path: &quot;/account&quot;,\n  component: Account\n&#125;页面展示如下：\n\n这里为了方便查看效果，输入框就不以密码的形式隐藏输入了，点击「提交」按钮之后，接口调用成功，但是我为 admin 账户在服务端设置了不能修改密码的权限，这里方便大家测试页面方便，不能随意修改密码。\n\n\n\n\n\n\n\n\n\n测试账号：admin，密码：111111\n退出登录退出登录操作，我的处理方式是将本地的 token 清除，并且回到登录页面，简单粗暴了一些，但也不失为一个解决方案。\n在 User/index.jsx 下添加代码如下：\njsconst User = () =&gt; &#123;\n  // 退出登录\n  const logout = async () =&gt; &#123;\n    localStorage.removeItem(&quot;token&quot;);\n    navigateTo(&quot;/login&quot;);\n  &#125;;\n\n  return (\n    &lt;div className=&#123;s.user&#125;&gt;\n      ...\n      &lt;Button className=&#123;s.logout&#125; block theme=&quot;danger&quot; onClick=&#123;logout&#125;&gt;\n        退出登录\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  );\n&#125;;样式如下：\ncss.logout &#123;\n  width: 90%;\n  position: absolute;\n  bottom: 70px;\n  left: 50%;\n  transform: translateX(-50%);\n&#125;通过绝对定位将按钮定位在底部，我们尝试点击它，如下所示：\n\n再次点击登录，发现没有自动前往首页，我们这里对登录页面进行修改，打开 Login/index.jsx，做如下修改：\njsconst &#123; data &#125; = await post(&quot;/api/user/login&quot;, &#123;\n  username,\n  password,\n&#125;);\nconsole.log(&quot;data&quot;, data);\nlocalStorage.setItem(&quot;token&quot;, data.token);\nwindow.location.href = &quot;/&quot;;这里之所以用 window.location.href 的原因是，utils/axios.js 内部需要再次被执行，才能通过 localStorage.getItem 拿到最新的 token。如果只是用 navigateTo 跳转页面的话，页面是不会被刷新，那么 axios.js 的 token 就无法设置。\n","slug":"119-react","date":"2023-01-31T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"12cb6fac9dc950824d8c6ec414bbf2ec","title":"118、稀土掘金小册-记账本（九） 账单可视化","content":"\n\n前言账单的操作部分在之前的章节已经结束了，本章节我们学习如何将账单列表，以可视化数据的新形势展示，本章节我们会通过 Echart 插件，对数据进行可视化展示。\n页面布局和分析如下所示：\n\n知识点\nEchart 引入和使用。\n进度条组件 Progress 的使用。\n\n正文头部筛选和数据实现当你看到顶部的时间筛选项的时候，你会再一次体会到当初把时间筛选功能封装成公用组件的好处，于是我们打开 Data/index.jsx，添加如下代码：\njsimport React, &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;\nimport &#123; Icon, Progress &#125; from &quot;zarm&quot;;\nimport cx from &quot;classnames&quot;;\nimport dayjs from &quot;dayjs&quot;;\nimport &#123; get, typeMap &#125; from &quot;@/utils&quot;;\nimport CustomIcon from &quot;@/components/CustomIcon&quot;;\nimport PopupDate from &quot;@/components/PopupDate&quot;;\nimport s from &quot;./style.module.less&quot;;\n\nconst Data = () =&gt; &#123;\n  return (\n    &lt;div className=&#123;s.data&#125;&gt;\n      &lt;div className=&#123;s.total&#125;&gt;\n        &lt;div className=&#123;s.time&#125;&gt;\n          &lt;span&gt;2021-06&lt;/span&gt;\n          &lt;Icon className=&#123;s.date&#125; type=&quot;date&quot; /&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.title&#125;&gt;共支出&lt;/div&gt;\n        &lt;div className=&#123;s.expense&#125;&gt;¥1000&lt;/div&gt;\n        &lt;div className=&#123;s.income&#125;&gt;共收入¥200&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Data;头部的一些引入是为后面的代码所用，在这里事先引入，避免后面重复出现。\n上述代码为头部统计的页面布局，同样采用的 flex 布局，样式部分如下：\n\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n样式部分有一个小技巧需要注意，日期后面的小竖线，如下所示：\n\n在业务中，类似这样的需求非常多，这里我们可以使用伪类 ::before 或 ::after 去实现，减少在页面中再添加一些多余的标签。上述代码实现的逻辑是在日期的 span 上加上 ::after，如下所示：\ncssspan:nth-of-type(1)::after &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  top: 9px;\n  bottom: 8px;\n  right: 28px;\n  width: 1px;\n  background-color: rgba(0, 0, 0, 0.5);\n&#125;给一个空的 content，再给上 1px 的宽度，颜色和上下距离可以根据需求调整。\n苦口婆心的我再次强调，flex 布局的重要性，一定要把它吃透，至少在布局的时候，你可以灵活的运用横竖布局。\n点击如期按钮，弹出底部弹窗，这里使用到了之前写好的 PopupDate 组件，代码如下：\njsconst Data = () =&gt; &#123;\n  const monthRef = useRef();\n  const [currentMonth, setCurrentMonth] = useState(dayjs().format(&quot;YYYY-MM&quot;));\n\n  // 月份弹窗开关\n  const monthShow = () =&gt; &#123;\n    monthRef.current &amp;&amp; monthRef.current.show();\n  &#125;;\n\n  const selectMonth = (item) =&gt; &#123;\n    setCurrentMonth(item);\n  &#125;;\n\n  return (\n    &lt;div className=&#123;s.data&#125;&gt;\n      &lt;div className=&#123;s.total&#125;&gt;\n        &lt;div className=&#123;s.time&#125; onClick=&#123;monthShow&#125;&gt;\n          &lt;span&gt;&#123;currentMonth&#125;&lt;/span&gt;\n          &lt;Icon className=&#123;s.date&#125; type=&quot;date&quot; /&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.title&#125;&gt;共支出&lt;/div&gt;\n        &lt;div className=&#123;s.expense&#125;&gt;¥1000&lt;/div&gt;\n        &lt;div className=&#123;s.income&#125;&gt;共收入¥200&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;PopupDate ref=&#123;monthRef&#125; mode=&quot;month&quot; onSelect=&#123;selectMonth&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;;给日期按钮添加 monthShow 点击事件，调出 PopupDate 弹窗。并且，通过 selectMonth 方法，设置好选择的月份，展示于页面之上。效果如下所示：\n\n账单单项排名制作我们将账单排名部分的结构搭建出来，通过请求数据接口，将数据展示在页面上，代码如下：\njsconst Data = () =&gt; &#123;\n  ...\n  const [totalType, setTotalType] = useState(&#39;expense&#39;); // 收入或支出类型\n  const [totalExpense, setTotalExpense] = useState(0); // 总支出\n  const [totalIncome, setTotalIncome] = useState(0); // 总收入\n  const [expenseData, setExpenseData] = useState([]); // 支出数据\n  const [incomeData, setIncomeData] = useState([]); // 收入数据\n\n  useEffect(() =&gt; &#123;\n    getData()\n  &#125;, [currentMonth]);\n\n  // 获取数据详情\n  const getData = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/data?date=$&#123;currentMonth&#125;`);\n\n    // 总收支\n    setTotalExpense(data.total_expense);\n    setTotalIncome(data.total_income);\n\n    // 过滤支出和收入\n    const expense_data = data.total_data.filter(item =&gt; item.pay_type == 1).sort((a, b) =&gt; b.number - a.number); // 过滤出账单类型为支出的项\n    const income_data = data.total_data.filter(item =&gt; item.pay_type == 2).sort((a, b) =&gt; b.number - a.number); // 过滤出账单类型为收入的项\n    setExpenseData(expense_data);\n    setIncomeData(income_data);\n  &#125;;\n\n  return &lt;div className=&#123;s.data&#125;&gt;\n    ...\n    &lt;div className=&#123;s.structure&#125;&gt;\n      &lt;div className=&#123;s.head&#125;&gt;\n        &lt;span className=&#123;s.title&#125;&gt;收支构成&lt;/span&gt;\n        &lt;div className=&#123;s.tab&#125;&gt;\n          &lt;span onClick=&#123;() =&gt; changeTotalType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: totalType == &#39;expense&#39; &#125;)&#125;&gt;支出&lt;/span&gt;\n          &lt;span onClick=&#123;() =&gt; changeTotalType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: totalType == &#39;income&#39; &#125;)&#125;&gt;收入&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div className=&#123;s.content&#125;&gt;\n        &#123;\n          (totalType == &#39;expense&#39; ? expenseData : incomeData).map(item =&gt; &lt;div key=&#123;item.type_id&#125; className=&#123;s.item&#125;&gt;\n            &lt;div className=&#123;s.left&#125;&gt;\n              &lt;div className=&#123;s.type&#125;&gt;\n                &lt;span className=&#123;cx(&#123; [s.expense]: totalType == &#39;expense&#39;, [s.income]: totalType == &#39;income&#39; &#125;)&#125;&gt;\n                  &lt;CustomIcon\n                    type=&#123;item.type_id ? typeMap[item.type_id].icon : 1&#125;\n                  /&gt;\n                &lt;/span&gt;\n                &lt;span className=&#123;s.name&#125;&gt;&#123; item.type_name &#125;&lt;/span&gt;\n              &lt;/div&gt;\n              &lt;div className=&#123;s.progress&#125;&gt;¥&#123; Number(item.number).toFixed(2) || 0 &#125;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div className=&#123;s.right&#125;&gt;\n              &lt;div className=&#123;s.percent&#125;&gt;\n                &lt;Progress\n                  shape=&quot;line&quot;\n                  percent=&#123;Number((item.number / Number(totalType == &#39;expense&#39; ? totalExpense : totalIncome)) * 100).toFixed(2)&#125;\n                  theme=&#39;primary&#39;\n                /&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;)\n        &#125;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    ...\n  &lt;/div&gt;\n&#125;上述是账单排名部分的代码部分，通过 getData 方法获取账单数据，接口字段分析：\n\n首先我们需要传递日期参数 date，才能正常获取该月份的数据。\n\nnumber: 账单金额。\npay_type：账单类型，1 为支出，2 为收入。\ntype_id：账单种类 id。\ntype_name：账单种类名称，如购物、交通、医疗等。\n\n并将数据进行二次处理，将「收入」和「支出」分成两个数组保存。\n通过 changeTotalType 方法，切换展示「收入」或「支出」。\n通过对 Progress 组件的样式二次修改，样式代码如下：\n\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n将组件展示效果改成如下所示：\n\n饼图制作接下来我们尝试引入 Echart，我们不通过 npm 引入它，我们尝试引入它的静态资源，找到根目录下的 index.html，添加如下代码：\njs&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/favicons/v2/favicon-32x32.png~tplv-t2oaga2asx-image.image&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;掘掘手札&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;//s.yezgea02.com/1609305532675/echarts.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;module&quot; src=&quot;/src/main.jsx&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;这种引入方式，不会将 echart 打包到最终的入口脚本里。有同学会说可以按需引入，但是就算是按需引入，脚本也会变得很大，本身 echart 这类可视化工具库就非常大，因为内部使用了大量绘制图形的代码。\n完成上述操作之后，我们尝试在 /Data/index.jsx 添加如下代码：\njslet proportionChart = null; // 用于存放 echart 初始化返回的实例\n\nconst Data = () =&gt; &#123;\n  ...\n  const [pieType, setPieType] = useState(&#39;expense&#39;); // 饼图的「收入」和「支出」控制\n\n  useEffect(() =&gt; &#123;\n    getData();\n    return () =&gt; &#123;\n      // 每次组件卸载的时候，需要释放图表实例。clear 只是将其清空不会释放。\n      proportionChart.dispose();\n    &#125;;\n  &#125;, [currentMonth]);\n\n  // 绘制饼图方法\n  const setPieChart = (data) =&gt; &#123;\n    if (window.echarts) &#123;\n      // 初始化饼图，返回实例。\n      proportionChart = echarts.init(document.getElementById(&#39;proportion&#39;));\n      proportionChart.setOption(&#123;\n          tooltip: &#123;\n            trigger: &#39;item&#39;,\n            formatter: &#39;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#39;\n          &#125;,\n          // 图例\n          legend: &#123;\n              data: data.map(item =&gt; item.type_name)\n          &#125;,\n          series: [\n            &#123;\n              name: &#39;支出&#39;,\n              type: &#39;pie&#39;,\n              radius: &#39;55%&#39;,\n              data: data.map(item =&gt; &#123;\n                return &#123;\n                  value: item.number,\n                  name: item.type_name\n                &#125;\n              &#125;),\n              emphasis: &#123;\n                itemStyle: &#123;\n                  shadowBlur: 10,\n                  shadowOffsetX: 0,\n                  shadowColor: &#39;rgba(0, 0, 0, 0.5)&#39;\n                &#125;\n              &#125;\n            &#125;\n          ]\n      &#125;)\n    &#125;;\n  &#125;;\n\n  // 获取数据详情\n  const getData = async () =&gt; &#123;\n    // ...\n    // 绘制饼图\n    setPieChart(pieType == &#39;expense&#39; ? expense_data : income_data);\n  &#125;;\n\n  // 切换饼图收支类型\n  const changePieType = (type) =&gt; &#123;\n    setPieType(type);\n    // 重绘饼图\n    setPieChart(type == &#39;expense&#39; ? expenseData : incomeData);\n  &#125;\n\n  return &lt;div className=&#123;s.data&#125;&gt;\n    ...\n    &lt;div className=&#123;s.structure&#125;&gt;\n      &lt;div className=&#123;s.proportion&#125;&gt;\n        &lt;div className=&#123;s.head&#125;&gt;\n          &lt;span className=&#123;s.title&#125;&gt;收支构成&lt;/span&gt;\n          &lt;div className=&#123;s.tab&#125;&gt;\n            &lt;span onClick=&#123;() =&gt; changePieType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: pieType == &#39;expense&#39;  &#125;)&#125;&gt;支出&lt;/span&gt;\n            &lt;span onClick=&#123;() =&gt; changePieType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: pieType == &#39;income&#39;  &#125;)&#125;&gt;收入&lt;/span&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &#123;/* 这是用于放置饼图的 DOM 节点 */&#125;\n        &lt;div id=&quot;proportion&quot;&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&#125;切换饼图「收入」和「支出」这里，我使用了一个小技巧，每次调用 setPieChart 的时候，会将数据重新传入，此时的数据是经过 changePieType 接收的参数进行筛选的，如果形参 type 的值为 expense，那么给 setPieChart 传的参数为 expenseData，反之则为 incomeData。\n注意，在页面销毁前，需要将实例清除。在 useEffect 内 return 一个函数，该函数就是在组件销毁时执行，在函数内部执行 proportionChart.dispose(); 对实例进行销毁操作。\n最后，我们将头部的数据补上，如下所示：\nhtml&lt;div className=&quot;&#123;s.expense&#125;&quot;&gt;¥&#123; totalExpense &#125;&lt;/div&gt;\n&lt;div className=&quot;&#123;s.income&#125;&quot;&gt;共收入¥&#123; totalIncome &#125;&lt;/div&gt;浏览器展示如下：\n\n总结可视化的形式还有很多，相关的可视化库有 three.js、d3.js、highchart.js 等等，这些内容都值得你去深入，但是在此之前，希望同学们能明确自己希望深入那一方面的知识，进行深度学习。比如张鑫旭大神，对 CSS 的研究，入骨三分，我相信业务无人出其右。所以找准方向，往前冲。\n\n","slug":"118-react","date":"2023-01-28T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"3c7b3559e9eb77c25fa507806ab0b257","title":"117、稀土掘金小册-记账本（八） 账单详情","content":"\n\n前言账单模块还剩最后一个小节，账单详情。账单详情页要做的事情有两个，一个是编辑当前账单操作，另一个是删除当前账单操作，我们先来观察完成后页面结构，如下所示：\n\n这里是第一次涉及内页，所以我们需要制作一个公用的头部 Header，支持传参接收 title 信息。我们在上一章节提取的「添加账单弹窗组件」，在这里派上了用场，新增和编辑是一家，唯一的差别就是编辑的时候，需要传入当前账单的 id 给「添加账单组件」，组件内通过账单详情接口，获取账单详情，并将获取的参数用于各个字段初始化值，这就实现了组件的复用。\n知识点\n封装公用头部组件\n复用添加账单弹窗组件\n\n正文开始公用头部在 components 目录下新建 Header 目录，老规矩，添加两个文件 index.jsx 和 style.module.less。\n为 Header/index.jsx 添加代码如下：\njsimport React from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport &#123; NavBar, Icon &#125; from &quot;zarm&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Header = (&#123; title = &quot;&quot; &#125;) =&gt; &#123;\n  const navigateTo = useNavigate();\n  return (\n    &lt;div className=&#123;s.headerWarp&#125;&gt;\n      &lt;div className=&#123;s.block&#125;&gt;\n        &lt;NavBar\n          className=&#123;s.header&#125;\n          left=&#123;\n            &lt;Icon\n              type=&quot;arrow-left&quot;\n              theme=&quot;primary&quot;\n              onClick=&#123;() =&gt; navigateTo(-1)&#125;\n            /&gt;\n          &#125;\n          title=&#123;title&#125;\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nHeader.propTypes = &#123;\n  title: PropTypes.string, // 标题\n&#125;;\n\nexport default Header;我们采用 Zarm 组件库为我们提供的 NavBar 组件，实现头部的组件布局。为左边的返回箭头添加一个事件，navigateTo(-1) 的作用是路由返回事件，它不会触发浏览器的刷新，而是改变浏览器的地址栏，让组件匹配地址栏对应的地址组件。\n还有一点要提醒大家，写公用组件一定要写 PropTypes，这是让其他使用该组件的同事知道，你这个组件接受的参数有哪些，以及每个参数的作用是什么，都要注释清楚，这才是一个好的公用组件。我见过很多同事写公用组件都不写 PropTypes，这让使用者非常头大。\nCSS 样式代码\ncss.header-warp &#123;\n  border-bottom: 1px solid #e9e9e9;\n  .block &#123;\n    width: 100%;\n    height: 46px;\n    :global &#123;\n      .za-nav-bar__title &#123;\n        font-size: 14px;\n        color: rgba(0, 0, 0, 0.9);\n      &#125;\n      .za-icon--arrow-left &#123;\n        font-size: 20px;\n      &#125;\n    &#125;\n  &#125;\n  .header &#123;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    .more &#123;\n      font-size: 20px;\n    &#125;\n  &#125;\n&#125;完成上述代码之后，我们需要在 container/Detail/index.jsx 下引入这个公用头部，代码如下：\njsimport React from &quot;react&quot;;\nimport Header from &quot;@/components/Header&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Detail = () =&gt; &#123;\n  return (\n    &lt;div className=&#123;s.detail&#125;&gt;\n      &lt;Header title=&quot;账单详情&quot; /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Detail;效果如下所示：\n\n账单明细接下来，我们通过列表页传入的浏览器查询字符串，通俗的将就是浏览器地址栏上的参数，来获取该笔账单的详情，如下所示：\njs// container/Detail/index.jsx\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport &#123; useLocation &#125; from &quot;react-router-dom&quot;;\nimport qs from &quot;query-string&quot;;\nimport Header from &quot;@/components/Header&quot;;\nimport &#123; get &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Detail = () =&gt; &#123;\n  const location = useLocation(); // 获取 locaton 实例，我们可以通过打印查看内部都有些什么内容。\n  const &#123; id &#125; = qs.parse(location.search);\n\n  const [detail, setDetail] = useState(&#123;&#125;);\n\n  console.log(&quot;location&quot;, location);\n\n  useEffect(() =&gt; &#123;\n    getDetail();\n  &#125;, []);\n\n  const getDetail = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/detail?id=$&#123;id&#125;`);\n    setDetail(data);\n  &#125;;\n  return (\n    &lt;div className=&#123;s.detail&#125;&gt;\n      &lt;Header title=&quot;账单详情&quot; /&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Detail;我们先来看看，浏览器控制台打印出的 location 如下所示：\n\n可以看到，我们想要的参数在 search 属性中，我想把 ?id=917 转换成 json 键值对的形式，如：\njson&#123;\n  &quot;id&quot;: 917\n&#125;所以我通过 npm install query-string 引入了查询字符串解析的一个插件，通过如下方式：\njsqs.parse(location.search);可以将浏览器查询参数变成一个对象形式，所以我们在代码中可以通过 const 的解构，将 id 取出。最后通过 get 方法请求详情接口：\n\n接下来，我们给账单明细部分布局，并且将数据接入，代码如下所示：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport &#123; useLocation &#125; from &quot;react-router-dom&quot;;\nimport qs from &quot;query-string&quot;;\nimport dayjs from &quot;dayjs&quot;;\nimport cx from &quot;classnames&quot;;\nimport Header from &quot;@/components/Header&quot;;\nimport CustomIcon from &quot;@/components/CustomIcon&quot;;\nimport &#123; get, typeMap &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Detail = () =&gt; &#123;\n  const location = useLocation(); // 路由 location 实例\n  const &#123; id &#125; = qs.parse(location.search); // 查询字符串反序列化\n\n  const [detail, setDetail] = useState(&#123;&#125;); // 订单详情数据\n\n  useEffect(() =&gt; &#123;\n    getDetail();\n  &#125;, []);\n\n  const getDetail = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/detail?id=$&#123;id&#125;`);\n    setDetail(data);\n  &#125;;\n  return (\n    &lt;div className=&#123;s.detail&#125;&gt;\n      &lt;Header title=&quot;账单详情&quot; /&gt;\n      &lt;div className=&#123;s.card&#125;&gt;\n        &lt;div className=&#123;s.type&#125;&gt;\n          &#123;/* 通过 pay_type 属性，判断是收入或指出，给出不同的颜色*/&#125;\n          &lt;span\n            className=&#123;cx(&#123;\n              [s.expense]: detail.pay_type == 1,\n              [s.income]: detail.pay_type == 2,\n            &#125;)&#125;\n          &gt;\n            &#123;/* typeMap 是我们事先约定好的 icon 列表 */&#125;\n            &lt;CustomIcon\n              className=&#123;s.iconfont&#125;\n              type=&#123;detail.type_id ? typeMap[detail.type_id].icon : 1&#125;\n            /&gt;\n          &lt;/span&gt;\n          &lt;span&gt;&#123;detail.type_name || &quot;&quot;&#125;&lt;/span&gt;\n        &lt;/div&gt;\n        &#123;detail.pay_type == 1 ? (\n          &lt;div className=&#123;cx(s.amount, s.expense)&#125;&gt;-&#123;detail.amount&#125;&lt;/div&gt;\n        ) : (\n          &lt;div className=&#123;cx(s.amount, s.incom)&#125;&gt;+&#123;detail.amount&#125;&lt;/div&gt;\n        )&#125;\n        &lt;div className=&#123;s.info&#125;&gt;\n          &lt;div className=&#123;s.time&#125;&gt;\n            &lt;span&gt;记录时间&lt;/span&gt;\n            &lt;span&gt;&#123;dayjs(Number(detail.date)).format(&quot;YYYY-MM-DD HH:mm&quot;)&#125;&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div className=&#123;s.remark&#125;&gt;\n            &lt;span&gt;备注&lt;/span&gt;\n            &lt;span&gt;&#123;detail.remark || &quot;-&quot;&#125;&lt;/span&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.operation&#125;&gt;\n          &lt;span&gt;\n            &lt;CustomIcon type=&quot;shanchu&quot; /&gt;\n            删除\n          &lt;/span&gt;\n          &lt;span&gt;\n            &lt;CustomIcon type=&quot;tianjia&quot; /&gt;\n            编辑\n          &lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Detail;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n布局部分我都已经在代码中给了注释，还有不明白的同学可以在群里提问，再次强调一点，flex 布局请务必要掌握熟练，在日后的开发过程中，无论是小册还是公司的项目，都会大量的运用到它。甚至 Flutter 的布局也借鉴了 flex 的原理。\n浏览器展示效果如下：\n\n我们还需为底部的两个按钮添加事件。首先，为删除按钮添加删除事件：\njsimport &#123; useLocation, useNavigate &#125; from &#39;react-router-dom&#39;;\nimport &#123; get, post, typeMap &#125; from &#39;@/utils&#39;;\nimport &#123; Modal, Toast &#125; from &#39;zarm&#39;;\n...\n\nconst navigateTo = useNavigate();\n\n// 删除方法\nconst deleteDetail = () =&gt; &#123;\n  Modal.confirm(&#123;\n    title: &#39;删除&#39;,\n    content: &#39;确认删除账单？&#39;,\n    onOk: async () =&gt; &#123;\n      const &#123; data &#125; = await post(&#39;/api/bill/delete&#39;, &#123; id &#125;)\n      Toast.show(&#39;删除成功&#39;)\n      navigateTo(-1)\n    &#125;,\n  &#125;);\n&#125;这里我们利用 Zarm 组件提供的 Modal 组件，该组件提供了调用方法的形式唤起弹窗，我们利用这个属性 为「删除」加一个二次确认的形式，避免误触按钮。\n效果如下所示：\n\n最麻烦的编辑事件处理，我们先来明确一下思路。在点击「编辑」按钮之后，我们会唤起之前写好的「添加账单天窗」，然后将账单 detail 参数通过 props 传递给弹窗组件，组件在接收到 detail 时，将信息初始化给弹窗给的相应参数。\n我们来看代码的实现，首先在 Detail/index.jsx 内添加代码：\njsimport React, &#123; useEffect, useState, useRef &#125; from &#39;react&#39;;\nimport PopupAddBill from &#39;@/components/PopupAddBill&#39;;\n...\n\nconst editRef = useRef();\n...\n&lt;div className=&#123;s.operation&#125;&gt;\n  &lt;span onClick=&#123;deleteDetail&#125;&gt;&lt;CustomIcon type=&#39;shanchu&#39; /&gt;删除&lt;/span&gt;\n  &lt;span onClick=&#123;() =&gt; editRef.current &amp;&amp; editRef.current.show()&#125;&gt;&lt;CustomIcon type=&#39;tianjia&#39; /&gt;编辑&lt;/span&gt;\n&lt;/div&gt;\n...\n&lt;PopupAddBill ref=&#123;editRef&#125; detail=&#123;detail&#125; onReload=&#123;getDetail&#125; /&gt;尝试点击编辑按钮：\n\n紧接着，我们修改 PopupAddBill 组件，如下所示：\njsconst PopupAddBill = forwardRef((&#123; detail = &#123;&#125;, onReload &#125;, ref) =&gt; &#123;\n  ...\n  const id = detail &amp;&amp; detail.id // 外部传进来的账单详情 id\n\n  useEffect(() =&gt; &#123;\n    if (detail.id) &#123;\n      setPayType(detail.pay_type == 1 ? &#39;expense&#39; : &#39;income&#39;)\n      setCurrentType(&#123;\n        id: detail.type_id,\n        name: detail.type_name\n      &#125;)\n      setRemark(detail.remark)\n      setAmount(detail.amount)\n      setDate(dayjs(Number(detail.date)).$d)\n    &#125;\n  &#125;, [detail])\n\n  ...\n\n  useEffect(async () =&gt; &#123;\n    const &#123; data: &#123; list &#125; &#125; = await get(&#39;/api/type/list&#39;);\n    const _expense = list.filter(i =&gt; i.type == 1); // 支出类型\n    const _income = list.filter(i =&gt; i.type == 2); // 收入类型\n    setExpense(_expense);\n    setIncome(_income);\n      // 没有 id 的情况下，说明是新建账单。\n    if (!id) &#123;\n      setCurrentType(_expense[0]);\n    &#125;;\n  &#125;, []);\n\n  ...\n\n  // 添加账单\n  const addBill = async () =&gt; &#123;\n    if (!amount) &#123;\n      Toast.show(&#39;请输入具体金额&#39;)\n      return\n    &#125;\n    const params = &#123;\n      amount: Number(amount).toFixed(2),\n      type_id: currentType.id,\n      type_name: currentType.name,\n      date: dayjs(date).unix() * 1000,\n      pay_type: payType == &#39;expense&#39; ? 1 : 2,\n      remark: remark || &#39;&#39;\n    &#125;\n    if (id) &#123;\n      params.id = id;\n      // 如果有 id 需要调用详情更新接口\n      const result = await post(&#39;/api/bill/update&#39;, params);\n      Toast.show(&#39;修改成功&#39;);\n    &#125; else &#123;\n      const result = await post(&#39;/api/bill/add&#39;, params);\n      setAmount(&#39;&#39;);\n      setPayType(&#39;expense&#39;);\n      setCurrentType(expense[0]);\n      setDate(new Date());\n      setRemark(&#39;&#39;);\n      Toast.show(&#39;添加成功&#39;);\n    &#125;\n    setShow(false);\n    if (onReload) onReload();\n  &#125;\n&#125;)首先，通过 setXXX 将 detail 的数据依次设置初始值；其次，账单种类需要判断是否是编辑或是新建；最后，修改添加账单按钮，如果是「编辑」操作，给 params 参数添加一个 id，并且调用的接口变成 /api/bill/update。\n完成上述操作之后，我们查看浏览器操作情况如下所示：\n\n总结本小节我们学习了如何封装内页的头部组件，以及如何将之前的「新增」复用给「编辑」操作，可以以这个为一个思考点，用发散的思维去复制这样的模式，是否其他的新增和编辑操作，也可以这么实现。\n","slug":"117-react","date":"2023-01-21T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"8113b5b89040b1ca56e2a14d1a9ec5f9","title":"116、稀土掘金小册-记账本（七）新增账单弹窗封装","content":"\n\n前言回顾一下上一章节学习的内容。无限滚动列表、弹窗组件的内部控制显隐、工具方法以及常量的提取。若是你开发项目时，在潜意识里，有对这些内容进行封装的思想，那么你已经有模块化、组件化的开发理念了。在大量的工程中得出的实践，将会根深蒂固在你的开发理念里。\n之前，我们是对一个小组件，如时间筛选、类型筛选等小组件进行封装。本章节，我们对一个添加模块进行封装，好处就是你在任何地方，都能使用这个添加组件，对账单进行增加操作。\n我们先来看看本章节要绘制的页面和逻辑：\n\n如上图所示，本章节要实现的需求逻辑，基本上已经绘制在图中。所有的努力，都是为了凑出这几个参数：\n\n账单类型\n账单金额\n账单日期\n账单种类\n备注\n\n然后将这些数据，提交给服务端进行处理，然后存储到数据库，完事。\n正文上述需求整理清楚之后，我们开始本章节的制作环节。\n弹窗组件实现先实现点击新增按钮，调出弹窗的功能。首先，在 Home/index.jsx 文件中添加 「新增按钮」，如下所示：\njsimport CustomIcon from &#39;@/components/CustomIcon&#39;\n...\nconst Home = () =&gt; &#123;\n  ...\n  const addToggle = () =&gt; &#123;\n    // do something\n  &#125;\n  ...\n  return &lt;div className=&#123;s.home&#125;&gt;\n    ...\n    &lt;div className=&#123;s.add&#125; onClick=&#123;addToggle&#125;&gt;&lt;CustomIcon type=&#39;tianjia&#39; /&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&#125;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n样式中，注意我给 border 设置的是 1PX，大写的单位，因为这样写的话，postcss-pxtorem 插件就不会将其转化为 rem 单位。\n重启项目之后，刷新浏览器，如下所示：\n\n根据之前实现的弹窗组件，我们再实现一套类似的，在弹窗内控制弹窗组件的显示隐藏，在 components 下新建 PopupAddBill 文件夹，再新建 index.jsx 和 style.module.less，代码如下：\njs// PopupAddBill/index.jsx\nimport React, &#123; forwardRef, useEffect, useRef, useState &#125; from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport &#123; Popup &#125; from &quot;zarm&quot;;\n\nconst PopupAddBill = forwardRef((props, ref) =&gt; &#123;\n  const [show, setShow] = useState(false); // 内部控制弹窗显示隐藏。\n  // 通过 forwardRef 拿到外部传入的 ref，并添加属性，使得父组件可以通过 ref 控制子组件。\n  if (ref) &#123;\n    ref.current = &#123;\n      show: () =&gt; &#123;\n        setShow(true);\n      &#125;,\n      close: () =&gt; &#123;\n        setShow(false);\n      &#125;,\n    &#125;;\n  &#125;\n\n  return (\n    &lt;Popup\n      visible=&#123;show&#125;\n      direction=&quot;bottom&quot;\n      onMaskClick=&#123;() =&gt; setShow(false)&#125;\n      destroy=&#123;false&#125;\n      mountContainer=&#123;() =&gt; document.body&#125;\n    &gt;\n      &lt;div style=&#123;&#123; height: 200, background: \"#fff\" &#125;&#125;&gt;弹窗&lt;/div&gt;\n    &lt;/Popup&gt;\n  );\n&#125;);\n\nexport default PopupAddBill;写完弹窗组件，当然就得去 Home/index.jsx 中调用：\njs// Home/index.jsx\nimport PopupAddBill from &#39;@/components/PopupAddBill&#39;\n\nconst Home = () =&gt; &#123;\n  ...\n  const addRef = useRef(); // 添加账单 ref\n  ...\n  // 添加账单弹窗\n  const addToggle = () =&gt; &#123;\n    addRef.current &amp;&amp; addRef.current.show()\n  &#125;\n\n  return &lt;div className=&#123;s.home&#125;&gt;\n    ...\n    &lt;PopupAddBill ref=&#123;addRef&#125; /&gt;\n  &lt;/div&gt;\n&#125;重启浏览器，效果如下：\n\n此时我们的“地基”已经打好了，接下来我们要在这个基础上给新增账单弹窗“添砖加瓦”。\n账单类型和账单时间我们先实现弹窗头部左侧的「支出」和「收入」账单类型切换功能，添加代码如下：\njs// components/PopupAddBill/index.jsx\n...\nimport cx from &#39;classnames&#39;;\nimport &#123; Popup, Icon  &#125; from &#39;zarm&#39;;\n\nimport s from &#39;./style.module.less&#39;;\n\nconst PopupAddBill = forwardRef((props, ref) =&gt; &#123;\n  ...\n  const [payType, setPayType] = useState(&#39;expense&#39;); // 支出或收入类型\n  ...\n  // 切换收入还是支出\n  const changeType = (type) =&gt; &#123;\n    setPayType(type);\n  &#125;;\n\n  return &lt;Popup\n    visible=&#123;show&#125;\n    direction=&quot;bottom&quot;\n    onMaskClick=&#123;() =&gt; setShow(false)&#125;\n    destroy=&#123;false&#125;\n    mountContainer=&#123;() =&gt; document.body&#125;\n  &gt;\n    &lt;div className=&#123;s.addWrap&#125;&gt;\n      &#123;/* 右上角关闭弹窗 */&#125;\n      &lt;header className=&#123;s.header&#125;&gt;\n        &lt;span className=&#123;s.close&#125; onClick=&#123;() =&gt; setShow(false)&#125;&gt;&lt;Icon type=&quot;wrong&quot; /&gt;&lt;/span&gt;\n      &lt;/header&gt;\n       &#123;/* 「收入」和「支出」类型切换 */&#125;\n      &lt;div className=&#123;s.filter&#125;&gt;\n        &lt;div className=&#123;s.type&#125;&gt;\n          &lt;span onClick=&#123;() =&gt; changeType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: payType == &#39;expense&#39; &#125;)&#125;&gt;支出&lt;/span&gt;\n          &lt;span onClick=&#123;() =&gt; changeType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: payType == &#39;income&#39; &#125;)&#125;&gt;收入&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/Popup&gt;\n&#125;)\n\nexport default PopupAddBill为了减少代码的重复，上述代码只展示了需要添加的部分，尽量不让大家混淆视听。\n我们定义 expense 为支出，income 为收入，代码中通过 payType 变量，来控制「收入」和「支出」按钮的切换。上述代码视图效果如下所示：\n\n接下来在类型边上添加时间筛选弹窗，此时你将体会到之前提取时间筛选组件是多么的明智。我们继续添加代码：\njsimport React, &#123; forwardRef, useEffect, useRef, useState &#125; from &#39;react&#39;;\n...\nimport dayjs from &#39;dayjs&#39;;\nimport PopupDate from &#39;../PopupDate&#39;\n...\n\nconst PopupAddBill = forwardRef((props, ref) =&gt; &#123;\n  ...\n  const dateRef = useRef();\n  const [date, setDate] = useState(new Date()); // 日期\n  ...\n  // 日期选择回调\n  const selectDate = (val) =&gt; &#123;\n    setDate(val);\n  &#125;\n\n  return &lt;Popup\n    visible=&#123;show&#125;\n    direction=&quot;bottom&quot;\n    onMaskClick=&#123;() =&gt; setShow(false)&#125;\n    destroy=&#123;false&#125;\n    mountContainer=&#123;() =&gt; document.body&#125;\n  &gt;\n    &lt;div className=&#123;s.addWrap&#125;&gt;\n       &#123;/* 「收入」和「支出」类型切换 */&#125;\n      &lt;div className=&#123;s.filter&#125;&gt;\n        ...\n        &lt;div\n          className=&#123;s.time&#125;\n          onClick=&#123;() =&gt; dateRef.current &amp;&amp; dateRef.current.show()&#125;\n        &gt;&#123;dayjs(date).format(&#39;MM-DD&#39;)&#125; &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;PopupDate ref=&#123;dateRef&#125; onSelect=&#123;selectDate&#125; /&gt;\n    &lt;/div&gt;\n  &lt;/Popup&gt;\n&#125;)\n\nexport default PopupAddBill我们引入了公共组件 PopupDate，传入 ref 控制弹窗的显示隐藏，传入 onSelect 获取日期组件选择后回调的值，并通过 setDate 重制 date，触发视图的更新，我们来看浏览器展示效果如下：\n\n我们通过上述代码，已经创造出了两个值，分别是「账单类型」和「账单日期」，还差「账单金额」 「账单种类」、「备注」。\n账单金额本章开头大家也应该看到了，金额输入框是模拟的，也就是说当下面模拟数字键盘点击的时候，我们将返回的数据渲染到进入输入框的位置，下面我们先将金额输入框搭建出来，添加代码如下：\njs&lt;div className=&#123;s.money&#125;&gt;\n  &lt;span className=&#123;s.sufix&#125;&gt;¥&lt;/span&gt;\n  &lt;span className=&#123;cx(s.amount, s.animation)&#125;&gt;10&lt;/span&gt;\n&lt;/div&gt;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n\n我们将金额动态化，引入 Zarm 为我们提供的模拟数字键盘组件 Keyboard，代码如下：\njs...\n// 监听输入框改变值\n  const handleMoney = (value) =&gt; &#123;\n    value = String(value)\n    // 点击是删除按钮时\n    if (value == &#39;delete&#39;) &#123;\n      let _amount = amount.slice(0, amount.length - 1)\n      setAmount(_amount)\n      return\n    &#125;\n\n    // 点击确认按钮时\n    if (value == &#39;ok&#39;) &#123;\n      // 这里后续将处理添加账单逻辑\n      return\n    &#125;\n\n    // 当输入的值为 &#39;.&#39; 且 已经存在 &#39;.&#39;，则不让其继续字符串相加。\n    if (value == &#39;.&#39; &amp;&amp; amount.includes(&#39;.&#39;)) return\n    // 小数点后保留两位，当超过两位时，不让其字符串继续相加。\n    if (value != &#39;.&#39; &amp;&amp; amount.includes(&#39;.&#39;) &amp;&amp; amount &amp;&amp; amount.split(&#39;.&#39;)[1].length &gt;= 2) return\n    // amount += value\n    setAmount(amount + value)\n  &#125;\n...\n\n&lt;div className=&#123;s.money&#125;&gt;\n  &lt;span className=&#123;s.sufix&#125;&gt;¥&lt;/span&gt;\n  &lt;span className=&#123;cx(s.amount, s.animation)&#125;&gt;&#123;amount&#125;&lt;/span&gt;\n&lt;/div&gt;\n&lt;Keyboard type=&quot;price&quot; onKeyClick=&#123;(value) =&gt; handleMoney(value)&#125; /&gt;重启项目，浏览器展示如下图所示：\n\n\n\n\n\n\n\n\n\n\n这里一个小提示，我在制作项目的过程中，发现一个 Zarm 2.9.0 版本的 bug，Keyboard 组件在点击删除按钮的时候，onKeyClick 方法会反复被执行，于是我降级为 2.8.2 版本，并且去他们的官网提了 issue。\n此时「账单金额」也被安排上了。\n账单种类账单种类的作用是表示该笔账单的大致用途，我们通过接口从数据库回去账单种类列表，以横向滚动的形式，展示在金额的下面，接下来我们看具体的代码实现：\njs...\nimport CustomIcon from &#39;../CustomIcon&#39;;\nimport &#123; get, typeMap &#125; from &#39;@/utils&#39;;\n\n...\nconst [currentType, setCurrentType] = useState(&#123;&#125;); // 当前选中账单类型\nconst [expense, setExpense] = useState([]); // 支出类型数组\nconst [income, setIncome] = useState([]); // 收入类型数组\n\nuseEffect(async () =&gt; &#123;\n  const &#123; data: &#123; list &#125; &#125; = await get(&#39;/api/type/list&#39;);\n  const _expense = list.filter(i =&gt; i.type == 1); // 支出类型\n  const _income = list.filter(i =&gt; i.type == 2); // 收入类型\n  setExpense(_expense);\n  setIncome(_income);\n  setCurrentType(_expense[0]); // 新建账单，类型默认是支出类型数组的第一项\n&#125;, [])\n\n\n...\n&lt;div className=&#123;s.typeWarp&#125;&gt;\n  &lt;div className=&#123;s.typeBody&#125;&gt;\n    &#123;/* 通过 payType 判断，是展示收入账单类型，还是支出账单类型 */&#125;\n    &#123;\n      (payType == &#39;expense&#39; ? expense : income).map(item =&gt; &lt;div onClick=&#123;() =&gt; setCurrentType(item)&#125; key=&#123;item.id&#125; className=&#123;s.typeItem&#125;&gt;\n        &#123;/* 收入和支出的字体颜色，以及背景颜色通过 payType 区分，并且设置高亮 */&#125;\n        &lt;span className=&#123;cx(&#123;[s.iconfontWrap]: true, [s.expense]: payType == &#39;expense&#39;, [s.income]: payType == &#39;income&#39;, [s.active]: currentType.id == item.id&#125;)&#125;&gt;\n          &lt;CustomIcon className=&#123;s.iconfont&#125; type=&#123;typeMap[item.id].icon&#125; /&gt;\n        &lt;/span&gt;\n        &lt;span&gt;&#123;item.name&#125;&lt;/span&gt;\n      &lt;/div&gt;)\n    &#125;\n  &lt;/div&gt;\n&lt;/div&gt;注意，在 h5 界面实现横向滚动，和在网页端相比，多了如下属性：\ncss* &#123;\n  touch-action: pan-x;\n&#125;\n\n\n\n\n\n\n\n\nCSS 属性 touch-action 用于设置触摸屏用户如何操纵元素的区域(例如，浏览器内置的缩放功能)。\n如果不设置它，只是通过 overflow-x: auto，无法实现 h5 端的横向滚动的，并且你要在一个 div 容器内设置全局 * 为 touch-action: pan-x;，如果后续遇到类似的问题，大家可以参考我上述做法，这是经过实践验证过的方法。\n我们来看看浏览器的展示效果：\n\n备注弹窗备注虽然不起眼，但是别小看它，它可以在账单类型不足以概括账单时，加以一定的文字描述。\n我们直接将其放置于「账单种类」的下面，代码如下：\njs...\nimport &#123;  Input  &#125; from &#39;zarm&#39;;\n\n...\nconst [remark, setRemark] = useState(&#39;&#39;); // 备注\nconst [showRemark, setShowRemark] = useState(false); // 备注输入框展示控制\n\n...\n&lt;div className=&#123;s.remark&#125;&gt;\n  &#123;\n    showRemark ? &lt;Input\n      autoHeight\n      showLength\n      maxLength=&#123;50&#125;\n      type=&quot;text&quot;\n      rows=&#123;3&#125;\n      value=&#123;remark&#125;\n      placeholder=&quot;请输入备注信息&quot;\n      onChange=&#123;(val) =&gt; setRemark(val)&#125;\n      onBlur=&#123;() =&gt; setShowRemark(false)&#125;\n    /&gt; : &lt;span onClick=&#123;() =&gt; setShowRemark(true)&#125;&gt;&#123;remark || &#39;添加备注&#39;&#125;&lt;/span&gt;\n  &#125;\n&lt;/div&gt;CSS 样式部分\ncss.remark &#123;\n  padding: 0 24px;\n  padding-bottom: 12px;\n  color: #4b67e2;\n  :global &#123;\n    .za-input--textarea &#123;\n      border: 1px solid #e9e9e9;\n      padding: 10px;\n    &#125;\n  &#125;\n&#125;:global 的使用之前已经有描述过，这里再提醒大家一句，目前项目使用的是 css module 的形式，所以样式名都会被打上 hash 值，我们需要修改没有打 hash 值的 zarm 内部样式，需要通过 :global 方法。\n浏览器展示效果如下：\n\n调用上传账单接口此时我们集齐了五大参数：\n\n账单类型：payType\n账单金额：amount\n账单日期：date\n账单种类：currentType\n备注：remark\n\n我们给 Keyboard 的「确定」按钮回调添加方法：\njsimport &#123; Toast &#125; from &quot;zarm&quot;;\nimport &#123; post &#125; from &quot;@/utils&quot;;\n// 监听输入框改变值\nconst handleMoney = (value) =&gt; &#123;\n  value = String(value);\n  // 点击是删除按钮时\n  if (value == &quot;delete&quot;) &#123;\n    let _amount = amount.slice(0, amount.length - 1);\n    setAmount(_amount);\n    return;\n  &#125;\n  // 点击确认按钮时\n  if (value == &quot;ok&quot;) &#123;\n    addBill();\n    return;\n  &#125;\n  // 当输入的值为 &#39;.&#39; 且 已经存在 &#39;.&#39;，则不让其继续字符串相加。\n  if (value == &quot;.&quot; &amp;&amp; amount.includes(&quot;.&quot;)) return;\n  // 小数点后保留两位，当超过两位时，不让其字符串继续相加。\n  if (\n    value != &quot;.&quot; &amp;&amp;\n    amount.includes(&quot;.&quot;) &amp;&amp;\n    amount &amp;&amp;\n    amount.split(&quot;.&quot;)[1].length &gt;= 2\n  )\n    return;\n  // amount += value\n  setAmount(amount + value);\n&#125;;\n\n// 添加账单\nconst addBill = async () =&gt; &#123;\n  if (!amount) &#123;\n    Toast.show(&quot;请输入具体金额&quot;);\n    return;\n  &#125;\n  const params = &#123;\n    amount: Number(amount).toFixed(2), // 账单金额小数点后保留两位\n    type_id: currentType.id, // 账单种类id\n    type_name: currentType.name, // 账单种类名称\n    date: dayjs(date).unix() * 1000, // 日期传时间戳\n    pay_type: payType == &quot;expense&quot; ? 1 : 2, // 账单类型传 1 或 2\n    remark: remark || &quot;&quot;, // 备注\n  &#125;;\n  const result = await post(&quot;/api/bill/add&quot;, params);\n  // 重制数据\n  setAmount(&quot;&quot;);\n  setPayType(&quot;expense&quot;);\n  setCurrentType(expense[0]);\n  setDate(new Date());\n  setRemark(&quot;&quot;);\n  Toast.show(&quot;添加成功&quot;);\n  setShow(false);\n  if (props.onReload) props.onReload();\n&#125;;onReload 方法为首页账单列表传进来的函数，当添加完账单的时候，执行 onReload 重新获取首页列表数据。\njs&lt;PopupAddBill ref=&#123;addRef&#125; onReload=&#123;refreshData&#125; /&gt;浏览器展示如下所示：\n\n如果如上图所示，恭喜你，你已经成功完成了添加账单的 工作，此时再回头甚至之前写的代码，马上改正一些变量及一些方法的命名，规范化一下代码。\n千万别在后面再去完善，因为很大程度上，到后面你会懒得翻前面写的代码，除非实在是逻辑问题导致的 bug。\n总结本章节的内容也是非常丰富，我们的所有的努力，就是为了集齐「添加账单」所需要的五大参数。这是很多需求的一个索引，试问前端在调用接口的过程中，不都是做各种努力为了凑齐那几个参数呢？过程很重要，只要流程做得完善，结果自然水到渠成。\n","slug":"116-react","date":"2023-01-18T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"f961cc93192686566a5da2c2c5b232b6","title":"115、稀土掘金小册-记账本（六）账单列表","content":"\n\n前言上一章节介绍的登录注册是整个项目的根基，没有拿到 token，将无法进行后续的各种操作，如账单的增删改查。所以务必将上一章节好好地阅读与揣摩，为后面的学习做好铺垫。我们直接进入本次前端实战项目的主题，账单的增删改查之列表页。\n\n\n\n\n\n\n\n\n\n本教程已有线上地址在线地址，同学们可以在实战部分，对照着线上页面进行学习。\n知识点\n单项组件抽离\n列表页无限滚动\n下拉刷新列表\n弹窗组件封装\n\n我们先来欣赏一下最终的页面效果：\n\n列表页编写（静态部分）按照正常的开发流程，我们先将静态页面切出来，再填入数据使其动态化。在此之前，我们已经新建好了 Home 目录，该目录便是用于放置账单列表，所以我们直接在 Home/index.jsx 新增代码。\n头部统计实现列表的头部展示的内容为当月的收入和支出汇总，并且有两个列表条件过滤项，分别是类型过滤和时间过滤。\n我们新增代码如下：\njsimport React from &quot;react&quot;;\nimport &#123; Icon &#125; from &quot;zarm&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Home = () =&gt; &#123;\n  return (\n    &lt;div className=&#123;s.home&#125;&gt;\n      &lt;div className=&#123;s.header&#125;&gt;\n        &lt;div className=&#123;s.dataWrap&#125;&gt;\n          &lt;span className=&#123;s.expense&#125;&gt;\n            总支出：&lt;b&gt;¥ 200&lt;/b&gt;\n          &lt;/span&gt;\n          &lt;span className=&#123;s.income&#125;&gt;\n            总收入：&lt;b&gt;¥ 500&lt;/b&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.typeWrap&#125;&gt;\n          &lt;div className=&#123;s.left&#125;&gt;\n            &lt;span className=&#123;s.title&#125;&gt;\n              类型 &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;\n            &lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div className=&#123;s.right&#125;&gt;\n            &lt;span className=&#123;s.time&#125;&gt;\n              2022-06\n              &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;\n            &lt;/span&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Home;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n代码分析：\nheader 采用 fixed 固定定位，将整个汇总信息固定在页面的顶部位置，这样后续列表滚动的时候，你可以方便查看当月的收入汇总，以及筛选当月消费类型和时间段的筛选。每个列表展示的是当月的收入与支出明细，比如 2021-06 的收入明细。\n本次项目全程采用的是 Flex 弹性布局，这种布局形式在当下的开发生产环境已经非常成熟，同学们如果还有不熟悉的，请实现对 Flex 布局做一个简单的学习，这边推荐一个学习网站：\n\n\n\n\n\n\n\n\n\nflexboxfroggy.com&#x2F;#zh-cn\n笔者当初也是通过这个网站的学习，入门的 Flex。\n完成上述布局之后，页面如下所示：\n\n列表页面实现列表页面会用到 Zarm 组件库为我们提供的 Pull 组件，来实现下拉刷新以及无限滚动，我们先来将基础布局实现，如下所示：\njs// Home/index.jsx\nconst Home = () =&gt; &#123;\n  const [list, setList] = useState([\n    &#123;\n      bills: [\n        &#123;\n          amount: &quot;25.00&quot;,\n          date: &quot;1623390740000&quot;,\n          id: 911,\n          pay_type: 1,\n          remark: &quot;&quot;,\n          type_id: 1,\n          type_name: &quot;餐饮&quot;,\n        &#125;,\n      ],\n      date: &quot;2021-06-11&quot;,\n    &#125;,\n  ]); // 账单列表\n  return (\n    &lt;div className=&#123;s.home&#125;&gt;\n      &lt;div className=&#123;s.header&#125;&gt;...&lt;/div&gt;\n      &lt;div className=&#123;s.contentWrap&#125;&gt;\n        &#123;list.map((item, index) =&gt; (\n          &lt;BillItem /&gt;\n        ))&#125;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;上述我们添加 list 为列表假数据，BillItem 组件为账单单项组件，我们将其抽离到 components 组件库，如下：\njs// components/BillItem/index.jsx\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport dayjs from &quot;dayjs&quot;;\nimport &#123; Cell &#125; from &quot;zarm&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport CustomIcon from &quot;../CustomIcon&quot;;\nimport &#123; typeMap &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst BillItem = (&#123; bill &#125;) =&gt; &#123;\n  const [income, setIncome] = useState(0); // 收入\n  const [expense, setExpense] = useState(0); // 支出\n  const navigateTo = useNavigate(); // 路由实例\n\n  // 当添加账单是，bill.bills 长度变化，触发当日收支总和计算。\n  useEffect(() =&gt; &#123;\n    // 初始化将传入的 bill 内的 bills 数组内数据项，过滤出支出和收入。\n    // pay_type：1 为支出；2 为收入\n    // 通过 reduce 累加\n    const _income = bill.bills\n      .filter((i) =&gt; i.pay_type == 2)\n      .reduce((curr, item) =&gt; &#123;\n        curr += Number(item.amount);\n        return curr;\n      &#125;, 0);\n    setIncome(_income);\n    const _expense = bill.bills\n      .filter((i) =&gt; i.pay_type == 1)\n      .reduce((curr, item) =&gt; &#123;\n        curr += Number(item.amount);\n        return curr;\n      &#125;, 0);\n    setExpense(_expense);\n  &#125;, [bill.bills]);\n\n  // 前往账单详情\n  const goToDetail = (item) =&gt; &#123;\n    navigateTo(`/detail?id=$&#123;item.id&#125;`);\n  &#125;;\n\n  return (\n    &lt;div className=&#123;s.item&#125;&gt;\n      &lt;div className=&#123;s.headerDate&#125;&gt;\n        &lt;div className=&#123;s.date&#125;&gt;&#123;bill.date&#125;&lt;/div&gt;\n        &lt;div className=&#123;s.money&#125;&gt;\n          &lt;span&gt;\n            &lt;img src=&quot;//s.yezgea02.com/1615953405599/zhi%402x.png&quot; alt=&quot;支&quot; /&gt;\n            &lt;span&gt;¥&#123;expense.toFixed(2)&#125;&lt;/span&gt;\n          &lt;/span&gt;\n          &lt;span&gt;\n            &lt;img src=&quot;//s.yezgea02.com/1615953405599/shou%402x.png&quot; alt=&quot;收&quot; /&gt;\n            &lt;span&gt;¥&#123;income.toFixed(2)&#125;&lt;/span&gt;\n          &lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &#123;bill &amp;&amp;\n        bill.bills.map((item) =&gt; (\n          &lt;Cell\n            className=&#123;s.bill&#125;\n            key=&#123;item.id&#125;\n            onClick=&#123;() =&gt; goToDetail(item)&#125;\n            title=&#123;\n              &lt;&gt;\n                &lt;CustomIcon\n                  className=&#123;s.itemIcon&#125;\n                  type=&#123;item.type_id ? typeMap[item.type_id].icon : 1&#125;\n                /&gt;\n                &lt;span&gt;&#123;item.type_name&#125;&lt;/span&gt;\n              &lt;/&gt;\n            &#125;\n            description=&#123;\n              &lt;span\n                style=&#123;&#123; color: item.pay_type == 2 ? \"red\" : \"#39be77\" &#125;&#125;\n              &gt;&#123;`$&#123;item.pay_type == 1 ? &quot;-&quot; : &quot;+&quot;&#125;$&#123;item.amount&#125;`&#125;&lt;/span&gt;\n            &#125;\n            help=&#123;\n              &lt;div&gt;\n                &#123;dayjs(Number(item.date)).format(&quot;HH:mm&quot;)&#125;&#123;&quot; &quot;&#125;\n                &#123;item.remark ? `| $&#123;item.remark&#125;` : &quot;&quot;&#125;\n              &lt;/div&gt;\n            &#125;\n          &gt;&lt;/Cell&gt;\n        ))&#125;\n    &lt;/div&gt;\n  );\n&#125;;\n\nBillItem.propTypes = &#123;\n  bill: PropTypes.object,\n&#125;;\n\nexport default BillItem;通过 npm i dayjs -S 添加日期操作工具，移动端建议使用 dayjs，因为它相比 moment，体积小很多。\n上述代码中，typeMap 为我们自定义的属性，它是一个简直对，key 为消费类型 icon 的 id，value 为消费类型的 iconfont 的值，如下所示：\njs// utils/index.js\n...\nexport const typeMap = &#123;\n  1: &#123;\n    icon: &#39;canyin&#39;\n  &#125;,\n  2: &#123;\n    icon: &#39;fushi&#39;\n  &#125;,\n  3: &#123;\n    icon: &#39;jiaotong&#39;\n  &#125;,\n  4: &#123;\n    icon: &#39;riyong&#39;\n  &#125;,\n  5: &#123;\n    icon: &#39;gouwu&#39;\n  &#125;,\n  6: &#123;\n    icon: &#39;xuexi&#39;\n  &#125;,\n  7: &#123;\n    icon: &#39;yiliao&#39;\n  &#125;,\n  8: &#123;\n    icon: &#39;lvxing&#39;\n  &#125;,\n  9: &#123;\n    icon: &#39;renqing&#39;\n  &#125;,\n  10: &#123;\n    icon: &#39;qita&#39;\n  &#125;,\n  11: &#123;\n    icon: &#39;gongzi&#39;\n  &#125;,\n  12: &#123;\n    icon: &#39;jiangjin&#39;\n  &#125;,\n  13: &#123;\n    icon: &#39;zhuanzhang&#39;\n  &#125;,\n  14: &#123;\n    icon: &#39;licai&#39;\n  &#125;,\n  15: &#123;\n    icon: &#39;tuikuang&#39;\n  &#125;,\n  16: &#123;\n    icon: &#39;qita&#39;\n  &#125;\n&#125;完成上述操作之后，我们重启浏览器，如下所示：\n\n样式部分大家可以根据自己的喜好进行微调，不一定要一模一样，仁者见仁。\n下拉刷新、上滑无限加载我们修改 Home/index.jsx 如下所示：\njsimport React, &#123; useState, useEffect &#125; from &#39;react&#39;\nimport &#123; Icon, Pull &#125; from &#39;zarm&#39;\nimport dayjs from &#39;dayjs&#39;\nimport BillItem from &#39;@/components/BillItem&#39;\nimport &#123; get, REFRESH_STATE, LOAD_STATE &#125; from &#39;@/utils&#39; // Pull 组件需要的一些常量\n\nimport s from &#39;./style.module.less&#39;\n\nconst Home = () =&gt; &#123;\n  const [currentTime, setCurrentTime] = useState(dayjs().format(&#39;YYYY-MM&#39;)); // 当前筛选时间\n  const [page, setPage] = useState(1); // 分页\n  const [list, setList] = useState([]); // 账单列表\n  const [totalPage, setTotalPage] = useState(0); // 分页总数\n  const [refreshing, setRefreshing] = useState(REFRESH_STATE.normal); // 下拉刷新状态\n  const [loading, setLoading] = useState(LOAD_STATE.normal); // 上拉加载状态\n\n  useEffect(() =&gt; &#123;\n    getBillList() // 初始化\n  &#125;, [page])\n\n  // 获取账单方法\n  const getBillList = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;`);\n    // 下拉刷新，重制数据\n    if (page == 1) &#123;\n      setList(data.list);\n    &#125; else &#123;\n      setList(list.concat(data.list));\n    &#125;\n    setTotalPage(data.totalPage);\n    // 上滑加载状态\n    setLoading(LOAD_STATE.success);\n    setRefreshing(REFRESH_STATE.success);\n  &#125;\n\n  // 请求列表数据\n  const refreshData = () =&gt; &#123;\n    setRefreshing(REFRESH_STATE.loading);\n    if (page != 1) &#123;\n      setPage(1);\n    &#125; else &#123;\n      getBillList();\n    &#125;;\n  &#125;;\n\n  const loadData = () =&gt; &#123;\n    if (page &lt; totalPage) &#123;\n      setLoading(LOAD_STATE.loading);\n      setPage(page + 1);\n    &#125;\n  &#125;\n\n  return &lt;div className=&#123;s.home&#125;&gt;\n    &lt;div className=&#123;s.header&#125;&gt;\n      &lt;div className=&#123;s.dataWrap&#125;&gt;\n        &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ 200&lt;/b&gt;&lt;/span&gt;\n        &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ 500&lt;/b&gt;&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=&#123;s.typeWrap&#125;&gt;\n        &lt;div className=&#123;s.left&#125;&gt;\n          &lt;span className=&#123;s.title&#125;&gt;类型 &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.right&#125;&gt;\n          &lt;span className=&#123;s.time&#125;&gt;2022-06&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div className=&#123;s.contentWrap&#125;&gt;\n      &#123;\n        list.length ? &lt;Pull\n          animationDuration=&#123;200&#125;\n          stayTime=&#123;400&#125;\n          refresh=&#123;&#123;\n            state: refreshing,\n            handler: refreshData\n          &#125;&#125;\n          load=&#123;&#123;\n            state: loading,\n            distance: 200,\n            handler: loadData\n          &#125;&#125;\n        &gt;\n          &#123;\n            list.map((item, index) =&gt; &lt;BillItem\n              bill=&#123;item&#125;\n              key=&#123;index&#125;\n            /&gt;)\n          &#125;\n        &lt;/Pull&gt; : null\n      &#125;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&#125;\n\nexport default Home\n&#125;在 utils/index.js 中添加一些 Pull 组件需要用到的常量，如下：\njs// utils/index.js\nexport const REFRESH_STATE = &#123;\n  normal: 0, // 普通\n  pull: 1, // 下拉刷新（未满足刷新条件）\n  drop: 2, // 释放立即刷新（满足刷新条件）\n  loading: 3, // 加载中\n  success: 4, // 加载成功\n  failure: 5, // 加载失败\n&#125;;\n\nexport const LOAD_STATE = &#123;\n  normal: 0, // 普通\n  abort: 1, // 中止\n  loading: 2, // 加载中\n  success: 3, // 加载成功\n  failure: 4, // 加载失败\n  complete: 5, // 加载完成（无新数据）\n&#125;;代码中，已经为大家整理了详细的注释。无限滚动在移动端的应用随处可见，所以这块内容大家尽量能做到烂熟于心。如果有可能的话，希望你也能将其二次封装，便于多个地方的复用。我们打开浏览器查看效果：\n\n同学们注意一下上述动图中的细节，滑到底部的时候，有一部分内容被遮挡住了，此时我们需要添加下列样式，进行修复：\ncss.home &#123;\n  ... .content-wrap &#123;\n    height: calc(~&quot;(100% - 50px)&quot;);\n    overflow: hidden;\n    overflow-y: scroll;\n    background-color: #f5f5f5;\n    padding: 10px;\n    :global &#123;\n      .za-pull &#123;\n        overflow: unset;\n      &#125;\n    &#125;\n  &#125;\n&#125;给 content-wrap 对应的标签一个高度，并且减去 50px 的高度，这样就不会被遮挡住下面一点的部分。\n还有一个很关键的步骤，给 src 目录下的的 index.css 添加初始化高度和样式：\ncssbody &#123;\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Roboto&quot;,\n    &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;,\n    &quot;Helvetica Neue&quot;, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n&#125;\n\nbody,\nhtml,\np &#123;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n&#125;\n\n* &#123;\n  box-sizing: border-box;\n&#125;\n\n#root &#123;\n  height: 100%;\n&#125;\n\n.text-deep &#123;\n  color: rgba(0, 0, 0, 0.9);\n&#125;\n\n.text-light &#123;\n  color: rgba(0, 0, 0, 0.6);\n&#125;至此，滚动加载基本上就完成了。\n添加筛选条件最后我们需要添加两个筛选条件，类型选择和日期选择。\n我们先来实现类型选择弹窗，我们采用的形式如下，底部弹出的弹窗形式，大致如下：\n\n想要实现上述形式，我们需要借助 Zarm 组件库为我们提供的 Popup 组件，它的作用就是从不同方向弹出一个脱离文档流的弹出层。同样，我们使用组件的形式将其放置于 components 文件夹内实现，这样便于后续其他地方的使用。\n新建 components/PopupType，在其内部新建 index.jsx 和 style.module.less 内容如下：\njs// PopupType/index.jsx\nimport React, &#123; forwardRef, useEffect, useState &#125; from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport &#123; Popup, Icon &#125; from &quot;zarm&quot;;\nimport cx from &quot;classnames&quot;;\nimport &#123; get &#125; from &quot;@/utils&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\n// forwardRef 用于拿到父组件传入的 ref 属性，这样在父组件便能通过 ref 控制子组件。\nconst PopupType = forwardRef((&#123; onSelect &#125;, ref) =&gt; &#123;\n  const [show, setShow] = useState(false); // 组件的显示和隐藏\n  const [active, setActive] = useState(&quot;all&quot;); // 激活的 type\n  const [expense, setExpense] = useState([]); // 支出类型标签\n  const [income, setIncome] = useState([]); // 收入类型标签\n\n  useEffect(async () =&gt; &#123;\n    // 请求标签接口放在弹窗内，这个弹窗可能会被复用，所以请求如果放在外面，会造成代码冗余。\n    const &#123;\n      data: &#123; list &#125;,\n    &#125; = await get(&quot;/api/type/list&quot;);\n    setExpense(list.filter((i) =&gt; i.type == 1));\n    setIncome(list.filter((i) =&gt; i.type == 2));\n  &#125;, []);\n\n  if (ref) &#123;\n    ref.current = &#123;\n      // 外部可以通过 ref.current.show 来控制组件的显示\n      show: () =&gt; &#123;\n        setShow(true);\n      &#125;,\n      // 外部可以通过 ref.current.close 来控制组件的显示\n      close: () =&gt; &#123;\n        setShow(false);\n      &#125;,\n    &#125;;\n  &#125;\n\n  // 选择类型回调\n  const choseType = (item) =&gt; &#123;\n    setActive(item.id);\n    setShow(false);\n    // 父组件传入的 onSelect，为了获取类型\n    onSelect(item);\n  &#125;;\n\n  return (\n    &lt;Popup\n      visible=&#123;show&#125;\n      direction=&quot;bottom&quot;\n      onMaskClick=&#123;() =&gt; setShow(false)&#125;\n      destroy=&#123;false&#125;\n      mountContainer=&#123;() =&gt; document.body&#125;\n    &gt;\n      &lt;div className=&#123;s.popupType&#125;&gt;\n        &lt;div className=&#123;s.header&#125;&gt;\n          请选择类型\n          &lt;Icon\n            type=&quot;wrong&quot;\n            className=&#123;s.cross&#125;\n            onClick=&#123;() =&gt; setShow(false)&#125;\n          /&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.content&#125;&gt;\n          &lt;div\n            onClick=&#123;() =&gt; choseType(&#123; id: &quot;all&quot; &#125;)&#125;\n            className=&#123;cx(&#123; [s.all]: true, [s.active]: active == &quot;all&quot; &#125;)&#125;\n          &gt;\n            全部类型\n          &lt;/div&gt;\n          &lt;div className=&#123;s.title&#125;&gt;支出&lt;/div&gt;\n          &lt;div className=&#123;s.expenseWrap&#125;&gt;\n            &#123;expense.map((item, index) =&gt; (\n              &lt;p\n                key=&#123;index&#125;\n                onClick=&#123;() =&gt; choseType(item)&#125;\n                className=&#123;cx(&#123; [s.active]: active == item.id &#125;)&#125;\n              &gt;\n                &#123;item.name&#125;\n              &lt;/p&gt;\n            ))&#125;\n          &lt;/div&gt;\n          &lt;div className=&#123;s.title&#125;&gt;收入&lt;/div&gt;\n          &lt;div className=&#123;s.incomeWrap&#125;&gt;\n            &#123;income.map((item, index) =&gt; (\n              &lt;p\n                key=&#123;index&#125;\n                onClick=&#123;() =&gt; choseType(item)&#125;\n                className=&#123;cx(&#123; [s.active]: active == item.id &#125;)&#125;\n              &gt;\n                &#123;item.name&#125;\n              &lt;/p&gt;\n            ))&#125;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/Popup&gt;\n  );\n&#125;);\n\nPopupType.propTypes = &#123;\n  onSelect: PropTypes.func,\n&#125;;\n\nexport default PopupType;老规矩，代码逻辑注释我都写在代码中，我坚持不把注释和逻辑分开，是因为我自己在看其他教程的时候，遇到代码中没写逻辑的文章，来回看下边的注释和上边的代码，有点乱，如果同学们有疑问，可以进群截图咨询，我在群里看到的话，随时进行解答。\n类型弹窗组件写完之后，我们在 Home/index.jsx 内尝试调用它，如下所示：\njs...\nimport PopupType from &#39;@/components/PopupType&#39;\n\nconst Home = () =&gt; &#123;\n  const typeRef = useRef(); // 账单类型 ref\n  const [currentSelect, setCurrentSelect] = useState(&#123;&#125;); // 当前筛选类型\n  ...\n\n  useEffect(() =&gt; &#123;\n    getBillList() // 初始化\n  &#125;, [page, currentSelect])\n\n  const getBillList = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;&amp;type_id=$&#123;currentSelect.id || &#39;all&#39;&#125;`);\n    // 下拉刷新，重制数据\n    if (page == 1) &#123;\n      setList(data.list);\n    &#125; else &#123;\n      setList(list.concat(data.list));\n    &#125;\n    setTotalPage(data.totalPage);\n    // 上滑加载状态\n    setLoading(LOAD_STATE.success);\n    setRefreshing(REFRESH_STATE.success);\n  &#125;\n\n  ...\n\n  // 添加账单弹窗\n  const toggle = () =&gt; &#123;\n    typeRef.current &amp;&amp; typeRef.current.show()\n  &#125;;\n\n  // 筛选类型\n  const select = (item) =&gt; &#123;\n    setRefreshing(REFRESH_STATE.loading);\n    // 触发刷新列表，将分页重制为 1\n    setPage(1);\n    setCurrentSelect(item)\n  &#125;\n\n  return &lt;div className=&#123;s.home&#125;&gt;\n    &lt;div className=&#123;s.header&#125;&gt;\n      &lt;div className=&#123;s.dataWrap&#125;&gt;\n        &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ 200&lt;/b&gt;&lt;/span&gt;\n        &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ 500&lt;/b&gt;&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=&#123;s.typeWrap&#125;&gt;\n        &lt;div className=&#123;s.left&#125; onClick=&#123;toggle&#125;&gt;\n          &lt;span className=&#123;s.title&#125;&gt;&#123; currentSelect.name || &#39;全部类型&#39; &#125; &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div className=&#123;s.right&#125;&gt;\n          &lt;span className=&#123;s.time&#125;&gt;2022-06&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div className=&#123;s.contentWrap&#125;&gt;\n      &#123;\n        list.length ? &lt;Pull\n          animationDuration=&#123;200&#125;\n          stayTime=&#123;400&#125;\n          refresh=&#123;&#123;\n            state: refreshing,\n            handler: refreshData\n          &#125;&#125;\n          load=&#123;&#123;\n            state: loading,\n            distance: 200,\n            handler: loadData\n          &#125;&#125;\n        &gt;\n          &#123;\n            list.map((item, index) =&gt; &lt;BillItem\n              bill=&#123;item&#125;\n              key=&#123;index&#125;\n            /&gt;)\n          &#125;\n        &lt;/Pull&gt; : null\n      &#125;\n    &lt;/div&gt;\n    &lt;PopupType ref=&#123;typeRef&#125; onSelect=&#123;select&#125; /&gt;\n  &lt;/div&gt;\n&#125;添加类型选择弹窗注意几个点：\n1、使用 useState 声明好类型字段。 2、通过 useRef 声明的 ref 给到 PopupType 组件，便于控制内部的方法。 3、传递 onSelect 方法，获取到弹窗内部选择的类型。 4、useEffect 第二个参数，添加一个 currentSelect 以来，便于修改的时候，触发列表的重新渲染。\n有一个有趣的知识点，这里和大家分享一下，你尝试去打印 typeRef 变量，如下所示：\n\n可以看到，在 PopupType 组件内挂载的方法，可以在父组件内获取到，那么我们便可以直接把弹窗的显示隐藏参数放在子组件内维护，而不用每次都去在父组件声明 show 或 hide。\n加完类型筛选之后，我们再将时间筛选加上，同样将时间筛选添加至 components 目录下，便于后续数据页面的时间筛选。\njs// PopupDate/index.jsx\nimport React, &#123; forwardRef, useState &#125; from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport &#123; Popup, DatePicker &#125; from &quot;zarm&quot;;\nimport dayjs from &quot;dayjs&quot;;\n\nconst PopupDate = forwardRef((&#123; onSelect, mode = &quot;date&quot; &#125;, ref) =&gt; &#123;\n  const [show, setShow] = useState(false);\n  const [now, setNow] = useState(new Date());\n\n  const choseMonth = (item) =&gt; &#123;\n    setNow(item);\n    setShow(false);\n    if (mode == &quot;month&quot;) &#123;\n      onSelect(dayjs(item).format(&quot;YYYY-MM&quot;));\n    &#125; else if (mode == &quot;date&quot;) &#123;\n      onSelect(dayjs(item).format(&quot;YYYY-MM-DD&quot;));\n    &#125;\n  &#125;;\n\n  if (ref) &#123;\n    ref.current = &#123;\n      show: () =&gt; &#123;\n        setShow(true);\n      &#125;,\n      close: () =&gt; &#123;\n        setShow(false);\n      &#125;,\n    &#125;;\n  &#125;\n  return (\n    &lt;Popup\n      visible=&#123;show&#125;\n      direction=&quot;bottom&quot;\n      onMaskClick=&#123;() =&gt; setShow(false)&#125;\n      destroy=&#123;false&#125;\n      mountContainer=&#123;() =&gt; document.body&#125;\n    &gt;\n      &lt;div&gt;\n        &lt;DatePicker\n          visible=&#123;show&#125;\n          value=&#123;now&#125;\n          mode=&#123;mode&#125;\n          onOk=&#123;choseMonth&#125;\n          onCancel=&#123;() =&gt; setShow(false)&#125;\n        /&gt;\n      &lt;/div&gt;\n    &lt;/Popup&gt;\n  );\n&#125;);\n\nPopupDate.propTypes = &#123;\n  mode: PropTypes.string, // 日期模式\n  onSelect: PropTypes.func, // 选择后的回调\n&#125;;\n\nexport default PopupDate;底部时间弹窗逻辑和类型选择的逻辑相似，这里不做赘述，直接在 Home/index.jsx 中引入时间筛选框：\njs// Home/index.jsx\n...\nimport PopupDate from &#39;@/components/PopupDate&#39;\n\nconst Home = () =&gt; &#123;\n  ...\n  const monthRef = useRef(); // 月份筛选 ref\n\n  useEffect(() =&gt; &#123;\n    getBillList() // 初始化\n  &#125;, [page, currentSelect, currentTime])\n\n  ...\n\n  // 选择月份弹窗\n  const monthToggle = () =&gt; &#123;\n    monthRef.current &amp;&amp; monthRef.current.show()\n  &#125;;\n\n  // 筛选月份\n  const selectMonth = (item) =&gt; &#123;\n    setRefreshing(REFRESH_STATE.loading);\n    setPage(1);\n    setCurrentTime(item)\n  &#125;\n\n  return &lt;div className=&#123;s.home&#125;&gt;\n    ...\n    &lt;div className=&#123;s.right&#125;&gt;\n      &lt;span className=&#123;s.time&#125; onClick=&#123;monthToggle&#125;&gt;&#123; currentTime &#125;&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    ...\n\n    &lt;PopupDate ref=&#123;monthRef&#125; mode=&quot;month&quot; onSelect=&#123;selectMonth&#125; /&gt;\n  &lt;/div&gt;\n&#125;刷新浏览器如下所示：\n\n最后不要忘记计算当前月份的收入和支出汇总数据，放置于头部，修改 Home/index.jsx 内的代码如下：\njs...\nconst Home = () =&gt; &#123;\n  ...\n  const [totalExpense, setTotalExpense] = useState(0); // 总支出\n  const [totalIncome, setTotalIncome] = useState(0); // 总收入\n\n  const getBillList = async () =&gt; &#123;\n    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;&amp;type_id=$&#123;currentSelect.id || &#39;all&#39;&#125;`);\n    // 下拉刷新，重制数据\n    if (page == 1) &#123;\n      setList(data.list);\n    &#125; else &#123;\n      setList(list.concat(data.list));\n    &#125;\n    setTotalExpense(data.totalExpense.toFixed(2));\n    setTotalIncome(data.totalIncome.toFixed(2));\n    setTotalPage(data.totalPage);\n    // 上滑加载状态\n    setLoading(LOAD_STATE.success);\n    setRefreshing(REFRESH_STATE.success);\n  &#125;\n\n  return &lt;div className=&#123;s.home&#125;&gt;\n    ...\n    &lt;div className=&#123;s.dataWrap&#125;&gt;\n      &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ &#123; totalExpense &#125;&lt;/b&gt;&lt;/span&gt;\n      &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ &#123; totalIncome &#125;&lt;/b&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    ...\n  &lt;div&gt;\n&#125;最终展示效果如下所示：\n\n总结本章节的内容，偏向实战，而实战部分代码在文章的重复率不可避免，这里大家把握好本章节两个重要知识点：\n1、无限加载、下拉刷新。\n2、公用组件提取，如弹窗组件、账单组件。\n这两个知识点在实战中，用到的非常多，希望同学们能重视。\n","slug":"115-react","date":"2023-01-11T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"89fdc60b06f88685c7279c95eb4ad7cf","title":"114、稀土掘金小册-记账本（五）登录注册","content":"\n\n前言上一章节我们实现了底部导航栏，并且创建了三个主页面，这三个页面是需要展示底部导航栏，而我们本章节要制作的「登录注册页面」便是不需要底部导航栏的单独页面。\n\n\n\n\n\n\n\n\n\n本教程已有线上地址在线地址，同学们可以在实战部分，对照着线上页面进行学习。\n知识点组件：Cell、Input、Button、CheckBox。\n注册页面\n我们的系统是面向多用户的，换句话说也就是一个纯正的 C 端项目，任何人都可以通过网站，注册一个新的账号。接下来开始注册页面的编写。\n首先新建 Login 文件夹，在文件夹内添加两个文件 index.jsx 和 style.module.less，我们先把注册页面的静态页面切出来，首先给 index.jsx 添加如下代码：\njsimport React from &quot;react&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Login = () =&gt; &#123;\n  return &lt;div className=&#123;s.auth&#125;&gt;注册&lt;/div&gt;;\n&#125;;\n\nexport default Login;为它添加一个路由配置，打开 router/index.js 添加如下：\njsimport Login from &#39;@/container/Login&#39;\n...\n&#123;\n  path: &quot;/login&quot;,\n  component: Login\n&#125;重启项目，如下所示代表登录注册页面创建成功了：\n\n接下来为 Login/index.jsx 添加静态页面代码：\njsimport React from &quot;react&quot;;\nimport &#123; Cell, Input, Button, Checkbox &#125; from &quot;zarm&quot;;\nimport CustomIcon from &quot;@/components/CustomIcon&quot;;\n\nimport s from &quot;./style.module.less&quot;;\n\nconst Login = () =&gt; &#123;\n  return (\n    &lt;div className=&#123;s.auth&#125;&gt;\n      &lt;div className=&#123;s.head&#125; /&gt;\n      &lt;div className=&#123;s.tab&#125;&gt;\n        &lt;span&gt;注册&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=&#123;s.form&#125;&gt;\n        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;zhanghao&quot; /&gt;&#125;&gt;\n          &lt;Input clearable type=&quot;text&quot; placeholder=&quot;请输入账号&quot; /&gt;\n        &lt;/Cell&gt;\n        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;\n          &lt;Input clearable type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;\n        &lt;/Cell&gt;\n        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;\n          &lt;Input clearable type=&quot;text&quot; placeholder=&quot;请输入验证码&quot; /&gt;\n        &lt;/Cell&gt;\n      &lt;/div&gt;\n      &lt;div className=&#123;s.operation&#125;&gt;\n        &lt;div className=&#123;s.agree&#125;&gt;\n          &lt;Checkbox /&gt;\n          &lt;label className=&quot;text-light&quot;&gt;\n            阅读并同意&lt;a&gt;《掘掘手札条款》&lt;/a&gt;\n          &lt;/label&gt;\n        &lt;/div&gt;\n        &lt;Button block theme=&quot;primary&quot;&gt;\n          注册\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n&#125;;\n\nexport default Login;\n\n\n\n\n\n\n\n\n文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。\n上述代码中，关键部分是账号输入、密码输入、验证码输入，这三个输入框是需要获取数据作为接口的参数提交上去的。\n很多时候，服务端没有开发好接口的时候，我们前端要做的任务就是先还原 UI 稿，把该切的页面都切出来，并且预留好需要给接口提交的数据交互，比如上述三个输入框。\n样式编写部分，要注意的一点是 :global 这个关键词。由于我们采用的是 CSS Module 的形式进行开发，也就是你在页面中声明的类名都会根据当前页面，打一个唯一的 hash 值，比如我们页面中声明的 className=&#123;s.form&#125;，最终在浏览器中显示的是这样的：\n\n_form_kpur3_30 是已经被编译过的样式，这样做的目的是避免和别的页面的样式重名，这是目前样式管理的一个诟病，当多人参与项目开发的时候，很难做到不污染全局样式名称，除非很小心的命名样式名称。\n所以经过编译之后，想要修改 .form 下的 .za-cell，如下写法，将无法修改成功：\ncss.form &#123;\n  .za-cell &#123;\n    color: red;\n  &#125;\n&#125;原因是，上述写法，.za-cell 会被编译加上 hash，组件库 Zarm 内的 dom 类名还是叫 za-cell，如上图所示。所以为了不加 hash，就需要这样操作：\ncss.form &#123;\n  :global &#123;\n    .za-cell &#123;\n      color: red;\n    &#125;\n  &#125;\n&#125;这样 .za-cell 就不会被加上 hash，如下图所示：\n\n完成上述页面布局之后，你会看到这样一个效果：\n\n少了一个验证码，我们使用插件 react-captcha-code，我们通过 npm 下载它：\nbashnpm i react-captcha-code -S在代码中引入：\njs...\nimport Captcha from &quot;react-captcha-code&quot;\n...\n&lt;Input\n  clearable\n  type=&quot;text&quot;\n  placeholder=&quot;请输入验证码&quot;\n  onChange=&#123;(value) =&gt; setVerify(value)&#125;\n/&gt;\n&lt;Captcha charNum=&#123;4&#125; /&gt;浏览器展示如下所示：\n\n此时我们已经切完注册页面需要的内容。\n我们给页面加上相应的逻辑，首先是账号、密码、验证码：\njs...\nconst [username, setUsername] = useState(&#39;&#39;); // 账号\nconst [password, setPassword] = useState(&#39;&#39;); // 密码\nconst [verify, setVerify] = useState(&#39;&#39;); // 验证码\n...\n&lt;Input\n  clearable\n  type=&quot;text&quot;\n  placeholder=&quot;请输入账号&quot;\n  onChange=&#123;(value) =&gt; setUsername(value)&#125;\n/&gt;\n...\n&lt;Input\n  clearable\n  type=&quot;password&quot;\n  placeholder=&quot;请输入密码&quot;\n  onChange=&#123;(value) =&gt; setPassword(value)&#125;\n/&gt;\n...\n&lt;Input\n  clearable\n  type=&quot;text&quot;\n  placeholder=&quot;请输入验证码&quot;\n  onChange=&#123;(value) =&gt; setVerify(value)&#125;\n/&gt;当输入框内容修改的时候，onChange 会被触发，接受的回调函数参数，便是变化的输入值，此时我们将其保存在声明的变量中。\n我们输入的验证码是需要和验证码图片里的验证码匹配的，所以我们还需要拿到图片里的验证码，我们作如下操作：\njsimport React, &#123; useCallback &#125; from &#39;react&#39;\n...\nconst [captcha, setCaptcha] = useState(&#39;&#39;); // 验证码变化后存储值\n//  验证码变化，回调方法\nconst handleChange = useCallback((captcha) =&gt; &#123;\n  console.log(&#39;captcha&#39;, captcha)\n  setCaptcha(captcha)\n&#125;, []);\n...\n&lt;Captcha charNum=&#123;4&#125; onChange=&#123;handleChange&#125; /&gt;当验证码变化的时候，便能获取到相应的值。修改完上述代码，我们不妨测试一下：\n\n到此，注册需要的参数都有了，我们开始编写注册方法：\njsimport &#123; Cell, Input, Button, Checkbox, Toast &#125; from &#39;zarm&#39;\nimport &#123; post &#125; from &#39;@/utils&#39;\n...\nconst onSubmit = async () =&gt; &#123;\n  if (!username) &#123;\n    Toast.show(&#39;请输入账号&#39;)\n    return\n  &#125;\n  if (!password) &#123;\n    Toast.show(&#39;请输入密码&#39;)\n    return\n  &#125;\n  if (!verify) &#123;\n    Toast.show(&#39;请输入验证码&#39;)\n    return\n  &#125;;\n  if (verify != captcha) &#123;\n    Toast.show(&#39;验证码错误&#39;)\n    return\n  &#125;;\n  try &#123;\n    const &#123; data &#125; = await post(&#39;/api/user/register&#39;, &#123;\n      username,\n      password\n    &#125;);\n    Toast.show(&#39;注册成功&#39;);\n  &#125; catch (error) &#123;\n    Toast.show(&#39;系统错误&#39;);\n  &#125;\n&#125;;\n...\n&lt;Button onClick=&#123;onSubmit&#125; block theme=&quot;primary&quot;&gt;注册&lt;/Button&gt;上述代码中，因为我们使用的是 async await 做异步处理，所以需要通过 try catch 来捕获异步处理过程中出现的错误，如果使用 Promise 的回调函数，则无需使用 try catch，改动如下：\njspost(&quot;/api/user/register&quot;, &#123;\n  username,\n  password,\n&#125;).then((res) =&gt; &#123;\n  // do something\n&#125;);尝试使用之前注册过的用户名，注册一个账号：\n\n服务端给出正确的报错，我们再用一个未注册过的用户名：\n\n此时我们大致将注册功能实现了。这里我不再展开讲样式部分，因为这样会使得文章中出现过多的重复代码，不以阅读，大家尽量根据标签的类名去查找 css 样式部分。\n登录页面登录页面的逻辑我们直接做到同一个页面中，通过一个 type 参数作为判断条件，判断当前状态是登录页面或是注册页面。\n话不多说我们添加代码如下：\njs...\nimport cx from &#39;classnames&#39;\n...\n\nconst Login = () =&gt; &#123;\n  ...\n  const [type, setType] = useState(&#39;login&#39;); // 登录注册类型\n\n  return &lt;div className=&#123;s.auth&#125;&gt;\n    ...\n    &lt;div className=&#123;s.tab&#125;&gt;\n      &lt;span className=&#123;cx(&#123; [s.avtive]: type == &#39;login&#39; &#125;)&#125; onClick=&#123;() =&gt; setType(&#39;login&#39;)&#125;&gt;登录&lt;/span&gt;\n      &lt;span className=&#123;cx(&#123; [s.avtive]: type == &#39;register&#39; &#125;)&#125; onClick=&#123;() =&gt; setType(&#39;register&#39;)&#125;&gt;注册&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div className=&#123;s.form&#125;&gt;\n    ...\n    &#123;\n      type == &#39;register&#39; ? &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;\n        &lt;Input\n          clearable\n          type=&quot;text&quot;\n          placeholder=&quot;请输入验证码&quot;\n          onChange=&#123;(value) =&gt; setVerify(value)&#125;\n        /&gt;\n        &lt;Captcha ref=&#123;captchaRef&#125; charNum=&#123;4&#125; onChange=&#123;handleChange&#125; /&gt;\n      &lt;/Cell&gt; : null\n    &#125;\n  &lt;/div&gt;\n  &lt;div className=&#123;s.operation&#125;&gt;\n    &#123;\n      type == &#39;register&#39; ? &lt;div className=&#123;s.agree&#125;&gt;\n        &lt;Checkbox /&gt;\n        &lt;label className=&quot;text-light&quot;&gt;阅读并同意&lt;a&gt;《掘掘手札条款》&lt;/a&gt;&lt;/label&gt;\n      &lt;/div&gt; : null\n    &#125;\n    &lt;Button onClick=&#123;onSubmit&#125; block theme=&quot;primary&quot;&gt;&#123;type == &#39;login&#39; ? &#39;登录&#39; : &#39;注册&#39;&#125;&lt;/Button&gt;\n  &lt;/div&gt;\n&#125;\n\n\n\n\n\n\n\n\n注意，如果引入了新的工具包，请自行安装，如上述代码就需要安装 classnames。可以通过 npm i classnames -S 指令\n代码分析：\n上述代码中，通过 type 属性区分注册和登录。\n首先是 tab 切换，通过 classname 来判断是否是当前高亮，用于样式控制。\n其次，当 type == &#39;register&#39; 的时候，才把验证码展示出来，因为登录这边咱们就不设置验证码，只在注册的时候显示。\n最后是事件的判断，如果 type == &#39;login&#39;，则按钮文案显示为 登录，否则为 注册。\n此时点击触发的 onSubmit 事件也很关键，同样需要通过 type 判断是登录还是注册，修改代码如下：\njsconst onSubmit = async () =&gt; &#123;\n  if (!username) &#123;\n    Toast.show(&quot;请输入账号&quot;);\n    return;\n  &#125;\n  if (!password) &#123;\n    Toast.show(&quot;请输入密码&quot;);\n    return;\n  &#125;\n  try &#123;\n    // 判断是否是登录状态\n    if (type == &quot;login&quot;) &#123;\n      // 执行登录接口，获取 token\n      const &#123; data &#125; = await post(&quot;/api/user/login&quot;, &#123;\n        username,\n        password,\n      &#125;);\n      // 将 token 写入 localStorage\n      localStorage.setItem(&quot;token&quot;, data.token);\n    &#125; else &#123;\n      if (!verify) &#123;\n        Toast.show(&quot;请输入验证码&quot;);\n        return;\n      &#125;\n      if (verify != captcha) &#123;\n        Toast.show(&quot;验证码错误&quot;);\n        return;\n      &#125;\n      const &#123; data &#125; = await post(&quot;/api/user/register&quot;, &#123;\n        username,\n        password,\n      &#125;);\n      Toast.show(&quot;注册成功&quot;);\n      // 注册成功，自动将 tab 切换到 login 状态\n      setType(&quot;login&quot;);\n    &#125;\n  &#125; catch (error) &#123;\n    Toast.show(&quot;系统错误&quot;);\n  &#125;\n&#125;;由于登录注册的账号和密码是同一参数，我们这边就直接复用了逻辑，并通过 type 判断调用哪一个接口。\n重启项目，验证登录接口是否成功，如果成功则会返回 token 信息，如下图所示：\n\n此时，我们本地的 localStorage 里，已经存下了 token，如下图所示：\n\n保存 token 的形式有很多，你可以引入状态管理插件来对这些数据进行存储，但是这里我们对其进行简单处理，减少项目多余的负担，保证课程的完成度。有时候，成功的将课程完成，也是一种成就感。\n总结到此，我们的登录注册页面算是完成了，我们拿到的 token 是有时效性的，我在后台设置的是 24 小时的时效，如果过期了，请求其他接口时，就会报错，从而通过逻辑判断重新回到登录页面。下一章节，我会详细分析这块内容。\n","slug":"114-react","date":"2023-01-08T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"353e28eec06d8b45182abf1a539fd1b4","title":"113、稀土掘金小册-记账本（四）底部导航栏","content":"\n\n前言上一章节，我们从 0 开始搭建出一套以 React 技术栈为基础的前端开发环境，过程中肯定会遇到各种奇奇怪怪的问题，比如 Node 版本问题，工具包的版本问题，插件下载完之后，无法得到自己想要的效果等等，为了大家能顺畅地进行开发，请大家尽量将项目中用到的 node_module 包版本和我提供给大家的项目中的版本，保持一致。\n倘若你学会了这一套搭建流程，我希望你能举一反三，根据项目需求，灵活的切换组件库、PC 版、甚至是主框架。这对提升自己的知识广度很有帮助，因为相比每次都看教程，自己手动实现一遍，印象会更深刻，遇到问题也能通过自己的认知，去解决它。\n扯得有点远了，本章节我们将正式进入前端实战环节。\n\n\n\n\n\n\n\n\n\n本教程已有线上地址在线地址，同学们可以在实战部分，对照着线上页面。\n知识点\n编写底部导航栏\n创建图标公用组件\n路由控制底部导航栏的显隐\n\n编写底部导航栏我们先观察我们今天要实现的底部导航长啥样，如下所示：\n\n上图红框中的底部导航栏，在很多业务场景下都是需要的，三个导航栏对应着三个不同的三个页面组件，分别是「账单」、「统计」、「我的」。这三个页面组件是需要导航栏的。如果我们点击内页如账单详情页，则底部的导航栏会被隐藏，这就需要我们在导航栏的控制上，下一些功夫。\n话不多说，我们在上一章的代码基础上添加导航栏组件，在 src 目录下新建 components 目录，专门用于放置一些公用组件，我们再在 components 目录下新建 NavBar 目录，用于编写底部导航栏，代码如下所示：\nNav&#x2F;index.jsx\njsimport React, &#123; useState &#125; from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport &#123; TabBar &#125; from &quot;zarm&quot;;\nimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nimport s from &quot;./style.module.less&quot;;\n\nconst NavBar = (&#123; showNav &#125;) =&gt; &#123;\n  const [activeKey, setActiveKey] = useState(&quot;/&quot;);\n  const navigateTo = useNavigate();\n\n  const changeTab = (path) =&gt; &#123;\n    setActiveKey(path);\n    navigateTo(path);\n  &#125;;\n\n  return (\n    &lt;TabBar\n      visible=&#123;showNav&#125;\n      className=&#123;s.tab&#125;\n      activeKey=&#123;activeKey&#125;\n      onChange=&#123;changeTab&#125;\n    &gt;\n      &lt;TabBar.Item itemKey=&quot;/&quot; title=&quot;账单&quot; /&gt;\n      &lt;TabBar.Item itemKey=&quot;/data&quot; title=&quot;统计&quot; /&gt;\n      &lt;TabBar.Item itemKey=&quot;/user&quot; title=&quot;我的&quot; /&gt;\n    &lt;/TabBar&gt;\n  );\n&#125;;\n\nNavBar.propTypes = &#123;\n  showNav: PropTypes.bool,\n&#125;;\n\nexport default NavBar;代码解析：\n首先是声明 NavBar 函数组件，它接收一个外部传入的 showNav 属性，用于控制导航栏的显示隐藏。\n通过 useNavigate 钩子方法，拿到路由实例 navigateTo，它内部含有很多路由的方法，在上述代码中，我们使用到的是 navigateTo 进行路由跳转。\n在页面中，引入 TabBar 组件，它接受几个属性：\n\nvisible：用于控制导航栏的显示隐藏。\nactiveKey：当前被点击的导航栏。\nonChange：点击导航栏之后的回调方法，path 参数为 TabBar.Item 的 itemKey 属性。\n\n\n\n\n\n\n\n\n\n\nTabBar 官方文档：zarm.gitee.io&#x2F;#&#x2F;component…\n所以当你点击导航栏的时候，changeTab 方法便会被触发，执行内部的 setActiveKey 和 navigateTo，他们的作用分别是设置当前点击的高亮和让页面跳转到对应的页面组件。\n说到跳转到对应的组件，’&#x2F;‘、’&#x2F;data’、’&#x2F;user’ 这三个路由对应的三个组件我们还未编写，这里我们在 container 目录下新建这三个页面组件，作为占位。\njs// Home/index.jsx\nimport React from &#39;react&#39;\n\nconst Home = () =&gt; &#123;\n  return &lt;div&gt;首页&lt;/div&gt;\n&#125;\n\nexport default Home\n\n// Data/index.jsx\nimport React from &#39;react&#39;\n\nconst Data = () =&gt; &#123;\n  return &lt;div&gt;数据&lt;/div&gt;\n&#125;\n\nexport default Data\n\n// User/index.jsx\nimport React from &#39;react&#39;\n\nconst User = () =&gt; &#123;\n  return &lt;div&gt;个人中心&lt;/div&gt;\n&#125;\n\nexport default User别忘了，前往 router/index.js 添加路由配置，如果不添加这个配置，调用 navigateTo 这个方法，就无法匹配到对应的页面组件，代码如下：\njs// router/index.js\nimport Home from &quot;@/container/Home&quot;;\nimport Data from &quot;@/container/Data&quot;;\nimport User from &quot;@/container/User&quot;;\n\nconst routes = [\n  &#123;\n    path: &quot;/&quot;,\n    component: Home,\n  &#125;,\n  &#123;\n    path: &quot;/data&quot;,\n    component: Data,\n  &#125;,\n  &#123;\n    path: &quot;/user&quot;,\n    component: User,\n  &#125;,\n];\n\nexport default routes;这时，我们还缺少一步，将导航栏组件引入 App.jsx 入口页面，如下所示：\njs// App.jsx\n...\nimport NavBar from &#39;@/components/NavBar&#39;;\n...\nfunction App() &#123;\n  return &lt;Router&gt;\n    &lt;ConfigProvider primaryColor=&#123;&#39;#007fff&#39;&#125;&gt;\n      &lt;&gt;\n       &lt;Routes&gt;\n        &#123;routes.map(route =&gt; &lt;Route exact key=&#123;route.path&#125; path=&#123;route.path&#125; element=&#123;&lt;route.component /&gt;&#125; /&gt;)&#125;\n       &lt;/Routes&gt;\n      &lt;NavBar showNav=&#123;showNav&#125; /&gt;\n     &lt;/&gt;\n    &lt;/ConfigProvider&gt;\n    &lt;NavBar showNav=&#123;true&#125; /&gt;\n  &lt;/Router&gt;\n&#125;通过 npm run dev 启动项目，浏览器展示效果如下所示：\n\n上图效果所示，注意地址栏的变化，点击相应的 Tab，调用的 navigateTo 方法，将地址栏的 pathname 改变，随之而来的是页面组件的改变。这个就应证了我们第 10 章给大家解释的单页面路由控制的原理。navigateTo 做的事情就是改变地址栏，地址栏一旦改变，就会触发地址所对应的组件渲染，如 /data，渲染的就是 Data 页面组件。\n你会问为什么导航栏会一直显示在底部，我们来分析以下代码：\n\n红色框是组件展示的区域，每个路径对应着一个组件，这个在 router/index.js 文件中也有所体现。\n绿色框则代表导航栏的位置，也就是说，无论上面的组件怎么变化，底部的导航栏一直都是存在的。\n添加底部导航图标我们将图标写成公共组件，这样便于后面各个页面方便引入，我们新建 components/CustomIcon/index.jsx，添加如下代码：\njsimport &#123; Icon &#125; from &quot;zarm&quot;;\n\nexport default Icon.createFromIconfont(\n  &quot;//at.alicdn.com/t/font_2236655_w1mpqp7n1ni.js&quot;\n);上述代码，我们引入 Icon，执行它的自定义图标方法 createFromIconfont，它接收一个参数，为 iconfont 生产的静态脚本路径，你可以自己去 官网 配置，也可以直接用我提供的：\n\n这里我已经为大家添加好了各个图标，地址就是上述代码的地址。\n接着我们将其引入到代码中使用，打开 components/NavBar/index.jsx ，添加如下属性：\njsimport CustomIcon from &#39;../CustomIcon&#39;;\n...\n&lt;TabBar.Item\n  itemKey=&quot;/&quot;\n  title=&quot;账单&quot;\n  icon=&#123;&lt;CustomIcon type=&quot;zhangdan&quot; /&gt;&#125;\n/&gt;\n&lt;TabBar.Item\n  itemKey=&quot;/data&quot;\n  title=&quot;统计&quot;\n  icon=&#123;&lt;CustomIcon type=&quot;tongji&quot; /&gt;&#125;\n/&gt;\n&lt;TabBar.Item\n  itemKey=&quot;/user&quot;\n  title=&quot;我的&quot;\n  icon=&#123;&lt;CustomIcon type=&quot;wode&quot; /&gt;&#125;\n/&gt;查看浏览器展示效果如下：\n\n底部导航栏的显示隐藏我们在之前引入 NavBar 的代码中，将 showNav 属性写死为 true。此时，我们需要将其盘活，打开 App.jsx，添加如下代码：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\nimport &#123;\n  BrowserRouter as Router,\n  Routes,\n  Route,\n  useLocation,\n&#125; from &quot;react-router-dom&quot;;\n\nimport NavBar from &quot;@/components/NavBar&quot;;\n\nimport &#123; ConfigProvider &#125; from &quot;zarm&quot;;\n\nimport routes from &quot;@/router&quot;;\nfunction App() &#123;\n  const location = useLocation(); // 拿到 location 实例\n  const &#123; pathname &#125; = location; // 获取当前路径\n  const needNav = [&quot;/&quot;, &quot;/data&quot;, &quot;/user&quot;]; // 需要底部导航栏的路径\n  const [showNav, setShowNav] = useState(false); // 是否展示 Nav\n  useEffect(() =&gt; &#123;\n    setShowNav(needNav.includes(pathname));\n  &#125;, [pathname]); // [] 内的参数若是变化，便会执行上述回调函数=\n  return (\n    &lt;Router&gt;\n      &lt;ConfigProvider primaryColor=&#123;&quot;#007fff&quot;&#125;&gt;\n        &lt;Switch&gt;\n          &#123;routes.map((route) =&gt; (\n            &lt;Route exact key=&#123;route.path&#125; path=&#123;route.path&#125;&gt;\n              &lt;route.component /&gt;\n            &lt;/Route&gt;\n          ))&#125;\n        &lt;/Switch&gt;\n      &lt;/ConfigProvider&gt;\n      &lt;NavBar showNav=&#123;true&#125; /&gt;\n    &lt;/Router&gt;\n  );\n&#125;\n\nexport default App;当你刷新浏览器，控制台应该会报下面的错误：\n\n执行 useLocation 时，报错 location of undefined。这是因为想要在函数组件内执行 useLocation，该组件必须被 Router 高阶组件包裹，我们做如下改动，将 App.jsx 的 Router 组件，前移到 main.jsx 内，如下：\n\n逻辑分析：\n我们拿到 pathname，将其设置为 useEffect 钩子函数的第二个参数，监听它的变化，一旦 pathname 变化，便会触发回调函数执行 setShowNav(needNav.includes(pathname))，结果会传递给 NavBar 组件，从而控制组件的显示隐藏。needNav 为需要底部导航的路径值。\n我们不妨做个测试，在 container 目录下新建一个测试页面组件 Detail，并且添加路由配置。\n别忘记把组件属性修改成动态变量：\njs&lt;NavBar showNav=&#123;showNav&#125; /&gt;查看浏览器的展示效果：\n\n总结导航栏可以用在很多地方，映射到 PC 网页就是左侧侧边导航，道理都是相通的。移动端放在下面控制，PC 端放在左边或者右边控制罢了。所以再次强调不要学完了一个知识点，就思维定势地认为只能用在某一个需求上，能做到融会贯通，才是判断一个好程序员的标准。\n","slug":"113-react","date":"2023-01-05T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"64c2762fa9fc2624093936d7950b6579","title":"112、稀土掘金小册-记账本（三）react vite2.0 ZarmUI搭建开发环境","content":"\n\n前言React 技术栈的 UI 组件库相比 Vue，会少一些。我们耳熟能详的便是 Antd，但是它针对的是 PC 端的，我们的项目目前是一个 H5 的网页（不排除后期做一个 PC 端）。所以我选择了 Zarm。\n这里再次强调，不是 Zarm 就比别的移动端组件库好，只是目前我开发的这款记账本项目，Zarm 比较适合。\n知识点\n构架工具 Vite。\n前端框架 React 和路由 react-router-dom。\nCSS 预加载器 Less。\nHTTP 请求库 axios。\n移动端分辨率适配 flexible。\n跨域代理。\n\n初始化 Vite + React 项目Vite 官方提供两种初始化项目的方式，一种是如下所示，可以自由选择需要的前端框架。\nbashnpm init @vitejs/app另一种则是直接用官方提供的模板，一键生成项目：\nbash# npm 6.x\nnpm init @vitejs/app react-vite-h5 --template react\n\n# npm 7+, 需要额外的双横线：\nnpm init @vitejs/app react-vite-h5 -- --template react我们使用第二种方式初始化项目，如下所示：\n\n安装完 node_modules 之后，通过 npm run dev 启动项目，如下所示代表成功了：\n\n引入路由插件 react-router-dom没有路由的项目，那就不是一个完整项目，而是一个页面而已。真实项目都是存在各种模块之间的切换，各个模块的功能组合在一起才能叫做一个项目。\n首选安装 react-router-dom，指令如下：\nbashnpm i react-router-dom -S在项目 src 目录下新增 container 目录用于放置页面组件，再在 container 下新增两个目录分别是 Index 和 About ，添加如下内容：\njs// Index/index.jsx\nimport React from &#39;react&#39;\n\nexport default function Index() &#123;\n  return &lt;div&gt;\n    Index\n  &lt;/div&gt;\n&#125;\n\n// About/index.jsx\nimport React from &#39;react&#39;\n\nexport default function About() &#123;\n  return &lt;div&gt;\n    About\n  &lt;/div&gt;\n&#125;再来新建 src/router/index.js 配置路由数组，添加如下内容：\njs// router/index.js\nimport Index from &quot;../container/Index&quot;;\nimport About from &quot;../container/About&quot;;\n\nconst routes = [\n  &#123;\n    path: &quot;/&quot;,\n    component: Index,\n  &#125;,\n  &#123;\n    path: &quot;/about&quot;,\n    component: About,\n  &#125;,\n];\n\nexport default routes;在 App.jsx 引入路由配置，实现切换浏览器路径，显示相应的组件：\njs// App.jsx\nimport React, &#123; useState &#125; from &quot;react&quot;;\nimport &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;\nimport routes from &quot;../src/router&quot;;\nfunction App() &#123;\n  return (\n    &lt;&gt;\n      &lt;Routes&gt;\n        &#123;routes.map((route) =&gt; (\n          &lt;Route\n            exact\n            key=&#123;route.path&#125;\n            path=&#123;route.path&#125;\n            element=&#123;&lt;route.component /&gt;&#125;\n          /&gt;\n        ))&#125;\n      &lt;/Routes&gt;\n    &lt;/&gt;\n  );\n&#125;\n\nexport default App;启动项目 npm run dev，如下图所示：\n\n引入 Zarm UI 组件库首先通过如下指令安装它：\nbashnpm install zarm -S修改 App.jsx 的代码，全局引入样式和中文包：\njsimport React, &#123; useState &#125; from &quot;react&quot;;\nimport &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;\n\nimport &#123; ConfigProvider &#125; from &quot;zarm&quot;;\nimport zhCN from &quot;zarm/lib/config-provider/locale/zh_CN&quot;;\nimport &quot;zarm/dist/zarm.css&quot;;\n\nimport routes from &quot;../src/router&quot;;\nfunction App() &#123;\n  return (\n    &lt;Router&gt;\n      &lt;ConfigProvider primaryColor=&#123;&quot;#007fff&quot;&#125; locale=&#123;zhCN&#125;&gt;\n        &lt;&gt;\n          &lt;Routes&gt;\n            &#123;routes.map((route) =&gt; (\n              &lt;Route\n                exact\n                key=&#123;route.path&#125;\n                path=&#123;route.path&#125;\n                element=&#123;&lt;route.component /&gt;&#125;\n              /&gt;\n            ))&#125;\n          &lt;/Routes&gt;\n        &lt;/&gt;\n      &lt;/ConfigProvider&gt;\n    &lt;/Router&gt;\n  );\n&#125;\n\nexport default App;此时 zarm 的样式，已经全局引入了，我们先查看在 /container/Index/index.jsx 添加一个按钮是否生效：\njs// Index/index.jsx\nimport React from &quot;react&quot;;\nimport &#123; Button &#125; from &quot;zarm&quot;;\n\nexport default function Index() &#123;\n  return (\n    &lt;div&gt;\n      Index\n      &lt;Button theme=&quot;primary&quot;&gt;按钮&lt;/Button&gt;\n    &lt;/div&gt;\n  );\n&#125;重启项目，如下所示：\n\n此时恭喜你 🎉，你已经成功将组件引入项目中。\n小优化组件虽然引入成功了，但是有一个问题，我不希望所有的组件样式都被一次性的引入，因为这样代码会比较冗余，我只需要引入我使用到的组件样式，实现「按需引入」。\n我们先看看，就目前现在这个情况，打完包之后，静态资源有多大。运行指令 npm run build ，如下所示：\n\n腚眼一看，全局引入样式的形式，直接打完包， css 静态资源就 168.22kb 了，我们尝试配置「按需引入」。\n首先我们安装一个插件：\nbashnpm i vite-plugin-style-import -D然后在 vite.config.js 配置文件内添加如下内容：\n\n\n打完包之后，肉眼可见，css 提及从 168.22kb -&gt; 35.22kb。这种方式也是前端性能优化的其中一种。\n配置 CSS 预处理器 Less项目中采用的 Less 作为 CSS 预处理器，它能设置变量以及一些嵌套逻辑，便于项目的样式编写。\n安装 less 插件包，npm i less -D，因为上述配置我们使用的是 less，并且我们需要配置 javascriptEnabled 为 true，支持 less 内联 JS。\n修改 vite.config.js，如下：\njs&#123;\n  plugins: [...]\n  css: &#123;\n    modules: &#123;\n      localsConvention: &#39;dashesOnly&#39;\n    &#125;,\n    preprocessorOptions: &#123;\n      less: &#123;\n        // 支持内联 JavaScript\n        javascriptEnabled: true,\n      &#125;\n    &#125;\n  &#125;,\n&#125;并且添加了 css modules 配置，这样我们就不用担心在项目中，自定义的样式重名的风险，我们尝试在 /container/Index 目录下添加样式文件 style.module.less，并且在 /container/Index/index.jsx 中引入它，如下：\ncss.index &#123;\n  span &#123;\n    color: red;\n  &#125;\n&#125;\n// Index/index.jsx\nimport React from &#39;react&#39;\nimport &#123; Button &#125; from &#39;zarm&#39;\n\nimport s from &#39;./style.module.less&#39;\n\nexport default function Index() &#123;\n  return &lt;div className=&#123;s.index&#125;&gt;\n    &lt;span&gt;样式&lt;/span&gt;\n    &lt;Button theme=&#39;primary&#39;&gt;按钮&lt;/Button&gt;\n  &lt;/div&gt;\n&#125;\n此时我只能再次恭喜你，Less 成功被引入。\n移动端项目适配 rem移动端项目，肯定是需要适配各种分辨率屏幕的，就比如你 10px 的宽度，在每个屏幕上的占比都是不一样的，我们这里不对分辨率做深入的探讨，我们目前的首要目的是完成项目移动端的分辨率适配。\n首先我们需要安装 lib-flexible：\nbashnpm i lib-flexible -S并在 main.jsx 中引入它：\njsimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport &quot;lib-flexible/flexible&quot;;\nimport &quot;./index.css&quot;;\nimport App from &quot;./App&quot;;\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;App /&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById(&quot;root&quot;)\n);然后再安装一个 postcss-pxtorem，它的作用是在你编写完 css 后，将你的单位自动转化为 rem 单位。\nbashnpm i postcss-pxtorem在项目根目录新建 postcss.config.js：\njs// postcss.config.js\n// 用 vite 创建项目，配置 postcss 需要使用 post.config.js，之前使用的 .postcssrc.js 已经被抛弃\n// 具体配置可以去 postcss-pxtorem 仓库看看文档\nmodule.exports = &#123;\n  plugins: [\n    require(&quot;postcss-pxtorem&quot;)(&#123;\n      rootValue: 37.5,\n      propList: [&quot;*&quot;],\n      selectorBlackList: [&quot;.norem&quot;], // 过滤掉.norem-开头的class，不进行rem转换\n    &#125;),\n  ],\n&#125;;修改 Index/style.module.less：\ncss.index &#123;\n  width: 200px;\n  height: 200px;\n  background: green;\n  span &#123;\n    color: red;\n  &#125;\n&#125;重启项目 npm run dev，如下所示：\n\n可以看到，200px 已经被转化为 5.3333rem，我们设置的 rootValue 是 37.5，你可以换算一下 5.33333 * 37.5 = 200。\n我们目前把浏览器调整成的是 iphone 6，html 的 font-size 为 37.5px，当我们手机变成其他尺寸的时候，这个 font-size 的值也会变化，这是 flexible 起到的作用，动态的变化 html 的 font-size 的值，从而让 1rem 所对应的 px 值一直都是动态适应变化的。\n当我切换成 iphone 6 plus 时：\n\n变成了 41.4px，而相应的，我们 div 还是 5.33333rem，所以此时 div 宽度就变大了，但是手机的屏幕宽度也变大了，这就不会影响视觉上的比例误差太大。\n二次封装 axios说到这里，那就要涉及到项目的服务端 API 接口，我们在前面的章节里，已经完成了服务端的代码编写，但是此时我们的服务端项目是跑在 http://127.0.0.1/7001 端口上的。\n此时你是可以在后续的请求中，使用 http://127.0.0.1/7001 作为项目的 baseURL。但是照顾到有些同学没有启动服务端项目，直奔前端项目来的。这里我已经将接口提前部署到了线上环境，供大家使用。接口地址是 http://api.chennick.wang。\n所以在后续的封装过程中，我会提醒大家两种使用。\n首先我们安装 npm i axios -S，在 src 目录下新建 utils 目录，并新建 axios.js 脚本：\njs// src/utils/axios.js\nimport axios from &quot;axios&quot;;\nimport &#123; Toast &#125; from &quot;zarm&quot;;\n\nconst MODE = import.meta.env.MODE; // 环境变量\n\naxios.defaults.baseURL =\n  MODE == &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;\naxios.defaults.withCredentials = true;\naxios.defaults.headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;\naxios.defaults.headers[&quot;Authorization&quot;] = `$&#123;\n  localStorage.getItem(&quot;token&quot;) || null\n&#125;`;\naxios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json&quot;;\n\naxios.interceptors.response.use((res) =&gt; &#123;\n  if (typeof res.data !== &quot;object&quot;) &#123;\n    Toast.show(&quot;服务端异常！&quot;);\n    return Promise.reject(res);\n  &#125;\n  if (res.data.code != 200) &#123;\n    if (res.data.msg) Toast.show(res.data.msg);\n    if (res.data.code == 401) &#123;\n      window.location.href = &quot;/login&quot;;\n    &#125;\n    return Promise.reject(res.data);\n  &#125;\n\n  return res.data;\n&#125;);\n\nexport default axios;我逐行为大家分析上述代码的情况情况。\njsconst MODE = import.meta.env.MODE;MODE 是一个环境变量，通过 Vite 构建的项目中，环境变量在项目中，可以通过 import.meta.env.MODE 获取，环境变量的作用就是判断当前代码运行在开发环境还是生产环境。\njsaxios.defaults.baseURL = &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;baseURL 是 axios 的配置项，它的作用就是设置请求的基础路径，后续我们会在项目实战中有所体现。配置基础路径的好处就是，当请求地址修改的时候，可以在此统一配置。\njsaxios.defaults.headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;\naxios.defaults.headers[&quot;Authorization&quot;] = `$&#123;\n  localStorage.getItem(&quot;token&quot;) || null\n&#125;`;\naxios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json&quot;;上述三个配置是用于请求头的设置，Authorization 是我们在服务端鉴权的时候用到的，我们在前端设置好 token，服务端通过获取请求头中的 token 去验证每一次请求是否合法。\n最后一行是配置 post 请求是，使用的请求体，这里默认设置成 application/json 的形式。\njsaxios.interceptors.response.use((res) =&gt; &#123;\n  if (typeof res.data !== &quot;object&quot;) &#123;\n    Toast.show(&quot;服务端异常！&quot;);\n    return Promise.reject(res);\n  &#125;\n  if (res.data.code != 200) &#123;\n    if (res.data.msg) Toast.show(res.data.msg);\n    if (res.data.code == 401) &#123;\n      window.location.href = &quot;/login&quot;;\n    &#125;\n    return Promise.reject(res.data);\n  &#125;\n\n  return res.data;\n&#125;);interceptors 为拦截器，拦截器的作用是帮你拦截每一次请求，你可以在回调函数中做一些“手脚”，再将数据 return 回去。上述代码就是拦截了响应内容，统一判断请求内容，如果非 200，则提示错误信息，401 的话，就是没有登录的用户，默认跳到 /login 页面。如果是正常的响应，则 retrun res.data。\n最后我们将这个 axios 抛出，供页面组件请求使用。\n在 utils 下新建一个 index.js，内容如下：\njsimport axios from &quot;./axios&quot;;\n\nexport const get = axios.get;\n\nexport const post = axios.post;这样获取的时候，能少写几行代码，能少写点就少写点。\n代理配置baseURL 为什么在 development 环境下，用 /api 这样的请求地址。其实它就是为了代理请求而配置的。\n这样配置完后，在请求接口的时候，请求地址大概长这样：\njs/api/userInfo于是我们需要去配置代理，打开 vite.config.js，添加如下代码：\njsserver: &#123;\n  proxy: &#123;\n    &#39;/api&#39;: &#123;\n      // 当遇到 /api 路径时，将其转换成 target 的值\n      target: &#39;http://api.chennick.wang/api/&#39;,\n      changeOrigin: true,\n      rewrite: path =&gt; path.replace(/^\\/api/, &#39;&#39;) // 将 /api 重写为空\n    &#125;\n  &#125;\n&#125;这样配置完之后，开发环境下，/api/userInfo -&gt; http://api.chennick.wang/api/userInfo。这样就解决了大家老大难的跨域问题。\n但是其实服务端只要设置好白名单，就不会有这样那样的跨域问题。\nresolve.alias 别名设置这里我们必须得设置好别名，否则在页面中，你会写出很长一串类似这样的代码 ../../../。\n打开 vite.config.js，添加配置如下：\njs...\nimport path from &#39;path&#39;\n\nexport default defineConfig(&#123;\n  ...\n  resolve: &#123;\n    alias: &#123;\n      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;), // src 路径\n      &#39;utils&#39;: path.resolve(__dirname, &#39;src/utils&#39;) // src 路径\n    &#125;\n  &#125;,\n&#125;)此时我们便可以修改之前的代码如下：\nrouter&#x2F;index.js\njsimport Index from &quot;@/container/Index&quot;;\nimport About from &quot;@/container/About&quot;;App.jsx\njsimport routes from &quot;@/router&quot;;总结行文至此，我们的基础开发环境已经搭建完毕，涉及构建工具、前端框架、UI 组件库、HTTP 请求库、CSS 预加载器、跨域代理、移动端分辨率适配，这些知识都是一个合格的前端工程师应该具备的，所以请大家加油，将他们都通通拿下。\n","slug":"112-react","date":"2023-01-04T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"09473714551f922240c448f4bd63c8bd","title":"111、稀土掘金小册-记账本（二）react vite","content":"\n\n前言我还是那句话，工具永远是服务于需求的。纵观整个前端生态的项目构建工具，有服务于 React 生态的 create-react-app、umi、Next.js 等。服务于 Vue 生态的 Vue CLI、Vite、Nuxt.js 等。它们都是耳熟能详的团队和大佬，为了解决各自需求而研发出来的前端构建工具。而我们要做的其实就是根据项目的需求，进行合理的选择和学习。说白了，在你没有决定权的时候，公司用什么，你就学什么。在你有话语权，能自己抉择的时候，哪个让你开发起来比较舒服，就用哪个。\n这些构建工具中，有一个比较特殊，那就是 Vite，它是尤雨溪在发布 Vue 3.0 时，同步推出的一款前端构建工具。它不光服务于 Vue，同时也对其他的框架如 React、Svelte、Preact 都有一定的支持，我们本着学新不学旧的理念，在项目中引进了 Vite 作为构建工具。\n在开始使用 Vite 之前，我们来认识一下它。\n知识点\nVite 是什么。\nVite 与 Webpack 相比优势在哪里。\nVite 的构建原理。\n\nVite 是什么我们引用官方的一句话来介绍它，“下一代前端开发与构建工具”。\n它有以下几个特点：\n1、 快速启动，Vite 会在本地启动一个开发服务器，来管理开发环境的资源请求。\n2、相比 Webpack 的开发环境打包构建，它在开发环境下是无需打包的，热更新相比 Webpack 会快很多。\n3、原生 ES Module，要什么就当场给你什么。而 Webpack 则是先将资源构建好之后，再根据你的需要，分配给你想要的资源。\n尤雨溪在发布 Vite 前，发过这么一条微博。\n\n从话语间可以看出，尤雨溪团队对该打包工具也是报以厚望，所以这里大家可以不必担心后续它们会放弃维护这个项目，当然也不能打包票。\nVite 与 Webpack 相比优势在哪里接下来我们来聊聊，为什么说它是下一代前端开发与构建工具。是不是当代构建工具出了什么问题？\n我们知道当代的前端构建工具有很多，比较受欢迎的有 Webpack、Rollup、Parcel等，绝大多数脚手架工具都是使用 Webpack 作为构建工具，如 Vue-CLI。\n在利用 Webpack 作为构建工具时，开发过程中，每次修改代码，都会导致重新编译，随着项目代码量的增多，热更新的速度也随之变慢，甚至要几秒钟才能看到视图的更新。\n生产环境下，它将各个模块之间通过编码的方式联系在一起，最终生成一个庞大的 bundle 文件。\n导致这些问题出现的原因，有以下几点：\n1、HTTP 1.1 时代，各个浏览器资源请求并发是有上限的（如谷歌浏览器为 6 个，这导致你必须要减少资源请求数）。\n2、浏览器并不支持 CommonJS 模块化系统（它不能直接运行在浏览器环境下，它是 Node 提出的模块化规范，所以需要经过 Webpack 的打包，编译成浏览器可识别的 JS 脚本）\n3、模块与模块之间的依赖顺序和管理问题（文件依赖层级越多，静态资源也就变得越多，如果一个资源有 100 个依赖关系，可能需要加载 100 个网络请求，这对生产环境可能是灾难，所以在生产环境最终会打包成一个 bundle 脚本，会提前进行资源按需加载的配置。）\n那么为什么现在又出现了不打包的构建趋势？1、工程越来越庞大，热更新变得缓慢，十分影响开发体验。推动着我们不断地去创新，不断地尝试着去突破瓶颈。\n2、各大浏览器已经开始慢慢的支持原生 ES Module (谷歌、火狐、Safari、Edge 的最新版本，都已支持。这让我们看到了希望)。\n3、HTTP 2.0 采用的多路复用。不用太担心请求并发量的问题。\n4、越来越多的 npm 包开始采用了原生 ESM 的开发形式。虽然还有很多包不支持，但是我相信这将会是趋势。\n我们通过表格的形式，对比一下 bundle 和 bundleless 的区别。\n\nVite 构建原理众所周知，Vite 的生产模式和开发模式是不同的概念。我们先聊聊，Vite 的开发模式。\n首先要明确一点，Vite 在开发模式下，有一个 依赖预构建 的概念。\n什么是依赖预构建在 Vite 启动开发服务器之后，它将第三方依赖的多个静态资源整合为一个，比如 lodash、qs、axios 等这类资源包，存入 ·node_modules&#x2F;.vite 文件下。\n为什么需要依赖预构建如果直接采用 ES Module 的形式开发代码，会产生一大串依赖，就好像俄罗斯套娃一样，一层一层的嵌套，在浏览器资源有限的情况下，同时请求大量的静态资源，会造成浏览器的卡顿，并且资源响应的时间也会变慢。\n我们先不通过 Vite，而是手动搭建原生 ES Module 开发形式，通过引入 lodash-es 包，实现一个数组去重的小例子，来详细分析为什么需要依赖预构建。\n新建 test1 文件夹，通过 npm init -y 初始化了一个前端工程：\n\n手动新建 index.html，通过 script 标签，引入 main.js。这里注意，需要将 type 属性设置为 module，这样才能支持 ES Module 模块化开发。\n通过 npm 安装 lodash-es，这里我们之所以不使用 lodash，是因为 lodash 不是通过 ES Module 形式开发的，直接通过相对路径引入会报错，需要通过 Webpack 打包构建。\nbashnpm i lodash-es新建 main.js 添加去重逻辑：\njsimport uniq from &quot;./node_modules/lodash-es/uniq.js&quot;;\n\nconst arr = [1, 2, 3, 3, 4];\n\nconsole.log(uniq(arr));这里我们采用 VSCode 的插件，Live Server，来启动项目。\n\n安装完之后，在项目中双击 index.html，找到右下角的 「Go Live」，如下所示：\n\n点击后，自动启动一个 Web 服务，浏览器自动打开，如下所示：\n\n结果正确，数组中的 3 被去除了，接下来关键的一个点，我们点击 Network 查看，资源引入情况：\n\n我们只是获取去重方法，却意外引入了 59 资源，这是为什么呢？\n我们先查看 main.js 内的代码，如下所示：\n\n代码中只有在首行通过 import 引入了 ./node_modules/lodash-es/uniq.js，所以 uniq.js 被作为资源引入进来，我们再看 uniq.js 的情况：\n\nuniq.js 中，首行通过 import 引入了 _baseUniq.js，我们继续：\n\n_baseUniq.js 中，引入了上图箭头中的一些脚本，不用往下看，我盲猜这种俄罗斯套娃的模式，会一直引用到 uniq.js 相关的所有脚本代码。\n这只是一个 uniq 方法，足足就引入了 59 个资源，这仿佛是在军训浏览器，也就是谷歌能跟它博弈几个回合，引入的包再多几个，我估计也是顶不住的。\n所以这时候 Vite 便引入了「依赖预构建」的概念。\n依赖现预构建浅析同样的，再通过 Vite 构建出一个 React 项目，去实现上述逻辑，我们观察 Vite 是怎么作的。\n首先通过 Vite 指令生成项目：\nbashnpm init @vitejs/app test2 --template react并安装 lodash-es，修改入口脚本 main.jsx：\njsimport uniq from &quot;lodash-es/uniq.js&quot;;\n\nconst arr = [1, 2, 3, 3, 4];\n\nconsole.log(uniq(arr));我们观察浏览器的 Network，如下所示：\n\n注意上图，执行 npm run dev 后，脚本中引用 lodash-es/uniq 的路径是在 /node_modules/.vite 文件夹下，并且左下角的请求资源数，也没有我们之前原生 ES Module 时的多，少了足足 3&#x2F;4 还多。\n再观察文件目录：\n\nlodash-es/uniq 已经被 Vite 提前预编译到了 .vite 文件夹下，这样代码中直接去这个文件夹拿现成的包，就不必再递归地去加载很多静态资源脚本。\n总结本章节，通过实例分析，对 Vite 有了初步的了解。那么下一章节，我将带大家通过 Vite 去搭建一个 React 的完整开发环境。\n","slug":"111-react","date":"2023-01-03T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"1345bfb96de851cf82279abce3ebd565","title":"110、稀土掘金小册-记账本（一） react hooks","content":"React 早期的写法以 Class 类组件为主，附带一些纯用于展示的函数组件，但是函数组件是不能控制自身的状态的。\n直到 16.8 版本出来之后，引入了全新的 Hooks 写法，这让之前的类写法就显得 比较累赘，函数组件的写法开始流行起来。函数组件引入了多种钩子函数如 useEffect、useState、useRef、useCallback、useMemo、useReducer 等等，通过这些钩子函数来管理函数组件的各自状态。\n\n\n正文本章节我会通过一个请求，带大家入门整个 React Hook 知识体系。首先我们需要创建一个空项目，由于本实验采用的是 Vite 2.0 作为脚手架工具，所以我们的 Node 版本必须要在 12.0.0 以上，目前我的版本是 12.6.0。\n我们通过指令新建一个联手项目，如下所示：\nbash# npm 6.x\nnpm init @vitejs/app hooks-demo --template react\n\n# npm 7+, 需要额外的双横线：\nnpm init @vitejs/app hooks-demo -- --template react\n\n# yarn\nyarn create @vitejs/app hooks-demo --template react根据你的需求，选择上述三个其中一个。新建之后项目目录如下所示：\n\nbashnpm install\nnpm run dev如下所示：\n\n看到如上述所示代表项目已经启动成功了。\nuseState接下来我们清空 App.jsx，添加如下代码：\njsimport React, &#123; useState &#125; from &quot;react&quot;;\n\nfunction App() &#123;\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &#123;data.map((item, index) =&gt; (\n        &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;\n      ))&#125;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;函数内声明变量，可以通过 useState 方法，它接受一个参数，可以为默认值，也可以为一个函数。上述我们先分析默认值的情况，默认给一个数组 [1, 2, 3, 4, 5]，data 参数便可以直接在 JSX 模板中使用。\nuseEffect此时，我们通过 useEffect 副作用，请求一个接口数据，如下所示：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n// 模拟数据接口，3 秒钟返回数据。\nconst getList = () =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve([6, 7, 8, 9, 10]);\n    &#125;, 3000);\n  &#125;);\n&#125;;\n\nfunction App() &#123;\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n\n  useEffect(() =&gt; &#123;\n    (async () =&gt; &#123;\n      const data = await getList();\n      console.log(&quot;data&quot;, data);\n      setData(data);\n    &#125;)();\n  &#125;);\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &#123;data.map((item, index) =&gt; (\n        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;\n      ))&#125;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;函数组件默认进来之后，会执行 useEffect 中的回调函数，但是当 setData 执行之后，App 组件再次刷新，刷新之后会再次执行 useEffect 的回调函数，这便会形成一个可怕的死循环，回调函数会一直被这样执行下去。\n\n所以这里引出 useEffect 的第二个参数。它是一个数组，数组内接收回调函数内使用到的状态参数，一旦在组件内改变了状态参数，则会触发副作用 useEffect 的回调函数执行。\n所以我们如果传一个空数组 []，则该副作用只会在组件渲染的时候，执行一次，如下所示：\njsuseEffect(() =&gt; &#123;\n  (async () =&gt; &#123;\n    const data = await getList();\n    console.log(&quot;data&quot;, data);\n    setData(data);\n  &#125;)();\n&#125;, []);\n执行一次之后，副作用不再被触发。\n此时我们需要给请求一个 query 参数，如下所示：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nconst getList = (query) =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;query&quot;, query);\n      resolve([6, 7, 8, 9, 10]);\n    &#125;, 3000);\n  &#125;);\n&#125;;\n\nfunction App() &#123;\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  const [query, setQuery] = useState(&quot;&quot;);\n\n  useEffect(() =&gt; &#123;\n    (async () =&gt; &#123;\n      const data = await getList(query);\n      console.log(&quot;data&quot;, data);\n      setData(data);\n    &#125;)();\n  &#125;, [query]);\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &#123;data.map((item, index) =&gt; (\n        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;\n      ))&#125;\n      &lt;input\n        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入搜索值&quot;\n      /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;此时我们改变 query 的值，副作用函数便会被执行，如下所示：\n\n所以，如果你的接口有查询参数，可以将参数设置在 useEffect 的第二个参数的数组值中，这样改变查询变量的时候，副作用便会再次触发执行，相应的函数也会重新带着最新的参数，获取接口数据。\n自定义 Hook我们可以将上述的请求，抽离成一个自定义 hook，方便在多个地方调用，新建 useApi.js 如下所示：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n// 模拟请求\nconst getList = (query) =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;query&quot;, query);\n      resolve([6, 7, 8, 9, 10]);\n    &#125;, 3000);\n  &#125;);\n&#125;;\n// 自定义 hook\nconst useApi = () =&gt; &#123;\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  const [query, setQuery] = useState(&quot;&quot;);\n\n  useEffect(() =&gt; &#123;\n    (async () =&gt; &#123;\n      const data = await getList();\n      console.log(&quot;data&quot;, data);\n      setData(data);\n    &#125;)();\n  &#125;, [query]);\n\n  return [&#123; data &#125;, setQuery];\n&#125;;\n\nexport default useApi;如上述所示，最终将 data 数据，和设置请求参数的方法抛出，在 App.jsx 中做如下改动：\njsimport React from &quot;react&quot;;\nimport useApi from &quot;./useApi&quot;;\n\nfunction App() &#123;\n  const [&#123; data &#125;, setQuery] = useApi();\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &#123;data.map((item, index) =&gt; (\n        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;\n      ))&#125;\n      &lt;input\n        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入搜索值&quot;\n      /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;我们查看浏览器展示结果：\n\n上述这类自定义 Hook 的使用，在开发中也非常常见，比如有一个请求公共数据的接口，在多个页面中被重复使用，你便可通过自定义 Hook 的形式，将请求逻辑提取出来公用，这也是之前 Class 类组件所不能做到的。\nuseMemo我们修改 App.jsx，在内部新增一个子组件，子组件接收父组件传进来的一个对象，作为子组件的 useEffect 的第二个依赖参数。\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nfunction Child(&#123; data &#125;) &#123;\n  useEffect(() =&gt; &#123;\n    console.log(&quot;查询条件：&quot;, data);\n  &#125;, [data]);\n\n  return &lt;div&gt;子组件&lt;/div&gt;;\n&#125;\n\nfunction App() &#123;\n  const [name, setName] = useState(&quot;&quot;);\n  const [phone, setPhone] = useState(&quot;&quot;);\n  const [kw, setKw] = useState(&quot;&quot;);\n\n  const data = &#123;\n    name,\n    phone,\n  &#125;;\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入姓名&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入电话&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入关键词&quot;\n      /&gt;\n      &lt;Child data=&#123;data&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;当我们修改姓名和电话的时候，观察子组件是否监听到依赖的变化，执行 useEffect 内的回调函数。\n\n此时，上述的结果是我们预期的，我们只监听了 name 和 phone 两个参数，但是我们修改关键词输入框，会得到下面的结果。\n\n子组件并没有监听 kw 的变化，但是结果却是子组件也被触发渲染了。原因其实是我们在父组件重新 setKw 之后，data 值和未作修改 kw 前的值已经不一样了。你可能会说，data 的值并没有变化，为什么说它已经不一样了呢？详细的分析我们放在后续部分，我们此时可以通过 useMemo 将 data 包装一下，告诉 data 它需要监听的值。\njsimport React, &#123; useEffect, useState, useMemo &#125; from &quot;react&quot;;\n\nfunction Child(&#123; data &#125;) &#123;\n  useEffect(() =&gt; &#123;\n    console.log(&quot;查询条件：&quot;, data);\n  &#125;, [data]);\n\n  return &lt;div&gt;子组件&lt;/div&gt;;\n&#125;\n\nfunction App() &#123;\n  const [name, setName] = useState(&quot;&quot;);\n  const [phone, setPhone] = useState(&quot;&quot;);\n  const [kw, setKw] = useState(&quot;&quot;);\n\n  const data = useMemo(\n    () =&gt; (&#123;\n      name,\n      phone,\n    &#125;),\n    [name, phone]\n  );\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入姓名&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入电话&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入关键词&quot;\n      /&gt;\n      &lt;Child data=&#123;data&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;效果如下：\n\n这便是 useMemo 的作用，它相当于把父组件需要传递的参数做了一个标记，无论父组件其他状态更新任何值，都不会影响要传递给子组件的对象。\nuseCallback同理，useCallback 也是和 useMemo 有类似的功能，比如我们传递一个函数给子组件，如下所示：\njsimport React, &#123; useEffect, useState, useCallback &#125; from &quot;react&quot;;\n\nfunction Child(&#123; callback &#125;) &#123;\n  useEffect(() =&gt; &#123;\n    callback();\n  &#125;, [callback]);\n\n  return &lt;div&gt;子组件&lt;/div&gt;;\n&#125;\n\nfunction App() &#123;\n  const [name, setName] = useState(&quot;&quot;);\n  const [phone, setPhone] = useState(&quot;&quot;);\n  const [kw, setKw] = useState(&quot;&quot;);\n\n  const callback = () =&gt; &#123;\n    console.log(&quot;我是callback&quot;);\n  &#125;;\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入姓名&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入电话&quot;\n      /&gt;\n      &lt;input\n        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;\n        type=&quot;text&quot;\n        placeholder=&quot;请输入关键词&quot;\n      /&gt;\n      &lt;Child callback=&#123;callback&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;当我们修改任何状态值，都会触发子组件的回调函数执行，但是 callback 没有作任何变化。\n\n此时，我们给要传递的函数，包裹一层 useCallback，如下所示：\njsconst callback = useCallback(() =&gt; &#123;\n  console.log(&quot;我是callback&quot;);\n&#125;, []);无论修改其他任何属性，都不会触发子组件的副作用：\n\n\n\n\n\n\n\n\n\n\nuseCallback 的第二个参数同 useEffect 和 useMemo 的第二个参数，它是用于监听你需要监听的变量，如在数组内添加 name、phone、kw 等参数，当改变其中有个，都会触发子组件副作用的执行。\n所以，useMemo 和 useCallback，都能为「重复渲染」这个问题，提供很好的帮助。\n重新认识 useEffect上述很多现象，都是因为你没有很好地去理解 React Hooks 函数组件写法的渲染机制。通过一个小例子，我们来重新认识 useEffect。\n我们将上述 App.jsx 作如下修改：\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nfunction App() &#123;\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + count);\n    &#125;, 3000);\n  &#125;;\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;\n      &lt;button onClick=&#123;handleClick&#125;&gt;展示点击次数&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;我们作下列几个动作：\n1、点击增加按钮两次，将 count 增加到 2。\n2、点击「展示点击次数」。\n3、在 console.log 执行之前，也就是 3 秒内，再次点击新增按钮 2 次，将 count 增加到 4。\n按照正常的思路，浏览器应该打印出 点击次数: 4，我们来查看浏览器的展示效果：\n\n点击「展示点击次数」按钮，3 秒后，我们看到的结果是 点击次数: 2，这与我们的预期有出入。\n函数组件 App，在每一次渲染都会被调用，而每一次调用都会形成一个独立的上下文，可以理解成一个快照。每一次渲染形成的快照，都是互相独立的。\n默认进来的时候，形成一个快照，此时 count 为 0；当我们点击新增按钮第一次，执行 setCount，函数组件被刷新一次，此时的快照中，count 为 1；再次点击按钮，再次生成快照，此时的 count 为 2，此时点击 「展示点击次数」按钮，在这份快照中，我们的 count 参数就是 2。所以我们后面无论怎么新增 count，最终输出的结果 count 就是 2。\n我们用一份伪代码来解释，大致如下：\njs// 默认初始化\nfunction App() &#123;\n  const count = 0; // useState 返回默认值\n  // ...\n  function handleClick() &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + count);\n    &#125;, 3000);\n  &#125;\n  // ...\n&#125;\n\n// 第一次点击\nfunction App() &#123;\n  const count = 1; // useState 返回值\n  // ...\n  function handleClick() &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + count);\n    &#125;, 3000);\n  &#125;\n  // ...\n&#125;\n\n// 第二次点击\nfunction App() &#123;\n  const count = 2; // useState 返回值\n  // ...\n  function handleAlertClick() &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + count);\n    &#125;, 3000);\n  &#125;\n  // ...\n&#125;上述代码中，第二次点击的快照中，console.log(&#39;点击次数: &#39; + count); 取的便是 const count = 2。\n同理，我们可以直到，每次渲染函数组件时，useEffect 都是新的，都是不一样的。我们对上面的写法稍作改动。\njsimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nfunction App() &#123;\n  const [count, setCount] = useState(0);\n\n  useEffect(() =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + count);\n    &#125;, 3000);\n  &#125;);\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nexport default App;\n每一次点击，都会重新执行 useEffect 内的回调，并且 count 值也是当时的快照的一个常量值。\n这和之前的类组件是不同的，我们改成类组件的实现形式如下：\njsimport React from &quot;react&quot;;\n\nexport default class App extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;\n      count: 0,\n    &#125;;\n  &#125;\n  componentDidUpdate() &#123;\n    setTimeout(() =&gt; &#123;\n      console.log(&quot;点击次数: &quot; + this.state.count);\n    &#125;, 3000);\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;\n        点击&#123;this.state.count&#125;次\n      &lt;/button&gt;\n    );\n  &#125;\n&#125;\n类组件，声明之后，会在内部生成一个实例 instance，所有的数据都会存在类的上下文中，所以 this.state.count 会一直指向最新的 count 值。\n说到这里，大家应该对 React Hooks 的函数组件写法有了新的认识。\n总结行文至此，希望让同学们能好好地阅读和学习本章节的内容，以及课后对 React Hooks 的拓展。更好的理解它，有助于写出可维护、可拓展的代码，技术本身是服务于业务需求的，但是你不能很好的利用技术的特点，那业务也很难达到做满意的效果。\n","slug":"110-react","date":"2022-12-30T12:00:00.000Z","categories_index":"","tags_index":"react","author_index":"Jude"},{"id":"64e85fbcb5e4c032bd9a3cf4465ac9a7","title":"109、CSS代码片段：布局、视觉、动画","content":"css 代码片段\n\n\n一、清除浮动的更好方式(浏览器支持情况：100%)html&lt;div class=&quot;clearfix&quot;&gt;\n  &lt;div class=&quot;floated&quot;&gt;float a&lt;/div&gt;\n  &lt;div class=&quot;floated&quot;&gt;float b&lt;/div&gt;\n  &lt;div class=&quot;floated&quot;&gt;float c&lt;/div&gt;\n&lt;/div&gt;css.clearfix &#123;\n  border: solid 1px red;\n&#125;\n.clearfix::after &#123;\n  content: &quot;&quot;;\n  display: block;\n  clear: both;\n&#125;\n.floated &#123;\n  float: left;\n  margin-left: 20px;\n&#125;二、不变宽高比给定宽度可变的元素，它将确保其高度以响应方式保持成比例（即，其宽高比保持不变）。\nhtml&lt;div class=&quot;constant-width-to-height-ratio&quot;&gt;&lt;/div&gt;css.constant-width-to-height-ratio &#123;\n  background: #333;\n  width: 50%;\n&#125;\n.constant-width-to-height-ratio::before &#123;\n  content: &quot;&quot;;\n  padding-top: 100%;\n  float: left;\n&#125;\n.constant-width-to-height-ratio::after &#123;\n  content: &quot;&quot;;\n  display: block;\n  clear: both;\n&#125;1、width:50% 只设置父级元素的宽度2、::before 为父级元素定义一个伪元素3、padding-top: 100%; 设置伪元素的内上边距，这里的百分比的值是按照宽度计算的，所以会呈现为一个响应式的元素块。4、此方法还允许将内容正常放置在元素内。\n三、display:table 居中使用 display:table 替代 flexbox 使子元素在其父元素中水平垂直居中。\nhtml&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;center&quot;&gt;&lt;span&gt;Centered content&lt;/span&gt;&lt;/div&gt;\n&lt;/div&gt;css.container &#123;\n  border: 1px solid #333;\n  height: 250px;\n  width: 250px;\n&#125;\n.center &#123;\n  display: table;\n  height: 100%;\n  width: 100%;\n&#125;\n.center &gt; span &#123;\n  display: table-cell;\n  text-align: center;\n  vertical-align: middle;\n&#125;display：table 使.center 元素的行为类似于&lt;table&gt; HTML 元素;设置.center 的宽高为 100%，使其填满父元素;display：table-cell, 设置’.center &gt; span’的 table-cell 允许元素表现得像 HTML 元素;text-align: center 使子元素水平居中;vertical-align: middle 使子元素垂直居中;\n外部父级必须有固定的宽高。\n四、子元素均匀分布html&lt;div class=&quot;evenly-distributed-children&quot;&gt;\n  &lt;p&gt;Item1&lt;/p&gt;\n  &lt;p&gt;Item2&lt;/p&gt;\n  &lt;p&gt;Item3&lt;/p&gt;\n&lt;/div&gt;css.evenly-distributed-children &#123;\n  display: flex;\n  justify-content: space-between;\n&#125;display: flex :启动 flex 布局\njustify-content: space-between：\n均匀地水平分配子元素。 第一个子元素位于左边缘，而最后一个子元素位于右边缘。 或者，使用 justify-content：space-around 来分配子节点周围的空间，而不是它们之间。\n五、图片在容器中显示的更舒适html&lt;img class=&quot;image image-contain&quot; src=&quot;https://picsum.photos/600/200&quot; /&gt;\n&lt;img class=&quot;image image-cover&quot; src=&quot;https://picsum.photos/600/200&quot; /&gt;css.image &#123;\n  background: #34495e;\n  border: 1px solid #34495e;\n  width: 200px;\n  height: 200px;\n&#125;\n.image-contain &#123;\n  object-fit: contain;\n  object-position: center;\n&#125;\n.image-cover &#123;\n  object-fit: cover;\n  object-position: right top;\n&#125;object-fit: contain 容器内显示整个图像，并且保持宽高比object-fit: cover 用图像填充容器，并保持宽高比object-position: [x] [y] 对图像的显示部位进行调整\n六、flexbox 居中(常用)html&lt;div class=&quot;flexbox-centering&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content.&lt;/div&gt;&lt;/div&gt;css.flexbox-centering &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100px;\n&#125;display: flex 启用 flex 局部justify-content: center 子元素水平居中align-items: center 子元素垂直居中\n七、将元素垂直居中于另一个元素html&lt;div class=&quot;ghost-trick&quot;&gt;\n  &lt;div class=&quot;ghosting&quot;&gt;\n    &lt;p&gt;Vertically centered without changing the position property.&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;css.ghosting &#123;\n  height: 300px;\n  background: #0ff;\n&#125;\n.ghosting:before &#123;\n  content: &quot;&quot;;\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n&#125;\np &#123;\n  display: inline-block;\n  vertical-align: middle;\n&#125;使用 ：before 伪元素的样式垂直对齐内联元素而不更改其 position 属性。\n八、grid 居中html&lt;div class=&quot;grid-centering&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content.&lt;/div&gt;&lt;/div&gt;css.grid-centering &#123;\n  display: grid;\n  justify-content: center;\n  align-items: center;\n  height: 100px;\n&#125;display: grid 启用网格布局justify-content: center 使子元素水平居中align-items: center 使子元素垂直居中\n九、使最后一项占满剩余高度html&lt;div class=&quot;container&quot;&gt;\n  &lt;div&gt;Div 1&lt;/div&gt;\n  &lt;div&gt;Div 2&lt;/div&gt;\n  &lt;div&gt;Div 3&lt;/div&gt;\n&lt;/div&gt;csshtml,\nbody &#123;\n  height: 100%;\n  margin: 0;\n&#125;\n.container &#123;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n&#125;\n.container &gt; div:last-child &#123;\n  background-color: tomato;\n  flex: 1;\n&#125;height: 100% 将容器的高度设为视口的高度display: flex 启用 flexflex-direction: column 将项目的顺序设置成从上到下flex-grow: 1 flexbox 会将容器的剩余可用空间应用于最后一个子元素。 父级必须具有视口高度。 flex-grow：1 可以应用于第一个或第二个元素，它将具有所有可用空间。\n十、屏外隐藏元素html&lt;a class=&quot;button&quot; href=&quot;https://www.baidu.com&quot;&gt;\n  Learn More &lt;span class=&quot;offscreen&quot;&gt; about baidu&lt;/span&gt;\n&lt;/a&gt;css.offscreen &#123;\n  border: 0;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n&#125;删除所有边框使用 clip 隐藏元素设置宽高为 1px使用 margin：-1px 取消元素的高度和宽度隐藏元素的溢出移除所有的 padding绝对定位元素，使其不占用 DOM 中的空间\n十一、transform 居中子元素html&lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content&lt;/div&gt;&lt;/div&gt;css.parent &#123;\n  border: 1px solid #333;\n  height: 250px;\n  position: relative;\n  width: 250px;\n&#125;\n.child &#123;\n  left: 50%;\n  position: absolute;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n&#125;十二、多行文本截断显示html&lt;p class=&quot;truncate-text-multiline&quot;&gt;\n  Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy\n  eirmod tempor invidunt ut labore et.\n&lt;/p&gt;css.truncate-text-multiline &#123;\n  overflow: hidden;\n  display: block;\n  height: 109.2px;\n  margin: 0 auto;\n  font-size: 26px;\n  line-height: 1.4;\n  width: 400px;\n  position: relative;\n&#125;\n.truncate-text-multiline:after &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 150px;\n  height: 36.4px;\n  background: linear-gradient(to right, rgba(0, 0, 0, 0), #f5f6f9 50%);\n&#125;overflow: hidden 防止内容溢出width: 400px 确保元素有尺寸height: 109.2px 计算的高度值，它等于 font-size line-height numberOfLines（在这种情况下为 26 1.4 3 &#x3D; 109.2）height: 36.4px 渐变容器的计算值，它等于 font-size line-height（在这种情况下为 26 1.4 &#x3D; 36.4）background: linear-gradient(to right, rgba(0, 0, 0, 0), #f5f6f9 50% 渐变从 透明到渐变从透明到＃f5f6f9\n十三、CSS 列表计数器html&lt;ul&gt;\n  &lt;li&gt;List item&lt;/li&gt;\n  &lt;li&gt;List item&lt;/li&gt;\n  &lt;li&gt;\n    List item\n    &lt;ul&gt;\n      &lt;li&gt;List item&lt;/li&gt;\n      &lt;li&gt;List item&lt;/li&gt;\n      &lt;li&gt;List item&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;cssul &#123;\n  counter-reset: counter;\n&#125;\nli::before &#123;\n  counter-increment: counter;\n  content: counters(counter, &quot;.&quot;) &quot; &quot;;\n&#125;counter-reset 初始化计数器，该值是计数器的名称。默认情况下，计数器从 0 开始。此属性还可用于将其值更改为任何特定数字。counter-increment 用于可数的元素。 一旦计数器重置初始化，计数器的值可以增加或减少。counter(name, style)显示节计数器的值。通常用于内容属性。此函数可以接收两个参数，第一个作为计数器的名称，第二个参数表示占位内容，例如 3.1 的小数点。CSS 计数器对于制作轮廓列表特别有用，因为计数器的新实例是在子元素中自动创建的。使用 counters（）函数，可以在不同级别的嵌套计数器之间插入分隔文本。\n十四、自定义滚动条html&lt;div class=&quot;custom-scrollbar&quot;&gt;\n  &lt;p&gt;\n    Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;br /&gt;\n    Iure id exercitationem nulla qui repellat laborum vitae, &lt;br /&gt;\n    molestias tempora velit natus. Quas, assumenda nisi. &lt;br /&gt;\n    Quisquam enim qui iure, consequatur velit sit?\n  &lt;/p&gt;\n&lt;/div&gt;css.custom-scrollbar &#123;\n  height: 70px;\n  overflow-y: scroll;\n&#125;\n/* To style the document scrollbar, remove `.custom-scrollbar` */\n.custom-scrollbar::-webkit-scrollbar &#123;\n  width: 8px;\n&#125;\n.custom-scrollbar::-webkit-scrollbar-track &#123;\n  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);\n  border-radius: 10px;\n&#125;\n.custom-scrollbar::-webkit-scrollbar-thumb &#123;\n  border-radius: 10px;\n  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);\n&#125;十五、自定义文本选择的样式html&lt;p class=&quot;custom-text-selection&quot;&gt;Select some of this text.&lt;/p&gt;css::selection &#123;\n  background: aquamarine;\n  color: black;\n&#125;\n.custom-text-selection::selection &#123;\n  background: deeppink;\n  color: white;\n&#125;十六、Focus Within 伪类html&lt;div class=&quot;focus-within&quot;&gt;\n  &lt;form&gt;\n    &lt;label for=&quot;given_name&quot;&gt;Given Name:&lt;/label&gt;\n    &lt;input id=&quot;given_name&quot; type=&quot;text&quot; /&gt; &lt;br /&gt;\n    &lt;label for=&quot;family_name&quot;&gt;Family Name:&lt;/label&gt;\n    &lt;input id=&quot;family_name&quot; type=&quot;text&quot; /&gt;\n  &lt;/form&gt;\n&lt;/div&gt;cssform &#123;\n  border: 3px solid #2d98da;\n  color: #000000;\n  padding: 4px;\n&#125;\nform:focus-within &#123;\n  background: #f7b731;\n  color: #000000;\n&#125;伪类：：focus-within 将对应的样式应用于父元素（任何子元素被聚焦）。 例如，表单元素内的输入元素。\n十七、指定元素的全屏html&lt;div class=&quot;container&quot;&gt;\n  &lt;p&gt;\n    &lt;em&gt;Click the button below to enter the element into fullscreen mode. &lt;/em&gt;\n  &lt;/p&gt;\n  &lt;div class=&quot;element&quot; id=&quot;element&quot;&gt;\n    &lt;p&gt;I change color in fullscreen mode!&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;br /&gt;\n  &lt;button\n    onclick=&quot;var el = document.getElementById(&#39;element&#39;); el.requestFullscreen();&quot;\n  &gt;\n    Go Full Screen!\n  &lt;/button&gt;\n&lt;/div&gt;css.container &#123;\n  margin: 40px auto;\n  max-width: 700px;\n&#125;\n.element &#123;\n  padding: 20px;\n  height: 300px;\n  width: 100%;\n  background-color: skyblue;\n&#125;\n.element p &#123;\n  text-align: center;\n  color: white;\n  font-size: 3em;\n&#125;\n.element:-ms-fullscreen p &#123;\n  visibility: visible;\n&#125;\n.element:fullscreen &#123;\n  background-color: #e4708a;\n  width: 100vw;\n  height: 100vh;\n&#125;:fullscreen 伪类选择器用于选择和设置以全屏模式显示的元素。\n十八、：not 伪类选择器html&lt;ul class=&quot;css-not-selector-shortcut&quot;&gt;\n  &lt;li&gt;One&lt;/li&gt;\n  &lt;li&gt;Two&lt;/li&gt;\n  &lt;li&gt;Three&lt;/li&gt;\n  &lt;li&gt;Four&lt;/li&gt;\n&lt;/ul&gt;css.css-not-selector-shortcut &#123;\n  display: flex;\n&#125;\nul &#123;\n  padding-left: 0;\n&#125;\nli &#123;\n  list-style-type: none;\n  margin: 0;\n  padding: 0 0.75rem;\n&#125;\nli:not(:last-child) &#123;\n  border-right: 2px solid #d2d5e4;\n&#125;li:not(:last-child) 设置除 last：child 之外的所有 li 元素的样式，所以最后一个元素右侧没有 border.\n十九、斑马条纹列表html&lt;ul&gt;\n  &lt;li&gt;Item 01&lt;/li&gt;\n  &lt;li&gt;Item 02&lt;/li&gt;\n  &lt;li&gt;Item 03&lt;/li&gt;\n  &lt;li&gt;Item 04&lt;/li&gt;\n  &lt;li&gt;Item 05&lt;/li&gt;\n&lt;/ul&gt;cssli:nth-child(odd) &#123;\n  background-color: #eee;\n&#125;二十、弹跳 loading 动画html&lt;div class=&quot;bouncing-loader&quot;&gt;\n  &lt;div&gt;&lt;/div&gt;\n  &lt;div&gt;&lt;/div&gt;\n  &lt;div&gt;&lt;/div&gt;\n&lt;/div&gt;css@keyframes bouncing-loader &#123;\n  to &#123;\n    opacity: 0.1;\n    transform: translate3d(0, -1rem, 0);\n  &#125;\n&#125;\n.bouncing-loader &#123;\n  display: flex;\n  justify-content: center;\n&#125;\n.bouncing-loader &gt; div &#123;\n  width: 1rem;\n  height: 1rem;\n  margin: 3rem 0.2rem;\n  background: #8385aa;\n  border-radius: 50%;\n  animation: bouncing-loader 0.6s infinite alternate;\n&#125;\n.bouncing-loader &gt; div:nth-child(2) &#123;\n  animation-delay: 0.2s;\n&#125;\n.bouncing-loader &gt; div:nth-child(3) &#123;\n  animation-delay: 0.4s;\n&#125;二十一、按钮边框动画html&lt;div class=&quot;button-border&quot;&gt;&lt;button class=&quot;button&quot;&gt;Submit&lt;/button&gt;&lt;/div&gt;css.button &#123;\n  background-color: #c47135;\n  border: none;\n  color: #ffffff;\n  outline: none;\n  padding: 12px 40px 10px;\n  position: relative;\n&#125;\n.button:before,\n.button:after &#123;\n  border: 0 solid transparent;\n  transition: all 0.25s;\n  content: &quot;&quot;;\n  height: 24px;\n  position: absolute;\n  width: 24px;\n&#125;\n.button:before &#123;\n  border-top: 2px solid #c47135;\n  left: 0px;\n  top: -5px;\n&#125;\n.button:after &#123;\n  border-bottom: 2px solid #c47135;\n  bottom: -5px;\n  right: 0px;\n&#125;\n.button:hover &#123;\n  background-color: #c47135;\n&#125;\n.button:hover:before,\n.button:hover:after &#123;\n  height: 100%;\n  width: 100%;\n&#125;before 和：after 伪元素作为在悬停时设置动画的边框。\n二十二、高度过度html&lt;div class=&quot;trigger&quot;&gt;\n  Hover me to see a height transition.\n  &lt;div class=&quot;el&quot;&gt;content&lt;/div&gt;\n&lt;/div&gt;css.el &#123;\n  transition: max-height 0.5s;\n  overflow: hidden;\n  max-height: 0;\n&#125;\n.trigger:hover &gt; .el &#123;\n  max-height: var(--max-height);\n&#125;二十三、悬停阴影动画html&lt;p class=&quot;hover-shadow-box-animation&quot;&gt;Box it!&lt;/p&gt;css.hover-shadow-box-animation &#123;\n  display: inline-block;\n  vertical-align: middle;\n  transform: perspective(1px) translateZ(0);\n  box-shadow: 0 0 1px transparent;\n  margin: 10px;\n  transition-duration: 0.3s;\n  transition-property: box-shadow, transform;\n&#125;\n.hover-shadow-box-animation:hover,\n.hover-shadow-box-animation:focus,\n.hover-shadow-box-animation:active &#123;\n  box-shadow: 1px 10px 10px -10px rgba(0, 0, 24, 0.5);\n  transform: scale(1.2);\n&#125;二十四、悬停下划线动画html&lt;p class=&quot;hover-underline-box-animation&quot;&gt;Box it!&lt;/p&gt;css.hover-underline-animation &#123;\n  display: inline-block;\n  position: relative;\n  color: #0087ca;\n&#125;\n.hover-underline-animation::after &#123;\n  content: &quot;&quot;;\n  position: absolute;\n  width: 100%;\n  transform: scaleX(0);\n  height: 2px;\n  bottom: 0;\n  left: 0;\n  background-color: #0087ca;\n  transform-origin: bottom right;\n  transition: transform 0.25s ease-out;\n&#125;\n.hover-underline-animation:hover::after &#123;\n  transform: scaleX(1);\n  transform-origin: bottom left;\n&#125;display: inline-block 使 p 成为内联块，以防止下划线跨越整行宽度而不仅仅是文本内容。position: relative 设置父元素为相对定位::after 定义一个伪元素position: absolute 将伪元素脱离文档六，并将其相对于父元素定位width: 100% 确保伪元素和父元素的宽度一致。transform: scaleX(0) 最初将伪元素缩放为 0，因此他是看不见的。bottom: 0 and left: 0 将伪元素放在父元素的左下角。transition: transform 0.25s ease-out 设置动画效果为 ease-out,并且在 0.25 秒内完成。transform-origin: bottom right 变换中心点到父元素的右下角。:hover::after 然后使用 scaleX（1）将宽度转换为 100％，然后将中心点更改为左下角，允许它在悬停时从另一个方向转换出来。\n二十五、弹出菜单html&lt;div class=&quot;reference&quot; tabindex=&quot;0&quot;&gt;\n  &lt;div class=&quot;popout-menu&quot;&gt;Popout menu&lt;/div&gt;\n&lt;/div&gt;css.reference &#123;\n  position: relative;\n  background: tomato;\n  width: 100px;\n  height: 100px;\n&#125;\n.popout-menu &#123;\n  position: absolute;\n  visibility: hidden;\n  left: 100%;\n  background: #333;\n  color: white;\n  padding: 15px;\n&#125;\n.reference:hover &gt; .popout-menu,\n.reference:focus &gt; .popout-menu,\n.reference:focus-within &gt; .popout-menu &#123;\n  visibility: visible;\n&#125;left: 100% 弹出菜单从左侧偏移其父级宽度的 100％。visibility: hidden.reference:hover &gt; .popout-menu 鼠标悬停时，.popout-menu 显示.reference:focus &gt; .popout-menu 聚焦时，.popout-menu 显示.reference:focus-within &gt; .popout-menu 确保在焦点位于参考范围内时显示弹出窗口。\n二十六、悬停时，兄弟元素淡化html&lt;div class=&quot;sibling-fade&quot;&gt;\n  &lt;span&gt;Item 1&lt;/span&gt; &lt;span&gt;Item 2&lt;/span&gt; &lt;span&gt;Item 3&lt;/span&gt;\n  &lt;span&gt;Item 4&lt;/span&gt; &lt;span&gt;Item 5&lt;/span&gt; &lt;span&gt;Item 6&lt;/span&gt;\n&lt;/div&gt;cssspan &#123;\n  padding: 0 1rem;\n  transition: opacity 0.2s;\n&#125;\n.sibling-fade:hover span:not(:hover) &#123;\n  opacity: 0.5;\n&#125;transition: opacity 0.2s 设置 0.2 秒的淡化动画。.sibling-fade:hover span:not(:hover)当父级悬停时，选择当前未悬停的 span 子项并将其透明度更改为 0.5。\n","slug":"109-css","date":"2022-12-20T12:00:00.000Z","categories_index":"","tags_index":"css","author_index":"Jude"},{"id":"52af268647275c68c1b4c71356f5a090","title":"108、web components和vue+web components","content":"Web Components 提供了基于原生支持的、对视图层的封装能力，可以让单个组件相关的 javaScript、css、html 模板运行在以 html 标签为界限的局部环境中，不会影响到全局，组件间也不会相互影响 。 再简单来说：就是提供了我们自定义标签的能力，并且提供了标签内完整的生命周期 。\n\n\nCustom elements（自定义元素）：JavaScript API，允许定义 custom elements 及其行为，然后可以在我们的用户界面中按照需要使用它们。\nShadow DOM（影子 DOM）：JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，开发者可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\nHTML templates（HTML 模板）：和元素使开发者可以编写与 HTML 结构类似的组件和样式。然后它们可以作为自定义元素结构的基础被多次重用。\n一、web components 示例：btn.js\njsclass Btn extends HTMLElement &#123;\n  constructor() &#123;\n    super();\n    const shadowDom = this.attachShadow(&#123; mode: &quot;open&quot; &#125;);\n    this.p = this.h(&quot;p&quot;);\n    this.p.innerText = &quot;jude&quot;;\n    this.p.setAttribute(\n      &quot;style&quot;,\n      &quot;width:100px;height:100px;border:1px solid #999;background:yellowgreen&quot;\n    );\n    shadowDom.appendChild(this.p);\n\n    // tempalte\n    this.template = this.h(&quot;template&quot;);\n    this.template.innerHTML = `\n      &lt;style&gt;\n        div&#123;\n          width:50px;\n          height:50px;\n          background:green;\n        &#125;\n      &lt;/style&gt;\n      &lt;div&gt;\n      我是template,上面的样式会被隔离\n      &lt;/div&gt;\n`;\n    shadowDom.appendChild(this.template.content.cloneNode(true));\n  &#125;\n  h(el) &#123;\n    return document.createElement(el);\n  &#125;\n  // 生命周期\n  // 当自定义元素第一次被连接到文档DOM时被调用\n  connectedCallback() &#123;\n    console.log(&quot;连接调用&quot;);\n  &#125;\n  // 当自定义元素与文档DOM断开连接时被调用\n  disconnectedCallback() &#123;\n    console.log(&quot;断开调用&quot;);\n  &#125;\n  // 当自定义元素被移动到新文档时被调用\n  adoptedCallback() &#123;\n    console.log(&quot;移动时调用&quot;);\n  &#125;\n  // 当自定义元素的第一个属性被增加、移除或者更改时被调用\n  attributeChangedCallback(attrName, oldVal, newVal) &#123;\n    console.log(&quot;改变调用&quot;, attrName, oldVal, newVal);\n  &#125;\n&#125;\n\nwindow.customElements.define(&quot;yu-btn&quot;, Btn);\n\n\n\n\n\n\n\n\n这里存在一个问题，如果使用 window.customElements.define(“btn”, Btn)，会报错：Uncaught DOMException: Failed to execute ‘define’ on ‘CustomElementRegistry’: “btn” is not a valid custom element name,修改一下 name 即可\nindex.html\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;./btn.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;yu-btn&gt;&lt;/yu-btn&gt;\n  &lt;/body&gt;\n&lt;/html&gt;二、vue 使用自定义组件defineCustomElement\n首先需要告知 vue 这是一个自定义组件，跳过组件检查\nts/*vite config ts 配置*/\nvue(&#123;\n  template: &#123;\n    compilerOptions: &#123;\n      isCustomElement: (tag) =&gt; tag.includes(&quot;yu-&quot;),\n    &#125;,\n  &#125;,\n&#125;);父组件：\n\n\n\n\n\n\n\n\n\n这里需要注意，传递参数 如果是对象需要序列化 他是作用于 标签上的\nvue&lt;template&gt;\n  &lt;div&gt;\n    &lt;yu-btn :title=&quot;JSON.stringify(name)&quot;&gt;&lt;/yu-btn&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport &#123; ref, reactive, defineCustomElement &#125; from &quot;vue&quot;;\n//自定义元素模式  要开启这个模式，只需要将你的组件文件以 .ce.vue 结尾即可\nimport customVueVue from &quot;./components/custom-vue.ce.vue&quot;;\nconst Btn = defineCustomElement(customVueVue);\ncustomElements.define(&quot;yu-btn&quot;, Btn);\n\nconst name = ref(&#123; a: 1 &#125;);\n&lt;/script&gt;\n\n&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;子组件：\nvue&lt;template&gt;\n  &lt;div&gt;title: &#123;&#123; title &#125;&#125;&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\n\ndefineProps&lt;&#123;\n  title: string;\n&#125;&gt;();\n&lt;/script&gt;\n\n&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;","slug":"108-vue3","date":"2022-12-15T12:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"1b47ecac068834c9ef16aa0b723eb24c","title":"107、Mac的MySQL无法启动","content":"安装好 MySQL 之后，在 Mac 的系统设置 最下方会新增一个 MySQL,点击之后，会出现 MySQL 的版本号:MySQL 8.0.32,点击 start MySQL Server,仍然无法启动。\n\n\n解决方法：\nshellsudo chown -R mysql /usr/local/mysql/data\n\nsudo /usr/local/mysql/support-files/mysql.server start\n// 会出现success  MySQL启动成功","slug":"107-mysql","date":"2022-12-13T12:00:00.000Z","categories_index":"","tags_index":"mysql","author_index":"Jude"},{"id":"2443c0af2f4306e6e6c56b730ac2d4c6","title":"106、ref小技巧","content":"使用 console.log 输出一个 ref 对象时，控制台查看结果时很不方便，Chrome 浏览器对此有一个格式化的处理。\n\n\n示例：js&lt;script setup lang=&quot;ts&quot;&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nconst str = ref&lt;string&gt;(&#39;jude&#39;)\nconsole.log(&#39;str&#39;,str)\n&lt;/script&gt;控制台打印结果为\ntxtRefImp&#123;\n  dep:undefined\n  __v_isRef:true\n  __v_isShallow:false\n  _rawValue:&#39;jude&#39;\n  _value:&#39;jude&#39;\n  value:&#39;jude&#39;\n&#125;点击控制台右上角设置按钮 — 偏好设置 — 启动自定义格式设置工具，此时控制台的打印结果就很明显了。\n","slug":"106.ref","date":"2022-12-12T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"980fcb723b6d7d88e53e47d050c6f3b3","title":"105、typescript函数Class类型：函数重载和面向对象(三)","content":"\n\n日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：函数。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。\n介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如重载与面向对象的编程等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。\n函数函数的类型签名如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了函数入参类型与函数返回值类型，它们同样使用:的语法进行类型标注。我们直接看最简单的例子：\ntypescriptfunction foo(name: string): number &#123;\n  return name.length;\n&#125;在函数类型中同样存在着类型推导。比如在这个例子中，你可以不写返回值处的类型，它也能被正确推导为 number 类型。\n在 JavaScript 中，我们称 function name () &#123;&#125; 这一声明函数的方式为函数声明（*Function Declaration*）。除了函数声明以外，我们还可以通过函数表达式（*Function Expression*），即 const foo = function()&#123;&#125; 的形式声明一个函数。在表达式中进行类型声明的方式是这样的：\ntypescriptconst foo = function (name: string): number &#123;\n  return name.length;\n&#125;;我们也可以像对变量进行类型标注那样，对 foo 这个变量进行类型声明：\ntypescriptconst foo: (name: string) =&gt; number = function (name) &#123;\n  return name.length;\n&#125;;这里的 (name: string) =&gt; number 看起来很眼熟，对吧？它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 TypeScript 中的函数类型签名。而实际的箭头函数，我们的类型标注也是类似的：\ntypescript// 方式一\nconst foo = (name: string): number =&gt; &#123;\n  return name.length;\n&#125;;\n\n// 方式二\nconst foo: (name: string) =&gt; number = (name) =&gt; &#123;\n  return name.length;\n&#125;;在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性会非常差。因此，一般不推荐这么使用，要么直接在函数中进行参数和返回值的类型声明，要么使用类型别名将函数声明抽离出来：\ntypescripttype FuncFoo = (name: string) =&gt; number;\n\nconst foo: FuncFoo = (name) =&gt; &#123;\n  return name.length;\n&#125;;如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：\ntypescriptinterface FuncFooStruct &#123;\n  (name: string): number;\n&#125;这时的 interface 被称为 Callable Interface，看起来可能很奇怪，但我们可以这么认为，interface 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型罢了。\nvoid 类型在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。\ntypescript// 没有调用 return 语句\nfunction foo(): void &#123;&#125;\n\n// 调用了 return 语句，但没有返回值\nfunction bar(): void &#123;\n  return;\n&#125;原因和我们在原始类型与对象类型一节中讲到的：在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数没有进行返回操作。但在上面的第二个例子中，其实更好的方式是使用 undefined ：\ntypescriptfunction bar(): undefined &#123;\n  return;\n&#125;此时我们想表达的则是，这个函数进行了返回操作，但没有返回实际的值。\n可选参数与 rest 参数在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 ? 描述一个可选属性一样，在函数类型中我们也使用 ? 描述一个可选参数：\ntypescript// 在函数逻辑中注入可选参数默认值\nfunction foo1(name: string, age?: number): number &#123;\n  const inputAge = age || 18; // 或使用 age ?? 18\n  return name.length + inputAge;\n&#125;\n\n// 直接为可选参数声明默认值\nfunction foo2(name: string, age: number = 18): number &#123;\n  const inputAge = age;\n  return name.length + inputAge;\n&#125;需要注意的是，可选参数必须位于必选参数之后。毕竟在 JavaScript 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用 ? 了，因为既然都有默认值，那肯定是可选参数啦。\ntypescriptfunction foo(name: string, age: number = 18): number &#123;\n  const inputAge = age || 18;\n  return name.length + inputAge;\n&#125;在某些情况下，这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。\n对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：\n\n\n\n\n\n\n\n\n\n对于 any 类型，你可以简单理解为它包含了一切可能的类型，我们会在下一节详细介绍。\ntypescriptfunction foo(arg1: string, ...rest: any[]) &#123;&#125;当然，你也可以使用我们前面学习的元祖类型进行标注：\ntypescriptfunction foo(arg1: string, ...rest: [number, boolean]) &#123;&#125;\n\nfoo(&quot;linbudu&quot;, 18, true);重载在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：\ntypescriptfunction func(foo: number, bar?: boolean): string | number &#123;\n  if (bar) &#123;\n    return String(foo);\n  &#125; else &#123;\n    return foo * 599;\n  &#125;\n&#125;在这个实例中，函数的返回类型基于其入参 bar 的值，并且从其内部逻辑中我们知道，当 bar 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。\n要想实现与入参关联的返回值类型，我们可以使用 TypeScript 提供的函数重载签名（*Overload Signature*），将以上的例子使用重载改写：\ntypescriptfunction func(foo: number, bar: true): string;\nfunction func(foo: number, bar?: false): number;\nfunction func(foo: number, bar?: boolean): string | number &#123;\n  if (bar) &#123;\n    return String(foo);\n  &#125; else &#123;\n    return foo * 599;\n  &#125;\n&#125;\n\nconst res1 = func(599); // number\nconst res2 = func(599, true); // string\nconst res3 = func(599, false); // number这里我们的三个 function func 其实具有不同的意义：\n\nfunction func(foo: number, bar: true): string，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。\nfunction func(foo: number, bar?: false): number，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。\nfunction func(foo: number, bar?: boolean): string | number，函数的实现签名，会包含重载签名的所有可能情况。\n\n基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。\n这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。\n\n\n\n\n\n\n\n\n\n你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。\n实际上，TypeScript 中的重载更像是伪重载，它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上。而在如 C++ 等语言中，重载体现在多个名称一致但入参不同的函数实现上，这才是更广义上的函数重载。\n异步函数、Generator 函数等类型签名对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：\ntypescriptasync function asyncFunc(): Promise&lt;void&gt; &#123;&#125;\n\nfunction* genFunc(): Iterable&lt;void&gt; &#123;&#125;\n\nasync function* asyncGenFunc(): AsyncIterable&lt;void&gt; &#123;&#125;其中，Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。而对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 Promise&lt;T&gt;（关于泛型我们会在后面进行详细了解）。\n在函数这一节中，我们主要关注函数的类型标注。因为 TypeScript 中的函数实际上相比 JavaScript 也只是多在重载这一点上，我们需要着重掌握的仍然是类型标注。但在 Class 中，我们的学习重点其实更侧重于其语法与面向对象的编程理念。\nClass类与类成员的类型签名一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有构造函数、属性、方法和访问符（*Accessor*），我们也只需要关注这三个部分即可。这里我要说明一点，有的同学可能认为装饰器也是 Class 的结构，但我个人认为它并不是 Class 携带的逻辑，不应该被归类在这里。\n\n\n\n\n\n\n\n\n\n而对于这些结构的具体意义以及 Class 的入门语法，你可以阅读阮一峰老师的 ES6 标准入门。\n属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：\ntypescriptclass Foo &#123;\n  prop: string;\n\n  constructor(inputProp: string) &#123;\n    this.prop = inputProp;\n  &#125;\n\n  print(addon: string): void &#123;\n    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);\n  &#125;\n\n  get propA(): string &#123;\n    return `$&#123;this.prop&#125;+A`;\n  &#125;\n\n  set propA(value: string) &#123;\n    this.prop = `$&#123;value&#125;+A`;\n  &#125;\n&#125;唯一需要注意的是，setter 方法不允许进行返回值的类型标注，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致，这里我们不再赘述。\n就像函数可以通过函数声明与函数表达式创建一样，类也可以通过类声明和类表达式的方式创建。很明显上面的写法即是类声明，而使用类表达式的语法则是这样的：\ntypescriptconst Foo = class &#123;\n  prop: string;\n\n  constructor(inputProp: string) &#123;\n    this.prop = inputProp;\n  &#125;\n\n  print(addon: string): void &#123;\n    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);\n  &#125;\n\n  // ...\n&#125;;修饰符在 TypeScript 中我们能够为 Class 成员添加这些修饰符：public &#x2F; private &#x2F; protected &#x2F; readonly。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。\n这些修饰符应用的位置在成员命名前：\ntypescriptclass Foo &#123;\n  private prop: string;\n\n  constructor(inputProp: string) &#123;\n    this.prop = inputProp;\n  &#125;\n\n  protected print(addon: string): void &#123;\n    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);\n  &#125;\n\n  public get propA(): string &#123;\n    return `$&#123;this.prop&#125;+A`;\n  &#125;\n\n  public set propA(value: string) &#123;\n    this.propA = `$&#123;value&#125;+A`;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n我们通常不会为构造函数添加修饰符，而是让它保持默认的 public。在扩展阅读中我们会讲到 private 修饰构造函数的场景。\n如果没有其他语言学习经验，你可能不太理解 public &#x2F; private &#x2F; protected 的意义，我们简单做个解释。\n\npublic：此类成员在类、类的实例、子类中都能被访问。\nprivate：此类成员仅能在类的内部被访问。\nprotected：此类成员仅能在类与子类中被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即不允许再访问受保护的成员。\n\n当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以在构造函数中对参数应用访问性修饰符：\ntypescriptclass Foo &#123;\n  constructor(public arg1: string, private arg2: boolean) &#123;&#125;\n&#125;\n\nnew Foo(&quot;linbudu&quot;, true);此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。\n静态成员在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：\ntypescriptclass Foo &#123;\n  static staticHandler() &#123;&#125;\n\n  public instanceHandler() &#123;&#125;\n&#125;不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 Foo.staticHandler 这种形式进行访问。我们可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别：\njavascriptvar Foo = /** @class */ (function () &#123;\n  function Foo() &#123;&#125;\n  Foo.staticHandler = function () &#123;&#125;;\n  Foo.prototype.instanceHandler = function () &#123;&#125;;\n  return Foo;\n&#125;)();从中我们可以看到，静态成员直接被挂载在函数体上，而实例成员挂载在原型上，这就是二者的最重要差异：静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。\n而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如我会用类 + 静态成员来收敛变量与 utils 方法：\ntypescriptclass Utils &#123;\n  public static identifier = &quot;linbudu&quot;;\n\n  public static makeUHappy() &#123;\n    Utils.studyWithU();\n    // ...\n  &#125;\n\n  public static studyWithU() &#123;&#125;\n&#125;\n\nUtils.makeUHappy();继承、实现、抽象类既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：\ntypescriptclass Base &#123;&#125;\n\nclass Derived extends Base &#123;&#125;对于这里的两个类，比较严谨的称呼是 基类（*Base*） 与 派生类（*Derived*）。当然，如果你觉得叫父类与子类更容易理解也没问题。关于基类与派生类，我们需要了解的主要是派生类对基类成员的访问与覆盖操作。\n基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。我们在上面其实已经介绍过，派生类中可以访问到使用 public 或 protected 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但我们仍然可以通过 super 访问到基类中的方法：\ntypescriptclass Base &#123;\n  print() &#123;&#125;\n&#125;\n\nclass Derived extends Base &#123;\n  print() &#123;\n    super.print();\n    // ...\n  &#125;\n&#125;在派生类中覆盖基类方法时，我们并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？所以，TypeScript 4.3 新增了 override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义：\ntypescriptclass Base &#123;\n  printWithLove() &#123;&#125;\n&#125;\n\nclass Derived extends Base &#123;\n  override print() &#123;\n    // ...\n  &#125;\n&#125;在这里 TS 将会给出错误，因为尝试覆盖的方法并未在基类中声明。通过这一关键字我们就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。\n除了基类与派生类以外，还有一个比较重要的概念：抽象类。抽象类是对类结构与方法的抽象，简单来说，一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的入参类型与返回值类型。\n抽象类使用 abstract 关键字声明：\ntypescriptabstract class AbsFoo &#123;\n  abstract absProp: string;\n  abstract get absGetter(): string;\n  abstract absMethod(name: string): string;\n&#125;注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。我们可以实现（implements）一个抽象类：\ntypescriptclass Foo implements AbsFoo &#123;\n  absProp: string = &quot;linbudu&quot;;\n\n  get absGetter() &#123;\n    return &quot;linbudu&quot;;\n  &#125;\n\n  absMethod(name: string) &#123;\n    return name;\n  &#125;\n&#125;此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中无法声明静态的抽象成员。\n对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的。interface 不仅可以声明函数结构，也可以声明类的结构：\ntypescriptinterface FooStruct &#123;\n  absProp: string;\n  get absGetter(): string;\n  absMethod(input: string): string;\n&#125;\n\nclass Foo implements FooStruct &#123;\n  absProp: string = &quot;linbudu&quot;;\n\n  get absGetter() &#123;\n    return &quot;linbudu&quot;;\n  &#125;\n\n  absMethod(name: string) &#123;\n    return name;\n  &#125;\n&#125;在这里，我们让类去实现了一个接口。这里接口的作用和抽象类一样，都是描述这个类的结构。除此以外，我们还可以使用 Newable Interface 来描述一个类的结构（类似于描述函数结构的 Callable Interface）：\ntypescriptclass Foo &#123;&#125;\n\ninterface FooStruct &#123;\n  new (): Foo;\n&#125;\n\ndeclare const NewableFoo: FooStruct;\n\nconst foo = new NewableFoo();总结与预告在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类，实际上我们了解的更多是新的语法，如访问性修饰符 public &#x2F; private &#x2F; protected ，操作修饰符 readonly ，静态成员 static ，抽象类 abstract ，以及 override 等在 JavaScript（ECMAScript）中不存在或实现并不完全的能力。\n对于函数与类，你需要更多地实际使用才能掌握得更好。不妨继续对你手上的 JavaScript 进行改造，让函数与类都能披上类型的铠甲，获得完整的类型能力。\n在下一节，我们将要接触的就是 JavaScript 中完全没有类似概念的新朋友了，它们是 TypeScript 类型编程最基础的一部分，包括了 any 、 unknown 、never 内置类型，以及类型断言等概念，这些类型工具会是你以后玩转类型编程时最常打交道的一部分。\n扩展阅读私有构造函数上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？\ntypescriptclass Foo &#123;\n  private constructor() &#123;&#125;\n&#125;看起来好像没什么问题，但是当你想要实例化这个类时，一行美丽的操作就会出现：类的构造函数被标记为私有，且只允许在类内部访问。\n那这就很奇怪了，我们要一个不能实例化的类有啥用？摆设吗？\n还真不是，有些场景下私有构造函数确实有奇妙的用法，比如像我一样把类作为 utils 方法时，此时 Utils 类内部全部都是静态成员，我们也并不希望真的有人去实例化这个类。此时就可以使用私有构造函数来阻止它被错误地实例化：\ntypescriptclass Utils &#123;\n  public static identifier = &quot;linbudu&quot;;\n\n  private constructor() &#123;&#125;\n\n  public static makeUHappy() &#123;&#125;\n&#125;或者在一个类希望把实例化逻辑通过方法来实现，而不是通过 new 的形式时，也可以使用私有构造函数来达成目的。\n你可能会想到，既然有私有构造函数，那没道理没有受保护的构造函数（protected）啊？还真有。但这里我想留给你自己去探寻，你可以先查找下这么做的意义，再想想，什么场景下我们非用它不可？\nSOLID 原则SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。\nS，单一功能原则，一个类应该仅具有一种职责，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和写操作也应当被视为两种不同的职责，并被分配到两个类中。更进一步，对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来。\nO，开放封闭原则，一个类应该是可扩展但不可修改的。即假设我们的业务中支持通过微信、支付宝登录，原本在一个 login 方法中进行 if else 判断，假设后面又新增了抖音登录、美团登录，难道要再加 else if 分支（或 switch case）吗？\ntypescriptenum LoginType &#123;\n  WeChat,\n  TaoBao,\n  TikTok,\n  // ...\n&#125;\n\nclass Login &#123;\n  public static handler(type: LoginType) &#123;\n    if (type === LoginType.WeChat) &#123;\n    &#125; else if (type === LoginType.TikTok) &#123;\n    &#125; else if (type === LoginType.TaoBao) &#123;\n    &#125; else &#123;\n      throw new Error(&quot;Invalid Login Type!&quot;);\n    &#125;\n  &#125;\n&#125;当然不，基于开放封闭原则，我们应当将登录的基础逻辑抽离出来，不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑。\ntypescriptabstract class LoginHandler &#123;\n  abstract handler(): void;\n&#125;\n\nclass WeChatLoginHandler implements LoginHandler &#123;\n  handler() &#123;&#125;\n&#125;\n\nclass TaoBaoLoginHandler implements LoginHandler &#123;\n  handler() &#123;&#125;\n&#125;\n\nclass TikTokLoginHandler implements LoginHandler &#123;\n  handler() &#123;&#125;\n&#125;\n\nclass Login &#123;\n  public static handlerMap: Record&lt;LoginType, LoginHandler&gt; = &#123;\n    [LoginType.TaoBao]: new TaoBaoLoginHandler(),\n    [LoginType.TikTok]: new TikTokLoginHandler(),\n    [LoginType.WeChat]: new WeChatLoginHandler(),\n  &#125;;\n  public static handler(type: LoginType) &#123;\n    Login.handlerMap[type].handler();\n  &#125;\n&#125;L，里式替换原则，一个派生类可以在程序的任何一处对其基类进行替换。这也就意味着，子类完全继承了父类的一切，对父类进行了功能地扩展（而非收窄）。\nI，接口分离原则，类的实现方应当只需要实现自己需要的那部分接口。比如微信登录支持指纹识别，支付宝支持指纹识别和人脸识别，这个时候微信登录的实现类应该不需要实现人脸识别方法才对。这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对。\nD，依赖倒置原则，这是实现开闭原则的基础，它的核心思想即是对功能的实现应该依赖于抽象层，即不同的逻辑通过实现不同的抽象类。还是登录的例子，我们的登录提供方法应该基于共同的登录抽象类实现（LoginHandler），最终调用方法也基于这个抽象类，而不是在一个高阶登录方法中去依赖多个低阶登录提供方。\n","slug":"105-ts","date":"2022-12-10T12:00:00.000Z","categories_index":"","tags_index":"ts","author_index":"Jude"},{"id":"c7620c92dc932103f528df2223f3f201","title":"104、typescript字面量类型和枚举(二)","content":"\n\n了解了原始类型与对象类型以后，我们已经能完成简单场景的类型标注了。但这还远远不够，我们还可以让这些类型标注更精确一些。比如，有一个接口结构，它描述了响应的消息结构：\ntypescriptinterface IRes &#123;\n  code: number;\n  status: string;\n  data: any;\n&#125;在大多数情况下，这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 &#x2F; 10001 &#x2F; 50000，status 可能是 &quot;success&quot; &#x2F; &quot;failure&quot;。而上面的类型只给出了一个宽泛的 number（string），此时我们既不能在访问 code 时获得精确的提示，也失去了 TypeScript 类型即文档的功能。\n这个时候要怎么做？\n字面量类型与联合类型我们可以使用联合类型加上字面量类型，把上面的例子改写成这样：\ntypescriptinterface Res &#123;\n  code: 10000 | 10001 | 50000;\n  status: &quot;success&quot; | &quot;failure&quot;;\n  data: any;\n&#125;这个时候，我们就能在访问时获得精确地类型推导了。\n\n对于 declare var res: Res，你可以认为它其实就是快速生成一个符合指定类型，但没有实际值的变量，同时它也不存在于运行时中。上面引入了一些新的概念，我们来一个一个了解。\n字面量类型最开始你可能觉得很神奇，&quot;success&quot; 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做字面量类型（Literal Types），它代表着比原始类型更精确的类型，同时也是原始类型的子类型（关于类型层级，我们会在后面详细了解）。\n字面量类型主要包括字符串字面量类型、数字字面量类型、布尔字面量类型和对象字面量类型，它们可以直接作为类型标注：\ntypescriptconst str: &quot;linbudu&quot; = &quot;linbudu&quot;;\nconst num: 599 = 599;\nconst bool: true = true;为什么说字面量类型比原始类型更精确？我们可以看这么个例子：\ntypescript// 报错！不能将类型“&quot;linbudu599&quot;”分配给类型“&quot;linbudu&quot;”。\nconst str1: &quot;linbudu&quot; = &quot;linbudu599&quot;;\n\nconst str2: string = &quot;linbudu&quot;;\nconst str3: string = &quot;linbudu599&quot;;上面的代码，原始类型的值可以包括任意的同类型值，而字面量类型要求的是值级别的字面量一致。\n单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 |）一起使用，表达一组字面量类型：\ntypescriptinterface Tmp &#123;\n  bool: true | false;\n  num: 1 | 2 | 3;\n  str: &quot;lin&quot; | &quot;bu&quot; | &quot;du&quot;;\n&#125;联合类型而联合类型你可以理解为，它代表了一组类型的可用集合，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，我们还可以将各种类型混合到一起：\ntypescriptinterface Tmp &#123;\n  mixed: true | string | 599 | &#123;&#125; | (() =&gt; &#123;&#125;) | (1 | 2);\n&#125;这里有几点需要注意的：\n\n对于联合类型中的函数类型，需要使用括号()包裹起来\n函数类型并不存在字面量类型，因此这里的 (() =&gt; &#123;&#125;) 就是一个合法的函数类型\n你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中\n\n联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：\ntypescriptinterface Tmp &#123;\n  user:\n    | &#123;\n        vip: true;\n        expires: string;\n      &#125;\n    | &#123;\n        vip: false;\n        promotion: string;\n      &#125;;\n&#125;\n\ndeclare var tmp: Tmp;\n\nif (tmp.user.vip) &#123;\n  console.log(tmp.user.expires);\n&#125;在这个例子中，user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true ，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）。这一能力的使用涉及类型守卫与类型控制流分析，我们会在后面的章节详细来说。\n我们也可以通过类型别名来复用一组字面量联合类型：\ntypescripttype Code = 10000 | 10001 | 50000;\n\ntype Status = &quot;success&quot; | &quot;failure&quot;;除了原始类型的字面量类型以外，对象类型也有着对应的字面量类型。\n对象字面量类型类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：\ntypescriptinterface Tmp &#123;\n  obj: &#123;\n    name: &quot;linbudu&quot;;\n    age: 18;\n  &#125;;\n&#125;\n\nconst tmp: Tmp = &#123;\n  obj: &#123;\n    name: &quot;linbudu&quot;,\n    age: 18,\n  &#125;,\n&#125;;如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。对象字面量类型在实际开发中的使用较少，我们只需要了解。\n总的来说，在需要更精确类型的情况下，我们可以使用字面量类型加上联合类型的方式，将类型从 string 这种宽泛的原始类型直接收窄到 &quot;resolved&quot; | &quot;pending&quot; | &quot;rejected&quot; 这种精确的字面量类型集合。\n需要注意的是，无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。\n如果说字面量类型是对原始类型的进一步扩展（对象字面量类型的使用较少），那么枚举在某些方面则可以理解为是对对象类型的扩展。\n枚举枚举并不是 JavaScript 中原生的概念，在其他语言中它都是老朋友了（Java、C#、Swift 等）。目前也已经存在给 JavaScript（ECMAScript）引入枚举支持的 proposal-enum 提案，但还未被提交给 TC39 ，仍处于 Stage 0 阶段。\n如果要和 JavaScript 中现有的概念对比，我想最贴切的可能就是你曾经写过的 constants 文件了：\njavascriptexport default &#123;\n  Home_Page_Url: &quot;url1&quot;,\n  Setting_Page_Url: &quot;url2&quot;,\n  Share_Page_Url: &quot;url3&quot;,\n&#125;;\n\n// 或是这样：\nexport const PageUrl = &#123;\n  Home_Page_Url: &quot;url1&quot;,\n  Setting_Page_Url: &quot;url2&quot;,\n  Share_Page_Url: &quot;url3&quot;,\n&#125;;如果把这段代码替换为枚举，会是如下的形式：\ntypescriptenum PageUrl &#123;\n  Home_Page_Url = &quot;url1&quot;,\n  Setting_Page_Url = &quot;url2&quot;,\n  Share_Page_Url = &quot;url3&quot;,\n&#125;\n\nconst home = PageUrl.Home_Page_Url;这么做的好处非常明显。首先，你拥有了更好的类型提示。其次，这些常量被真正地约束在一个命名空间下（上面的对象声明总是差点意思）。如果你没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增：\ntypescriptenum Items &#123;\n  Foo,\n  Bar,\n  Baz,\n&#125;在这个例子中，Items.Foo , Items.Bar , Items.Baz的值依次是 0，1，2 。\n如果你只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。\ntypescriptenum Items &#123;\n  // 0\n  Foo,\n  Bar = 599,\n  // 600\n  Baz,\n&#125;在数字型枚举中，你可以使用延迟求值的枚举值，比如函数：\ntypescriptconst returnNum = () =&gt; 100 + 499;\n\nenum Items &#123;\n  Foo = returnNum(),\n  Bar = 599,\n  Baz,\n&#125;但要注意，延迟求值的枚举值是有条件的。如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后（如上例），或者放在第一位：\ntypescriptenum Items &#123;\n  Baz,\n  Foo = returnNum(),\n  Bar = 599,\n&#125;TypeScript 中也可以同时使用字符串枚举值和数字枚举值：\ntypescriptenum Mixed &#123;\n  Num = 599,\n  Str = &quot;linbudu&quot;,\n&#125;枚举和对象的重要差异在于，对象是单向映射的，我们只能从键映射到键值。而枚举是双向映射的，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：\ntypescriptenum Items &#123;\n  Foo,\n  Bar,\n  Baz,\n&#125;\n\nconst fooValue = Items.Foo; // 0\nconst fooKey = Items[0]; // &quot;Foo&quot;要了解这一现象的本质，我们需要来看一看枚举的编译产物，如以上的枚举会被编译为以下 JavaScript 代码：\ntypescript&quot;use strict&quot;;\nvar Items;\n(function (Items) &#123;\n  Items[(Items[&quot;Foo&quot;] = 0)] = &quot;Foo&quot;;\n  Items[(Items[&quot;Bar&quot;] = 1)] = &quot;Bar&quot;;\n  Items[(Items[&quot;Baz&quot;] = 2)] = &quot;Baz&quot;;\n&#125;)(Items || (Items = &#123;&#125;));obj[k] = v 的返回值即是 v，因此这里的 obj[obj[k] = v] = k 本质上就是进行了 obj[k] = v 与 obj[v] = k 这样两次赋值。\n但需要注意的是，仅有值为数字的枚举成员才能够进行这样的双向枚举，字符串枚举成员仍然只会进行单次映射：\ntypescriptenum Items &#123;\n  Foo,\n  Bar = &quot;BarValue&quot;,\n  Baz = &quot;BazValue&quot;,\n&#125;\n\n// 编译结果，只会进行 键-值 的单向映射\n(&quot;use strict&quot;);\nvar Items;\n(function (Items) &#123;\n  Items[(Items[&quot;Foo&quot;] = 0)] = &quot;Foo&quot;;\n  Items[&quot;Bar&quot;] = &quot;BarValue&quot;;\n  Items[&quot;Baz&quot;] = &quot;BazValue&quot;;\n&#125;)(Items || (Items = &#123;&#125;));除了数字枚举与字符串枚举这种分类以外，其实还存在着普通枚举与常量枚举这种分类方式。\n常量枚举常量枚举和枚举相似，只是其声明多了一个 const：\ntypescriptconst enum Items &#123;\n  Foo,\n  Bar,\n  Baz,\n&#125;\n\nconst fooValue = Items.Foo; // 0它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，你只能通过枚举成员访问枚举值（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象（如上面的 Items 对象），对枚举成员的访问会被直接内联替换为枚举的值。以上的代码会被编译为如下形式：\njavascriptconst fooValue = 0; /* Foo */ // 0\n\n\n\n\n\n\n\n\n实际上，常量枚举的表现、编译产物还受到配置项 --isolatedModules 以及 --preserveConstEnums 等的影响，我们会在后面的 TSConfig 详解中了解更多。\n总结与预告在这一节中，我们了解了字面量类型和枚举的使用，包括字面量类型的分类，与联合类型的结合使用，以及枚举与其编译产物等等。\n对于字面量类型，我们可以使用它来提供更精确的类型标注。比如，你可以将如用户类型与请求状态码这一类属性的类型，都使用字面量类型＋联合类型的形式改写，获得更详细的类型信息与更严格的类型约束。\n而对于枚举，我们可以使用它来替换掉之前使用对象进行常量收敛的代码，而如果你希望减少编译后的代码，可以进一步地使用在编译后会被完全抹除的常量枚举。\n扩展阅读类型控制流分析中的字面量类型除了手动声明字面量类型以外，实际上 TypeScript 也会在某些情况下将变量类型推导为字面量类型，看这个例子：\n\n\n你会发现，使用 const 声明的变量，其类型会从值推导出最精确的字面量类型。而对象类型则只会推导至符合其属性结构的接口，不会使用字面量类型：\n\n要解答这个现象，需要你回想 let 和 const 声明的意义。我们知道，使用 let 声明的变量是可以再次赋值的，在 TypeScript 中要求赋值类型始终与原类型一致（如果声明了的话）。因此对于 let 声明，只需要推导至这个值从属的类型即可。而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型，但对象类型变量仍可变（但同样会要求其属性值类型保持一致）。\n","slug":"104-ts","date":"2022-12-07T12:00:00.000Z","categories_index":"","tags_index":"ts","author_index":"Jude"},{"id":"b2cb300a93e61d3aa2c5b38ae613e327","title":"103、typescript理解原始类型和对象类型(一)","content":"\n\n原始类型的类型标注JavaScript 的内置原始类型,除了最常见的 number &#x2F; string &#x2F; boolean &#x2F; null &#x2F; undefined， ECMAScript 2015（ES6）、2020 (ES11) 又分别引入了 2 个新的原始类型：symbol 与 bigint 。在 TypeScript 中它们都有对应的类型注解：\ntypescriptconst name: string = &quot;linbudu&quot;;\nconst age: number = 24;\nconst male: boolean = false;\nconst undef: undefined = undefined;\nconst nul: null = null;\nconst obj: object = &#123; name, age, male &#125;;\nconst bigintVar1: bigint = 9007199254740991n;\nconst bigintVar2: bigint = BigInt(9007199254740991);\nconst symbolVar: symbol = Symbol(&quot;unique&quot;);其中，除了 null 与 undefined 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念，因此这里我们只对 null 与 undefined 展开介绍。\nnull 与 undefined在 JavaScript 中，null 与 undefined 分别表示“这里有值，但是个空值”和“这里没有值”。而在 TypeScript 中，null 与 undefined 类型都是有具体意义的类型。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 strictNullChecks 检查的情况下，会被视作其他类型的子类型，比如 string 类型会被认为包含了 null 与 undefined 类型：\ntypescriptconst tmp1: null = null;\nconst tmp2: undefined = undefined;\n\nconst tmp3: string = null; // 仅在关闭 strictNullChecks 时成立，下同\nconst tmp4: string = undefined;除了上面介绍的原始类型以及 null、undefined 类型以外，在 TypeScript 中还存在着一个特殊的类型：void，它和 JavaScript 中的 void 同样不是一回事，我们接着往下看。\nvoid你是否看到过以下的 JavaScript 代码呢？\ntypescript&lt;a href=&quot;javascript:void(0)&quot;&gt;清除缓存&lt;/a&gt;这里的 void(0) 等价于 void 0，即 void expression 的语法。void 操作符会执行后面跟着的表达式并返回一个 undefined，如你可以使用它来执行一个立即执行函数（IIFE）：\ntypescriptvoid (function iife() &#123;\n  console.log(&quot;Invoked!&quot;);\n&#125;)();能这么做是因为，void 操作符强制将后面的函数声明转化为了表达式，因此整体其实相当于：void((function iife()&#123;&#125;)())。\n事实上，TypeScript 的原始类型标注中也有 void，但与 JavaScript 中不同的是，这里的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值，如：\ntypescriptfunction func1() &#123;&#125;\nfunction func2() &#123;\n  return;\n&#125;\nfunction func3() &#123;\n  return undefined;\n&#125;在这里，func1 与 func2 的返回值类型都会被隐式推导为 void，只有显式返回了 undefined 值的 func3 其返回值类型才被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。\n\n\n\n\n\n\n\n\n\n虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。\n这里可能有点绕，你可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型（注意与它们在 JavaScript 中的意义区分）。而 undefined 能够被赋值给 void 类型的变量，就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined 。null 类型也可以，但需要在关闭 strictNullChecks 配置的情况下才能成立。\ntypescriptconst voidVar1: void = undefined;\n\nconst voidVar2: void = null; // 需要关闭 strictNullChecks到这里，我们了解了 JavaScript 中原始数据类型到 TypeScript 原始类型概念地映射，你应当能感觉到 TypeScript 对 JavaScript 开发者的友好，大部分概念都能比较自然地过渡，下面的数组与对象的类型标注同样如此。\n数组的类型标注数组同样是我们最常用的类型之一，在 TypeScript 中有两种方式来声明一个数组类型：\ntypescriptconst arr1: string[] = [];\n\nconst arr2: Array&lt;string&gt; = [];这两种方式是完全等价的，但其实更多是以前者为主，如果你将鼠标悬浮在 arr2 上，会发现它显示的类型签名是 string[]。数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用 元组（Tuple） 来代替数组要更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度地访问：\ntypescriptconst arr3: string[] = [&quot;lin&quot;, &quot;bu&quot;, &quot;du&quot;];\n\nconsole.log(arr3[599]);这种情况肯定是不符合预期的，因为我们能确定这个数组中只有三个成员，并希望在越界访问时给出类型报错。这时我们可以使用元组类型进行类型标注：\ntypescriptconst arr4: [string, string, string] = [&quot;lin&quot;, &quot;bu&quot;, &quot;du&quot;];\n\nconsole.log(arr4[599]);此时将会产生一个类型错误：**长度为“3”的元组类型“[string, string, string]”在索引“599“处没有元素**。除了同类型的元素以外，元组内部也可以声明多个与其位置强绑定的，不同类型的元素：\ntypescriptconst arr5: [string, number, boolean] = [&quot;linbudu&quot;, 599, true];在这种情况下，对数组合法边界内的索引访问（即 0、1、2）将精确地获得对应位置上的类型。同时元组也支持了在某一个位置上的可选成员：\ntypescriptconst arr6: [string, number?, boolean?] = [&quot;linbudu&quot;];\n// 下面这么写也可以\n// const arr6: [string, number?, boolean?] = [&#39;linbudu&#39;, , ,];对于标记为可选的成员，在 --strictNullCheckes 配置下会被视为一个 string | undefined 的类型。此时元组的长度属性也会发生变化，比如上面的元组 arr6 ，其长度的类型为 1 | 2 | 3：\ntypescripttype TupleLength = typeof arr6.length; // 1 | 2 | 3也就是说，这个元组的长度可能为 1、2、3。\n\n\n\n\n\n\n\n\n\n关于类型别名（type）、类型查询（typeof）以及联合类型，我们会在后面讲到，这里你只需要简单了解即可。\n你可能会觉得，元组的可读性实际上并不好。比如对于 [string, number, boolean]来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式。而在 TypeScript 4.0 中，有了具名元组（Labeled Tuple Elements）的支持，使得我们可以为元组中的元素打上类似属性的标记：\ntypescriptconst arr7: [name: string, age: number, male: boolean] = [&quot;linbudu&quot;, 599, true];有没有很酷？考虑到某些拼装对象太麻烦，我们完全可以使用具名元组来做简单替换。具名元组可选元素的修饰符将成为以下形式：\ntypescriptconst arr7: [name: string, age: number, male?: boolean] = [\n  &quot;linbudu&quot;,\n  599,\n  true,\n];实际上除了显式地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式：\ntypescriptconst arr1: string[] = [];\n\nconst [ele1, ele2, ...rest] = arr1;对于数组，此时仍然无法检查出是否存在隐式访问，因为类型层面并不知道它到底有多少个元素。但对于元组，隐式的越界访问也能够被揪出来给一个警告：\ntypescriptconst arr5: [string, number, boolean] = [&quot;linbudu&quot;, 599, true];\n\n// 长度为 &quot;3&quot; 的元组类型 &quot;[string, number, boolean]&quot; 在索引 &quot;3&quot; 处没有元素。\nconst [name, age, male, other] = arr5;JavaScript 的开发者对元组 Tuple 的概念可能比较陌生，毕竟在 JavaScript 中我们很少声明定长的数组。但使用元组确实能帮助我们进一步提升数组结构的严谨性，包括基于位置的类型标注、避免出现越界访问等等。除了通过数组类型提升数组结构的严谨性，TypeScript 中的对象类型也能帮助我们提升对象结构的严谨性。接下来我们就一起来看看。\n对象的类型标注作为 JavaScript 中使用最频繁的数据结构，对象的类型标注是我们本节要重点关注的部分。接下来我们会学习如何在 TypeScript 中声明对象、修饰对象属性，以及了解可能存在的使用误区。这些内容能够帮助你建立起对 TypeScript 中立体类型（我们可以理解为前面的原始类型是“平面类型”）的了解，正式入门 TypeScript 。\n类似于数组类型，在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 interface ，你可以理解为它代表了这个对象对外提供的接口结构。\n首先我们使用 interface 声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：\ntypescriptinterface IDescription &#123;\n  name: string;\n  age: number;\n  male: boolean;\n&#125;\n\nconst obj1: IDescription = &#123;\n  name: &quot;linbudu&quot;,\n  age: 599,\n  male: true,\n&#125;;这里的“描述”指：\n\n每一个属性的值必须一一对应到接口的属性类型\n不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 obj1.other = &#39;xxx&#39; 这样属性访问赋值的形式\n\n除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括可选（Optional） 与 只读（Readonly） 这两种。\n修饰接口属性类似于上面的元组可选，在接口结构中同样通过 ? 来标记一个属性为可选：\ntypescriptinterface IDescription &#123;\n  name: string;\n  age: number;\n  male?: boolean;\n  func?: Function;\n&#125;\n\nconst obj2: IDescription = &#123;\n  name: &quot;linbudu&quot;,\n  age: 599,\n  male: true,\n  // 无需实现 func 也是合法的\n&#125;;在这种情况下，即使你在 obj2 中定义了 male 属性，但当你访问 obj2.male 时，它的类型仍然会是 boolean | undefined，因为毕竟这是我们自己定义的类型嘛。\n假设新增一个可选的函数类型属性，然后进行调用：obj2.func() ，此时将会产生一个类型报错：**不能调用可能是未定义的方法**。但可选属性标记不会影响你对这个属性进行赋值，如：\ntypescriptobj2.male = false;\nobj2.func = () =&gt; &#123;&#125;;即使你对可选属性进行了赋值，TypeScript 仍然会使用接口的描述为准进行类型检查，你可以使用类型断言、非空断言或可选链解决（别急，我们在后面会讲到）。\n除了标记一个属性为可选以外，你还可以标记这个属性为只读：readonly。很多同学对这一关键字比较陌生，因为以往 JavaScript 中并没有这一类概念，它的作用是防止对象的属性被再次赋值。\ntypescriptinterface IDescription &#123;\n  readonly name: string;\n  age: number;\n&#125;\n\nconst obj3: IDescription = &#123;\n  name: &quot;linbudu&quot;,\n  age: 599,\n&#125;;\n\n// 无法分配到 &quot;name&quot; ，因为它是只读属性\nobj3.name = &quot;林不渡&quot;;其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同。\n\n你只能将整个数组&#x2F;元组标记为只读，而不能像对象那样标记某个属性为只读。\n一旦被标记为只读，那这个只读数组&#x2F;元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是类型 xxx 上不存在属性“push”这种。这一实现的本质是只读数组与只读元组的类型实际上变成了 ReadonlyArray，而不再是 Array。\n\ntype 与 interface我也知道，很多同学更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而我更推荐的方式是，interface 用来描述对象、类的结构，而类型别名用来将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题。\nobject、Object 以及 { }object、Object 以及&#123;&#125;（一个空对象）这三者的使用可能也会让部分同学感到困惑，所以我也专门解释下。\n首先是 Object 的使用。被 JavaScript 原型链折磨过的同学应该记得，原型链的顶端是 Object 以及 Function，这也就意味着所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：\ntypescript// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks\nconst tmp1: Object = undefined;\nconst tmp2: Object = null;\nconst tmp3: Object = void 0;\n\nconst tmp4: Object = &quot;linbudu&quot;;\nconst tmp5: Object = 599;\nconst tmp6: Object = &#123; name: &quot;linbudu&quot; &#125;;\nconst tmp7: Object = () =&gt; &#123;&#125;;\nconst tmp8: Object = [];和 Object 类似的还有 Boolean、Number、String、Symbol，这几个装箱类型（Boxed Types） 同样包含了一些超出预期的类型。以 String 为例，它同样包括 undefined、null、void，以及代表的 拆箱类型（Unboxed Types） string，但并不包括其他装箱类型对应的拆箱类型，如 boolean 与 基本对象类型，我们看以下的代码：\ntypescriptconst tmp9: String = undefined;\nconst tmp10: String = null;\nconst tmp11: String = void 0;\nconst tmp12: String = &quot;linbudu&quot;;\n\n// 以下不成立，因为不是字符串类型的拆箱类型\nconst tmp13: String = 599; // X\nconst tmp14: String = &#123; name: &quot;linbudu&quot; &#125;; // X\nconst tmp15: String = () =&gt; &#123;&#125;; // X\nconst tmp16: String = []; // X在任何情况下，你都不应该使用这些装箱类型。\nobject 的引入就是为了解决对 Object 类型的错误使用，它代表所有非原始类型的类型，即数组、对象与函数类型这些：\ntypescriptconst tmp17: object = undefined;\nconst tmp18: object = null;\nconst tmp19: object = void 0;\n\nconst tmp20: object = &quot;linbudu&quot;; // X 不成立，值为原始类型\nconst tmp21: object = 599; // X 不成立，值为原始类型\n\nconst tmp22: object = &#123; name: &quot;linbudu&quot; &#125;;\nconst tmp23: object = () =&gt; &#123;&#125;;\nconst tmp24: object = [];最后是&#123;&#125;，一个奇奇怪怪的空对象，如果你了解过字面量类型，可以认为&#123;&#125;就是一个对象字面量类型（对应到字符串字面量类型这样）。否则，你可以认为使用&#123;&#125;作为类型签名就是一个合法的，但内部无属性定义的空对象，这类似于 Object（想想 new Object()），它意味着任何非 null &#x2F; undefined 的值：\ntypescriptconst tmp25: &#123;&#125; = undefined; // 仅在关闭 strictNullChecks 时成立，下同\nconst tmp26: &#123;&#125; = null;\nconst tmp27: &#123;&#125; = void 0; // void 0 等价于 undefined\n\nconst tmp28: &#123;&#125; = &quot;linbudu&quot;;\nconst tmp29: &#123;&#125; = 599;\nconst tmp30: &#123;&#125; = &#123; name: &quot;linbudu&quot; &#125;;\nconst tmp31: &#123;&#125; = () =&gt; &#123;&#125;;\nconst tmp32: &#123;&#125; = [];虽然能够将其作为变量的类型，但你实际上无法对这个变量进行任何赋值操作：\ntypescriptconst tmp30: &#123;&#125; = &#123; name: &quot;linbudu&quot; &#125;;\n\ntmp30.age = 18; // X 类型“&#123;&#125;”上不存在属性“age”。这是因为它就是纯洁的像一张白纸一样的空对象，上面没有任何的属性（除了 toString 这种与生俱来的）。在类型层级一节我们还会再次见到它，不过那个时候它已经被称为“万物的起源”了。\n最后，为了更好地区分 Object、object 以及&#123;&#125;这三个具有迷惑性的类型，我们再做下总结：\n\n在任何时候都不要，不要，不要使用 Object 以及类似的装箱类型。\n当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 Record&lt;string, unknown&gt; 或 Record&lt;string, any&gt; 表示对象，unknown[] 或 any[] 表示数组，(...args: any[]) =&gt; any表示函数这样。\n我们同样要避免使用&#123;&#125;。&#123;&#125;意味着任何非 null / undefined 的值，从这个层面上看，使用它和使用 any 一样恶劣。\n\n总结与预告这一节，我们一起学习了 TypeScript 中原始类型、对象类型、数组（元组）的类型标注，以及对数组的只读、对象类型属性的访问性修饰。这里的知识其实可以分为两类：\n\n与 JavaScript 概念基本一致的部分，如原始类型与数组类型需要重点掌握，但因为思维方式基本没有变化，所以你可以认为你就是在写更严格一些的 JavaScript。\n一些全新的概念，比如元组与 readonly 修饰等，这一部分你可能不会很快适应，需要稍微转换一下思维方式。我建议你可以从现在开始，有意识地在日常开发中去多多使用它们。\n\n另外，对于 readonly 这一修饰符，JavaScript 开发者可能需要一定的时间来理解和习惯，但它在工程层面确实是非常推荐的一种实践，可以使用只读标记来避免数组和对象被错误修改。当然，TypeScript 目前只能够帮助你在编译时做检查，类型信息在编译后都会被擦除，所以 readonly 并不会在实际运行时报错。\n学习完这一小节后，不妨找出你曾经的 JavaScript 项目，试试用本章学到的知识为这些 JavaScript 代码添加一些类型，再把某些场景下的数组换成元组，为部分对象类型的属性添加 readonly，来感受 TypeScript 代码的严格之美。\n在下一节我们要介绍的字面量类型以及枚举，在某些方面其实可以理解为是原始类型与对象类型的进一步延伸，也同样是日常会被重度使用的语法。在完成下一节的学习后，你就可以开始进一步地改造你的 JavaScript 项目，让那些类型变得更精确一些！\n扩展阅读unique symbolSymbol 在 JavaScript 中代表着一个唯一的值类型，它类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象 &#x2F; Class 内部属性的情况。而在 TypeScript 中，symbol 类型并不具有这一特性，一百个具有 symbol 类型的对象，它们的 symbol 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 unique symbol 这一类型声明，它是 symbol 类型的子类型，每一个 unique symbol 类型都是独一无二的。\ntypescriptconst uniqueSymbolFoo: unique symbol = Symbol(&quot;linbudu&quot;);\n\n// 类型不兼容\nconst uniqueSymbolBar: unique symbol = uniqueSymbolFoo;在 JavaScript 中，我们可以用 Symbol.for 方法来复用已创建的 Symbol，如 Symbol.for(&quot;linbudu&quot;) 会首先查找全局是否已经有使用 linbudu 作为 key 的 Symbol 注册，如果有，则返回这个 Symbol，否则才会创建新的 Symbol 。\n在 TypeScript 中，如果要引用已创建的 unique symbol 类型，则需要使用类型查询操作符 typeof ：\ntypescriptdeclare const uniqueSymbolFoo: unique symbol;\n\nconst uniqueSymbolBaz: typeof uniqueSymbolFoo = uniqueSymbolFoo;\n\n\n\n\n\n\n\n\n以上代码实际执行时会报错，这是因为 uniqueSymbolFoo 是一个仅存在于类型空间的值，这里只是为了进行示例~\n\n\n\n\n\n\n\n\n\n这里的 declare、typeof 等使用，都会在后面有详细地讲解。同时 unique symbol 在日常开发的使用非常少见，这里做了解就好~\n","slug":"103-ts","date":"2022-12-06T12:00:00.000Z","categories_index":"","tags_index":"ts","author_index":"Jude"},{"id":"8067607e93cde0ed0f0c6008751f5844","title":"102、项目部署通用方案","content":"之前用过阿里巴巴的云效（codeup）管理代码及部署，通过搭建流水线的方式，前端提交完代码之后(前端提交代码时不用 npm run build)，可以按照简单的步骤将前端代码打包、发布(包括开发环境、测试环境)。\n\n\n一、为什么需要打包项目？浏览器只能识别并运行 html、css、js 文件 。\n那么换句话而言，项目中的 .vue 文件，浏览器是不认识的。\n而打包的过程就是把 .vue 的 单文件组件 打包成 html、css、js 的文件，让浏览器进行识别，并展示我们的项目\n二、打包后的项目可以直接使用浏览器访问吗？通过 npm run build 打包项目之后，打包的文件会被放入到 dist 文件夹中，其实我们可以直接双击 index.html 文件，可以发现，浏览器是 无法 显示项目的。\nF12 查看控制台，发现抛出了很多错误。根据错误可以知道，无法显示项目的原因是一些文件找不到。\n文件找不到的原因是我们打开 dist 下的 index.html 文件，在浏览器的 URL 其实是一个 file 协议，对应着的文件路径就会变成盘符下的 xxx,在我们当前的盘符下没有对应的文件，项目自然是无法访问的。\n三、为什么需要服务？项目需要通过一个服务托管，从而避免出现模块无法被找到等原因。\n四、明确域名、DNS、公网 IP、服务器、Nginx 之间的关系\n域名：https://.baidu.com\nDNS：域名解析服务器\n公网 IP：服务器在网络中的唯一地址\n服务器：服务部署的电脑\nNginx：网页服务\n\n五、服务器的连接方式常见的连接服务器方式：1、云商控制台中进行远程链接2、SSH 工具（XShell）3、SSH 指令远程登录\n\n\n\n\n\n\n\n\n\nSSH 工具-XShell\n1、新建会话2、确定会话信息，协议为 SSH、主机为服务器 IP、端口号为 223、双击会话进行连接4、输入用户名（默认为 root）5、输入密码\n\n\n\n\n\n\n\n\n\nNginx 环境处理\n\nnginx 编译时依赖 gcc 环境\ntxtyum -y install gcc gcc-c++\n安装 prce，让 nginx 支持重写功能\ntxtyum -y install pcre*\n安装 zlib，nginx 使用 zlib 对 http 包内容进行 gzip 压缩\ntxtyum -y install zlib zlib-devel\n安装 openssl，用于通讯加密\ntxtyum -y install openssl openssl-devel\n进行 nginx 安装\n\n创建 nginx 文件夹\n\n下载 nginx 压缩包\ntxtwget https://nginx.org/download/nginx-1.11.5.tar.gz\n解压 nginx\ntxttar -zxvf  nginx-1.11.5.tar.gz\n进入 nginx-1.11.5 目录\ntxtcd nginx-1.11.5\n检查平台安装环境\ntxt./configure --prefix=/usr/local/nginx\n进行源码编译\ntxtmake\n安装 nginx\ntxtmake install\n查看 nginx 配置\ntxt/usr/local/nginx/sbin/nginx -t\n制作 nginx 软连接\n\n进入 usr/bin 目录\ntxtcd /usr/bin\n制作软连接\ntxtln -s /usr/local/nginx/sbin/nginx nginx\n接下来制作配置文件\n\n首先进入到 nginx 的默认配置文件中\ntxtvim /usr/local/nginx/conf/nginx.conf\n在最底部增加配置项（按下 i 进入 输入模式）\ntxtinclude /nginx/*.conf;\n按下 esc 键，通过 :wq! 保存并退出\n\n创建新的配置文件\ntxttouch /nginx/nginx.conf\n进入到 /root/nginx/nginx.conf 文件\ntxtvim /nginx/nginx.conf\n写入如下配置\njsserver &#123;\n    # 端口\n    listen       80;\n    # 域名\n    server_name  localhost;\n    # 资源地址\n    root   /nginx/dist/;\n    # 目录浏览\n    autoindex on;\n    # 缓存处理\n    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;\n    # 请求配置\n    location / &#123;\n        # 跨域\n        add_header Access-Control-Allow-Origin *;\n        # 返回 index.html\n        try_files $uri $uri/ /index.html;\n    &#125;\n&#125;\n通过 :wq! 保存退出\n\n在 root/nginx 中创建 dist 文件夹\ntxtmkdir /nginx/dist\n在 nginx/dist 中写入 index.html 进行测试\n\n通过 nginx -s reload 重启服务\n\n在 浏览器中通过，IP 测试访问\n\n\n","slug":"102-deploy","date":"2022-12-03T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"3ac83e6bede6fd33b2745525c8614d45","title":"101、富文本与markdown对文本的处理","content":"\n\n编辑文本的 2 种方式：1、富文本; 2、markdown。这 2 种编辑形式在前端中有很多第 3 方库。\n一、创建文本基本结构1-1 创建文本基本结构，主要分为三部分：1、article-create 页面：基本结构\n2、Editor 组件：富文本编辑器\n3、Markdown 组件： markdown 编辑器\nsrc 目录下的项目结构：\ntxtviews / article - create / components / Editor.vue;\n\nviews / article - create / components / Markdown.vue;\n\nviews / article - create / index.vue;1-2 创建文本父组件vue&lt;template&gt;\n  &lt;div class=&quot;article-create&quot;&gt;\n    &lt;el-card&gt;\n      &lt;el-input\n        class=&quot;title-input&quot;\n        placeholder=&quot;请输入标题&quot;\n        v-model=&quot;title&quot;\n        maxlength=&quot;20&quot;\n        clearable\n      &gt;\n      &lt;/el-input&gt;\n      &lt;el-tabs v-model=&quot;activeName&quot;&gt;\n        &lt;el-tab-pane label=&quot;markdown&quot; name=&quot;markdown&quot;&gt;\n          &lt;markdown&gt;&lt;/markdown&gt;\n        &lt;/el-tab-pane&gt;\n        &lt;el-tab-pane label=&quot;富文本&quot; name=&quot;editor&quot;&gt;\n          &lt;editor&gt;&lt;/editor&gt;\n        &lt;/el-tab-pane&gt;\n      &lt;/el-tabs&gt;\n    &lt;/el-card&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport Editor from &quot;./components/Editor.vue&quot;;\nimport Markdown from &quot;./components/Markdown.vue&quot;;\nimport &#123; ref &#125; from &quot;vue&quot;;\n\nconst activeName = ref(&quot;markdown&quot;);\nconst title = ref(&quot;&quot;);\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.title-input &#123;\n  margin-bottom: 20px;\n&#125;\n&lt;/style&gt;1-3 markdown 编辑器：tui.editor\n\n\n\n\n\n\n\n\n安装 plugin：\nshellnpm i @toast-ui/editor@3.0.2\n\n\n\n\n\n\n\n\n渲染 markdown 基本结构\nvue&lt;template&gt;\n  &lt;div class=&quot;markdown-container&quot;&gt;\n    &lt;!-- 渲染区 --&gt;\n    &lt;div id=&quot;markdown-box&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;bottom&quot;&gt;\n      &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmitClick&quot;&gt;提交&lt;/el-button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport &#123;&#125; from &quot;vue&quot;;\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.markdown-container &#123;\n  .bottom &#123;\n    margin-top: 20px;\n    text-align: right;\n  &#125;\n&#125;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n初始化 editor\njs&lt;script setup&gt;\nimport MkEditor from &#39;@toast-ui/editor&#39;\nimport &#39;@toast-ui/editor/dist/toastui-editor.css&#39;\n// 国际化部分\n// import &#39;@toast-ui/editor/dist/i18n/zh-cn&#39;\nimport &#123; onMounted &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\n// Editor实例\nlet mkEditor\n// 处理离开页面切换语言导致 dom 无法被获取\nlet el\nonMounted(() =&gt; &#123;\n  el = document.querySelector(&#39;#markdown-box&#39;)\n  initEditor()\n&#125;)\n\nconst store = useStore()\nconst initEditor = () =&gt; &#123;\n  mkEditor = new MkEditor(&#123;\n    el,\n    height: &#39;500px&#39;,\n    previewStyle: &#39;vertical&#39;\n  &#125;)\n\n  mkEditor.getMarkdown()\n&#125;\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n新建文本及新建文本的提交\n接口定义：\njs// src/api/article.js\n/**\n * 创建文章\n */\nexport const createArticle = (data) =&gt; &#123;\n  return request(&#123;\n    url: &quot;/article/create&quot;,\n    method: &quot;POST&quot;,\n    data,\n  &#125;);\n&#125;;\n/**\n * 编辑文章详情\n */\nexport const articleEdit = (data) =&gt; &#123;\n  return request(&#123;\n    url: &quot;/article/edit&quot;,\n    method: &quot;POST&quot;,\n    data,\n  &#125;);\n&#125;;\n\n\n\n\n\n\n\n\n\n注意：markwodn 和富文本最终都会处理提交事件，将提交合并到一个模块实现\n\njs// src/views/article-create/components/commit.js\nimport &#123; createArticle, articleEdit &#125; from &quot;@/api/article&quot;;\nimport &#123; ElMessage &#125; from &quot;element-plus&quot;;\n\nexport const commitArticle = async (data) =&gt; &#123;\n  const res = await createArticle(data);\n  ElMessage.success(&quot;创建成功！&quot;);\n  return res;\n&#125;;\nexport const editArticle = async (data) =&gt; &#123;\n  const res = await articleEdit(data);\n  ElMessage.success(&quot;编辑成功！&quot;);\n  return res;\n&#125;;\n\n// 将此方法导入到markdown.vue中\nimport &#123; commitArticle &#125; from &quot;./commit&quot;;\n\n\n\n\n\n\n\n\n提交文本事件的触发\njs// markdown.vue\nconst props = defineProps(&#123;\n  title: &#123;\n    required: true,\n    type: String\n  &#125;\n&#125;)\n\nconst emits = defineEmits([&#39;onSuccess&#39;])\n...\n// 处理提交\nconst onSubmitClick = async () =&gt; &#123;\n  // 创建文章\n  await commitArticle(&#123;\n    title: props.title,\n    content: mkEditor.getHTML()\n  &#125;)\n  // 重置一下\n  mkEditor.reset()\n  emits(&#39;onSuccess&#39;)\n&#125;\n\n\n\n\n\n\n\n\n父组件中处理传递的 title，处理 onSuccess 事件\njs// 创建成功\nconst onSuccess = () =&gt; &#123;\n  title.value = &quot;&quot;;\n&#125;;\n\n\n\n\n\n\n\n\nmarkdown 文本编辑\njs// 路径为src/views/article-detail/index.vue\n&lt;template&gt;\n  &lt;div class=&quot;article-detail-container&quot;&gt;\n    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123; detail.title &#125;&#125;&lt;/h2&gt;\n    &lt;div class=&quot;header&quot;&gt;\n      &lt;span class=&quot;author&quot;&gt;\n        作者：&#123;&#123; detail.author &#125;&#125;\n      &lt;/span&gt;\n      &lt;span class=&quot;time&quot;&gt;\n        时间: &#123;&#123; $filters.relativeTime(detail.publicDate) &#125;&#125;\n      &lt;/span&gt;\n      &lt;el-button type=&quot;text&quot; class=&quot;edit&quot; @click=&quot;onEditClick&quot;&gt;编辑&lt;/el-button&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;content&quot; v-html=&quot;detail.content&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\nimport &#123; useRoute, useRouter &#125; from &#39;vue-router&#39;\nimport &#123; articleDetail &#125; from &#39;@/api/article&#39;\n\n// 获取数据\nconst route = useRoute()\nconst articleId = route.params.id\nconst detail = ref(&#123;&#125;)\nconst getArticleDetail = async () =&gt; &#123;\n  detail.value = await articleDetail(articleId)\n&#125;\ngetArticleDetail()\n// 编辑\nconst router = useRouter()\nconst onEditClick = () =&gt; &#123;\n  router.push(`/article/editor/$&#123;articleId&#125;`)\n&#125;\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.article-detail-container &#123;\n  .title &#123;\n    font-size: 22px;\n    text-align: center;\n    padding: 12px 0;\n  &#125;\n\n  .header &#123;\n    padding: 26px 0;\n\n    .author &#123;\n      font-size: 14px;\n      color: #555666;\n      margin-right: 20px;\n    &#125;\n\n    .time &#123;\n      font-size: 14px;\n      color: #999aaa;\n      margin-right: 20px;\n    &#125;\n\n    .edit &#123;\n      float: right;\n    &#125;\n  &#125;\n\n  .content &#123;\n    font-size: 14px;\n    padding: 20px 0;\n    border-top: 1px solid #d4d4d4;\n    ;\n  &#125;\n&#125;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n将数据传递给 markdown 组件\njs&lt;markdown :title=&quot;title&quot; :detail=&quot;detail&quot; @onSuccess=&quot;onSuccess&quot;&gt;&lt;/markdown&gt;\n\n// 数据接收\nconst props = defineProps(&#123;\n  title: &#123;\n    required: true,\n    type: String\n  &#125;,\n  detail: &#123;\n    type: Object\n  &#125;\n&#125;)\n\n\n\n\n\n\n\n\n使用 watch 检测数据变化，存在 detail 时，将 detail 赋值给 mkEditor\njs// 编辑相关\nwatch(\n  () =&gt; props.detail,\n  (val) =&gt; &#123;\n    if (val &amp;&amp; val.content) &#123;\n      mkEditor.setHTML(val.content);\n    &#125;\n  &#125;,\n  &#123;\n    immediate: true,\n  &#125;\n);\n\n\n\n\n\n\n\n\nmarkdown 组件中处理提交事件\njs// 处理提交\nconst onSubmitClick = async () =&gt; &#123;\n  if (props.detail &amp;&amp; props.detail._id) &#123;\n    // 编辑文章\n    await editArticle(&#123;\n      id: props.detail._id,\n      title: props.title,\n      content: mkEditor.getHTML(),\n    &#125;);\n  &#125; else &#123;\n    // 创建文章\n    await commitArticle(&#123;\n      title: props.title,\n      content: mkEditor.getHTML(),\n    &#125;);\n  &#125;\n\n  mkEditor.reset();\n  emits(&quot;onSuccess&quot;);\n&#125;;1-4 富文本编辑器：wangEditor\n\n\n\n\n\n\n\n\n安装 plugin\nshellnpm i wangeditor@4.7.6\n\n\n\n\n\n\n\n\n富文本的基本组件结构和 markdown 组件基本一致\njs&lt;template&gt;\n  &lt;div class=&quot;editor-container&quot;&gt;\n    &lt;div id=&quot;editor-box&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;bottom&quot;&gt;\n      &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmitClick&quot;&gt;提交&lt;/el-button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport E from &#39;wangeditor&#39;\nimport &#123; onMounted, defineProps, defineEmits, watch &#125; from &#39;vue&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\nimport &#123; commitArticle, editArticle &#125; from &#39;./commit&#39;\n\nconst props = defineProps(&#123;\n  title: &#123;\n    required: true,\n    type: String\n  &#125;,\n  detail: &#123;\n    type: Object\n  &#125;\n&#125;)\n\nconst emits = defineEmits([&#39;onSuccess&#39;])\n\nconst store = useStore()\n\n// Editor实例\nlet editor\n// 处理离开页面切换语言导致 dom 无法被获取\nlet el\nonMounted(() =&gt; &#123;\n  el = document.querySelector(&#39;#editor-box&#39;)\n  initEditor()\n&#125;)\n\nconst initEditor = () =&gt; &#123;\n  editor = new E(el)\n  editor.config.zIndex = 1\n  // 菜单栏提示\n  editor.config.showMenuTooltips = true\n  editor.config.menuTooltipPosition = &#39;down&#39;\n\n  editor.create()\n&#125;\n\n// 编辑相关\nwatch(\n  () =&gt; props.detail,\n  val =&gt; &#123;\n    if (val &amp;&amp; val.content) &#123;\n      editor.txt.html(val.content)\n    &#125;\n  &#125;,\n  &#123;\n    immediate: true\n  &#125;\n)\n\n// 处理文本提交的事件\nconst onSubmitClick = async () =&gt; &#123;\n  if (props.detail &amp;&amp; props.detail._id) &#123;\n    // 编辑文章\n    await editArticle(&#123;\n      id: props.detail._id,\n      title: props.title,\n      content: editor.txt.html()\n    &#125;)\n  &#125; else &#123;\n    // 创建文章\n    await commitArticle(&#123;\n      title: props.title,\n      content: editor.txt.html()\n    &#125;)\n  &#125;\n\n  editor.txt.html(&#39;&#39;)\n  emits(&#39;onSuccess&#39;)\n&#125;\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.editor-container &#123;\n  .bottom &#123;\n    margin-top: 20px;\n    text-align: right;\n  &#125;\n&#125;\n&lt;/style&gt;\n","slug":"101-markdown","date":"2022-12-01T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"5eacc1a76b17657b3d8adae27636584f","title":"100、vuex的缺点及从0写一个vuex的思路","content":"\n\n1、用过 module，项目规模变大之后，单独一个 store 对象会过于庞大臃肿，通过模块方式可以拆分开来便于维护\n2、可以按之前规则单独编写子模块代码，然后在主文件中通过modules选项组织起来：createStore(&#123;modules:&#123;...&#125;&#125;)。\n3、不过使用时要注意访问子模块状态时需要加上注册时模块名：store.state.a.xxx，但同时getters、mutations和actions又在全局空间中，使用方式和之前一样。如果要做到完全拆分，需要在子模块加上namespace选项，此时再访问它们就要加上命名空间前缀。\n很显然，模块的方式可以拆分代码，但是缺点也很明显，就是使用起来比较繁琐复杂，容易出错。而且类型系统支持很差，不能给我们带来帮助。pinia 显然在这方面有了很大改进，是时候切换过去了。\n修改状态只能是mutations，actions只能通过提交mutation修改状态即可\n官方文档说：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，mutation 非常类似于事件：每个 mutation 都有一个字符串的类型 (type)**和一个** 回调函数 (handler) 。Action 类似于 mutation，不同在于：Action可以包含任意异步操作，但它不能修改状态， 需要提交mutation才能变更状态。\n因此，开发时，包含异步操作或者复杂业务组合时使用 action；需要直接修改状态则提交 mutation。但由于 dispatch 和 commit 是两个 API，容易引起混淆，实践中也会采用统一使用 dispatch action 的方式。\n调用 dispatch 和 commit 两个 API 时几乎完全一样，但是定义两者时却不甚相同，mutation 的回调函数接收参数是 state 对象。action 则是与 Store 实例具有相同方法和属性的上下文 context 对象，因此一般会解构它为&#123;commit, dispatch, state&#125;，从而方便编码。另外 dispatch 会返回 Promise 实例便于处理内部异步结果。\n实现上 commit(type)方法相当于调用options.mutations[type](state)；dispatch(type)方法相当于调用options.actions[type](store)，这样就很容易理解两者使用上的不同了。\n\n\n\n\n\n\n\n\n\n如何从零写一个 vuex？思路是什么？\n\n官方说vuex是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个vuex：\n要实现一个Store存储全局状态\n要提供修改状态所需 API：commit(type, payload), dispatch(type, payload)\n\n\n实现Store时，可以定义 Store 类，构造函数接收选项 options，设置属性 state 对外暴露状态，提供 commit 和 dispatch 修改属性 state。这里需要设置 state 为响应式对象，同时将 Store 定义为一个 Vue 插件。\ncommit(type, payload)方法中可以获取用户传入mutations并执行它，这样可以按用户提供的方法修改状态。 dispatch(type, payload)类似，但需要注意它可能是异步的，需要返回一个 Promise 给用户以处理异步结果。\n\njsclass Store &#123;\n  constructor(options) &#123;\n    this.state = reactive(options.state);\n    this.options = options;\n  &#125;\n  commit(type, payload) &#123;\n    this.options.mutations[type].call(this, this.state, payload);\n  &#125;\n&#125;vuex 如何监听数据的变化？\n\n\n\n\n\n\n\n\n\n可以通过 watch 选项或者 watch 方法监听状态\n可以使用 vuex 提供的 API：store.subscribe()\nwatch 选项方式，可以以字符串形式监听$store.state.xx；subscribe 方式，可以调用 store.subscribe(cb),回调函数接收 mutation 对象和 state 对象，这样可以进一步判断 mutation.type 是否是期待的那个，从而进一步做后续处理。\nwatch 方式简单好用，且能获取变化前后值，首选；subscribe 方法会被所有 commit 行为触发，因此还需要判断 mutation.type，用起来略繁琐，一般用于 vuex 插件中。\njs// watch\nconst app = createApp(&#123;\n  watch: &#123;\n    &quot;$store.state.counter&quot;() &#123;\n      console.log(&quot;counter change!&quot;);\n    &#125;,\n  &#125;,\n&#125;);\n// subscrible\nstore.subscribe((mutation, state) =&gt; &#123;\n  if (mutation.type === &quot;add&quot;) &#123;\n    console.log(&quot;counter change in subscribe()!&quot;);\n  &#125;\n&#125;);","slug":"100-vuex","date":"2022-11-29T12:00:00.000Z","categories_index":"","tags_index":"vuex","author_index":"Jude"},{"id":"480d09ccf327606485d7ffb7e81e17c3","title":"99、script标签写export为什么会报错?","content":"\n\n一、脚本和模块​ JavaScript 有 2 种源文件，一种叫做脚本，一种叫做模块。这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前版本中，就只有一种源文件格式，即脚本。\n​ 脚本是可以由浏览器或者 node 环境引入执行的，而模块智能有 JavaScript 代码用 import 引入执行。\n​ 脚本具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块是被动行的 JavaScript 代码段，是等待被调用的库。\n​ 实际上，模块和脚本之间的区别仅仅在于是否包含import和export。\n​ 脚本是一种兼容之前的版本的定义，在这个模式下，没有 import 就不需要处理加载.js 文件问题。\n​ 现代浏览器可以支持用 script 标签引入模块或者脚本，如果需要引入模块，必须给 script 标签添加 type&#x3D;”module”。如果引入脚本，则不需要 type。\njs&lt;script type=&quot;module&quot; scr=&quot;XXX.js&quot;&gt;&lt;/script&gt;​ script 标签如果不加 type&#x3D;“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会抛错。\n​ 脚本可以包含语句。模块包含 3 中内容：import 声明、export 声明、语句。\n​ import声明用法有 2 种：一个是直接import一个模块、另一个是&#96;&#96;带from的import&#96;（能引入模块里的一些信息）\njsimport &quot;module&quot;; // 引入一个模块\nimport m from &quot;module&quot;; // 把模块默认的导出值放入变量m​ 用法 1 直接 import 一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。\n​ 用法 2 带 from 的 import 意思是引入模块中的一部分信息，可以把他们变成本地的变量。\n​ 带 from 的 import 又分为 3 种用法：\njsimport x from &quot;./a.js&quot;; // 引入模块中导出的默认值\nimport &#123; a as x, modify &#125; from &quot;./a.js&quot;; // 引入模块中的变量\nimport * as x from &quot;./a.js&quot;; // 把模块中所有的变量以类型对象属性的方式引入\n\n// 第一种方式还可以跟后两种组合使用\nimport d, &#123; a as x, modify &#125; from &quot;./a.js&quot;;\nimport d, * as x from &quot;./a.js&quot;;​ 语法要求不带 as 的默认值永远在最前。注意，这里的变量实际上仍然可以受到原来模块的控制。\n示例代码：\n模块a\njsexport var a = 1;\nexport function modify() &#123;\n  a = 2;\n&#125;模块b\njsimport &#123; a, modify &#125; from &quot;./a.js&quot;;\nconsole.log(a);\nmodify();\nconsole.log(a);​ 当我们调用修改变量的函数后，b 模块变量也跟着发生了改变。这说明导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。\nexport声明：承担的是导出的任务。\n​ 模块中导出变量的方式有两种，一种是独立使用 export 声明，一种是直接在声明型语句前添加 export 关键字。\n​ 独立使用 export 声明就是一个 export 关键字加上变量名列表。\njsexport &#123; a, b, c &#125;;​ 我们也可以直接在声明型语句前添加 export 关键字，这里的 export 可以加在任何声明性质的语句之前\njsvar\nfunction(含async 和generator)\nclass\nlet\nconst​ export 还有一种特殊的用法，就是跟 default 联合使用。export default 表示到处一个默认变量值，它可以用于 function 和 class。这里导出的变量是没有名称的，可以使用 import x from ‘.&#x2F;a.js’ 这样的语法，在模块中引入。\n​ export default 还支持一种语法，后面跟一个表达式\njsvar a = &#123;&#125;;\nexport default a;​ 但是，这里的行为跟导出变量是不一致，这里导出的是值，导出的就是普通变量a的值，以后a的变化与导出的值就无关了，修改变量 a，不会使得其他模块中引入的 default 值发生改变。\n​ 在 import 语句前无法加入 export，但是我们可以直接使用 export from 语法\njsexport a from &quot;a.js&quot;;​ JavaScript 引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处。\n二、函数体\n\n\n\n\n\n\n\n\n执行函数的行为通常是在 JavaScript 代码执行时，注册宿主环境的某些事件触发的，而执行的过程，就是执行函数体（函数的花括号中间的部分）。\n下面的 setTimeout 函数注册了一个函数给宿主，当一定时间之后，宿主就会执行这个函数。\njssetTimeout(function () &#123;\n  console.log(&quot;go&quot;);\n&#125;, 10000);宿主会为这样的函数创建宏任务。宏任务中可能会执行的代码包括脚本、模块、函数体。\n函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了 return 语句可以用。\n普通函数体：\njsfunction foo() &#123;\n  //function body\n&#125;异步函数体：\njsasync function foo() &#123;\n  // function body\n&#125;生成器函数体：\njsfunction* foo() &#123;\n  // function body\n&#125;异步生成器函数体：\njsasync function* foo() &#123;\n  // function body\n&#125;上面的 4 种函数体的区别在于：能否使用 await 或者 yield\n类型 yield await return import&amp;export\n普通函数体 X X √ X\n异步函数体 X √ √ X\n生成器函数体 √ X √ X\n异步生成器函数体 √ √ √ X\n脚本 X X X X\n模块 X X X √\n三、预处理机制JavaScript 语法的全局机制：预处理和指令序言。这 2 个机制对于我们解释一些 JavaScript 的语法现象非常重要。预处理机制可以理解 var 等声明类语句行为，指令序言可以解释严格模式。\n预处理：JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。\nvar声明：var 声明永远作用于脚本、模块和函数体，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。\njsvar a = 1;\nfunction foo() &#123;\n  console.log(a); // undefined\n  var a = 2;\n&#125;\nfoo();上面的代码声明了一个脚本级别的 a，又声明了 foo 函数体级别的 a，函数体级的 var 出现在 console.log 语句之后。\n预处理过程在执行前，所以有函数体级的变量 a，就不会去访问外层作用域中的变量 a 了，而函数体级的变量 a 此时还没有复制，所以是 undefined。\njsvar a = 1;\nfunction foo() &#123;\n  console.log(a);\n  if (false) &#123;\n    var a = 2;\n  &#125;\n&#125;\nfoo();这段代码比上一段代码在 var a &#x3D; 2 之外多了一段 if，我们知道 if(false) 中的代码永远不会被执行，但是预处理阶段并不管这个，var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。所以这里结果跟前一段代码完全一样，我们会得到 undefined。\njsvar a = 1;\n\nfunction foo() &#123;\n  var o = &#123; a: 3 &#125;;\n  with (o) &#123;\n    var a = 2;\n  &#125;\n  console.log(o.a);\n  console.log(a);\n&#125;\n\nfoo();引入 with 语句，with(o)创建了一个作用域，并把 o 对象加入词法环境，在其中使用了 var a &#x3D; 2 语句。\n在预处理阶段，只认 var 中声明的变量，所以同样为 foo 的作用域创建了 a 这个变量，但是没有赋值。在执行阶段，当执行到 var a &#x3D; 2 时，作用域变成了 with 语句内，这时候的 a 被认为访问到了对象 o 的属性 a，所以最终执行的结果，我们得到了 2 和 undefined。\nfunction声明：function 声明的行为，在全局（脚本、模块和函数体），function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值。\njsconsole.log(foo);\nfunction foo() &#123;&#125;在声明函数 foo 之前，打印函数 foo,我们可以发现，已经是函数 foo 的值了。\n下面示例不再被提前赋值：\njsconsole.log(foo); // undefined\nif (true) &#123;\n  function foo() &#123;&#125;\n&#125;function 声明出现在 if 等语句中，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值。\n上述打印结果为 undefined，声明 function 在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。\n出现在 if 等语句中的 function，在 if 创建的作用域中仍然会被提前，产生赋值效果。\nclass声明：在全局的行为跟 function 和 var 都不一样。\n在 class 声明前使用 class 类名，会抛出错误：\njsconsole.log(c); // c is not defined\nclass c &#123;&#125;这个抛错很像是 class 没有预处理，但实际上并非如此。\n复杂一点的例子：\njsvar c = 1;\nfunction foo() &#123;\n  console.log(c);\n  class c &#123;&#125;\n&#125;\nfoo();上面的代码，把 class 放进了一个函数体中，在外层作用域中有变量 c。\n执行后，我们看到，仍然抛出了错误，如果去掉 class 声明，则会正常打印出 1，也就是说，出现在后面的 class 声明影响了前面语句的结果。这说明，class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。\nclass 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。\n四、指令序言机制\n\n\n\n\n\n\n\n\n脚本和模块都支持一种特别的语法，指令序言最早是为了 use strict 设计的，它规定了一种给 JavaScript 代码添加元信息的方式。\njs&quot;use strict&quot;;\nfunction f() &#123;\n  console.log(this);\n&#125;\nf.call(null);null 原封不动地被当做 this 值打印了出来，这是严格模式的特征。\n去掉严格模式，打印结果会变成 global。\n‘use strict’是 JavaScript 标准中规定的唯一一种指令序言，但是设计指令序言的目的是留给 JavaScript 的引擎和实现者一些统一的表达式，在静态规定扫描时指定 JavaScript 代码的一些特性。\nJavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。\njsfunction doSth() &#123;\n  //\n&#125;\n(&quot;use strict&quot;);\nvar a = 1;\n// .....‘use strct’没有出现在最前，所以不是指令序言。\njs&quot;use strict&quot;; // 单引号也是指令序言\nfunction doSth() &#123;\n  // ....\n&#125;","slug":"99-script标签写上export","date":"2022-11-27T12:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"ac9377bb15e422a5f96baff96a68759d","title":"98、基于JavaScript开发灵活的数据应用--基本数据处理(一)","content":"现代编程语言中，最基本的数据格式都会是字符串和数字。字符串用于表达人类文明的自然语言，数字用于表达量化世界的各种数值。\n\n\n一、字符串字符串的运用包括，字符串的创建、分割、大小写转换、拼接等\n1-1 创建字符串在 JavaScript 中创建一个字符串跟其他语言并没有较大的区别，可以分别使用 ‘、” 和 &#96; 作为边界标识。\njsconst str1 = &quot;string 1&quot;;\nconst str2 = &quot;string 2&quot;;\nconst str3 = `string 3`;从 JavaScript 的语法定义上 ‘ 和 “ 并没有太大的差别，但是 &#96; 的用途较为特殊。 同样可以以与 ‘ 和 “ 一样的使用方式使用，但也可以有更高级的用法。\n例如：\njsconst target = &quot;world&quot;;\nconst word = `hello $&#123;target&#125;`; // =&gt; hello world同时 &#96; 也可以用于创建一个“多行字符串”，即字符串内容中包含多行文本。\n1-2 分割字符串例如：如何将 “Hey jude,how is it going?” 转换为“hey jude how is it going”\n二者不同之处在于，去除了文本中的标点符号、数字、大写字母转换为小写字母。\n任务理解：去除标点符号、数字可以说是只保留英文字母，只需筛选出英文字母和空格即可，需要使用 ASCII 码进行甄别，大写字母的 ASCII 码范围为 65 到 90（即：A-Z），小写字母则为 97 到 122，空格的 ASCII 码为 32，换行符的 ASCII 码为 10。JS 中可以用 string.charCodeAt()方法获取字符串的 ASCII 码。\njsconst originalText = &quot;Hey jude,how is it going?&quot;;\nlet wordOnlyText = &quot;&quot;;\nfor (let i = 0; i &lt; originalText.length; i++) &#123;\n  const letter = originalText[i];\n  const asciiCode = letter.charCodeAt();\n  if (\n    (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) ||\n    (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) ||\n    asciiCode === 32\n  ) &#123;\n    wordOnlyText += letter;\n  &#125;\n&#125;\n\nconsole.log(wordOnlyText); // =&gt; Hey judehow is it going将大写字母转换为小写字母\nstring.charCodeAt() 方法来获取字符的 ASCII 码，那么自然也有对应的方法用于将 ASCII 码转换为对应字符 String.fromCharCode(code)。\n而从字母的 ASCII 码范围可以看到，将大写字母的 ASCII 码数值加上 32 便是其对应小写字母的 ASCII 码数值。\njslet lowerCaseText = &quot;&quot;;\n\nfor (let i = 0; i &lt; wordOnlyText.length; ++i) &#123;\n  const letter = wordOnlyText[i];\n  const asciiCode = letter.charCodeAt();\n\n  if (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) &#123;\n    lowerCaseText += String.fromCharCode(asciiCode + 32);\n  &#125; else &#123;\n    lowerCaseText += letter;\n  &#125;\n&#125;\n\nconsole.log(lowerCaseText); // =&gt; hey judehow is it going在 JavaScript 中早就已经内置了将文本中的大写字母转换为小写字母的 API 了 —— string.toLowerCase()。\njsconst lowerCaseText = wordOnlyText.toLowerCase();1-3 字符串的分割最主要用到的方法便是 string.split(separator)，其中这个 separator 则是定义了用于分割字符串内容的“分割符”。\njsconst originalText = `\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n`;\n\nlet wordOnlyText = &quot;&quot;;\n\nfor (let i = 0; i &lt; originalText.length; ++i) &#123;\n  const letter = originalText[i];\n  const asciiCode = letter.charCodeAt();\n\n  if (\n    (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) ||\n    (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) ||\n    asciiCode === 32\n  ) &#123;\n    wordOnlyText += letter;\n  &#125;\n&#125;\n\nconst lowerCaseText = wordOnlyText.toLowerCase();\n\nconst words = lowerCaseText.split(&quot; &quot;);\n\nconsole.log(words.length); //=&gt; 1601-4 字符串的拼接除了对字符串进行拆分以外，我们也常常需要将不同的信息通过各种方式拼装成一个完整的字符串信息。最常见的例子便是我们几乎每天都能遇见的，由程序自动发送的自动短信、自动邮件等。\n字符串之间的连接可以直接使用 + 运算符完成。\njsconst str1 = &quot;hello&quot;;\nconst str2 = &quot;world&quot;;\nconsole.log(str1 + &quot; &quot; + str2); // =&gt; &#39;hello world&#39;使用 + 运算符是最基本的字符串拼接方式，适用于数据量较小的字符串拼接。数据量大时，我们需要将多个数据量‘嵌入’到文本模板中，这种情况通常可以使用模板引擎来实现这个功能。\njsconst name = &quot;jude&quot;;\nconst level = &quot;Gold&quot;;\n\nconst message = `\nHello,$&#123;name&#125;.\nHere is LOL account,you are the $&#123;level&#125; of our games.\n`;\nconsole.log(message);\n// =&gt; Hello,jude.\n// Here is LOL account,you are the Gold of our games.loading…\n二、对象字面量2-1 对象的内容读取JavaScript 中对象内容读取十分的简单，如果属性键为字符串，且该字符串中只包含英文字母和下划线的话，可以直接用 . 来读取属性值。\njsconst person = &#123;\n  name: &quot;jude&quot;,\n  age: &quot;18&quot;,\n  skills: &#123;\n    title: &quot;vue&quot;,\n    desc: &quot;mvvm&quot;,\n    author: &quot;Evan You&quot;,\n  &#125;,\n  others: &quot;....&quot;,\n&#125;;\n\nconsole.log(person.name); // =&gt; jude\nconsole.log(person.skills.title); // =&gt; vue而当对象中所需要读取的目标属性键为数字、包含英文字母和下划线以外的字符串甚至是 Symbol 对象的时候，就需要使用 obj[key] 的形式来读取属性值了。\njsconst obj = &#123;\n  1: 2,\n  &quot;a b c&quot;: &quot;d e f&quot;,\n  [Symbol.for(&quot;foo&quot;)]: &quot;bar&quot;,\n&#125;;\nconsole.log(obj[1]); // =&gt; 2\nconsole.log(obj[&quot;a b c&quot;]); // =&gt; d e f\nconsole.log(obj[Symbol.for(&quot;foo&quot;)]); // =&gt; bar2-2 修改对象内容const 语句定义的对象是不能直接被替换，但是其中的内容依然是能被修改的。在 JavaScript 中存在着“引用”和“值”的概念区别，对对象内容进行修改跟进行读取类似，只是在读取语句后面加上 &#x3D;  即可。\njsconst obj = &#123;\n  foo: &quot;bar&quot;,\n  1: 2,\n  &quot;a b c&quot;: &quot;d e f&quot;,\n  [Symbol.for(&quot;foo&quot;)]: &quot;bar&quot;,\n&#125;;\nobj.foo = &quot;read&quot;;\nobj[1] = 3;\nconsole.log(obj.foo); // =&gt; read\nconsole.log(obj[1]); // =&gt; 3当你需要为一个对象添加新的属性时，也是通过同样的方式添加属性。\njsconst obj = &#123;&#125;;\nobj.foo = &quot;bar&quot;;\nobj[1] = 2;在一般情况下，无论是对对象进行添加、读取还是修改属性，都遵循着嵌套链完整的原则\njsconst outer = &#123;\n  inner: &#123;&#125;,\n&#125;;\nouter.inner.foo = &quot;bar&quot;; // success\nouter.something.bar = 1; // error三、数组3-1 数组增加内容向数组内增加内容包括向数组首端、末尾、中间添加新内容\n\n\n\n\n\n\n\n\n\n添加到末端：array.push()\njsconst array = [];\narray.push(1);\nconsole.log(array); // =&gt; [1]\n\narray.push(2, 3);\nconsole.log(array); // =&gt; [1,2,3]\nconsole.log(array.length); // 3\n\n\n\n\n\n\n\n\n添加到首端: array.unshift()\njsconst array = [4, 5];\narray.unshift(3);\nconsole.log(array); // =&gt; [3,4,5]\n\narray.unshift(1, 2);\nconsole.log(array); // =&gt; [1,2,3,4,5]\n\n\n\n\n\n\n\n\n添加到数组中间某一位置：array.splice(start,deleteCount,element,….)\n该方法第二个参数是 deleteCount，因为这个方法也可以用来删除数组中某一个位置开始的若干个元素，而当我们将这个参数设置为 0 的时候，该方法第三个以及后面的参数便会插入到下标为 start 的位置，后面的元素自动往后推导。\njsconst array = [1, 2, 6, 7];\narray.splice(2, 0, 3);\nconsole.log(array); // =&gt; [1,2,3,6,7]\n\narray.splice(3, 0, 4, 5);\nconsole.log(array); // =&gt; [1,2,3,4,5,6,7]\n\n\n\n\n\n\n\n\n查找内容：filter\nfilter 过滤器的逻辑便是定义一个过滤函数，该函数会有序地被传入数组中当前下标的元素，而它则需要返回该函数是否符合其过滤要求，即结果为 true 或 false。\njsconst array = [1, 2, 3, 4, 5, 6, 7, 8];\nconst evenNumbers = array.filter(function (x) &#123;\n  return x % 2 == 0;\n&#125;);\n\nconsole.log(evenNumbers); // =&gt; [2,4,6,8]\n\n\n\n\n\n\n\n\n删除内容：array.splice(start,deleteCount)\njsconst array = [1, 2, 3, 10, 4, 5];\narray.splice(3, 1);\nconsole.log(array); // =&gt; [1,2,3,4,5]\n\n\n\n\n\n\n\n\n更新内容\njsconst array = [1, 2, 3, 4, 5];\narray[0] = 10;\nconsole.log(array); // =&gt; [10,2,3,4,5]\n\n\n\n\n\n\n\n\n封装数组操作工具\n虽然绝大多数操作都可以直接使用 JavaScript 中自带的 API 来实现，但是如 array.splice() 这种方法看上去就很容易产生操作错误。那么为了避免开发中的失误，我们可以通过定义一个抽象对象来封装一个用于操作数组的工具库。\njsconst arrayUtils = &#123;\n  // 末端添加\n  append(array,...elements)&#123;\n    array.push(...elements)\n    return array\n  &#125;,\n  // 首端添加\n  prepend(array,...elements)&#123;\n    array.unshift(...elements)\n    return array\n  &#125;\n  // 中间插入\n  insert(array,index,...elements)&#123;\n    array.splice(index,0,...elements)\n    return array\n  &#125;\n  // 删除内容\n  remove(array,index)&#123;\n    array.splice(index,1)\n    return array\n  &#125;\n&#125;\n// 使用\nconst array = []\narrayUtils.append(array,3)\narrayUtils.prepend(array,1)\narrayUtils.insert(array,1,2)\nconsole.log(array) // =&gt; [1,2,3]\n\narrayUtils.remove(array,1)\nconsole.log(array) // =&gt; [1,3]3-2 数组转换&#x2F;聚合\n\n\n\n\n\n\n\n\nmap\njsconst array = [1, 2, 3, 4, 5];\nconst addedArray = array.map(function (x) &#123;\n  return x + 2;\n&#125;);\n\nconsole.log(addedArray); // =&gt; [3,4,5,6,7]\n\n\n\n\n\n\n\n\nreduce\njsconst array = [1,2,3,4]\nconst sumResult = array.reduce(function(a,b)&#123;\n  return a + b\n&#125;)\nconsole.log(sumResult) // =&gt; 10\n\nfunction multi(array)&#123;\n  return array.reduce(function(a,b)&#123;\n    return a * b\n  &#125;)\n&#125;\nconsole.log(multi(array))\n\n// 函数式编程，进一步抽象封装\nconst array = [1,2,3,4]\nfunction reduceFn(callback)&#123;\n  return funtion(array)&#123;\n    return array.reduce(callback)\n  &#125;\n&#125;\n\nconst sum = reduceFn(function(a,b)&#123;\n  return a + b\n&#125;)\nconst multi = reduceFn(function(a,b)&#123;\n  return a + b\n&#125;)\nconsole.log(sum(array)) // =&gt; 10\nconsole.log(multi(array)) // =&gt; 24\n\n\n\n\n\n\n\n\n1、将数组[1,2,3,4,5] 转换为 [‘a1’,’a2’,’a3’,’a4’,’a5’]\njsconst array = [1, 2, 3, 4, 5];\nconst result = array.map((item) =&gt; &#123;\n  return &quot;a&quot; + item;\n&#125;);\n\n\n\n\n\n\n\n\n将数组 [ 1, 2, 3, 4, 5 ] 转换为 [ ‘a1’, ‘b2’, ‘c3’, ‘d4’, ‘e5’ ]\njsconst array = [1, 2, 3, 4, 5];\nconst result = array.map((item) =&gt; &#123;\n  return String.fromCharCode(96 + item) + item;\n&#125;);\nconsole.log(result);\n\n\n\n\n\n\n\n\n将数组 [ 1, 2, 3, 4, 5 ] 转换为 [ 1, 4, 9, 16, 25 ]\njsconst array = [1, 2, 3, 4, 5];\nconst result = array.map((item) =&gt; &#123;\n  return Math.pow(item, 2);\n&#125;);\nconsole.log(result);\n\n\n\n\n\n\n\n\n查询 JavaScript 中 Array.prototype.map 方法的详细文档，并将数组 [ 0, 0, 0, 0, 0 ] 转换为 [ ‘A’, ‘B’, ‘C’, ‘D’, ‘E’ ]\njsconst array = [0, 0, 0, 0, 0];\nconst result = array.map((item, index) =&gt; &#123;\n  return String.fromCharCode(65 + index);\n&#125;);\nconsole.log(result);\n\n\n\n\n\n\n\n\n提取数组 [ 1, 2, 3, 4, 5 ] 中的 [ 2, 3, 4 ]\njsconst array = [1, 2, 3, 4, 5];\nconst result = array.filter((item) =&gt; &#123;\n  return item &gt; 1 &amp;&amp; item &lt; 5;\n&#125;);\nconsole.log(result);","slug":"98-js-string-number-array","date":"2022-11-26T12:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"e929ef3d125c37b460b3ea3c3fcb86e1","title":"97、promise代码为什么比setTimeout先执行？","content":"​ 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。\n\n\n一、JavaScript 的执行​ 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。\n​ 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。\n​ JavaScript 语言，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。\n二、宏观任务与微观任务​ JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。\n\n\n\n\n\n\n\n\n\n宏观任务的队列就相当于事件循环\n​ 在宏观任务中，JavaScript 的 promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此每个宏观任务中又包含一个微观任务队列。\nMacroTask\n​ microTask microTask microTask\nMacroTask\n​ microTask microTask microTask\nMacroTask\n​ 有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。\n三、Promise​ Promise 是 JavaScript 语言提供的一种标准化的异步管理方式。promise 总体思想是，需要进行 IO、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（promise 的 then 方法回调）\njsfunction sleep(duration) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(resolve, duration);\n  &#125;);\n&#125;\nsleep(1000).then(() =&gt; console.log(&quot;finished&quot;));sleep 函数的作用：等候传入参数指定的时长。\nPromise 的 then 回调是一个异步的执行过程。示例代码：\njsvar test = new Promise(function (resolve, reject) &#123;\n  console.log(&quot;a&quot;);\n  resolve();\n&#125;);\ntest.then(() =&gt; console.log(&quot;c&quot;));\nconsole.log(&quot;b&quot;);\n\n\n\n\n\n\n\n\n打印顺序：a &gt; b &gt; c\n​ 在进入 console.log(‘b’)之前，毫无疑问 test 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。\n当 setTimeout 和 Promise 混用，设置两段互不相干的异步操作：通过 setTimeout 执行 console.log(‘d’)，通过 Promise 执行 console.log(‘c’)\njsvar test = new Promise(function (resolve, reject) &#123;\n  console.log(&quot;a&quot;);\n  resolve();\n&#125;);\nsetTimeout(() =&gt; console.log(&quot;d&quot;), 0);\ntest.then(() =&gt; console.log(&quot;c&quot;));\nconsole.log(&quot;b&quot;);我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。\n理解微任务始终先于宏任务，示例：\njs// 执行一个耗时1秒的Promise\nsetTimeout(() =&gt; console.log(&quot;d&quot;), 0);\nvar r = new Promise(function (resolve, reject) &#123;\n  resolve();\n&#125;);\nr.then(() =&gt; &#123;\n  var begin = Date.now();\n  while (Date.now() - begin &lt; 1000);\n  console.log(&quot;c1&quot;);\n  new Promise(function (resolve, reject) &#123;\n    resolve();\n  &#125;).then(() =&gt; console.log(&quot;c2&quot;));\n&#125;);执行顺序：c1 &gt; c2 &gt; d 。 即使耗时 1 秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行，这可以很好的解释了微任务优先的原理。\n异步执行的顺序：\n\n\n\n\n\n\n\n\n\n1、分析有多少个宏任务\n2、在每个宏任务中，分析有多少个微任务\n3、根据调用次序，确定宏任务中的微任务执行次序\n4、根据宏任务的触发规则和调用次序，确定宏任务的执行次序\n5、确定整个顺序\n复杂的例子：\njsfunction sleep(duration) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    console.log(&quot;b&quot;);\n    setTimeout(resolve, duration);\n  &#125;);\n&#125;\nconsole.log(&quot;a&quot;);\nsleep(5000).then(() =&gt; console.log(&quot;c&quot;));执行顺序：a &gt; b &gt; c 。setTimeout 把整个代码分割成了 2 个宏观任务，，不论是 5 秒还是 0 秒，都是一样。\n第一个宏观任务中，包含了先后同步执行的 console.log(‘a’)和 console.log(‘b’)\nsetTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(‘c’),最终输出的顺序为： a b c 。\n​ Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async&#x2F;await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。\n四、async&#x2F;await​ async&#x2F;await 是 ES2016 新加入的特性，它提供了用 for、if 等结构来编写异步的方式。\n它的运行时基础是 Promise。\n​ async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。\nasync 函数是一种特殊语法，特征是在 function 关键字之前加上一个 async 关键字，这样就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。\njsfunction sleep(duration) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    setTimeout(resolve, duration);\n  &#125;);\n&#125;\nasync function foo() &#123;\n  console.log(&quot;a&quot;);\n  await sleep(2000);\n  console.log(&quot;b&quot;);\n&#125;\nfoo();​ async 函数强大之处在于，它是可以嵌套的。\njsfunction sleep(duration) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    setTimeout(resolve, duration);\n  &#125;);\n&#125;\nasync function foo(name) &#123;\n  await sleep(2000);\n  console.log(name);\n&#125;\nasync function foo2() &#123;\n  await foo(&quot;a&quot;);\n  await foo(&quot;b&quot;);\n&#125;","slug":"97-promise","date":"2022-11-23T12:00:00.000Z","categories_index":"","tags_index":"promise","author_index":"Jude"},{"id":"84e16524d6625869d4ec840ccc50d079","title":"96、vue3的使用transition时，不写根标签的警告","content":"terminal 中的警告：[Vue warn]: Component inside  renders non-element root node that cannot be animated.\n\n\nVue3 支持 template 可以不写根标签，transition 使用组件动画必须含根标签\n\n\n\n\n\n\n\n\n\n解决方法：组件加回根标签 div\n","slug":"96-transition","date":"2022-11-22T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"4a802e600b102f789dcec2a9924c790b","title":"95、vue3.0使用sass预处理器使用::v-deep深度选择器抛出警告","content":"terminal 中的警告：::v-deep usage as a combinator has been deprecated. Use :deep(＜ inner-selector ＞)警告解决\n\n\n警告的写法为：\ncss.redirect:hover &#123;\n  color: v-bind(linkHoverColor);\n&#125;\n\n::v-deep .no-redirect &#123;\n  color: #97a8be;\n  cursor: text;\n&#125;正确写法：\ncss.redirect:hover &#123;\n  color: v-bind(linkHoverColor);\n&#125;\n\n::v-deep(.no-redirect) &#123;\n  color: #97a8be;\n  cursor: text;\n&#125;","slug":"95-v-deep","date":"2022-11-21T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"1813ccd46442cde5aca0aaf935690ed9","title":"94、使用vue3+element-plus写后台管理系统：（四）","content":"包括后台项目 layout 基础架构、用户主动和被动退出、动态 menu 菜单、结构路由表、侧边菜单栏的收缩、组件状态驱动的动态 CSS 值\n\n\nlayout 基础架构布局\nlayout 基本布局结构包括：Menu 菜单栏、NavBar 顶部导航栏（包含个人信息）、Main（页面主要展示区域）\n1、登录成功进入首页之后，整个首页也就是上面说的分为三个部分创建三个对应的组件\n\n\n\n\n\n\n\n\n\nlayout&#x2F;components&#x2F;Sidebar&#x2F;index.vuelayout&#x2F;components&#x2F;Navbar.vuelayout&#x2F;components&#x2F;AppMain.vue\n2、在layout/index引入创建的三个组件jsimport Navbar from &quot;./components/Navbar.vue&quot;;\nimport Sidebar from &quot;./components/Sidebar/index.vue&quot;;\nimport AppMain from &quot;./components/AppMain&quot;;3、layout/index对应的布局html&lt;template&gt;\n  &lt;div class=&quot;app-wrapper&quot;&gt;\n    &lt;!-- 左侧 menu --&gt;\n    &lt;sidebar class=&quot;sidebar-container&quot; /&gt;\n    &lt;div class=&quot;main-container&quot;&gt;\n      &lt;div class=&quot;fixed-header&quot;&gt;\n        &lt;!-- 顶部的 navbar --&gt;\n        &lt;navbar /&gt;\n      &lt;/div&gt;\n      &lt;!-- 内容区 --&gt;\n      &lt;app-main /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;4、在 styles 文件夹下定义 3 个 scss 文件\n\n\n\n\n\n\n\n\nvariables.scss 定义常量mixin.scss 定义通用的 csssidebar.scss 处理 menu 菜单的样式\ncss// variables.scss\n// sidebar的样式  定义如下常量将其导出\n$menuText: #bfcbd9;\n$menuActiveText: #ffffff;\n$subMenuActiveText: #f4f4f5;\n\n$menuBg: #304156;\n$menuHover: #263445;\n\n$subMenuBg: #1f2d3d;\n$subMenuHover: #001528;\n\n$sideBarWidth: 210px;\n\n// JS 与 scss 共享变量，在 scss 中通过 :export 进行导出，在 js 中可通过 ESM 进行导入\n:export &#123;\n  menuText: $menuText;\n  menuActiveText: $menuActiveText;\n  subMenuActiveText: $subMenuActiveText;\n  menuBg: $menuBg;\n  menuHover: $menuHover;\n  subMenuBg: $subMenuBg;\n  subMenuHover: $subMenuHover;\n  sideBarWidth: $sideBarWidth;\n&#125;\n\n\n\n\n\n\n\n\n注意:这里是使用 :export{ } 方法将 css 常量导出\nmixin.scss\ncss// mixin.scss\n@mixin clearfix &#123;\n  &amp;:after &#123;\n    content: &quot;&quot;;\n    display: table;\n    clear: both;\n  &#125;\n&#125;\n\n@mixin scrollBar &#123;\n  &amp;::-webkit-scrollbar-track-piece &#123;\n    background: #d3dce6;\n  &#125;\n\n  &amp;::-webkit-scrollbar &#123;\n    width: 6px;\n  &#125;\n\n  &amp;::-webkit-scrollbar-thumb &#123;\n    background: #99a9bf;\n    border-radius: 20px;\n  &#125;\n&#125;\n\n@mixin relative &#123;\n  position: relative;\n  width: 100%;\n  height: 100%;\n&#125;sidebar.scss\n\n点我展示代码\n\ncss// sidebar.scss\n#app &#123;\n  .main-container &#123;\n    min-height: 100%;\n    transition: margin-left 0.28s;\n    margin-left: $sideBarWidth;\n    position: relative;\n  &#125;\n\n  .sidebar-container &#123;\n    transition: width 0.28s;\n    width: $sideBarWidth !important;\n    height: 100%;\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 1001;\n    overflow: hidden;\n\n    // 重置 element-plus 的css\n    .horizontal-collapse-transition &#123;\n      transition: 0s width ease-in-out, 0s padding-left ease-in-out,\n        0s padding-right ease-in-out;\n    &#125;\n\n    .scrollbar-wrapper &#123;\n      overflow-x: hidden !important;\n    &#125;\n\n    .el-scrollbar__bar.is-vertical &#123;\n      right: 0px;\n    &#125;\n\n    .el-scrollbar &#123;\n      height: 100%;\n    &#125;\n\n    &amp;.has-logo &#123;\n      .el-scrollbar &#123;\n        height: calc(100% - 50px);\n      &#125;\n    &#125;\n\n    .is-horizontal &#123;\n      display: none;\n    &#125;\n\n    a &#123;\n      display: inline-block;\n      width: 100%;\n      overflow: hidden;\n    &#125;\n\n    .svg-icon &#123;\n      margin-right: 16px;\n    &#125;\n\n    .sub-el-icon &#123;\n      margin-right: 12px;\n      margin-left: -2px;\n    &#125;\n\n    .el-menu &#123;\n      border: none;\n      height: 100%;\n      width: 100% !important;\n    &#125;\n\n    .is-active &gt; .el-submenu__title &#123;\n      color: $subMenuActiveText !important;\n    &#125;\n\n    &amp; .nest-menu .el-submenu &gt; .el-submenu__title,\n    &amp; .el-submenu .el-menu-item &#123;\n      min-width: $sideBarWidth !important;\n    &#125;\n  &#125;\n\n  .hideSidebar &#123;\n    .sidebar-container &#123;\n      width: 54px !important;\n    &#125;\n\n    .main-container &#123;\n      margin-left: 54px;\n    &#125;\n\n    .submenu-title-noDropdown &#123;\n      padding: 0 !important;\n      position: relative;\n\n      .el-tooltip &#123;\n        padding: 0 !important;\n\n        .svg-icon &#123;\n          margin-left: 20px;\n        &#125;\n\n        .sub-el-icon &#123;\n          margin-left: 19px;\n        &#125;\n      &#125;\n    &#125;\n\n    .el-submenu &#123;\n      overflow: hidden;\n\n      &amp; &gt; .el-submenu__title &#123;\n        padding: 0 !important;\n\n        .svg-icon &#123;\n          margin-left: 20px;\n        &#125;\n\n        .sub-el-icon &#123;\n          margin-left: 19px;\n        &#125;\n\n        .el-submenu__icon-arrow &#123;\n          display: none;\n        &#125;\n      &#125;\n    &#125;\n\n    .el-menu--collapse &#123;\n      .el-submenu &#123;\n        &amp; &gt; .el-submenu__title &#123;\n          &amp; &gt; span &#123;\n            height: 0;\n            width: 0;\n            overflow: hidden;\n            visibility: hidden;\n            display: inline-block;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n\n  .el-menu--collapse .el-menu .el-submenu &#123;\n    min-width: $sideBarWidth !important;\n  &#125;\n\n  .withoutAnimation &#123;\n    .main-container,\n    .sidebar-container &#123;\n      transition: none;\n    &#125;\n  &#125;\n&#125;\n\n.el-menu--vertical &#123;\n  &amp; &gt; .el-menu &#123;\n    .svg-icon &#123;\n      margin-right: 16px;\n    &#125;\n    .sub-el-icon &#123;\n      margin-right: 12px;\n      margin-left: -2px;\n    &#125;\n  &#125;\n\n  // 菜单项过长时\n\n  &gt; .el-menu--popup &#123;\n    max-height: 100vh;\n    overflow-y: auto;\n\n    &amp;::-webkit-scrollbar-track-piece &#123;\n      background: #d3dce6;\n    &#125;\n\n    &amp;::-webkit-scrollbar &#123;\n      width: 6px;\n    &#125;\n\n    &amp;::-webkit-scrollbar-thumb &#123;\n      background: #99a9bf;\n      border-radius: 20px;\n    &#125;\n  &#125;\n&#125;\n\n5、创建的三个 scss 文件导入到 styles&#x2F;index.scsscss// index.scss\n@import &quot;./variables.scss&quot;;\n@import &quot;./mixin.scss&quot;;\n@import &quot;./sidebar.scss&quot;;layout/index.vue写入样式\ncss&lt;style lang=&quot;scss&quot; scoped&gt;\n@import &#39;@/styles/mixin.scss&#39;;\n@import &#39;@/styles/variables.scss&#39;;\n\n.app-wrapper &#123;\n  @include clearfix;\n  position: relative;\n  height: 100%;\n  width: 100%;\n&#125;\n\n.fixed-header &#123;\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 9;\n  width: calc(100% - #&#123;$sideBarWidth&#125;);\n&#125;\n&lt;/style&gt;6、侧边栏要实现主题更换功能，sidebar 赋值动态背景颜色html&lt;template&gt;\n  ...\n  &lt;!-- 左侧 menu --&gt;\n  &lt;sidebar\n    class=&quot;sidebar-container&quot;\n    :style=&quot;&#123; backgroundColor: variables.menuBg &#125;&quot;\n  /&gt;\n  ...\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import variables from &quot;@/styles/variables.scss&quot;;\n&lt;/script&gt;7、Navbar、Sidebar、AppMain 组件初始化代码占位及样式修改需要处理 AppMain 组件和 Navbar 组件重叠问题\nhtml&lt;template&gt;\n  &lt;div class=&quot;app-main&quot;&gt;AppMain&lt;/div&gt;\n&lt;/template&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .app-main &#123;\n    min-height: calc(100vh - 50px);\n    width: 100%;\n    position: relative;\n    overflow: hidden;\n    padding: 61px 20px 20px 20px;\n    box-sizing: border-box;\n  &#125;\n&lt;/style&gt;8、用户个人信息这里需要处理一下用户个人信息展示\napi/sys.js文件定义方法、axios 请求拦截器对 token 进行 header 注入\njs/**\n * 获取用户信息\n */\nexport const getUserInfo = () =&gt; &#123;\n  return request(&#123;\n    url: &quot;/sys/profile&quot;,\n  &#125;);\n&#125;;\n\n// utils/request.js\nimport store from &quot;@/store&quot;;\n// 请求拦截器\nservice.interceptors.request.use(\n  (config) =&gt; &#123;\n    // 在这个位置需要统一的去注入token\n    if (store.getters.token) &#123;\n      // 如果token存在 注入token\n      config.headers.Authorization = `Bearer $&#123;store.getters.token&#125;`;\n    &#125;\n    return config; // 必须返回配置\n  &#125;,\n  (error) =&gt; &#123;\n    return Promise.reject(error);\n  &#125;\n);定义调用接口的动作store/modules/user.js\njsimport &#123; login, getUserInfo &#125; from &#39;@/api/sys&#39;\n...\nexport default &#123;\n  namespaced: true,\n  state: () =&gt; (&#123;\n    ...\n    userInfo: &#123;&#125;\n  &#125;),\n  mutations: &#123;\n    ...\n    setUserInfo(state, userInfo) &#123;\n      state.userInfo = userInfo\n    &#125;\n  &#125;,\n  actions: &#123;\n    ...\n    async getUserInfo(context) &#123;\n      const res = await getUserInfo()\n      this.commit(&#39;user/setUserInfo&#39;, res)\n      return res\n    &#125;\n  &#125;\n&#125;在权限拦截时触发的动作permission.js\njs    if (to.path === &#39;/login&#39;) &#123;\n      ...\n    &#125; else &#123;\n      // 判断用户资料是否获取\n      // 若不存在用户信息，则需要获取用户信息\n      if (!store.getters.hasUserInfo) &#123;\n        // 触发获取用户信息的 action\n        await store.dispatch(&#39;user/getUserInfo&#39;)\n      &#125;\n      next()\n    &#125;\n  &#125;写入判断用户信息store/getters.js\njsconst getters = &#123;\n  ...\n  userInfo: state =&gt; state.user.userInfo,\n  /**\n   * @returns true 表示已存在用户信息\n   */\n  hasUserInfo: state =&gt; &#123;\n    return JSON.stringify(state.user.userInfo) !== &#39;&#123;&#125;&#39;\n  &#125;\n&#125;9、element-plus 的 dropdown avatar 组件实现用户头像信息及用户主动退出功能用户头像功能及下拉菜单栏\n\n点我展示代码\n\nhtml// layout/components/navbar.vue\n&lt;template&gt;\n  &lt;div class=&quot;navbar&quot;&gt;\n    &lt;div class=&quot;right-menu&quot;&gt;\n      &lt;!-- 头像 --&gt;\n      &lt;el-dropdown class=&quot;avatar-container&quot; trigger=&quot;click&quot;&gt;\n        &lt;div class=&quot;avatar-wrapper&quot;&gt;\n          &lt;el-avatar\n            shape=&quot;square&quot;\n            :size=&quot;40&quot;\n            :src=&quot;$store.getters.userInfo.avatar&quot;\n          &gt;&lt;/el-avatar&gt;\n        &lt;/div&gt;\n        &lt;template #dropdown&gt;\n          &lt;el-dropdown-menu class=&quot;user-dropdown&quot;&gt;\n            &lt;router-link to=&quot;/&quot;&gt;\n              &lt;el-dropdown-item&gt; 首页 &lt;/el-dropdown-item&gt;\n            &lt;/router-link&gt;\n            &lt;el-dropdown-item divided&gt; 退出登录 &lt;/el-dropdown-item&gt;\n          &lt;/el-dropdown-menu&gt;\n        &lt;/template&gt;\n      &lt;/el-dropdown&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import &#123;&#125; from &quot;vue&quot;;\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .navbar &#123;\n    height: 50px;\n    overflow: hidden;\n    position: relative;\n    background: #fff;\n    box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);\n\n    .right-menu &#123;\n      display: flex;\n      align-items: center;\n      float: right;\n      padding-right: 16px;\n\n      ::v-deep .avatar-container &#123;\n        cursor: pointer;\n        .avatar-wrapper &#123;\n          margin-top: 5px;\n          position: relative;\n          n .el-avatar &#123;\n            --el-avatar-background-color: none;\n            margin-right: 12px;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&lt;/style&gt;\n\n10、主动退出功能:在 store&#x2F;moduels&#x2F;user.js 中，清除当前用户缓存数据、清除用户权限相关配置、返回到登录页jsimport router from &#39;@/router&#39;\n\nlogout() &#123;\n    this.commit(&#39;user/setToken&#39;, &#39;&#39;)\n    this.commit(&#39;user/setUserInfo&#39;, &#123;&#125;)\n    removeAllItem()\n    router.push(&#39;/login&#39;)\n&#125;退出按钮点击事件，触发 logout 的 action\njsimport &#123; useStore &#125; from &quot;vuex&quot;;\n\nconst store = useStore();\nconst logout = () =&gt; &#123;\n  store.dispatch(&quot;user/logout&quot;);\n&#125;;11、被动退出功能：token 过期、单一账户同时登录token 表示一个用户的身份令牌，对服务端而言，只认令牌不认人，所以说一旦其他人获取了你的 token，那么可以伪装成你，来获取对应的敏感数据。\n为了保证用户的信息安全，那么对于 token 而言就被制定了很多安全策略。token 的安全策略：动态 token、刷新 token、失效 token\n选择时效 token：服务端处理 token 时效的同时，在前端主动介入 token 时效的处理中，从而保证用户信息的安全性。\n实现方案：\n\n\n\n\n\n\n\n\n\n1、在用户登录时，记录当前登录时间2、制定失效时长3、接口调用时，根据当前时间对比登录时间，看是否超过了时效时长。如果未超过，则正常进行后续操作；如果超过，则进行退出登录操作\njs// utils/auth.js\nimport &#123; TIME_STAMP, TOKEN_TIMEOUT_VALUE &#125; from &quot;@/constant&quot;;\nimport &#123; setItem, getItem &#125; from &quot;@/utils/storage&quot;;\n/**\n * 获取时间戳\n */\nexport function getTimeStamp() &#123;\n  return getItem(TIME_STAMP);\n&#125;\n/**\n * 设置时间戳\n */\nexport function setTimeStamp() &#123;\n  setItem(TIME_STAMP, Date.now());\n&#125;\n/**\n * 是否超时\n */\nexport function isCheckTimeout() &#123;\n  // 当前时间戳\n  var currentTime = Date.now();\n  // 缓存时间戳\n  var timeStamp = getTimeStamp();\n  return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE;\n&#125;\n\n// token时间戳\nexport const TIME_STAMP = &quot;timeStamp&quot;;\n// 超时时长(毫秒) 两小时\nexport const TOKEN_TIMEOUT_VALUE = 2 * 3600 * 1000;用户登录成功之后设置时间，到 store&#x2F;user.js 的 login 中：\njsimport &#123; setTimeStamp &#125; from &#39;@/utils/auth&#39;\n\nlogin(context, userInfo) &#123;\n      ...\n      return new Promise((resolve, reject) =&gt; &#123;\n        ...\n          .then(data =&gt; &#123;\n            ...\n            // 保存登录时间\n            setTimeStamp()\n            resolve()\n          &#125;)\n      &#125;)\n    &#125;,在utils/request对应的请求拦截器中进行主动介入\njsimport &#123; isCheckTimeout &#125; from &#39;@/utils/auth&#39;\n\nif (store.getters.token) &#123;\n      if (isCheckTimeout()) &#123;\n        // 登出操作\n        store.dispatch(&#39;user/logout&#39;)\n        return Promise.reject(new Error(&#39;token 失效&#39;))\n      &#125;\n      ...\n    &#125;\n\n// 响应拦截器\nservice.interceptors.response.use(\n  response =&gt; &#123;\n    ...\n  &#125;,\n  error =&gt; &#123;\n    // 处理 token 超时问题\n    if (\n      error.response &amp;&amp;\n      error.response.data &amp;&amp;\n      error.response.data.code === 401\n    ) &#123;\n      // token超时\n      store.dispatch(&#39;user/logout&#39;)\n    &#125;\n    ElMessage.error(error.message) // 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)12、临时menu菜单layout&#x2F;Sidebar&#x2F;SidebarMenu.vue\nhtml&lt;template&gt;\n  &lt;!-- 一级 menu 菜单 --&gt;\n  &lt;el-menu\n    :uniqueOpened=&quot;true&quot;\n    default-active=&quot;2&quot;\n    background-color=&quot;#545c64&quot;\n    text-color=&quot;#fff&quot;\n    active-text-color=&quot;#ffd04b&quot;\n  &gt;\n    &lt;!-- 子集 menu 菜单 --&gt;\n    &lt;el-submenu index=&quot;1&quot;&gt;\n      &lt;template #title&gt;\n        &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;\n        &lt;span&gt;导航一&lt;/span&gt;\n      &lt;/template&gt;\n      &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;\n      &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;\n    &lt;/el-submenu&gt;\n    &lt;!-- 具体菜单项 --&gt;\n    &lt;el-menu-item index=&quot;4&quot;&gt;\n      &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;\n      &lt;template #title&gt;导航四&lt;/template&gt;\n    &lt;/el-menu-item&gt;\n  &lt;/el-menu&gt;\n&lt;/template&gt;layout&#x2F;Sidebar&#x2F;index 导入该组件\njs&lt;template&gt;\n  &lt;div class=&quot;&quot;&gt;\n    &lt;h1&gt;Admin&lt;/h1&gt;\n    &lt;el-scrollbar&gt;\n      &lt;sidebar-menu&gt;&lt;/sidebar-menu&gt;\n    &lt;/el-scrollbar&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport SidebarMenu from &#39;./SidebarMenu&#39;\nimport &#123;&#125; from &#39;vue&#39;\n&lt;/script&gt;生成一个临时的 menu 菜单，从这个临时的 menu 菜单可以看出，el-menu 分为三部分：\n\n\n\n\n\n\n\n\n\nel-menu：整个 menu 菜单el-sub-menu:子集 menu 菜单el-menu-item:具体菜单项\n13、动态 menu 菜单处理\n\n\n\n\n\n\n\n\n动态 menu 菜单主要和动态路由表配合来实现用户权限的（后续需要完成用户权限）。动态 menu 菜单指的是：根据路由表的配置，自动生成对应的 menu 菜单，当路由表发生变化时，menu 菜单自动发生变化。\n实现步骤：\n\n\n\n\n\n\n\n\n\n1、定义路由表对应的 menu 菜单规则（核心步骤）2、根据规则制定路由表3、根据规则，一路路由表生成 menu 菜单\n上面步骤 1 的菜单规则制定：\n\n\n\n\n\n\n\n\n\n1、如果meta &amp;&amp; meta.title &amp;&amp; meta.icon ：则显示在 menu 菜单中，其中 title 为显示的内容，icon 为显示的图标。如果存在 children：则展示子菜单 el-sub-menu；否则展示 el-menu-item。2、不显示在 menu 中\n14、创建页面组件views 文件夹下创建页面：（1）、创建文章:article-create（2）、文章详情:article-detail（3）、文章列表:article-ranking（4）、401 和 404 页面:error-page&#x2F;401.vue 404.vue（5）、导入:import（6）、权限列表:permission-list（7）、个人中心:profile（8）、角色列表:role-list（9）、用户信息:user-info（10）、用户管理:user-manage\n15、用户权限处理需要先对路由表进行划分：私有路由表 privateRoutes(权限路由)、公有路由表 publicRoutes(非权限路由)\nrouter/index.js\n\n显示详细代码\n\njs// 私有路由表\nconst privateRoutes = [\n  &#123;\n    path: &quot;/user&quot;,\n    component: layout,\n    redirect: &quot;/user/manage&quot;,\n    meta: &#123;\n      title: &quot;user&quot;,\n      icon: &quot;personnel&quot;,\n    &#125;,\n    children: [\n      &#123;\n        path: &quot;/user/manage&quot;,\n        component: () =&gt; import(&quot;@/views/user-manage/index&quot;),\n        meta: &#123;\n          title: &quot;userManage&quot;,\n          icon: &quot;personnel-manage&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/user/role&quot;,\n        component: () =&gt; import(&quot;@/views/role-list/index&quot;),\n        meta: &#123;\n          title: &quot;roleList&quot;,\n          icon: &quot;role&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/user/permission&quot;,\n        component: () =&gt; import(&quot;@/views/permission-list/index&quot;),\n        meta: &#123;\n          title: &quot;permissionList&quot;,\n          icon: &quot;permission&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/user/info/:id&quot;,\n        name: &quot;userInfo&quot;,\n        component: () =&gt; import(&quot;@/views/user-info/index&quot;),\n        meta: &#123;\n          title: &quot;userInfo&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/user/import&quot;,\n        name: &quot;import&quot;,\n        component: () =&gt; import(&quot;@/views/import/index&quot;),\n        meta: &#123;\n          title: &quot;excelImport&quot;,\n        &#125;,\n      &#125;,\n    ],\n  &#125;,\n  &#123;\n    path: &quot;/article&quot;,\n    component: layout,\n    redirect: &quot;/article/ranking&quot;,\n    meta: &#123;\n      title: &quot;article&quot;,\n      icon: &quot;article&quot;,\n    &#125;,\n    children: [\n      &#123;\n        path: &quot;/article/ranking&quot;,\n        component: () =&gt; import(&quot;@/views/article-ranking/index&quot;),\n        meta: &#123;\n          title: &quot;articleRanking&quot;,\n          icon: &quot;article-ranking&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/article/:id&quot;,\n        component: () =&gt; import(&quot;@/views/article-detail/index&quot;),\n        meta: &#123;\n          title: &quot;articleDetail&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/article/create&quot;,\n        component: () =&gt; import(&quot;@/views/article-create/index&quot;),\n        meta: &#123;\n          title: &quot;articleCreate&quot;,\n          icon: &quot;article-create&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/article/editor/:id&quot;,\n        component: () =&gt; import(&quot;@/views/article-create/index&quot;),\n        meta: &#123;\n          title: &quot;articleEditor&quot;,\n        &#125;,\n      &#125;,\n    ],\n  &#125;,\n];\n// 公开路由表\nconst publicRoutes = [\n  &#123;\n    path: &quot;/login&quot;,\n    component: () =&gt; import(&quot;@/views/login/index&quot;),\n  &#125;,\n  &#123;\n    path: &quot;/&quot;,\n    // 注意：带有路径“/”的记录中的组件“默认”是一个不返回 Promise 的函数\n    component: layout,\n    redirect: &quot;/profile&quot;,\n    children: [\n      &#123;\n        path: &quot;/profile&quot;,\n        name: &quot;profile&quot;,\n        component: () =&gt; import(&quot;@/views/profile/index&quot;),\n        meta: &#123;\n          title: &quot;profile&quot;,\n          icon: &quot;el-icon-user&quot;,\n        &#125;,\n      &#125;,\n      &#123;\n        path: &quot;/404&quot;,\n        name: &quot;404&quot;,\n        component: () =&gt; import(&quot;@/views/error-page/404&quot;),\n      &#125;,\n      &#123;\n        path: &quot;/401&quot;,\n        name: &quot;401&quot;,\n        component: () =&gt; import(&quot;@/views/error-page/401&quot;),\n      &#125;,\n    ],\n  &#125;,\n];\n\nconst router = createRouter(&#123;\n  history: createWebHashHistory(),\n  routes: [...publicRoutes, ...privateRoutes],\n&#125;);\n\n\n\n\n\n\n\n\n\n\n注意：要在 layout/AppMain.vue 中设置路由出口\nhtml&lt;template&gt;\n  &lt;div class=&quot;app-main&quot;&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;16、解析路由表，获取结构化数据数据结构为\n\n显示详细代码\n\njson[\n  &#123;\n    &quot;title&quot;: &quot;个人中心&quot;,\n    &quot;path&quot;: &quot;&quot;\n  &#125;,\n  &#123;\n    &quot;title&quot;: &quot;用户&quot;,\n    &quot;children&quot;: [\n      &#123;\n        &quot;title&quot;: &quot;员工管理&quot;,\n        &quot;path&quot;: &quot;&quot;\n      &#125;,\n      &#123;\n        &quot;title&quot;: &quot;角色列表&quot;,\n        &quot;path&quot;: &quot;&quot;\n      &#125;,\n      &#123;\n        &quot;title&quot;: &quot;权限列表&quot;,\n        &quot;path&quot;: &quot;&quot;\n      &#125;\n    ]\n  &#125;,\n  &#123;\n    &quot;title&quot;: &quot;文章&quot;,\n    &quot;children&quot;: [\n      &#123;\n        &quot;title&quot;: &quot;文章排名&quot;,\n        &quot;path&quot;: &quot;&quot;\n      &#125;,\n      &#123;\n        &quot;title&quot;: &quot;创建文章&quot;,\n        &quot;path&quot;: &quot;&quot;\n      &#125;\n    ]\n  &#125;\n]\n\n获取路由表数据的 2 中方式：\n\n\n\n\n\n\n\n\n\n1、router.options.routes:初始路由列表2、router.getRoutes()：获取所有路由记录的完整列表（选择此种方法）\n在 layout&#x2F;components&#x2F;Sidebar&#x2F;SidebarMenu 中\njs&lt;script setup&gt;\n  import &#123;useRouter&#125; from &#39;vue-router&#39; const router = useRouter()\n  console.log(router.getRoutes()) // 这里返回的是一个完整的路由表\n&lt;/script&gt;打印的结果是一个完整的路由表，里面存在一些问题：\n\n\n\n\n\n\n\n\n\n存在重复的路由数据不满足该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon 的数据不应该存在\n17、处理数据结构问题创建utils/route.js，里面 2 个函数方法：filterRouters()&#x2F;generateMenus()很重要\n\n显示完整代码\n\njsimport path from &quot;path&quot;;\n\n/**\n * 返回所有子路由\n */\nconst getChildrenRoutes = (routes) =&gt; &#123;\n  const result = [];\n  routes.forEach((route) =&gt; &#123;\n    if (route.children &amp;&amp; route.children.length &gt; 0) &#123;\n      result.push(...route.children);\n    &#125;\n  &#125;);\n  return result;\n&#125;;\n/**\n * 处理脱离层级的路由：某个一级路由为其他子路由，则剔除该一级路由，保留路由层级\n * @param &#123;*&#125; routes router.getRoutes()\n */\nexport const filterRouters = (routes) =&gt; &#123;\n  const childrenRoutes = getChildrenRoutes(routes);\n  return routes.filter((route) =&gt; &#123;\n    return !childrenRoutes.find((childrenRoute) =&gt; &#123;\n      return childrenRoute.path === route.path;\n    &#125;);\n  &#125;);\n&#125;;\n\n/**\n * 判断数据是否为空值\n */\nfunction isNull(data) &#123;\n  if (!data) return true;\n  if (JSON.stringify(data) === &quot;&#123;&#125;&quot;) return true;\n  if (JSON.stringify(data) === &quot;[]&quot;) return true;\n  return false;\n&#125;\n/**\n * 根据 routes 数据，返回对应 menu 规则数组\n */\nexport function generateMenus(routes, basePath = &quot;&quot;) &#123;\n  const result = [];\n  // 遍历路由表\n  routes.forEach((item) =&gt; &#123;\n    // 不存在 children &amp;&amp; 不存在 meta 直接 return\n    if (isNull(item.meta) &amp;&amp; isNull(item.children)) return;\n    // 存在 children 不存在 meta，进入迭代\n    if (isNull(item.meta) &amp;&amp; !isNull(item.children)) &#123;\n      result.push(...generateMenus(item.children));\n      return;\n    &#125;\n    // 合并 path 作为跳转路径\n    const routePath = path.resolve(basePath, item.path);\n    // 路由分离之后，存在同名父路由的情况，需要单独处理\n    let route = result.find((item) =&gt; item.path === routePath);\n    if (!route) &#123;\n      route = &#123;\n        ...item,\n        path: routePath,\n        children: [],\n      &#125;;\n\n      // icon 与 title 必须全部存在\n      if (route.meta.icon &amp;&amp; route.meta.title) &#123;\n        // meta 存在生成 route 对象，放入 arr\n        result.push(route);\n      &#125;\n    &#125;\n\n    // 存在 children 进入迭代到children\n    if (item.children) &#123;\n      route.children.push(...generateMenus(item.children, route.path));\n    &#125;\n  &#125;);\n  return result;\n&#125;\n\n18、SidebarMenu 调用 filterRouters、generateMenus 方法js&lt;script setup&gt;\nimport &#123; computed &#125; from &#39;vue&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\nimport &#123; filterRouters, generateMenus &#125; from &#39;@/utils/route&#39;\n\nconst router = useRouter()\nconst routes = computed(() =&gt; &#123;\n  const filterRoutes = filterRouters(router.getRoutes())\n  return generateMenus(filterRoutes)\n&#125;)\nconsole.log(JSON.stringify(routes.value))\n&lt;/script&gt;19、生成动态 menu 菜单整个 menu 菜单，分为 3 个组件来进行处理\n\n\n\n\n\n\n\n\n\n1、SidebarMenu:处理数据，作为最顶层 menu 载体\nhtml&lt;template&gt;\n  &lt;!-- 一级 menu 菜单 --&gt;\n  &lt;el-menu ...&gt;\n    &lt;sidebar-item\n      v-for=&quot;item in routes&quot;\n      :key=&quot;item.path&quot;\n      :route=&quot;item&quot;\n    &gt;&lt;/sidebar-item&gt;\n  &lt;/el-menu&gt;\n&lt;/template&gt;\n\n\n\n\n\n\n\n\n2、SidebarItem：根据数据处理当前项为 el-sub-menu || el-menu-item\nhtml&lt;template&gt;\n  &lt;!-- 支持渲染多级 menu 菜单 --&gt;\n  &lt;el-submenu v-if=&quot;route.children.length &gt; 0&quot; :index=&quot;route.path&quot;&gt;\n    &lt;template #title&gt;\n      &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt;\n    &lt;/template&gt;\n    &lt;!-- 循环渲染 --&gt;\n    &lt;sidebar-item\n      v-for=&quot;item in route.children&quot;\n      :key=&quot;item.path&quot;\n      :route=&quot;item&quot;\n    &gt;&lt;/sidebar-item&gt;\n  &lt;/el-submenu&gt;\n  &lt;!-- 渲染 item 项 --&gt;\n  &lt;el-menu-item v-else :index=&quot;route.path&quot;&gt;\n    &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt;\n  &lt;/el-menu-item&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import MenuItem from &quot;./MenuItem&quot;;\n  import &#123; defineProps &#125; from &quot;vue&quot;;\n  // 定义 props\n  defineProps(&#123;\n    route: &#123;\n      type: Object,\n      required: true,\n    &#125;,\n  &#125;);\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n3、MenuItem:处理 el-menu-item 样式\nhtml&lt;template&gt;\n  &lt;i v-if=&quot;icon.includes(&#39;el-icon&#39;)&quot; class=&quot;sub-el-icon&quot; :class=&quot;icon&quot;&gt;&lt;/i&gt;\n  &lt;svg-icon v-else :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;\n  &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import &#123; defineProps &#125; from &quot;vue&quot;;\n  defineProps(&#123;\n    title: &#123;\n      type: String,\n      required: true,\n    &#125;,\n    icon: &#123;\n      type: String,\n      required: true,\n    &#125;,\n  &#125;);\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;menu 菜单完成，还需解决样式问题、菜单路由跳转问题、默认激活项\n样式修改：store&#x2F;getters 创建快捷访问（后续加入主题更换功能，样式不能写死）\njsimport variables from &#39;@/styles/variables.scss&#39;\nconst getters = &#123;\n  ...\n  cssVar: state =&gt; variables\n&#125;\nexport default gettersSidebarMenu写入样式（el-menu 里的 router 是指定路由跳转， activeMenu 为默认激活项）\nhtml// template\n&lt;el-menu\n  :background-color=&quot;$store.getters.cssVar.menuBg&quot;\n  :text-color=&quot;$store.getters.cssVar.menuText&quot;\n  :active-text-color=&quot;$store.getters.cssVar.menuActiveText&quot;\n  :default-active=&quot;activeMenu&quot;\n  :unique-opened=&quot;true&quot;\n  router\n&gt;&lt;/el-menu&gt;\n\n// js\n&lt;script setup&gt;\n  ...\n\n  // 计算高亮 menu 的方法\n  const route = useRoute()\n  const activeMenu = computed(() =&gt; &#123;\n    const &#123; path &#125; = route\n    return path\n  &#125;)\n&lt;/script&gt;20、菜单的伸缩功能创建store/modules/app.js\njsexport default &#123;\n  namespaced: true,\n  state: () =&gt; (&#123;\n    sidebarOpened: true,\n  &#125;),\n  mutations: &#123;\n    triggerSidebarOpened(state) &#123;\n      state.sidebarOpened = !state.sidebarOpened;\n    &#125;,\n  &#125;,\n  actions: &#123;&#125;,\n&#125;;在store/index.js中引入上面的 app.js\njsimport app from &quot;./modules/app&quot;;\nexport default createStore(&#123;\n  getters,\n  modules: &#123;\n    user,\n    app,\n  &#125;,\n&#125;);在 store/getters 中创建快捷访问\njssidebarOpened: (state) =&gt; state.app.sidebarOpened;21、创建收缩 icon 组件 hamburger创建src/components/Hamburger/index.vue\nhtml&lt;template&gt;\n  &lt;div class=&quot;hamburger-container&quot; @click=&quot;toggleClick&quot;&gt;\n    &lt;svg-icon class=&quot;hamburger&quot; :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import &#123; computed &#125; from &quot;vue&quot;;\n  import &#123; useStore &#125; from &quot;vuex&quot;;\n\n  const store = useStore();\n  const toggleClick = () =&gt; &#123;\n    store.commit(&quot;app/triggerSidebarOpened&quot;);\n  &#125;;\n\n  const icon = computed(() =&gt;\n    store.getters.sidebarOpened ? &quot;hamburger-opened&quot; : &quot;hamburger-closed&quot;\n  );\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .hamburger-container &#123;\n    padding: 0 16px;\n    .hamburger &#123;\n      display: inline-block;\n      vertical-align: middle;\n      width: 20px;\n      height: 20px;\n    &#125;\n  &#125;\n&lt;/style&gt;在layout/components/Navbar.vue中使用 Hamburger 组件\nhtml&lt;template&gt;\n  &lt;div class=&quot;navbar&quot;&gt;\n    &lt;hamburger class=&quot;hamburger-container&quot; /&gt;\n    ...\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import Hamburger from &#39;@/components/Hamburger&#39;\n  ...\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .navbar &#123;\n    ...\n\n    .hamburger-container &#123;\n      line-height: 46px;\n      height: 100%;\n      float: left;\n      cursor: pointer;\n      // hover 动画\n      transition: background 0.5s;\n\n      &amp;:hover &#123;\n        background: rgba(0, 0, 0, 0.1);\n      &#125;\n    &#125;\n\n   ...\n  &#125;\n&lt;/style&gt;在layout/components/Sidebar/SidebarMenu.vue中添加控制 el-menu 的collapse属性\nhtml&lt;el-menu\n    :collapse=&quot;!$store.getters.sidebarOpened&quot;\n    ...在layout/index.vue中指定侧边栏的宽度和缩放动画\nhtml&lt;div\n  class=&quot;app-wrapper&quot;\n  :class=&quot;[$store.getters.sidebarOpened ? &#39;openSidebar&#39; : &#39;hideSidebar&#39;]&quot;\n&gt;\n  ...\n&lt;/div&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  ... .fixed-header &#123;\n    position: fixed;\n    top: 0;\n    right: 0;\n    z-index: 9;\n    width: calc(100% - #&#123;$sideBarWidth&#125;);\n    transition: width 0.28s;\n  &#125;\n\n  .hideSidebar .fixed-header &#123;\n    width: calc(100% - #&#123;$hideSideBarWidth&#125;);\n  &#125;\n&lt;/style&gt;\n\n&lt;style&gt;\n  // 在 `styles/variables.scss` 中指定 `hideSideBarWidth`\n  $hideSideBarWidth: 54px;\n&lt;/style&gt;22、SidebarHeader 处理\n显示详细代码\n\nhtml&lt;template&gt;\n  &lt;div class=&quot;&quot;&gt;\n    &lt;div class=&quot;logo-container&quot;&gt;\n      &lt;el-avatar size=&quot;44&quot; shape=&quot;square&quot; src=&quot;http://xxxxx.com&quot; /&gt;\n      &lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt;Admin&lt;/h1&gt;\n    &lt;/div&gt;\n    ...\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .logo-container &#123;\n    height: 44px;\n    padding: 10px 0 22px 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    .logo-title &#123;\n      margin-left: 10px;\n      color: #fff;\n      font-weight: 600;\n      line-height: 50px;\n      font-size: 16px;\n      white-space: nowrap;\n    &#125;\n  &#125;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n\n处理 el-avatar 的图片背景问题\n创建 styles/element.scss,然后将其导入到style/index.scss\ncss.el-avatar &#123;\n  --el-avatar-background-color: none;\n&#125;\n\n\n\n\n\n\n\n\n处理动画问题\n在 styles/variables.scss 中，加入以下变量\ncss$sideBarDuration: 0.28s;styles/sidebar.scss 修改时长\ncss  .main-container &#123;\n    transition: margin-left #&#123;$sideBarDuration&#125;;\n   ...\n  &#125;\n\n  .sidebar-container &#123;\n    transition: width #&#123;$sideBarDuration&#125;;\n      ...\n  &#125;layout/index 修改样式\ncss.fixed-header &#123;\n  ...\n  transition: width #&#123;$sideBarDuration&#125;;\n&#125;23、组件状态驱动的动态 CSS 值html&lt;template&gt; ... &lt;el-avatar :size=&quot;logoHeight&quot; ... &lt;/template&gt;\n\n&lt;script setup&gt;\n  ...\n  const logoHeight = 44\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n  .logo-container &#123;\n    height: v-bind(logoHeight) + &#39;px&#39;;\n  ...\n  &#125;\n&lt;/style&gt;","slug":"94-vue3-ele-plus-admin","date":"2022-11-19T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"6b8bfac8e09d7ad60db5fe489aa355a1","title":"93、使用vue3+element-plus写后台管理系统：（三）","content":"包括配置环境变量封装 axios、接口请求模块、vuex 登录请求动作、保存服务端的 token、登录鉴权\n\n\n一、配置环境变量及封装 axios 模块在跟目录下创建.env.development .env.production 2 个文件\njs// .env.development\nENV = &quot;development&quot;;\nVUE_APP_BASE_API = &quot;/api&quot;;\n\n// .env.production\nENV = &quot;production&quot;;\nVUE_APP_BASE_APIU = &quot;/prod-api&quot;;axios 的封装 utils 下创建 request.js\njsimport axios from &quot;axios&quot;;\nconst service = axios.create(&#123;\n  baseURL: process.env.VUE_APP_BASE_API,\n  timeout: 5000,\n&#125;);\n\nexport default service;二、封装登录请求动作根目录下的 src 下创建 api 文件夹，touch sys.js\njsimport request from &quot;@/utils/request&quot;;\nexport const login = (data) =&gt; &#123;\n  return request(&#123;\n    url: &quot;/sys/login&quot;,\n    method: &quot;PSOT&quot;,\n    data,\n  &#125;);\n&#125;;将登录请求的动作封装到 vuex 的 action 中，在store文件夹下创建 modules 文件夹，在 modules 下touch user.js模块（此模块用于处理所有和用户相关的内容）\n\n\n\n\n\n\n\n\n\n安装 md5 插件，加密登录密码 yarn add md5\njs// user.js\nimport &#123; login &#125; from &#39;@/api/sys&#39;\nimport md5 from &#39;md5&#39;\nexport default &#123;\n  namespaced: true,\n  state: () =&gt; (&#123;&#125;),\n  mutations: &#123;&#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      const &#123; username, password &#125; = userInfo\n      return new Promise((resolve, reject) =&gt; &#123;\n        login(&#123;\n          username,\n          password: md5(password)\n        &#125;)\n          .then(data =&gt; &#123;\n            resolve()\n          &#125;)\n          .catch(err =&gt; &#123;\n            reject(err)\n          &#125;)\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n// 在store/index.js中注册\nimport &#123; createStore &#125; from &#39;vuex&#39;\nimport user from &#39;./modules/user.js&#39;\nexport default createStore(&#123;\n  modules:&#123;\n    user\n  &#125;\n&#125;)在登录页，触发定义的 action，此时存在一个问题就是，我们当前请求的接口不存在，需要使用 devServer 代理\njs// vue.config.js\nmodule.exports = &#123;\n  devService: &#123;\n    proxy: &#123;\n      &quot;/api&quot;: &#123;\n        // 要代理的服务器地址， 不需要写api\n        target: &quot;https://api.xxx.com&quot;,\n        changeOrigin: true, // 是否跨域\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;;重启项目，再次点击登录，就可以跳转到首页了。\n三、本地缓存的处理登录成功之后，前端会拿到后端返回的 token,我们需要将 token 进行缓存\n缓存的 2 种方式：\n\n\n\n\n\n\n\n\n\n1、本地缓存：localStorage2、全局状态管理： vuex\nlocalStorage 可以方便实现自动登录功能保存在 vuex 中是为了后面在其他位置进行使用\n(一)、localStorage在 utils 文件夹下，新建 storage..js1、封装 4 个方法\njs/**\n * 存储数据\n */\nexport const setItem = (key, value) =&gt; &#123;\n  // 将数组、对象类型的数据转化为 JSON 字符串进行存储\n  if (typeof value === &quot;object&quot;) &#123;\n    value = JSON.stringify(value);\n  &#125;\n  window.localStorage.setItem(key, value);\n&#125;;\n\n/**\n * 获取数据\n */\nexport const getItem = (key) =&gt; &#123;\n  const data = window.localStorage.getItem(key);\n  try &#123;\n    return JSON.parse(data);\n  &#125; catch (err) &#123;\n    return data;\n  &#125;\n&#125;;\n\n/**\n * 删除数据\n */\nexport const removeItem = (key) =&gt; &#123;\n  window.localStorage.removeItem(key);\n&#125;;\n\n/**\n * 删除所有数据\n */\nexport const removeAllItem = (key) =&gt; &#123;\n  window.localStorage.clear();\n&#125;;(二)、vuex 处理 token在 store 的 user.js 中\njsimport &#123; login &#125; from &#39;@/api/sys&#39;\nimport md5 from &#39;md5&#39;\nimport &#123; setItem, getItem &#125; from &#39;@/utils/storage&#39;\n// 常量目录 export const TOKEN = &#39;token&#39;\nimport &#123; TOKEN &#125; from &#39;@/constant&#39;\nexport default &#123;\n  namespaced: true,\n  state: () =&gt; (&#123;\n    token: getItem(TOKEN) || &#39;&#39;\n  &#125;),\n  mutations: &#123;\n    setToken(state, token) &#123;\n      state.token = token\n      setItem(TOKEN, token)\n    &#125;\n  &#125;,\n  actions: &#123;\n    login(context, userInfo) &#123;\n      ...\n          .then(data =&gt; &#123;\n            this.commit(&#39;user/setToken&#39;, data.data.data.token)\n            resolve()\n          &#125;)\n          ...\n      &#125;)\n    &#125;\n  &#125;\n&#125;四、响应数据的统一处理上面这一行代码this.commit(&#39;user/setToken&#39;, data.data.data.token)，需要使用 data.data.data.token，书写方式不美观。\njsimport axios from &#39;axios&#39;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n...\n// 响应拦截器\nservice.interceptors.response.use(\n  response =&gt; &#123;\n    const &#123; success, message, data &#125; = response.data\n    //   要根据success的成功与否决定下面的操作\n    if (success) &#123;\n      return data\n    &#125; else &#123;\n      // 业务错误\n      ElMessage.error(message) // 提示错误消息\n      return Promise.reject(new Error(message))\n    &#125;\n  &#125;,\n  error =&gt; &#123;\n    // TODO: 将来处理 token 超时问题\n    ElMessage.error(error.message) // 提示错误信息\n    return Promise.reject(error)\n  &#125;\n)\n\nexport default service上面的代码简写为：\njsthis.commit(&quot;user/setToken&quot;, data.token);","slug":"93-vue3-ele-plus-admin","date":"2022-11-10T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"c23526b6d95d909419929499f0fd438e","title":"92、使用vue3+element-plus写后台管理系统：（二）","content":"包括 element-plus 的安装、登录、svg icons 的处理（坑：svg 不显示的问题）\n\n\n一、安装 element-plusshellnpm install @element-plus/icons\nyarn add @element-plus/icons\npnpm install @element-plus/icons\n\n\n\n\n\n\n\n\n安装成功，会出现一个 element-plus 安装成功和一个按钮\n二、公开路由表配置js// router/router.js\nimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;\n\nconst publicRoutes = [\n  &#123;\n    path: &quot;/login&quot;,\n    component: () =&gt; import(&quot;@/views/login/index&quot;),\n  &#125;,\n];\n\nconst router = createRouter(&#123;\n  history: createWebHistory(),\n  routes: publicRoutes,\n&#125;);\n\nexport default router;三、登录页html&lt;template&gt;\n  &lt;div class=&quot;login-container&quot;&gt;\n    &lt;el-form\n      class=&quot;login-form&quot;\n      ref=&quot;loginFormRef&quot;\n      :model=&quot;loginForm&quot;\n      :rules=&quot;loginRules&quot;\n    &gt;\n      &lt;div class=&quot;title-container&quot;&gt;\n        &lt;h3 class=&quot;title&quot;&gt;后台管理系统&lt;/h3&gt;\n      &lt;/div&gt;\n      &lt;el-form-item prop=&quot;username&quot;&gt;\n        &lt;span class=&quot;svg-container&quot;&gt;\n          &lt;svg-icon icon=&quot;user&quot; /&gt;\n        &lt;/span&gt;\n        &lt;el-input\n          placeholder=&quot;username&quot;\n          name=&quot;username&quot;\n          type=&quot;text&quot;\n          v-model=&quot;loginForm.username&quot;\n        &gt;&lt;/el-input&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item&gt;\n        &lt;span class=&quot;svg-container&quot;&gt;\n          &lt;svg-icon icon=&quot;password&quot; /&gt;\n        &lt;/span&gt;\n        &lt;el-input\n          placeholder=&quot;password&quot;\n          name=&quot;password&quot;\n          :type=&quot;passwordType&quot;\n          v-model=&quot;loginForm.password&quot;\n        &gt;&lt;/el-input&gt;\n        &lt;span class=&quot;show-pwd&quot;&gt;\n          &lt;svg-icon\n            :icon=&quot;passwordType === &#39;password&#39; ? &#39;eye&#39; : &#39;eye-open&#39;&quot;\n            @click=&quot;onChangePwdType&quot;\n          &gt;&lt;/svg-icon&gt;\n        &lt;/span&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-button\n        type=&quot;primary&quot;\n        style=&quot;width:100%;margin-bottom: 30px&quot;\n        :loading=&quot;loading&quot;\n        @click=&quot;handleLogin&quot;\n        &gt;login\n      &lt;/el-button&gt;\n    &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js\njs&lt;script setup&gt;\nimport &#123; ref, computed &#125; from &#39;vue&#39;\nimport &#123; validatePassword &#125; from &#39;./rules&#39;\nimport &#123; useStore &#125; from &#39;vuex&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\n\n// 数据源\nconst loginForm = ref(&#123;\n  username: &#39;super-admin&#39;,\n  password: &#39;123456&#39;\n&#125;)\n// 验证规则\nconst loginRules = ref(&#123;\n  username: [&#123;\n    required: true,\n    trigger: &#39;blur&#39;,\n    message: computed(() =&gt; &#123;\n      return &#39;error&#39;\n    &#125;)\n  &#125;\n  ],\n  password: [\n    &#123;\n      required: true,\n      trigger: &#39;blur&#39;,\n      validator: validatePassword()\n    &#125;\n  ]\n&#125;)\n// 处理密码\nconst passwordType = ref(&#39;password&#39;)\nconst onChangePwdType = () =&gt; &#123;\n  if (passwordType.value === &#39;password&#39;) &#123;\n    passwordType.value = &#39;text&#39;\n  &#125; else &#123;\n    passwordType.value = &#39;password&#39;\n  &#125;\n&#125;\n// 登录\nconst loading = ref(false)\nconst loginFormRef = ref(null)\nconst router = useRouter()\nconst store = useStore()\nconst handleLogin = () =&gt; &#123;\n  loginFormRef.value.validate(valid =&gt; &#123;\n    if (!valid) return\n    loading.value = false\n    store.dispatch(&#39;user/login&#39;, loginForm.value).then(() =&gt; &#123;\n      loading.value = false\n      router.push(&#39;/&#39;)\n    &#125;).catch(err =&gt; &#123;\n      console.log(err)\n      loading.value = false\n    &#125;)\n  &#125;)\n&#125;\n\n&lt;/script&gt;\n校验规则：\njsexport const validatePassword = () =&gt; &#123;\n  return (rule, value, callback) =&gt; &#123;\n    if (value.length &lt; 6) &#123;\n      // callback(new Error(i18n.global.t(&#39;msg.login.passwordRule&#39;)))\n      callback(new Error(&quot;error&quot;));\n    &#125; else &#123;\n      callback();\n    &#125;\n  &#125;;\n&#125;;登录页样式：\nscss&lt;style lang=&quot;scss&quot; scoped&gt;\n$bgColor: #2d3a4b;\n$dark_gray: #889aa4;\n$light_gray: #eee;\n$cursor: #fff;\n\n.login-container &#123;\n  min-height: 100%;\n  width: 100%;\n  background-color: $bgColor;\n  overflow: hidden;\n\n  .login-form &#123;\n    position: relative;\n    width: 520px;\n    max-width: 100%;\n    padding: 160px 35px 0;\n    margin: 0 auto;\n    overflow: hidden;\n\n    ::v-deep .el-form-item &#123;\n      border: 1px solid rgba(255, 255, 255, 0.1);\n      background-color: rgba(0, 0, 0, 0.1);\n      border-radius: 5px;\n      color: #454545;\n    &#125;\n\n    ::v-deep .el-input &#123;\n      display: inline-block;\n      height: 47px;\n      width: 85%;\n\n      input &#123;\n        background: transparent;\n        border: 0px;\n        -webkit-appearance: none;\n        border-radius: 0px;\n        padding: 12px 5px 12px 15px;\n        color: $light_gray;\n        height: 47px;\n        caret-color: $cursor;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n.svg-container &#123;\n  padding: 6px 5px 6px 15px;\n  color: $dark_gray;\n  vertical-align: middle;\n  display: inline-block;\n&#125;\n\n.title-container &#123;\n  position: relative;\n\n  .title &#123;\n    font-size: 26px;\n    color: $light_gray;\n    margin: 0px auto 40px auto;\n    text-align: center;\n    font-weight: bold;\n  &#125;\n\n  ::v-deep .lang-select &#123;\n    position: absolute;\n    top: 4px;\n    right: 0;\n    background-color: white;\n    font-size: 22px;\n    padding: 4px;\n    border-radius: 4px;\n    cursor: pointer;\n  &#125;\n&#125;\n\n.show-pwd &#123;\n  position: absolute;\n  right: 10px;\n  top: 7px;\n  font-size: 16px;\n  color: $dark_gray;\n  cursor: pointer;\n  user-select: none;\n&#125;\n&lt;/style&gt;\n全局样式：src&#x2F;styles&#x2F;index.scss\nscsshtml,\nbody &#123;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft\n      YaHei, Arial, sans-serif;\n&#125;\n\n#app &#123;\n  height: 100%;\n&#125;\n\n*,\n*:before,\n*:after &#123;\n  box-sizing: inherit;\n  margin: 0;\n  padding: 0;\n&#125;\n\na:focus,\na:active &#123;\n  outline: none;\n&#125;\n\na,\na:focus,\na:hover &#123;\n  cursor: pointer;\n  color: inherit;\n  text-decoration: none;\n&#125;\n\ndiv:focus &#123;\n  outline: none;\n&#125;\n\n.clearfix &#123;\n  &amp;:after &#123;\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: &quot; &quot;;\n    clear: both;\n    height: 0;\n  &#125;\n&#125;导入全局样式\njsimport &quot;./styles/index.scss&quot;;这里有个坑： 登录页输入框的 svg 小图标不显示\n四、icon 图标处理方法：SvgIcon结合 vue-element-admin 项目的借鉴，将 icon 图标分为 element-plus 图标和自定义引入图标\n\n\n\n\n\n\n\n\n\n自定义 SVG 图标组件的能力：显示外部引入图标和项目内的 svg 图标\n封装 SvgIcon 组件\nhtml&lt;template&gt;\n  &lt;div\n    v-if=&quot;isExternal&quot;\n    :style=&quot;styleExternalIcon&quot;\n    class=&quot;svg-external-icon svg-icon&quot;\n    :class=&quot;className&quot;\n  /&gt;\n  &lt;svg v-else class=&quot;svg-icon&quot; :class=&quot;className&quot; aria-hidden=&quot;true&quot;&gt;\n    &lt;use :xlink:href=&quot;iconName&quot; /&gt;\n  &lt;/svg&gt;\n&lt;/template&gt;js// utils/validate.js\n/**\n * 判断是否为外部资源\n */\nexport function isExternal(path) &#123;\n  return /^(https?:|mailto:|tel:)/.test(path)\n&#125;\n\n\n&lt;script setup&gt;\nimport &#123; isExternal as external &#125; from &#39;@/utils/validate&#39;\nimport &#123; defineProps, computed &#125; from &#39;vue&#39;\n\nconst props = defineProps(&#123;\n  icon: &#123;\n    type: String,\n    required: true\n  &#125;,\n  className: &#123;\n    type: String,\n    default: &#39;&#39;\n  &#125;\n&#125;)\n// 判断是否为外部图标\nconst isExternal = computed(() =&gt; external(props.icon))\n// 外部图标样式\nconst styleExternalIcon = computed(() =&gt; (&#123;\n  mask: `url($&#123;props.icon&#125;) no-repeat 50% 50%`,\n  &#39;-webkit-mask&#39;: `url($&#123;props.icon&#125;) no-repeat 50% 50%`\n&#125;))\n// 项目内图标\nconst iconName = computed(() =&gt; `#icon-$&#123;props.icon&#125;`)\n\n&lt;/script&gt;样式\nscss.svg-icon &#123;\n  width: 1em;\n  height: 1em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n&#125;\n\n.svg-external-icon &#123;\n  background-color: currentColor;\n  mask-size: cover !important;\n  display: inline-block;\n&#125;上面只处理了外部 svg 图标的展示，还要处理 element-plus 的图标\n&#x2F;&#x2F; 创建 icons 文件夹 内部包含：内部 svg 图标、SvgIcon 全局注册\njsimport SvgIcon from &quot;@/components/SvgIcon&quot;;\n// 通过 require.context() 函数来创建自己的 context\nconst svgRequire = require.context(&quot;./svg&quot;, false, /\\.svg$/);\n// 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。\n// 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标\n// 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入\n\nsvgRequire.keys().forEach((SvgIcon) =&gt; svgRequire(SvgIcon));\n\nexport default (app) =&gt; &#123;\n  app.component(&quot;svg-icon&quot;, SvgIcon);\n&#125;;main.js 引入 svgIcon\njs// 导入 svgIcon\nimport installIcons from &quot;@/icons&quot;;\ninstallIcons(app);此时，svg图标仍然不显示，还需要使用 svg-sprite-loader 处理 svg 图标\nshellnpm i --save-dev svg-sprite-loader@6.0.9配置 vue.config.js\njsconst path = require(&quot;path&quot;);\nfunction resolve(dir) &#123;\n  return path.join(__dirname, dir);\n&#125;\n\nmodule.exports = &#123;\n  chainWebpack(config) &#123;\n    // 设置 svg-sprite-loader\n    config.module.rule(&quot;svg&quot;).exclude.add(resolve(&quot;src/icons&quot;)).end();\n    config.module\n      .rule(&quot;icons&quot;)\n      .test(/\\.svg$/)\n      .include.add(resolve(&quot;src/icons&quot;))\n      .end()\n      .use(&quot;svg-sprite-loader&quot;)\n      .loader(&quot;svg-sprite-loader&quot;)\n      .options(&#123;\n        symbolId: &quot;icon-[name]&quot;,\n      &#125;)\n      .end();\n  &#125;,\n&#125;;至此，svg 图标可以正常显示。\n","slug":"92-vue3-ele-plus-admin","date":"2022-11-07T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"51217e730619a24081f2a57960d90416","title":"91、使用vue3+element-plus写后台管理系统：（一）","content":"创建项目及代码格式提交规范（备注：遇见 2 个坑：yarn 问题、git cz 提交空格问题）\n\n\n一、vue-cli 创建项目vue-cli 版本应当大于 4.5.13\n升级 vue-cli\nshellnpm update -g @vue/cli创建项目\nshellvue create vue3-admin\n\n// 进入模板选择\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features  // 选择手动配置\n// ----------------------------------------------------------\n? Check the features needed for your project:\n (*) Choose Vue version // 选择 vue 版本\n (*) Babel // 使用 babel\n ( ) TypeScript // 不使用 ts\n ( ) Progressive Web App (PWA) Support // 不使用 PWA\n (*) Router // 添加 vue-router\n (*) Vuex // 添加 vuex\n&gt;(*) CSS Pre-processors // 使用 css 预处理器\n (*) Linter / Formatter // 代码格式化\n ( ) Unit Testing // 不配置测试\n ( ) E2E Testing  // // 不配置测试\n// ----------------------------------------------------------\n Choose a version of Vue.js that you want to start the project with\n  2.x\n&gt; 3.x // 选择 vue 3.0 版本\n// ----------------------------------------------------------\n Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) n // 不使用 history模式 的路由\n// ----------------------------------------------------------\n ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default):\n&gt; Sass/SCSS (with dart-sass) // 使用基于 dart-sass 的 scss 预处理器\n  Sass/SCSS (with node-sass)\n  Less\n  Stylus\n// ----------------------------------------------------------\n? Pick a linter / formatter config:\n  ESLint with error prevention only\n  ESLint + Airbnb config\n&gt; ESLint + Standard config // 使用 ESLint 标准代码格式化方案\n  ESLint + Prettier\n// ----------------------------------------------------------\n? Pick additional lint features:\n (*) Lint on save //\n&gt;(*) Lint and fix on commit  // 保存时 &amp;&amp; 提交时，都进行 lint\n// ----------------------------------------------------------\n? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)\n&gt; In dedicated config files // 单独的配置文件\n  In package.json\n// ----------------------------------------------------------\n Save this as a preset for future projects? (y/N) n // 不存储预设进入项目，然后启动项目\n创建项目这里的坑:&#106;&#x65;&#x73;&#x74;&#45;&#x77;&#x6f;&#x72;&#107;&#101;&#x72;&#x40;&#x32;&#56;&#46;&#x31;&#46;&#x33;: The engine “node” is incompatible with this module. Expe\n\n\n\n\n\n\n\n\n\n解决方法： yarn config set ignore-engines true\n二、ESLint 和 Prettier 解决代码格式问题创建项目时，已经选择了 eslint，配置文件为.eslintrc.js\nvscode 下载prettier插件，创建.prettierrc 文件，配置如下：\njs&#123;\n  // 不尾随分号\n  &quot;semi&quot;: false,\n  // 使用单引号\n  &quot;singleQuote&quot;: true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;vscode 设置中，搜索Format On Save,然后勾选在保存时格式化文件。\n还要解决一个问题就是 eslint 和 prettier 的冲突问题，例如 created 钩子函数后面会有一个空格，prettier 会将空格去掉\n解决方法：\njs// .eslintrc.js  rules规则下添加\n&#39;space-before-function-paren&#39;: &#39;off&#39;三、git 提交规范1、全局安装 commitizen\nshellnpm install -g commitizen@4.2.42、安装并配置 cz-customizable\nshellnpm i cz-customizable@6.3.0 --save-dev\n配置：\njs// package.json\n&quot;config&quot;:&#123;\n  &quot;commitizen&quot;: &#123;\n    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;\n  &#125;\n&#125;\n3、根目录下创建.cz-config.js 自定义提示文件\njsmodule.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: &quot;feat&quot;, name: &quot;feat:     新功能&quot; &#125;,\n    &#123; value: &quot;fix&quot;, name: &quot;fix:      修复&quot; &#125;,\n    &#123; value: &quot;docs&quot;, name: &quot;docs:     文档变更&quot; &#125;,\n    &#123; value: &quot;style&quot;, name: &quot;style:    代码格式(不影响代码运行的变动)&quot; &#125;,\n    &#123;\n      value: &quot;refactor&quot;,\n      name: &quot;refactor: 重构(既不是增加feature，也不是修复bug)&quot;,\n    &#125;,\n    &#123; value: &quot;perf&quot;, name: &quot;perf:     性能优化&quot; &#125;,\n    &#123; value: &quot;test&quot;, name: &quot;test:     增加测试&quot; &#125;,\n    &#123; value: &quot;chore&quot;, name: &quot;chore:    构建过程或辅助工具的变动&quot; &#125;,\n    &#123; value: &quot;revert&quot;, name: &quot;revert:   回退&quot; &#125;,\n    &#123; value: &quot;build&quot;, name: &quot;build:    打包&quot; &#125;,\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: &quot;请选择提交类型:&quot;,\n    customScope: &quot;请输入修改范围(可选):&quot;,\n    subject: &quot;请简要描述提交(必填):&quot;,\n    body: &quot;请输入详细描述(可选):&quot;,\n    footer: &quot;请输入要关闭的issue(可选):&quot;,\n    confirmCommit: &quot;确认使用以上信息提交？(y/n/e/h)&quot;,\n  &#125;,\n  // 跳过问题\n  skipQuestions: [&quot;body&quot;, &quot;footer&quot;],\n  // subject文字长度默认是72\n  subjectLimit: 72,\n&#125;;4、使用 git cz 代替 git commit\n5、git hooks 校验提交信息\n2 个工具的的使用：\n\n\n\n\n\n\n\n\n\n\ncommitlint：用于检查提交信息\n\n\n\n\n\n\n\n\n\n\n\nhusky：是git hooks工具\n\n\n\n\n\n\n\n\n\n\n\nnpm 版本大于 7.x\n\n5.1 安装 commitlint\nshellnpm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.45.2 创建 commitlint.config.js(编码格式为 UTF-8)\njsmodule.exports = &#123;\n  // 继承的规则\n  extends: [&quot;@commitlint/config-conventional&quot;],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    &quot;type-enum&quot;: [\n      2,\n      &quot;always&quot;,\n      [\n        &quot;feat&quot;, // 新功能 feature\n        &quot;fix&quot;, // 修复 bug\n        &quot;docs&quot;, // 文档注释\n        &quot;style&quot;, // 代码格式(不影响代码运行的变动)\n        &quot;refactor&quot;, // 重构(既不增加新功能，也不是修复bug)\n        &quot;perf&quot;, // 性能优化\n        &quot;test&quot;, // 增加测试\n        &quot;chore&quot;, // 构建过程或辅助工具的变动\n        &quot;revert&quot;, // 回退\n        &quot;build&quot;, // 打包\n      ],\n    ],\n    // subject 大小写不做校验\n    &quot;subject-case&quot;: [0],\n  &#125;,\n&#125;;5.3 安装 husky\nshellnpm install husky@7.0.1 --save-dev\n// 启动hooks，生成.husky\nnpx husky install\n\n// 在 `package.json` 中生成 `prepare` 指令（ **需要 npm &gt; 7.0 版本** ）\nnpm set-script prepare &quot;husky install&quot;\n\n// 执行 `prepare` 指令\nnpm run prepare\n// 添加 `commitlint` 的 `hook` 到 `husky`中，并指令在 `commit-msg` 的 `hooks` 下执行 `npx --no-install commitlint --edit &quot;$1&quot;` 指令\n\nnpx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;不符合规范的将不能提交\n5.4 通过 pre-commit 检测提交时代码规范\nshell// 执行\nnpx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot;\n // 添加 `commit` 时的 `hook` （`npx eslint --ext .js,.vue src` 会在执行到该 hook 时运行\n// 上面操作会在.husky文件下生成pre-commit\n\n\n\n\n\n\n\n\nvscode 提交源代码管理 -&gt; stage all changes -&gt; git cz -&gt; 选择提交类型 -&gt; git push\n\n这里有个坑：\n\n\n\n\n\n\n\n\n\n在请简要描述提交（必填） 这一步填写信息时，需要加一个空格\n5.5 lint-staged 自动修复格式错误(无需安装，创建项目时自带)\njs// package.json\n&quot;lint-staged&quot;: &#123;\n    &quot;src/**/*.&#123;js,vue&#125;&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;\n修改 .husky/pre-commit 文件\njs#!/bin/sh\n. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;\n\nnpx lint-staged","slug":"91-vue3-ele-plus-admin","date":"2022-10-16T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"43c695a4c770e67321863ebb0ea62b5e","title":"90、相对时间及时间国际化的处理","content":"相对时间可以理解为最后一次“打招呼”的时间和当前时间的差值。例如：2 小时前，1 天前，1 年前等\n\n\n一、relativeTime 函数使用 day.js 将后端返回的时间戳处理为相对时间（1 小时前，1 天前等格式）\njsimport dayjs from &quot;dayjs&quot;;\nimport rTime from &quot;dayjs/plugin/relativeTime&quot;;\n// 处理语言\nimport &quot;dayjs/locale/zh-cn&quot;;\nimport store from &quot;@/store&quot;;\n\n// 时间格式处理： 2022-08-15\nconst dateFilter = (val, format = &quot;YYYY-MM-DD&quot;) =&gt; &#123;\n  if (!isNaN(val)) &#123;\n    val = parseInt(val);\n  &#125;\n  return dayjs(val).format(format);\n&#125;;\n\n// 加载相对时间插件\ndayjs.extend(rTime);\n// 相对时间处理\nfunction relativeTime(val) &#123;\n  if (!isNaN(val)) &#123;\n    val = parseInt(val);\n  &#125;\n  return dayjs()\n    .locale(store.getters.langeage === &quot;zh&quot; ? &quot;zh-cn&quot; : &quot;en&quot;)\n    .to(dayjs(val));\n&#125;\n\nexport default (app) =&gt; &#123;\n  app.config.globalProperties.$filters = &#123;\n    dateFilter,\n    relativeTime,\n  &#125;;\n&#125;;\n\n\n\n\n\n\n\n\napp.config.globalProperties 是挂载在 vue 实例上面的，所以可以直接在 template 里面访问\n二、组件内处理为相对时间html&lt;el-table ref=&quot;tableRef&quot; :data=&quot;tableData&quot; border&gt;\n  &lt;el-table-column\n    v-for=&quot;(item, index) in tableColumns&quot;\n    :key=&quot;index&quot;\n    :prop=&quot;item.prop&quot;\n    :label=&quot;item.label&quot;\n  &gt;\n    // 相对时间的处理\n    &lt;template #default=&quot;&#123; row &#125;&quot; v-if=&quot;item.prop === &#39;publicDate&#39;&quot;&gt;\n      &#123;&#123; $filters.relativeTime(row.publicDate) &#125;&#125;\n    &lt;/template&gt;\n  &lt;/el-table-column&gt;\n&lt;/el-table&gt;","slug":"90-relativeTime","date":"2022-08-15T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"0101df2ffc8279cbfc009c6ce954aa72","title":"89、vue-loader 是什么？","content":"vue-loader 是用于处理单文件的 webpack loader。在 Vue 组件中，分为 template\\script\\style,结合其他 loader,我们可以用 Pug 编写&lt;tempalte&gt;&lt;/tempalte&gt;,用 Sass&#x2F;Less 编写&lt;style&gt;&lt;/style&gt;,用 js&#x2F;ts 编写&lt;script&gt;&lt;/script&gt;\n\n\nwebpack 打包时，会以 loader 方式调用 vue-loader, vue-loader 被执行时，它会对单文件组件的每个语言块用单独的 loader 链处理，最后将这些单独的块装配成最终的组件模块。\nvue-loader 会调用@vue-compiler-sfc 模块解析 SFC 源码为一个描述符，然后为每个语言块生成 import 代码。\njs// 模板\nimport render from &#39;xxx.vue?vue&amp;type=template&#39;\n// script\nimport script from &#39;xxx.vue?vue&amp;type=script&#39;\nimport * from &quot;xxx.vue?vue&amp;type=script&quot;\n// 样式\nimport &#39;xxx.vue?vue&amp;type=style&amp;index=1&#39;\n\nscript.render = render\nexport default script","slug":"89、vue-loader","date":"2022-08-14T12:00:00.000Z","categories_index":"","tags_index":"vue-loader","author_index":"Jude"},{"id":"65bd3f1319c5268988323a5b73a44cf4","title":"88、Vue3和Vue2","content":"vue3 的 2 种响应式实现、Vue2 项目如何升级到 Vue3 等等。。。\n\n\n一、options api 选项式 API\nOptions Api 可以理解为就是组件的各个选项，data、methods、computed、watch 等等就像是组件的一个个选项，在对应的选项里做对应的事情。\njsexport default &#123;\n    data () &#123;\n        return &#123;\n            // 定义响应式数据的选项\n        &#125;\n    &#125;,\n    methods: &#123;\n        // 定义相关方法的选项\n    &#125;,\n    computed: &#123;\n        // 计算属性的选项\n    &#125;,\n    watch: &#123;\n        // 监听数据的选项\n    &#125;\n    ...\n&#125;在 data 中定义的数据，是无法做到响应式的，那是因为 Object.definePropety 只会对 data 选项中的数据进行递归拦截\n在实际项目的开发过程中，数据定义在 data 中，方法定义在 methods 中，当我们的代码多起来，比如达到四、五百行的时候，如果我们想改动某个功能，就要去 data 中改数据，再去 methods 中改方法，来回地寻找。\n二、composition api 组合式 api\n1、Composition Api\n\n\n\n\n\n\n\n\n\n支持将相同的功能模块代码写在一起，甚至可以将某个功能单独的封装成函数，随意导入引用；也可以将任意的数据定义成响应式，再也不用局限于 data 中，我们只需要将每个实现的功能组合起来就可以了。\n示例：\njs&lt;template&gt;\n    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n    import &#123; ref &#125; from &quot;vue&quot;;\n    let count = ref(0);\n&lt;/script&gt;2、watchEffect\n(1)、watchEffect 是立即执行的，不需要添加 immediate 属性。\n(2)、watchEffect 不需要指定对某个具体的数据监听，watchEffect 会根据内容自动去感知，所以我们也可以在一个 watchEffect 中添加多个数据的监听处理\n(3)、watchEffect 不能获取数据改变之前的值。\n同时，watchEffect 会返回一个对象 watchEffectStop，通过执行 watchEffectStop，我们可以控制监听在什么时候结束。\n\n\n\n\n\n\n\n\n\n简单理解 watchEffect 会在第一次运行时创建副作用函数并执行一次，如果存在响应式变量，取值会触发 get 函数，这个时候收集依赖存储起来，当其他地方给响应式变量重新赋值的时候，set 函数中会触发方法派发更新，执行收集到的副作用函数，如果不存在响应式变量，就不会被收集触发\n\n\n\n\n\n\n\n\n\n1、watchEffect 立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数。watch 侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数。2、watchEffect(effect)是一种特殊 watch，传入的函数既是依赖收集的数据源，也是回调函数。如果我们不关心响应式数据变化前后的值，只是想拿这些数据做些事情，那么 watchEffect 就是我们需要的。watch 更底层，可以接收多种数据源，包括用于依赖收集的 getter 函数，因此它完全可以实现 watchEffect 的功能，同时由于可以指定 getter 函数，依赖可以控制的更精确，还能获取数据变化前后的值，因此如果需要这些时我们会使用 watch。3、watchEffect 在使用时，传入的函数会立刻执行一次。watch 默认情况下并不会执行回调函数，除非我们手动设置 immediate 选项。4、watchEffect(fn)相当于 watch(fn,fn,{immediate:true})\nvue3 不再只能有一个根元素\n为什么在 vue2 时，只能拥有一个根元素？而 Vue3 可以写多个根节点？\n\n\n\n\n\n\n\n\n\n因为 vdom 是一颗单根树形结构，patch 方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个 vdom，自然应该满足这个要求。vue3 中之所以可以写多个根节点，是因为引入了 Fragment 的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个 Fragment 节点，把多个根节点作为它的 children。将来 patch 的时候，如果发现是一个 Fragment 节点，则直接遍历 children 创建或更新。\n3、ref 和 reactive\nref 和 reactive 的区别是什么呢，我们可以这样简单理解，它们都是用来定义响应式数据的，但是 ref 是用来给简单的数据类型定义响应式数据的，比如 number、string、boolean 等，而 reactive 是针对复杂的数据结构的，比如一个对象。\n它们写法的区别主要在：ref 定义的数据，修改的时候是需改 xxx.value 的，而 reactive 定义的不用，产生这个区别的原因是它们实现响应式的方法不一样。\n4、小结\n\n\n\n\n\n\n\n\n\nOptions Api\n1、选项式的 api，相关代码必须写在规定的选项中，导致相同功能的代码被分割，代码量上来后查找相关代码很麻烦，后期维护修改难度较大。\n2、数据都挂载在同一个 this 下，对 typescript 的支持不友好，类型推断很麻烦。\n3、代码的复用能力很差。\n\n\n\n\n\n\n\n\n\nComposition Api\n1、组合式 api，代码定义很自由，相同功能代码整合到一起，查找修改都很方便。\n2、公共代码的复用很简单，不同功能的代码也可以自由组合。\n3、Vue 相关的 api 都是通过 import 导入的，这在打包的时候很友好。\n另外，vue3 是支持 options api 的写法的\n三、Vue3 响应式的实现\n在 Vue2.x 中，响应式的机制深入人心，我们只需要在 data 中定义我们需要的数据，就会在初始化时被自动转为响应式数据。\n但是在 Vue2 中，响应式的使用还存在一些限制，比如对象属性的增加和删除等并不能被监听到，在 Vue3 中，重新设计了响应式系统来解决这些问题。\n1、Vue2.x 的响应式——Object.definePropertyVue2 响应式失效的现象\njs&lt;template&gt;\n    &lt;div&gt;\n        &lt;span&gt;姓名：&lt;/span&gt;\n        &lt;span&gt;&#123;&#123;person.name&#125;&#125;&lt;/span&gt;\n\n        &lt;span&gt;年龄：&lt;/span&gt;\n        &lt;span&gt;&#123;&#123;person.age&#125;&#125;&lt;/span&gt;\n\n        &lt;button @click=&quot;changeName&quot;&gt;修改姓名&lt;/button&gt;\n        &lt;button @click=&quot;addAge&quot;&gt;增加年龄&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\nexport default &#123;\n    data () &#123;\n        return &#123;\n            person: &#123;\n                name: &#39;小明&#39;\n            &#125;\n        &#125;\n     &#125;,\n     methods: &#123;\n         addAge() &#123;\n             this.person.age = &#39;18&#39;;\n         &#125;,\n         changeName() &#123;\n             this.person.name = &#39;小红&#39;;\n         &#125;\n     &#125;\n    ...\n&#125;data 里面只定义了一个响应式对象 person，我们定义了 2 个方法，一个是修改名称、一个是增加年龄，但是使用增加年龄方法时，会给响应式对象添加一个新的属性 age，页面上的年龄部分并不会发生改变。\nVue2 是通过 Object.defineProperty 循环遍历拦截 data 中的数据来实现响应式的。\n\n\n\n\n\n\n\n\n\nObject.defineProperty 其实不是真正的代理，而应该是拦截\n而且 Object.defineProperty 也不是对对象进行拦截，而是拦截对象的具体的某个属性。\njsconst person = &#123;&#125;;\n\nObject.defineProperty(person, &quot;name&quot;, &#123;\n  set(value) &#123;\n    console.log(&quot;name:&quot;, value);\n  &#125;,\n  get() &#123;\n    return &quot;小明&quot;;\n  &#125;,\n&#125;);\n\nconsole.log(person.name);Vue2.x 的响应式实现其实就是递归遍历 data 中返回的对象，对每一个属性都使用 Object.defineProperty 进行拦截，而不在 data 中被初始化的数据是没有添加拦截的。\nVue2 如何添加和删除响应式数据？\n需要额外的 api 来实现，Vue.$set 和Vue.$delete 方法分别实现添加、删除响应式数据\nVue2 响应式的局限性\n\n\n\n\n\n\n\n\n\n1、无法监听整个对象，只能对每个属性单独监听。\n\n\n\n\n\n\n\n\n\n2、无法监听对象的属性的新增，删除（需要补充额外的 api 来解决）。\n\n\n\n\n\n\n\n\n\n3、无法监听数组的变化。\n2、Vue3 的响应式-proxy\n\n\n\n\n\n\n\n\nproxy 是真正地对整个对象进行代理，因为 proxy 可以劫持整个对象，所以 Object.defineProperty 中新增，删除某个属性无法检测的问题就不存在了，同时 proxy 也可以检测数组的变化\njsconst person = &#123;\n  name: &quot;小明&quot;,\n  age: 18,\n&#125;;\nconst personProxy = new Proxy(person, &#123;\n  get: function (target, prop) &#123;\n    console.log(`获取了$&#123;prop&#125;:`, target[prop]);\n    return target[prop];\n  &#125;,\n  set: function (target, prop, value) &#123;\n    console.log(`修改了$&#123;prop&#125;:`, value);\n    target[prop] = value;\n  &#125;,\n&#125;);\n\nconsole.log(&quot;name:&quot;, personProxy.name); // 获取了name:小明\npersonProxy.age = 20; // 修改了age:20参数 target，表示当前代理的对象，prop 是我们具体要操作的属性，set 多了一个参数 value 是我们对新属性的赋值。\n从方法的参数我们其实就能看出来，proxy 是真的对整个对象进行拦截的，我们如果有新增或删除的属性，也不需要单独去添加处理，可以直接被检测代理。\n在添加删除属性时，无需额外的 api。proxy 不支持 IE11。\nvue3 另外一个代理的方法，那就是对象本身的 get、set 方法\njsconst count = &#123;\n  _value: 0,\n  set value(num) &#123;\n    console.log(&quot;修改了count:&quot;, num);\n    this._value = num;\n  &#125;,\n  get value() &#123;\n    console.log(&quot;获取了count&quot;);\n    return this._value;\n  &#125;,\n&#125;;\n\nconsole.log(count.value); // 获取了count\ncount.value = 1; // 修改了count: 1这其实就是为什么我们使用 ref 定义的数据，赋值和取值的时候需要使用 xxx.value 了\n一个 Vue3 composition api 常用的工具集：VueUse\n四、Vue2 升级到 Vue3 的非兼容性变更Vue3 中做了很多重构，有部分内容对于 Vue2 来说是不兼容的，所以说 Vue2 的代码直接升级到 Vue3 是不能直接运行的。\n1、createApp 的非兼容性变更Vue2 根实例挂载及全局组件注册方法：\njsimport Vue from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\n// 引入全局组件\nimport GlobalComponent from &quot;./GlobalComponent.vue&quot;;\n// 注册全局组件\nVue.component(&quot;GlobalComponent&quot;, GlobalComponent);\n\nnew Vue(&#123;\n  render: (h) =&gt; h(App),\n&#125;).$mount(&quot;#app&quot;);Vue3 不直接在 Vue 对象上进行操作了，而是通过 createApp 来创建一个 App 应用实例，所有的操作都在 App 上进行\njsimport &#123; createApp &#125; from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\n\ncreateApp(App).mount(&quot;#app&quot;);现在我们想要在一个 App 上引入 store，就可以使用下面的写法(全局对象被共享是一件非常危险的事情)\njs// 引入封装好的store\nimport store from &quot;./store&quot;;\n\ncreateApp(App).use(store).mount(&quot;#app&quot;);\ncreateApp(App2).mount(&quot;#app2&quot;);App 实例上的 store 不会影响 App2\n2、api 的 import 导入\n\n\n\n\n\n\n\n\n我们在使用这些挂载在 Vue 对象下的 Api 时，需要经过 import 导入的方式来使用。\njsimport &#123; nextTick &#125; from &#39;vue&#39;;\n\nnextTick(() =&gt; &#123;\n    ...\n&#125;)按需加载的使用。\n在 Vue2 的 Api 中，都是挂载在 Vue 下面，那么在打包的时候，会不管你有没有使用到这个 Api，都会一起打包进去，如果都是这样，随着 Vue 的全局 Api 越来越多，冗余的代码也就越多，打包的耗时、体积或者说代价也就越大。\n在 Vue3 中，通过 import 导入 Api 来使用，那我们在打包的时候，则只会将对应的模块打包进去，做到真正的用了多少就打包多少，就算 Vue 中再增加多少代码，也不会影响我们打包的项目。\n3、小结升级 Vue3 不仅需要更换 Vue 版本，还有一些非兼容性变更内容需要了解\n\n全局的操作不再使用 Vue 实例，而是使用通过 createApp 创建的 app 实例。\n全局和内部 API 已经被重构，需要使用 import 导入使用，并且支持 tree-shake。\n\n如何将 localStorage 中的数据变成响应式的？\njs// tool.js\nimport &#123; ref, watchEffect &#125; from &quot;vue&quot;;\n\nconst useLocalStorage = (name, value = &#123;&#125;) =&gt; &#123;\n  const localData = ref(JSON.parse(localStorage.getItem(name)) || value);\n\n  watchEffect(() =&gt; &#123;\n    // 监听本地localstorage数据对应的响应式变量更改\n    localStorage.setItem(name, JSON.stringify(localData.value));\n  &#125;);\n\n  return localData;\n&#125;;\n\nexport &#123; useLocalStorage &#125;;假设有一个计数器，需要将数据同步到本地的 localStorage 中，我们只需要在计数器文件中引入 useLocalStorage 方法即可：\njs&lt;script setup&gt;\n  import &#123;useLocalStorage&#125; from &#39;./useLocalStorage&#39;;\n  // 定义响应式数据\n  let count = useLocalStorage(&#39;count&#39;, 0);\n\n  const addCount = () =&gt; &#123;\n    count.value ++;\n  &#125;\n\n&lt;/script&gt;五、如何将 Vue2 项目升级到 Vue3?1、项目升级方法一将 vue-cli 升级到高版本\nVue 的依赖版本升级到 vue3,需要安装@vue&#x2F;compat\n\n\n\n\n\n\n\n\n\n\n注意@vue&#x2F;compat 的版本号需要与 Vue 的版本号保持一致\n\n@vue&#x2F;compat 是 Vue2 和 Vue3 的一个过渡产物，@vue&#x2F;compat 可以运行在 Vue2 的环境下，但会对 Vue3 不兼容或者废弃的部分进行警告，我们引入@vue&#x2F;compat 后，只需要根据警告的内容进行修改就可以了。通过@vue&#x2F;compat 也可以对警告进行分类过滤，单独针对某一些问题进行修改.\n安装完 Vue 和@vue&#x2F;compat 的依赖后，还需要在项目根目录下新增 vue.config.js 文件，包含以下内容:\njs// vue.config.js\nmodule.exports = &#123;\n  chainWebpack: (config) =&gt; &#123;\n    config.resolve.alias.set(&quot;vue&quot;, &quot;@vue/compat&quot;);\n\n    config.module\n      .rule(&quot;vue&quot;)\n      .use(&quot;vue-loader&quot;)\n      .tap((options) =&gt; &#123;\n        return &#123;\n          ...options,\n          compilerOptions: &#123;\n            compatConfig: &#123;\n              MODE: 2,\n            &#125;,\n          &#125;,\n        &#125;;\n      &#125;);\n  &#125;,\n&#125;;运行项目，根据警告信息的内容去 Vue 官网的特性参考中查询具体的错误原因，以及修改方案。\nvue-router 和 vuex 都要升级到 v4，Element-ui 也要更新到 Vue3 对应的版本（element-plus）\nvue3 版本 router 部分的写法：\njsimport &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;\n\nimport Home from &quot;../pages/home.vue&quot;;\nimport Login from &quot;../pages/login.vue&quot;;\n\nconst routes = [\n  &#123;\n    path: &quot;/home&quot;,\n    component: Home,\n  &#125;,\n  &#123;\n    path: &quot;/&quot;,\n    component: Login,\n  &#125;,\n];\n\nexport default createRouter(&#123;\n  history: createWebHashHistory(),\n  routes,\n&#125;);js// main.js\nimport &#123; createApp &#125; from &quot;vue&quot;;\n\nimport App from &quot;./App.vue&quot;;\nimport routers from &quot;./router&quot;;\n\nconst app = createApp(App);\napp.use(routers).mount(&quot;#app&quot;);2、项目升级方法二：gogocode1、安装最新的 gogocode-cli\njsnpm install gogocode-cli -g2、在需要升级的项目根目录下，运行下面的指令\njsgogocode -s ./src -t gogocode-plugin-vue -o ./src-out-s 后面指的是需要升级的源码文件夹，-o 后面的参数指的是升级后的代码输出位置\n3、代码转换了还不够，我们项目的依赖都要升级到对应版本GOGOCode 可以帮我们把 package.json 里面的 Vue&#x2F;Vuex&#x2F;Vue-router&#x2F;Vue 编译工具升级到适配 Vue3 的版本，在项目根目录下执行以下指令\njsgogocode -s package.json -t gogocode-plugin-vue -o package.json虽然使用了 GOGOCode，但也不代表我们的项目就可以直接完成升级，项目中如果用到了其他 Vue2 版本的组件库，还是需要我们自己去升级 Vue3 对应的版本，包括一些 Api 的变化都要我们自己去手动调整，并且使用 GOGOCode 也有一些转化规则是不支持的，具体的可以参考 GOGOCode 的转化规则覆盖。\n六、vite1、什么是 ES Module？\n\n\n\n\n\n\n\n\n将 JavaScript 程序拆分为可按需导入的单独模块的机制，简单来说就是我们可以对 JavaScript 模块化开发，通过 import 和 export 来导入导出我们的模块内容\nVite 在冷启动的时候，将代码分为依赖和源码两部分，源码部分通常会使用 ESModules 或者 CommonJS 拆分到大量小模块中，而对于依赖部分，Vite 使用 Esbuild 对依赖进行预构建\nEsbuild 的优势：\n1、语言优势，Esbuild 使用 Go 语言开发，相对于 JavaScript，Go 语言是一种编译型语言，在编译阶段就已经将源码转译为机器码。\n2、多线程，Rollup 和 webpack 都没有使用多线程的能力，而 Esbuild 在算法上进行了大量的优化，充分的利用了多 CPU 的优势。\n2、搭建 vite 项目js// node 16.3.0\nnpm init vite@latest3、vite 项目的目录js    |-- .gitignore\n    |-- index.html\n    |-- package-lock.json\n    |-- package.json\n    |-- README.md\n    |-- vite.config.js\n    |-- .vscode\n    |   |-- extensions.json\n    |-- public\n    |   |-- favicon.ico\n    |-- src\n        |-- App.vue\n        |-- main.js\n        |-- assets\n        |   |-- logo.png\n        |-- components\n            |-- HelloWorld.vue\n\n// src/\n|-- src\n    |-- App.vue\n    |-- main.js\n    |-- api           -- 请求数据，接口文件\n    |-- assets        -- 静态资源\n    |-- commons       -- 公共文件（公共方法，封装函数）\n    |-- components    -- Vue组件\n    |-- pages         -- 模块页面\n    |-- router        -- 路由文件\n    |-- store         -- 数据管理4、安装 vue-router 的 4.x 版本jsnpm install vue-router@4在 router 文件下新建 router.js 文件来增加路由控制，\njsimport &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;\n\nimport Login from &quot;../pages/login.vue&quot;;\nimport Home from &quot;../pages/home.vue&quot;;\n\nconst routes = [\n  &#123;\n    path: &quot;/login&quot;,\n    component: Login,\n  &#125;,\n  &#123;\n    path: &quot;/home&quot;,\n    component: Home,\n  &#125;,\n];\n\nconst router = createRouter(&#123;\n  history: createWebHashHistory(),\n  routes,\n&#125;);\n\nexport default router;createRouter 用来创建一个可以被 Vue 应用程序使用的路由实例，需要传入两个参数，history 是表示路由的历史记录，我们可以选择使用 createWebHistory、createWebHashHistory 来分别创建 HTML5 历史记录和 hash 历史记录，我们这里选择创建 hash 历史记录\n七、输入路由的时候是怎么获取到页面的\n\n\n\n\n\n\n\n\n当我们在浏览器中输入一个地址后，浏览器会根据路径构建一个请求，接下来就会对输入的域名进行 DNS 解析，得到正确的 IP 地址，然后和得到的 IP 地址建立 TCP 链接，发送 HTTP 请求，服务器接收到请求后，就会返回响应的 HTML 内容。完成了请求和响应后，浏览器拿到了返回的 HTML 字符串，转换成 DOM 树结构，经过对 DOM 的样式计算，最终生成布局，在页面上进行合成渲染\n八、性能优化1、路由懒加载：有效拆分 APP 尺寸，访问时才异步加载\n(1)当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样会更加高效，是一种优化手段。\n(2)一般来说，对所有的路由都使用动态导入是个好主意。\n(3)给 component 选项配置一个返回 Promise 组件的函数就可以定义懒加载路由。例如：{ path: ‘&#x2F;users&#x2F;:id’, component: () &#x3D;&gt; import(‘.&#x2F;views&#x2F;UserDetails’) }\n(4)结合注释() &#x3D;&gt; import(&#x2F;_ webpackChunkName: “group-user” _&#x2F; ‘.&#x2F;UserDetails.vue’)可以做 webpack 代码分块vite 中结合 rollupOptions 定义分块\n(5)路由中不能使用异步组件\n2、keep-alive 缓存页面：避免和重复创建组件实例，且能保留缓存组件状态\n3、v-show 复用 DOM：避免重复创建组件\n4、v-once 和 v-memo:不再变化的数据使用 v-once；按条件跳过更新时使用 v-memo\n5、长列表性能优化：如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容\n6、事件的销毁：Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件\n7、图片懒加载：图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。可以使用 vue-lazyload\n8、第三方插件按需引入：例如组件库（element-plus）\n9、服务端渲染：首屏渲染慢，可以考虑 SSR \\ SSG\n","slug":"88、vue3-vue2","date":"2022-08-11T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"4d836d52e736c79a6a6c9f9b03098430","title":"87、element的表单校验自动定位到未校验成功位置","content":"遇到的项目问题是在每个折叠面板里边都有不同的表单，用 element 上的校验时，若有没填写的表单或不符合表单格式的要求，则自动展开该折叠面板，且页面定位到没校验成功的表单。\n\n\n方法一jsthis.$refs.form.validate((valid, object) =&gt; &#123;\n  if (valid) &#123;\n    alert(&quot;submit!&quot;);\n  &#125; else &#123;\n    let split = &quot;&quot;;\n    for (let i in object) &#123;\n      let dom = this.$refs[i];\n      if (Object.prototype.toString.call(dom) !== &quot;[object Object]&quot;) &#123;\n        //这里是针对遍历的情况（多个输入框），取值为数组\n        dom = dom[0];\n        // 第一个未填写必填项的表单被记录，这个是为了处理如何把校验未成功的第一个面板展开\n        split = dom.prop;\n        let index = split.indexOf(&quot;.&quot;);\n        let last = split.lastIndexOf(&quot;.&quot;);\n        // 通过未填写的表单索引展开折叠面板\n        this.activeName = Number(split.slice(index + 1, last));\n        break;\n      &#125;\n      dom.$el.scrollIntoView(&#123;\n        //滚动到指定节点\n        block: &quot;center&quot;, //值有start,center,end，nearest，当前显示在视图区域中间\n        behavior: &quot;smooth&quot;, //值有auto、instant,smooth，缓动动画（当前是慢速的）\n      &#125;);\n    &#125;\n    console.log(&quot;error submit!!&quot;);\n    return false;\n  &#125;\n&#125;);方法二js submit(formName) &#123;\n    this.$refs[formName][&quot;validate&quot;]((valid) =&gt; &#123;\n      if (valid) &#123;\n\n      &#125; else &#123;\n        setTimeout(()=&gt;&#123;\n            var isError= document.getElementsByClassName(&quot;is-error&quot;);\n            isError[0].querySelector(&#39;input&#39;).focus();\n          &#125;,100);\n          return false;\n      &#125;\n    &#125;);\n  &#125;","slug":"87.element-validator","date":"2022-08-09T12:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"b9ee1ea0abd68e724076c2d54440fea9","title":"86、canvas电子签名","content":"canvas电子签名\n\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      #cvs &#123;\n        background-color: #000;\n        background: #000;\n      &#125;\n      body &#123;\n        height: 100vh;\n        background-color: rgb(26, 25, 25);\n      &#125;\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;canvas id=&quot;cvs&quot;&gt;&lt;/canvas&gt;\n    &lt;div style=&quot;margin-top: 50px&quot;&gt;\n      &lt;button id=&quot;clear&quot;&gt;清空&lt;/button&gt;\n      &lt;button id=&quot;back&quot;&gt;回退&lt;/button&gt;\n      &lt;button id=&quot;save&quot;&gt;保存&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      let width = 800;\n      let height = 400;\n      let isDownin = false;\n      let lastX = 0;\n      let lastY = 0;\n      let cacheData = [];\n\n      const cvs = document.getElementById(&quot;cvs&quot;);\n      const ctx = cvs.getContext(&quot;2d&quot;);\n      cvs.width = width;\n      cvs.height = height;\n\n      cvs.addEventListener(&quot;mousedown&quot;, (e) =&gt; &#123;\n        isDownin = true;\n        lastX = e.pageX;\n        lastY = e.pageY;\n        let cacheItem = ctx.getImageData(0, 0, width, height);\n        cacheData.push(cacheItem);\n        ctx.moveTo(lastX, lastY);\n      &#125;);\n      cvs.addEventListener(&quot;mousemove&quot;, (e) =&gt; &#123;\n        if (!isDownin) return;\n        drawLine(e.pageX, e.pageY);\n        ctx.stroke();\n      &#125;);\n      cvs.addEventListener(&quot;mouseup&quot;, (e) =&gt; &#123;\n        isDownin = false;\n      &#125;);\n\n      function drawLine(x, y) &#123;\n        ctx.beginPath();\n        ctx.lineWidth = 8;\n        ctx.strokeStyle = &quot;#fff&quot;;\n        ctx.lineCap = &quot;round&quot;;\n        ctx.lineJoin = &quot;round&quot;;\n        ctx.moveTo(lastX, lastY);\n        ctx.lineTo(x, y);\n        ctx.stroke();\n        lastX = x;\n        lastY = y;\n      &#125;\n\n      /* 清空 */\n      const clear = document.getElementById(&quot;clear&quot;);\n      clear.onclick = () =&gt; &#123;\n        ctx.clearRect(0, 0, width, height);\n      &#125;;\n\n      /* 回退 */\n      const back = document.getElementById(&quot;back&quot;);\n      back.onclick = () =&gt; &#123;\n        if (cacheData.length === 0) return;\n        ctx.putImageData(cacheData.pop(), 0, 0);\n      &#125;;\n\n      const save = document.getElementById(&quot;save&quot;);\n      save.onclick = () =&gt; &#123;\n        cvs.toBlob((blob) =&gt; &#123;\n          const a = document.createElement(&quot;a&quot;);\n          document.body.append(a);\n          a.download = `签名.png`;\n          a.href = URL.createObjectURL(blob);\n          a.click();\n          a.remove();\n        &#125;);\n      &#125;;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;","slug":"86.signature","date":"2022-08-08T15:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"6f52d7fc55673b773fa0af36dfe006d6","title":"85、常用代码片段","content":"整理一些常用的代码片段\n\n\n一、数组重排序jsconst shuffle = (arr) =&gt; arr.sort(() =&gt; Math.random() - 0.5);\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(shuffle(arr));二、复制到剪切板jsconst copyToClipboard = (text) =&gt;\n  navigator.clipboard &amp;&amp;\n  navigator.clipboard.writeText &amp;&amp;\n  navigator.clipboard.writeText(text);\n\ncopyToClipboard(&quot;Hello World!&quot;);三、滚动到顶部behavior:”smooth”：开启平滑滚动\njsconst scrollToTop = (element) =&gt;\n  element.scrollIntoView(&#123; behavior: &quot;smooth&quot;, block: &quot;start&quot; &#125;);四、检测设备jsconst detectDeviceType = () =&gt;\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  )\n    ? &quot;Mobile&quot;\n    : &quot;Desktop&quot;;\n\nconsole.log(detectDeviceType());五、深拷贝对象jsconst deepCopy = (obj) =&gt; JSON.parse(JSON.stringify(obj));六、等待函数jsconst wait = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));\n\nconst asyncFn = async () =&gt; &#123;\n  await wait(1000);\n  console.log(&quot;等待异步函数执行结束&quot;);\n&#125;;\n\nasyncFn();七、生成随机色jsconst generateRandomHexColor = () =&gt;\n  `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16)&#125;`;\n\nconsole.log(generateRandomHexColor());八、数组结构与树结构的转换数组结构数据\njsconst arrayData = [\n  &#123; id: 2, title: &quot;中国&quot;, parent_id: 0 &#125;,\n  &#123; id: 3, title: &quot;上海&quot;, parent_id: 2 &#125;,\n  &#123; id: 4, title: &quot;浦东新区&quot;, parent_id: 3 &#125;,\n  &#123; id: 5, title: &quot;新场古镇&quot;, parent_id: 4 &#125;,\n  &#123; id: 6, title: &quot;湖南省&quot;, parent_id: 2 &#125;,\n  &#123; id: 1, title: &quot;俄罗斯&quot;, parent_id: 0 &#125;,\n];方法一、使用递归：\n1、递归需分为两个函数来完成2、 以为返回的递归函数主要处理查找 id 添加 children3、 由转化函数将结果返回\njs/**\n * 递归查找添加children\n * @param &#123;数组数据&#125; data\n * @param &#123;存放返回结果&#125; result\n * @param &#123;父id&#125; pid\n */\nfunction getChildren(data, result, pid) &#123;\n  for (const item of data) &#123;\n    if (item.parent_id === pid) &#123;\n      const newItem = &#123; children: [], ...item &#125;;\n      result.push(newItem);\n      getChildren(data, newItem.children, item.id);\n    &#125;\n  &#125;\n&#125;\n\n/**\n * 转化方法\n * @param &#123;数组数据&#125; data\n * @param &#123;父id&#125; pid\n * @returns\n */\nfunction arrayToTree(data, pid) &#123;\n  let result = [];\n  getChildren(data, result, pid);\n  return result;\n&#125;\n\nconsole.log(arrayToTree(arrayData, 0));方法二、reduce\njs/**\n * 数组结构转为树结构\n * @param &#123;*&#125; data 数组数据\n * @returns\n */\nfunction arrayToTree(data) &#123;\n  const result = [];\n  const obj = data.reduce((pre, cur) =&gt; &#123;\n    pre[cur.id] = cur;\n    return pre;\n  &#125;, &#123;&#125;);\n  for (let item of data) &#123;\n    if (item.parent_id === 0) &#123;\n      result.push(item);\n      continue;\n    &#125;\n    if (item.parent_id in obj) &#123;\n      const parent = obj[item.parent_id];\n      parent.children = parent.children || [];\n      parent.children.push(item);\n    &#125;\n  &#125;\n  return result;\n&#125;九、树结构转数组结构数组结构\njs/** 树状形结构数据treeData */\nconst treeData = [\n  &#123;\n    id: 2,\n    title: &quot;中国&quot;,\n    parent_id: 0,\n    children: [\n      &#123;\n        id: 3,\n        title: &quot;上海&quot;,\n        parent_id: 2,\n        children: [\n          &#123;\n            id: 4,\n            title: &quot;浦东新区&quot;,\n            parent_id: 3,\n            children: [&#123; id: 5, title: &quot;新场古镇&quot;, parent_id: 4 &#125;],\n          &#125;,\n        ],\n      &#125;,\n      &#123; id: 6, title: &quot;湖南省&quot;, parent_id: 2 &#125;,\n    ],\n  &#125;,\n  &#123; id: 1, title: &quot;俄罗斯&quot;, parent_id: 0 &#125;,\n];递归方法\njs/**\n * 树结构数组扁平化\n * @param &#123;*&#125; data 树结构的数组\n * @returns\n */\nfunction treeToArray(data) &#123;\n  return data.reduce((pre, cur) =&gt; &#123;\n    const &#123; children = [], ...item &#125; = cur;\n    return pre.concat([&#123; ...item &#125;], treeToArray(children));\n  &#125;, []);\n&#125;十、数据类型验证jsfunction typeOf(obj) &#123;\n  const toString = Object.prototype.toString;\n  const map = &#123;\n    &quot;[object Boolean]&quot;: &quot;boolean&quot;,\n    &quot;[object Number]&quot;: &quot;number&quot;,\n    &quot;[object String]&quot;: &quot;string&quot;,\n    &quot;[object Function]&quot;: &quot;function&quot;,\n    &quot;[object Array]&quot;: &quot;array&quot;,\n    &quot;[object Date]&quot;: &quot;date&quot;,\n    &quot;[object RegExp]&quot;: &quot;regExp&quot;,\n    &quot;[object Undefined]&quot;: &quot;undefined&quot;,\n    &quot;[object Null]&quot;: &quot;null&quot;,\n    &quot;[object Object]&quot;: &quot;object&quot;,\n    &quot;[object FormData]&quot;: &quot;formData&quot;,\n  &#125;;\n  return map[toString.call(obj)];\n&#125;十一、只能输入金额html:rules=&quot;&#123; required: itrue, validator: validatePrice, trigger: &#39;blur&#39; &#125;&quot;jsvalidatePrice(rule, value, callback) &#123;\n    if (!value) &#123;\n        callback(new Error(&#39;请输入价格&#39;))\n    &#125; else if (!/(^[1-9]\\d*(\\.\\d&#123;1,2&#125;)?$)|(^0(\\.\\d&#123;1,2&#125;)?$)/.test(value)) &#123;\n        callback(new Error(&#39;请输入有效价格&#39;))\n    &#125; else if (value &gt;= 99999999) &#123;\n        callback(new Error(&#39;超过最大金额&#39;))\n    &#125; else &#123;\n        callback()\n    &#125;\n&#125;,十二、数字单位：10000 转换为万（含：亿）js/** 数字超过一万转换为万\n * @param &#123; Number &#125; value 数值\n * @param &#123; Number &#125; decimal 保留几位小数\n * @returns &#123; String &#125;\n */\nconst transNumberToShort = (value, decimal = 2) =&gt; &#123;\n  const k = 10000;\n  const sizes = [&quot;&quot;, &quot;万&quot;, &quot;亿&quot;, &quot;万亿&quot;];\n  let i = undefined;\n  let str = &quot;&quot;;\n  if (value &lt; k) &#123;\n    str = value;\n  &#125; else &#123;\n    i = Math.floor(Math.log(value) / Math.log(k));\n    str = (value / Math.pow(k, i)).toFixed(decimal) + sizes[i];\n  &#125;\n  return str;\n&#125;;十三、简单的数据双向绑定html&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;input type=&quot;text&quot; id=&quot;a&quot; /&gt;\n      &lt;span id=&quot;b&quot;&gt;&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n  &lt;script&gt;\n    var obj = &#123;\n      val: null,\n    &#125;; //定义一个空对象\n\n    Object.defineProperty(obj, &quot;val&quot;, &#123;\n      // 这里的 val 就是 obj 里面的值\n\n      get: function () &#123;\n        return val;\n      &#125;,\n\n      set: function (newVal) &#123;\n        val = newVal; //定义val等于修改后的内容\n        if (!val) return; // 阻止显示 undefined\n        document.getElementById(&quot;a&quot;).value = val; //让文本框的内容等于val\n\n        document.getElementById(&quot;b&quot;).innerHTML = val; //让span的内容等于val\n      &#125;,\n    &#125;);\n    document.addEventListener(&quot;keyup&quot;, function (e) &#123;\n      //当在文本框输入内容时让对象里你定义的val等于文本框的值\n\n      obj.val = e.target.value;\n    &#125;);\n  &lt;/script&gt;\n&lt;/html&gt;十四、数组大小排序jsvar num = [7, 8, 6, 5, 2];\n//倒序排列\nnum.sort((a, b) =&gt; &#123;\n  return b - a;\n&#125;);\n//正序排列\nnum.sort((a, b) =&gt; &#123;\n  return a - b;\n&#125;);十五、js 从数组里面取出某两个值作为对象的 key 和 valuejsconst data = [\n  &#123;\n    id: 1,\n    content: &quot;1111&quot;,\n  &#125;,\n  &#123;\n    id: 2,\n    content: &quot;2222&quot;,\n  &#125;,\n  &#123;\n    id: 3,\n    content: &quot;3333&quot;,\n  &#125;,\n];\nlet lessonObj = data.reduce((obj, cur, index) =&gt; &#123;\n  obj[`config_$&#123;cur[&quot;id&quot;]&#125;`] = cur[&quot;content&quot;];\n  return obj;\n&#125;, &#123;&#125;);十六、深拷贝、浅拷贝\n\n\n\n\n\n\n\n\n区别：浅拷贝地址还是指向原来那个内存地址，深拷贝是重新开辟一个内存地址\n\n\n\n\n\n\n\n\n\n浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间\njsObject.assign()\nArray.prototype.slice(0)\n扩展运算符（...）\n\n\n\n\n\n\n\n\n深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝\njs// 方法一\nJSON.parse(JSON.stringify());\n\n// 方法二\n// 循环对象，把对象的 KEY 和 VALUE 存放到一个新的变量里面\nfunction deepClone(source) &#123;\n  const targetObj = source.constructor === Array ? [] : &#123;&#125;;\n  for (keys in source) &#123;\n    if (source.hasOwnProperty(keys)) &#123;\n      // 数组和对象\n      if (source[keys] &amp;&amp; typeof source[keys] === &quot;object&quot;) &#123;\n        // targetObj[keys] = targetObj[keys] === Array ? [] : &#123;&#125;; // 只是为了可读性，可要可不要\n        targetObj[keys] = deepClone(source[keys]);\n      &#125; else &#123;\n        // 基本类型\n        targetObj[keys] = source[keys];\n      &#125;\n    &#125;\n  &#125;\n  return targetObj;\n&#125;","slug":"85.js-function","date":"2022-08-06T15:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"7625dec645dd96c87c054cb6dd2304f5","title":"84、Chrome快速切换搜索引擎","content":"如何在不同的搜索引擎的之间快速切换？其实谷歌浏览器（Chrome）自带了一个关键词功能，只需要稍加修改，就可以方便的实现搜索引擎切换，不需要额外安装任何特殊软件或者浏览器插件。\n\n\n一、Chrome浏览器的设置1、打开Chrome浏览器的设置，找到搜索引擎设置，然后点击管理搜索引擎。 \n2、进入后会看到各个搜索引擎的设置项，我们以百度为例，点击这一条右侧的三个小点，然后点击编辑\n3、在弹出来的对话框中，把关键词这一项改为一个更简洁的关键词，例如“bd”，然后点击保存。\n4、在Chrome搜索框内输入关键词，然后tab或者空格,即可切换输入法\n","slug":"84.search","date":"2022-08-04T14:00:00.000Z","categories_index":"","tags_index":"tool","author_index":"Jude"},{"id":"8b5c323045fddf5db82f04ce0344c7e7","title":"83、egg-jwt用户鉴权、注册、登录及中间件","content":"\n\n一、egg-jwt实现用户鉴权\n\n\n\n\n\n\n\n\n用户鉴权，一种用于在通信网络中对试图访问来自服务提供商的服务的用户进行鉴权的方法。用于用户登陆到DSMP或使用数据业务时，业务网关或Portal发送此消息到DSMP，对该用户使用数据业务的合法性和有效性（状态是否为激活）进行检查。\n简单理解，鉴权就是用户在浏览网页或 App 时，通过约定好的方式，让网页和用户建立起一种相互信赖的机制，继而返回给用户需要的信息。\n鉴权的机制：\n\nHTTP Basic Authentication\nsession-cookie\nToken 令牌\nOAuth(开放授权)\n\ntoken 可以运用在如网页、客户端、小程序、浏览器插件等等领域。如果选用 cookie 的形式鉴权，在客户端和小程序就无法使用这套接口，因为它们没有域的概念，而 cookie 是需要存在某个域下。\n二、注册接口在 controller 目录下新建 user.js 用于编写用户相关的代码\njs// controller/user.js\n&#39;use strict&#39;;\n\nconst Controller = require(&#39;egg&#39;).Controller;\n\nclass UserController extends Controller &#123;\n  async register() &#123;\n    const &#123; ctx &#125; = this;\n    const &#123; username, password &#125; = ctx.request.body; // 获取注册需要的参数\n  &#125;\n&#125;\n\nmodule.exports = UserController;此时我们拿到了 username 和 password，我们需要判断两个参数是否为空。如果是空，则返回错误信息：\njs// 判空操作\nif (!username || !password) &#123;\n  ctx.body = &#123;\n    code: 500,\n    msg: &#39;账号密码不能为空&#39;,\n    data: null\n  &#125;\n  return\n&#125;此时我们还需要一个判断，根据用户传入的 username 去数据库的 user 表查询，是否已经被注册。\n在 service 目录下新建 user.js，并且添加 getUserByName 方法用于根据 username 查找用户信息\njs//  service/user.js\n&#39;use strict&#39;;\n\nconst Service = require(&#39;egg&#39;).Service;\n\nclass UserService extends Service &#123;\n  // 通过用户名获取用户信息\n  async getUserByName(username) &#123;\n    const &#123; app &#125; = this;\n      try &#123;\n        const result = await app.mysql.get(&#39;user&#39;, &#123; username &#125;);\n        return result;\n      &#125; catch (error) &#123;\n        console.log(error);\n        return null;\n      &#125;\n  &#125;\n&#125;\nmodule.exports = UserService;\n\n\n\n\n\n\n\n\n使用 async 和 await 时，如果想捕获错误，需要使用 try…catch 来捕获，如果代码运行过程中发生错误，都将会被 catch 捕获。\n controller/user.js 继续添加逻辑，在 「判空操作」逻辑下，判断是否已经被注册的逻辑：\njs// controller/user.js\nasync register() &#123;\n  ...\n  // 验证数据库内是否已经有该账户名\n  const userInfo = await ctx.service.user.getUserByName(username) // 获取用户信息\n\n  // 判断是否已经存在\n  if (userInfo &amp;&amp; userInfo.id) &#123;\n    ctx.body = &#123;\n      code: 500,\n      msg: &#39;账户名已被注册，请重新输入&#39;,\n      data: null\n    &#125;\n    return\n  &#125;\n&#125;经过上述两层判断之后，接下便可将账号和密码写入数据库\njs// controller/user.js\n// 默认头像，放在 user.js 的最外，部避免重复声明。\nconst defaultAvatar = &#39;http://s.yezgea02.com/1615973940679/WeChat77d6d2ac093e247c361f0b8a7aeb6c2a.png&#39;\n// 调用 service 方法，将数据存入数据库。\nconst result = await ctx.service.user.register(&#123;\n  username,\n  password,\n  signature: &#39;世界和平。&#39;,\n  avatar: defaultAvatar\n&#125;);\n\nif (result) &#123;\n  ctx.body = &#123;\n    code: 200,\n    msg: &#39;注册成功&#39;,\n    data: null\n  &#125;\n&#125; else &#123;\n  ctx.body = &#123;\n    code: 500,\n    msg: &#39;注册失败&#39;,\n    data: null\n  &#125;\n&#125;service/user.js 添加 register 写入数据库的方法\njs// service/user.js\n...\n// 注册\nasync register(params) &#123;\n  const &#123; app &#125; = this;\n  try &#123;\n    const result = await app.mysql.insert(&#39;user&#39;, params);\n    return result;\n  &#125; catch (error) &#123;\n    console.log(error);\n    return null;\n  &#125;\n&#125;在 router.js 将接口抛出\njs// router.js\n&#39;use strict&#39;;\n\n/**\n * @param &#123;Egg.Application&#125; app - egg application\n */\nmodule.exports = app =&gt; &#123;\n  const &#123; router, controller &#125; = app;\n  router.post(&#39;/api/user/register&#39;, controller.user.register);\n&#125;;通过postman工具测试接口。\n三、登录接口\n\n\n\n\n\n\n\n\n通过注册的「用户名」和「密码」，调用登录接口，接口会返回给我们一个 token 令牌\n每次发起请求，无论是获取数据，还是提交数据，我们都需要将 token 带上，以此来标识，此次获取(GET)或提交(POST)是哪一个用户的行为。\n egg-jwt 有加密的功能，也有解密的功能。通过解密 token 拿到当初加密 token 时的信息，信息的内容大致就是当初注册时候的用户信息。\n安装egg-jwt插件\nshellnpm i egg-jwt -SEgg-jwt的仓库地址\n在 config/plugin.js 下添加插件：\njsjwt: &#123;\n  enable: true,\n  package: &#39;egg-jwt&#39;\n&#125;config/config.default.js 下添加自定义加密字符串\njsconfig.jwt = &#123;\n  secret: &#39;YQ&#39;,\n&#125;;\n\n\n\n\n\n\n\n\nsecret加密字符串，将在后续用于结合用户信息生成一串token\n在 /controller/user.js 下新建 login 方法\njsasync login() &#123;\n    // app 为全局属性，相当于所有的插件方法都植入到了 app 对象。\n    const &#123; ctx, app &#125; = this;\n    const &#123; username, password &#125; = ctx.request.body\n    // 根据用户名，在数据库查找相对应的id操作\n    const userInfo = await ctx.service.user.getUserByName(username)\n    // 没找到说明没有该用户\n    if (!userInfo || !userInfo.id) &#123;\n      ctx.body = &#123;\n        code: 500,\n        msg: &#39;账号不存在&#39;,\n        data: null\n      &#125;\n      return\n    &#125;\n    // 找到用户，并且判断输入密码与数据库中用户密码。\n    if (userInfo &amp;&amp; password != userInfo.password) &#123;\n      ctx.body = &#123;\n        code: 500,\n        msg: &#39;账号密码错误&#39;,\n        data: null\n      &#125;\n      return\n    &#125;\n       // 生成 token 加盐\n      // app.jwt.sign 方法接受两个参数，第一个为对象，对象内是需要加密的内容；第二个是加密字符串，上文已经提到过。\n    const token = app.jwt.sign(&#123;\n      id: userInfo.id,\n      username: userInfo.username,\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // token 有效期为 24 小时\n    &#125;, app.config.jwt.secret);\n\n    ctx.body = &#123;\n      code: 200,\n      message: &#39;登录成功&#39;,\n      data: &#123;\n        token\n      &#125;,\n    &#125;;\n&#125;\n把获取到的 userInfo 中的 id 和 username 两个属性，通过 app.jwt.sign 方法，结合 app.config.jwt.secret 加密字符串（之前声明的 YQ），生成一个 token。这个 token 会是一串很长的加密字符串\n在 /controller/user.js 中，新增一个验证方法 test\njs// 验证方法\nasync test() &#123;\n  const &#123; ctx, app &#125; = this;\n  // 通过 token 解析，拿到 user_id\n  const token = ctx.request.header.authorization; // 请求头获取 authorization 属性，值为 token\n  // 通过 app.jwt.verify + 加密字符串 解析出 token 的值 \n  const decode = await app.jwt.verify(token, app.config.jwt.secret);\n  // 响应接口\n  ctx.body = &#123;\n    code: 200,\n    message: &#39;获取成功&#39;,\n    data: &#123;\n      ...decode\n    &#125;\n  &#125;\n&#125;在路由 router.js 脚本中，将登录接口抛出\njs&#39;use strict&#39;;\n\n/**\n * @param &#123;Egg.Application&#125; app - egg application\n */\nmodule.exports = app =&gt; &#123;\n  const &#123; router, controller &#125; = app;\n  router.post(&#39;/api/user/register&#39;, controller.user.register);\n  router.post(&#39;/api/user/login&#39;, controller.user.login);\n&#125;;四、登录验证中间件中间件我们可以理解成一个过滤器，举个例子，我们有 A、B、C、D 四个接口是需要用户权限的，如果我们要判断是否有用户权限的话，就需要在这四个接口的控制层去判断用户是否登录。\n每个接口都验证存在的弊端\n\n\n\n\n\n\n\n\n\n1、每次编写新的接口，都要在方法内部做判断，这很费事。 2、一旦鉴权有所调整，我们需要修改每个用到判断登录的代码。\n在请求接口的时候，过一层中间件，判断该请求是否是登录状态下发起的。此时我们打开项目，在 app 目录下新新建一个文件夹 middleware，并且在该目录下新增 jwtErr.js\njs&#39;use strict&#39;;\n\nmodule.exports = (secret) =&gt; &#123;\n  return async function jwtErr(ctx, next) &#123;\n    const token = ctx.request.header.authorization; // 若是没有 token，返回的是 null 字符串\n    let decode\n    if(token != &#39;null&#39; &amp;&amp; token) &#123;\n      try &#123;\n        decode = ctx.app.jwt.verify(token, secret); // 验证token\n        await next();\n      &#125; catch (error) &#123;\n        console.log(&#39;error&#39;, error)\n        ctx.status = 200;\n        ctx.body = &#123;\n          msg: &#39;token已过期，请重新登录&#39;,\n          code: 401,\n        &#125;\n        return;\n      &#125;\n    &#125; else &#123;\n      ctx.status = 200;\n      ctx.body = &#123;\n        code: 401,\n        msg: &#39;token不存在&#39;,\n      &#125;;\n      return;\n    &#125;\n  &#125;\n&#125;\n首先中间件默认抛出一个函数，该函数返回一个异步方法 jwtErr，jewErr 方法有两个参数 ctx 是上下文，可以在 ctx 中拿到全局对象 app。\n首先，通过 ctx.request.header.authorization 获取到请求头中的 authorization 属性，它便是我们请求接口是携带的 token 值，如果没有携带 token，该值为字符串 null。我们通过 if 语句判断如果有 token 的情况下，使用 ctx.app.jwt.verify 方法验证该 token 是否存在并且有效，如果是存在且有效，则通过验证 await next() 继续执行后续的接口逻辑。否则判断是失效还是不存在该 token。\n中间件完成后，我们在路由中router.js 去使用它\njs&#39;use strict&#39;;\n\n/**\n * @param &#123;Egg.Application&#125; app - egg application\n */\nmodule.exports = app =&gt; &#123;\n  const &#123; router, controller, middleware &#125; = app;\n  const _jwt = middleware.jwtErr(app.config.jwt.secret); // 传入加密字符串\n  router.post(&#39;/api/user/register&#39;, controller.user.register);\n  router.post(&#39;/api/user/login&#39;, controller.user.login);\n  router.get(&#39;/api/user/test&#39;, _jwt, controller.user.test); // 放入第二个参数，作为中间件过滤项\n&#125;;","slug":"83-egg-jwt","date":"2022-08-03T14:00:00.000Z","categories_index":"","tags_index":"egg","author_index":"Jude"},{"id":"ca10d3e7f1a13d6503bb04ce7c675542","title":"82、egg-mysql的增删改查","content":"MySQL安装成功后，在egg项目中安装egg-mysql插件，配置完成后，编写查询、新增、删除、编辑接口。\n\n\n一、安装MySQL版本选择MySQL 8.0.20  Mac Intel 版本\n安装过程设置密码：0987654321\n此时在terminal输入命令：\ntxtmysql -u root -pCommod not found\n1、termina进入 路径：&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin  查看目录是否有mysql\n如果存在，在此路径下执行：vim ~&#x2F;.bash_profile\n打开后，输入 i 键，进入编辑，在.bash_profile中添加mysql&#x2F;bin的目录，完成后，ESC退出编辑，输入：wq回车保存\ntxtPATH=$PATH:/usr/local/mysql/bin2、输入source  ~&#x2F;.bash_profile      使配置生效\n3、指令登录数据库：mysql -u root -p   输入密码：0987654321\n4、开启服务：mysql.server start\n二、egg.js安装egg-mysql插件1、安装egg-mysql及插件配置shellnpm install egg-mysql\n\nconfig&#x2F;plugin.js\njs&#39;use strict&#39;;\n\n/** @type Egg.EggPlugin */\nmodule.exports = &#123;\n  ejs: &#123;\n    enable: true,\n    package: &#39;egg-view-ejs&#39;\n  &#125;,\n  mysql: &#123;\n    enable: true,\n    package: &#39;egg-mysql&#39;\n  &#125;\n&#125;;config&#x2F;plugin-default.js\njsexports.mysql = &#123;\n  // 单数据库信息配置\n  client: &#123;\n    // host\n    host: &#39;localhost&#39;,\n    // 端口号\n    port: &#39;3306&#39;,\n    // 用户名\n    user: &#39;root&#39;,\n    // 密码\n    password: &#39;数据库密码&#39;, // 初始化密码，没设置的可以不写\n    // 数据库名\n    database: &#39;test&#39;, // 我们新建的数据库名称\n  &#125;,\n  // 是否加载到 app 上，默认开启\n  app: true,\n  // 是否加载到 agent 上，默认关闭\n  agent: false,\n&#125;;2、修改 service/home.jsjs&#39;use strict&#39;;\n\nconst Service = require(&#39;egg&#39;).Service;\n\nclass HomeService extends Service &#123;\n  async user() &#123;\n    const &#123; ctx, app &#125; = this;\n    const QUERY_STR = &#39;id, name&#39;;\n    let sql = `select $&#123;QUERY_STR&#125; from list`; // 获取 id 的 sql 语句\n    try &#123;\n      const result = await app.mysql.query(sql); // mysql 实例已经挂载到 app 对象下，可以通过 app.mysql 获取到。\n      return result;\n    &#125; catch (error) &#123;\n      console.log(error);\n      return null;\n    &#125;\n  &#125;\n&#125;\nmodule.exports = HomeService;3、修改controller&#x2F;home.js中的user方法jsasync user() &#123;\n  const &#123; ctx &#125; = this;\n  const result = await ctx.service.home.user();\n  ctx.body = result\n&#125;4、路由配置jsrouter.get(&#39;/user&#39;, controller.home.user);三、新增接口在 service/home.js 下新建一个函数 addUser\njs// 新增\nasync addUser(name) &#123;\n  const &#123; ctx, app &#125; = this;\n  try &#123;\n    const result = await app.mysql.insert(&#39;list&#39;, &#123; name &#125;); // 给 list 表，新增一条数据\n    return result;\n  &#125; catch (error) &#123;\n    console.log(error);\n    return null;\n  &#125;\n&#125;再为 controller/home.js 添加一个 addUser 方法\njsasync addUser() &#123;\n  const &#123; ctx &#125; = this;\n  const &#123; name &#125; = ctx.request.body;\n  try &#123;\n    const result = await ctx.service.home.addUser(name);\n    ctx.body = &#123;\n      code: 200,\n      msg: &#39;添加成功&#39;,\n      data: null\n    &#125;\n  &#125; catch (error) &#123;\n    ctx.body = &#123;\n      code: 500,\n      msg: &#39;添加失败&#39;,\n      data: null\n    &#125;\n  &#125;\n&#125;配置路由\njsrouter.post(&#39;/add_user&#39;, controller.home.addUser);这个post请求需要使用postman测试接口是否成功。\n四、编辑接口通过 /user 拿到了列表数据，我们可以通过 id 定位某条数据，去修改它的 name 属性。\n/service/home.js，添加编辑操作\njs// 编辑\nasync editUser(id, name) &#123;\n  const &#123; ctx, app &#125; = this;\n  try &#123;\n    let result = await app.mysql.update(&#39;list&#39;, &#123; name &#125;, &#123;\n      where: &#123;\n        id\n      &#125;\n    &#125;);\n    return result;\n  &#125; catch (error) &#123;\n    console.log(error);\n    return null;\n  &#125;\n&#125;/controller/home.js 添加如下代码：\njs// 编辑\nasync editUser() &#123;\n  const &#123; ctx &#125; = this;\n  const &#123; id, name &#125; = ctx.request.body;\n  try &#123;\n    const result = await ctx.service.home.editUser(id, name);\n    ctx.body = &#123;\n      code: 200,\n      msg: &#39;添加成功&#39;,\n      data: null\n    &#125;\n  &#125; catch (error) &#123;\n    ctx.body = &#123;\n      code: 500,\n      msg: &#39;添加失败&#39;,\n      data: null\n    &#125;\n  &#125;\n&#125;配置路由：\njsrouter.post(&#39;/edit_user&#39;, controller.home.editUser);post请求需要使用postman工具测试接口\n五、删除接口在 /service/home.js 添加删除接口\njs// 删除\nasync deleteUser(id) &#123;\n  const &#123; ctx, app &#125; = this;\n  try &#123;\n    let result = await app.mysql.delete(&#39;list&#39;, &#123; id &#125;);\n    return result;\n  &#125; catch (error) &#123;\n    console.log(error);\n    return null;\n  &#125;\n&#125;/controller/home.js 添加相应的控制器方法\njs// 删除\nasync deleteUser() &#123;\n  const &#123; ctx &#125; = this;\n  const &#123; id &#125; = ctx.request.body;\n  try &#123;\n    const result = await ctx.service.home.deleteUser(id);\n    ctx.body = &#123;\n      code: 200,\n      msg: &#39;删除成功&#39;,\n      data: null\n    &#125;\n  &#125; catch (error) &#123;\n    ctx.body = &#123;\n      code: 500,\n      msg: &#39;删除失败&#39;,\n      data: null\n    &#125;\n  &#125;\n&#125;添加相应路由：\njs// router.js\nrouter.post(&#39;/delete_user&#39;, controller.home.deleteUser);","slug":"82-egg-mysql","date":"2022-08-03T12:00:00.000Z","categories_index":"","tags_index":"egg","author_index":"Jude"},{"id":"5f8f097a21466c69e2c88aab3ae33526","title":"81、egg.js(二)","content":"Egg.js：https://issummer.cn/2021/06/20/egg/\n\n\n一、项目环境egg.js对node版本是有要求的，node&gt; 8.x npm &gt;&#x3D; 6.1.0\n目前电脑环境：node:12.6.0  npm 6.1.0\negg提供脚手架生成指令\nshellmkdir egg-example &amp;&amp; cd egg-example\nnpm init egg --type=simple\nnpm i启动项目会出现报错：Cannot find module ‘fs&#x2F;promise’\n主要是由于node版本较低造成的，使用n 升级node版本到16.13.0 ,重新npm install，启动项目，报错消失。\n二、egg项目目录Egg 作为一套解决方案，它内部高度集成了封装好的项目目录结构，现代开发俗称“约定式开发”。正常情况下，你从 0 开始搭建一个 Node 服务端代码，需要结合很多工具插件来辅助完成项目的搭建，而 Egg 则提前为你提供好了这些繁琐的初始工作，让你能专心与业务层面的开发。\n当然，“约定式开发”也有不好的地方，很多配置项都是内部约定好的，在你想要用到某一个功能时，你可能需要去查阅 Egg 的官方文档是如何配置的，这就会消耗一点时间，但是相比之下，使用它的利大于弊。\n1、app&#x2F;router.js用于配置 URL 路由规则，比如 get 请求，npm run dev 启动项目之后，直接在浏览器中访问启动的端口 + 路径，默认是 http://localhost:7001/，将会拿到 app/controller 文件夹下，home.js 脚本中 index 方法返回的内容。\n这就是路由配置的作用，当然，抛出的形式有多种，如router.get、router.post、router.delete、router.put 等，都是支持的，更加具体的内容 Router 配置。\n2、app&#x2F;controller&#x2F;xx用于解析用户的输入，处理后返回相应的结果。通过请求路径将用户的请求基于 method 和 URL 分发到对应的 Controller 上，而 Controller 要做的事情就是响应用户的诉求。举个例子，我想拿到 A 用户的个人信息，于是我们要在控制器（Controller）里，通过请求携带的 A 用户的 id 参数，从数据库里获取指定用户的个人信息。\n控制器需要做的就是处理数据和响应请求返回数据。更加详细的描述 Controller 文档\n3、app&#x2F;service&#x2F;xx简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层。初始化项目中未声明 service 文件夹，它是可选项，但是官方建议我们操作业务逻辑最好做一层封装。我们换一种理解方式，Service 层就是用于数据库的查询，我们尽量将粒度细化，这样以便多个 Controller 共同调用同一个 Service。更加详细的描述 Service 文档。\n4、app&#x2F;middleware&#x2F;xx用于编写中间件，中间件的概念就是在路由配置里设置了中间件的路由，每次请求命中后，都要过一层中间件。在后续的开发中，也会利用到这个中间件的原理做用户鉴权。当用户未登录的情况下，是不能调用某些接口的。\n每次都在 Controller 判断，当前请求是否携带有效的用户认证信息。接口一多，到处都是这样的判断，逻辑重复。所以，中间件在某种程度上，也算是优化代码结构的一种方式。更加详细的描述 Middleware 文档。\n5、app&#x2F;public&#x2F;xx用于放置静态资源。会有一个上传静态资源的接口，包括图片、文本文档、excel、word等，都可以通过服务端读取文件之后，将其写入 app/public 文件夹中。在目前没有 OSS 服务的情况下，姑且先用这种方式存储静态资源，会消耗一点服务器的内存。\n6、config&#x2F;config.{env}.js用于编写配置文件。 config/config.default.js 文件，这个是 Egg 框架约定好的，在内部设置一些全局的配置常量，在任何地方都可以通过 app.config 获取到 config.default.js 文件内的配置项。\n7、config&#x2F;plugin.js用于配置需要加载的插件。比如 egg-mysql、egg-cors、egg-jwt 等官方提供的插件\n三、编写 GET 和 POST 接口GET 请求参数获取浏览器输入URL：http:*//localhost:7001/?id=12\n打开 app/controller/home.js，通过如下形式获取到浏览器查询参数\njsconst Controller = require(&#39;egg&#39;).Controller;\n\nclass HomeController extends Controller &#123;\n  async index() &#123;\n    const &#123; ctx &#125; = this;\n    const &#123; id &#125; = ctx.query;\n    ctx.body = id;\n  &#125;\n&#125;\n\nmodule.exports = HomeController;还有另一种获取申明参数，比如我希望通过这样一个地址获取用户参数 /user/5，想获取用户 id 为 5 的用户信息。我们可以这样操作，首先添加路由，打开 app/router.js 添加一个路由：\njs&#39;use strict&#39;;\n\n/**\n * @param &#123;Egg.Application&#125; app - egg application\n */\nmodule.exports = app =&gt; &#123;\n  const &#123; router, controller &#125; = app;\n  router.get(&#39;/&#39;, controller.home.index);\n  router.get(&#39;/user/:id&#39;, controller.home.user);\n&#125;;其次在 app/controller/home.js 下添加一个 user 方法如下：\njs&#39;use strict&#39;;\n\nconst Controller = require(&#39;egg&#39;).Controller;\n\nclass HomeController extends Controller &#123;\n  async index() &#123;\n    const &#123; ctx &#125; = this;\n    const &#123; id &#125; = ctx.query;\n    ctx.body = id;\n  &#125;\n  // 获取用户信息\n  async user() &#123;\n    const &#123; ctx &#125; = this;\n    const &#123; id &#125; = ctx.params; // 通过 params 获取申明参数\n    ctx.body = id;\n  &#125;\n&#125;\nmodule.exports = HomeController;浏览器输入URL：localhost:7001/user/123\n网页会打印出：123\npost请求参数获取POST 接口需要借助 Postman 工具进行请求，因为通过浏览器无法手动发起 POST 请求，只能通过浏览器地址栏发起 GET 请求。\njs// app/router.js\n// ...\nrouter.post(&#39;/add&#39;, controller.home.add);js// app/controller/home.js\n// post 请求方法\nasync add() &#123;\n  const &#123; ctx &#125; = this;\n  const &#123; title &#125; = ctx.request.body;\n  // Egg 框架内置了 bodyParser 中间件来对 POST 请求 body 解析成 object 挂载到 ctx.request.body 上\n  ctx.body = &#123;\n    title\n  &#125;;\n&#125;用Postman发送post请求会出现报错，触发网络请求的安防策略\nconfig/config.default.js 做好白名单配置，全部允许请求：\njsconfig.security = &#123;\n  csrf: &#123;\n    enable: false,\n    ignoreJSON: true\n  &#125;,\n  domainWhiteList: [ &#39;*&#39; ], // 配置白名单\n&#125;;配置完成后，再次发送请求，可以看到请求成功，成功拿到服务端参数。\n从 Service 内获取数据模拟一下在 Service 中获取数据库的数据，在 app 目录下新建 service，并且创建一个 home.js，\njs&#39;use strict&#39;\n\nconst Service = require(&#39;egg&#39;).Service\n\nclass HomeService extends Service &#123;\n  async user()&#123;\n    // 假设从数据库获取的用户信息\n    return &#123;\n      name:&#39;yu&#39;,\n      msg:&#39;i love you egg.js&#39;\n    &#125;\n  &#125;\n&#125;\n\nmodule.exports = HomeService在 Controller 内拿到上述方法\njs//  app/controller/home.js\n// 获取用户信息\nasync user() &#123;\n  const &#123; ctx &#125; = this;\n  const &#123; name, msg &#125; = await ctx.service.home.user();\n  ctx.body = &#123;\n    name,\n    msg\n  &#125;\n&#125;Postman打开http://127.0.0.1:7001/user/yu  可以看到网页显示：{“name”:”yu”,”msg”:”i love you egg.js”}\n四、Egg.js 中使用前端模板开发一些简单的网页，想快速部署到云服务器上，就可以使用前端模板的开发形式。\n1、首先安装插件 egg-view-ejs：shellnpm install egg-view-ejs -save2、然后在 config/plugin.js 里面声明需要用到的插件：jsmodule.exports = &#123;\n  ejs: &#123;\n    enable: true,\n    package: &#39;egg-view-ejs&#39;\n  &#125;\n&#125;;3、去 config/config.default.js 里配置 ejs ，这一步我们会将 .ejs 的后缀改成 .html 的后缀。jsconfig.view = &#123;\n  mapping: &#123;&#39;.html&#39;: &#39;ejs&#39;&#125;  //左边写成.html后缀，会自动渲染.html文件\n&#125;;上述的配置，指的是将 view 文件夹下的 .html 后缀的文件，识别为 .ejs。\n接着，在 app 目录下创建 view 文件夹，并且新建一个 index.html 文件，作为前端模板\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;&lt;%-title%&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- 使用模板数据 --&gt;\n    &lt;h1&gt;&lt;%-title%&gt;&lt;/h1&gt; \n&lt;/body&gt;\n&lt;/html&gt;在 Controller 内把变量注入到 index.html 文件，模板通过 &lt;%-xx%&gt;关键字获取到传入的变量。\n4、修改 controller/home.js 下的 index 方法jsasync index() &#123;\n  const &#123; ctx &#125; = this;\n  // ctx.render 默认会去 view 文件夹寻找 index.html，这是 Egg 约定好的。\n  await ctx.render(&#39;index.html&#39;, &#123;\n    title: &#39;于齐&#39;, // 将 title 传入 index.html\n  &#125;);\n&#125;浏览器打开：localhost:7001  就会显示：于齐\n上述开发模式便是前后端不分离的模式，在页面不复杂的情况下，整个项目不采用如 React 、Vue 这些前端框架，也是可以的。在上述代码 ctx.render 之前，我们可以从数据库获取想要的信息，作为参数塞入模板中，模板拿到数据，构建 HTML。如果是提交事件，可以通过原生 ajax 或者是引入一把梭专家 jQuery，提交数据。\n","slug":"81-egg.js","date":"2022-08-02T12:00:00.000Z","categories_index":"","tags_index":"egg","author_index":"Jude"},{"id":"6bbe4d12f264ccc0c8550bef06f65a4b","title":"80、使用 element-plus 版本升级后的问题清单","content":"element-plus 版本升级由@1.1.0-beta.15 升级到@2.0.4 版本时，在开发时遇到的问题整理及解决方法\n\n\n一、错误： Can&#39;t reexport the named export &#39;xxx&#39; from non EcmaScript module (only default export is available) 处理这个问题是 element plus 版本升级后，再运行项目，element plus 对 webpack 的一个编译处理。\n解决方式：\n在 vue.config.js 的 chainWebpack 下增加一个规则：\njschainWebpack(config)&#123;\n  config.module\n  .rule(&quot;element-plus-2&quot;)\n  .test(/\\.mjs$/)\n  // https://webpack.docschina.org/configuration/module/#ruletype\n  .type(&quot;javascript/auto&quot;)\n  .include.add(/node_modules/)\n  .end();\n&#125;二、样式错误问题：input的白&#x2F;蓝边、图片的灰色底在做用户登录发现的el-input 存在的2个样式问题\ncss// 处理 input 的白/蓝边\n.el-input__inner &#123;\n  box-shadow: none !important;\n  --el-select-input-focus-border-color: none !important;\n&#125;\n\n// 处理图片的灰色底\n.el-avatar &#123;\n  --el-avatar-bg-color: none !important;\n&#125;\n三、tbody路径的变更1.x版本的element plus获取el元素的方式为：\njsconst el = tableRef.value.$el.querySelectorAll(&#39;.el-table__body-wrapper &gt; table &gt; tbody&#39;)[0]2.x版本的element plus获取el元素的方式为\njsconst el = tableRef.value.$el.querySelectorAll(&#39;.el-table__body &gt; tbody&#39;)[0]四、中台项目侧边栏收起图标不显示问题查看控制台发现，#app .sidebar-container .svg-icon{margin-left:16px} 这个样式存在问题\n解决方式：在侧边栏menu收起时，取消margin-left\ncss.el-menu--collapse&#123;\n  .svg-icon&#123;\n    margin-right:0px;\n  &#125;\n&#125;","slug":"80-element-plus","date":"2022-08-01T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"37b219f184dabddbe2b36b7003f81908","title":"79、ref-reactive","content":"ref&#x2F;reactive 都能创建一个响应对象，这二者的区别是什么呢？\n\n\n一、reactive\n\n\n\n\n\n\n\n\nreactive 都能创建一个响应对象或数组\n1、reactive 用来创建引用类型的响应式数据\n2、reactive 的本质是将每一层的数据都解析成 proxy 对象\n3、reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一遍，重新渲染 dom\n4、直接解构，响应性会丢失，需要用 toRefs 包裹。引用类型直接改变引用地址也会导致响应式丢失\nhtml&lt;tempalte&gt;\n  &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt;\n&lt;/tempalte&gt;js// script 这里加了setup  没写setup需要在setup()&#123;&#125;内部定义 并返回（return）\n&lt;script setup&gt;\nimport &#123; reactive &#125; from &quot;vue&quot;\nconst state = reactive(&#123;count:0&#125;)\n&lt;/script&gt;\n二、ref\n\n\n\n\n\n\n\n\nvue3 提供了一个 ref()方法允许我们创建使用任何值类型的响应式 ref\n1、ref 用来创建基础类型的响应式数据\n2、template 中默认调用 value 显示数据，script 中需要使用.value 调用\n3、和 react ref 差不多，react 是.current 获取值，vue3 是.value\njsimport &#123; ref &#125; from &quot;vue&quot;;\nconst count = ref(0);\nconsole.log(count); // &#123; value:0 &#125;\ncount.value++;\nconsole.log(count.value); // 2相关 API\n1、Ref ts 定义 import { type Ref } from ‘vue’;\n2、isRef 判断是否为 ref 对象。一般是 ref，toRef，toRefs 创建的变量\n3、toRefs 将 reactive 对象解构为单个响应式对象\n4、shallowRef 创建一个跟踪自身  .value  变化的 ref，但不会使其值也变成响应式的，简单理解为创建一个和 ref 相同结构的非响应式变量\n5、triggerRef 强制更新页面 DOM。即使创建的 ref 没有变，想更新 dom 可以用\n6、customRef 提供类似于 computed 的 get 和 set，可自定义 ref 行为\nhtml&lt;template&gt;\n  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; @some-event=&quot;callback&quot; /&gt;\n  &lt;div&gt;父组件监听事件：&#123;&#123; counts &#125;&#125;&lt;/div&gt;\n  &lt;p&gt;v-model&lt;/p&gt;\n  &lt;custom-input\n    :modelValue=&quot;searchText&quot;\n    @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;\n  /&gt;\n  &lt;Child /&gt;\n  &lt;h2&gt;\n    reactive方法用来创建响应式对象，它接收一个对象/数组参数，返回对象的响应式副本，当该对象的属性值发生变化，会自动更新使用该对象的地方。\n  &lt;/h2&gt;\n  &lt;div&gt;\n    Object:&#123;&#123; reactiveObj.name &#125;&#125;\n    &lt;span @click=&quot;setReactiveObj&quot;&gt;Update&lt;/span&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    Array:&#123;&#123; reactiveArr &#125;&#125;\n    &lt;span @click=&quot;setReactiveArr&quot;&gt;Update&lt;/span&gt;\n  &lt;/div&gt;\n  &lt;h2&gt;\n    ref 的作用就是将一个原始数据类型（primitive data\n    type）转换成一个带有响应式特性的数据类型，原始数据类型共有7个，分别是：String/\n    Number /BigInt /Boolean /Symbol /Null /Undefined。 ref的值在 JS/TS\n    中读取和修改时，需要使用 .value获取，在模版中读取是，不需要使用 .value。\n  &lt;/h2&gt;\n  &lt;div&gt;\n    String:&#123;&#123;refValue&#125;&#125;\n    &lt;button @click=&quot;setRefValue&quot;&gt;Update&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    Object:&#123;&#123; refObj.name &#125;&#125;\n    &lt;button @click=&quot;setRefObj&quot;&gt;Update&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;h2&gt;vue3 reactive deep Obj/array&lt;/h2&gt;\n  &lt;div&gt;\n    Deep Object:&#123;&#123; reactiveDeepObj &#125;&#125;\n    &lt;button @click=&quot;setReactiveDeepObj&quot;&gt;Update&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    Deep Object Array: &#123;&#123; reactiveDeepArr &#125;&#125;\n    &lt;button @click=&quot;setReactiveDeepArr&quot;&gt;update&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script setup&gt;\nimport HelloWorld from &#39;./components/HelloWorld.vue&#39;\nimport CustomInput from &quot;./components/CustomInput.vue&quot;\nimport Child from &quot;./components/Child.vue&quot;\n\nimport &#123; ref, reactive, nextTick, provide &#125; from &quot;vue&quot;\nlet counts = ref(10)\n\nconst callback = () =&gt; &#123;\n  nextTick(() =&gt; &#123;\n    counts.value = 14\n  &#125;)\n&#125;\n\nconst provideMsg = ref(&quot;provide message&quot;)\nprovide(&quot;provideMsg&quot;, provideMsg)\n\n\n// reactive\nlet reactiveObj = reactive(&#123; name: &#39;jude&#39; &#125;)\n\nlet setReactiveObj = () =&gt; &#123;\n  reactiveObj.name = &#39;hello,jude&#39;\n&#125;\n\nlet reactiveArr = reactive([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\nlet setReactiveArr = () =&gt; &#123;\n  reactiveArr[1] = &#39;hello,jude!&#39;\n&#125;\n\n// Ref\nlet refValue = ref(&#39;jude 1992&#39;)\nlet setRefValue = () =&gt; &#123;\n  refValue.value = &#39;hello jude 1992&#39;\n&#125;\n\nlet refObj = ref(&#123; name: &#39;jude 1992&#39; &#125;)\nlet setRefObj = () =&gt; &#123;\n  refObj.value.name = &#39;hello jude 1992&#39;\n&#125;\n\n// reactive可以用在深层对象或者数组\nlet reactiveDeepObj = reactive(\n  &#123;\n    user: &#123;\n      name: &#39;jude 1992&#39;\n    &#125;\n  &#125;\n)\nlet setReactiveDeepObj = () =&gt; &#123;\n  reactiveDeepObj.user.name = &#39;hello  jude 1992&#39;\n&#125;\n\nlet reactiveDeepArr = reactive(\n  [&#39;a&#39;, [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;], &#39;c&#39;, &#39;d&#39;]\n)\nlet setReactiveDeepArr = () =&gt; &#123;\n  reactiveDeepArr[1][1] = &quot;hello jude 1992&quot;\n&#125;\n\n// reactive 返回值和源对象不相等\nlet reactivSource = &#123; name: &#39;jude 1992&#39; &#125;\nlet reactiveData = reactive(reactivSource)\nconsole.log(reactivSource === reactiveData) // false\nconsole.log(&#39;reactivSource&#39;, reactivSource);\nconsole.log(&#39;reactiveData&#39;, reactiveData);\n\n\n// ts写法\n// let refObjValue = ref &lt; string &gt; (&#39;jude 1992&#39;)\n// let reactiveObjValue = reactive &lt; &#123; name: string &#125; &gt; (&#123; name: &#39;jude 1992&#39; &#125;)\n&lt;/script&gt;\n三、总结\n\n\n\n\n\n\n\n\n1.reactive 一般用于对象&#x2F;数组类型的数据，都不需要使用 .value；2.ref 一般用于基础数据类型的数据，在 JS 中读取和修改时，需要使用 .value，在模版中使用时则不需要；3.reactive 可以修改深层属性值，并保持响应；4.reactive 返回值和源对象不同；5.reactive 的属性值可以是 ref 值；6.ref 本质也是 reactive，ref(obj)等价于 reactive({value: obj})。\n\n\n\n\n\n\n\n\n\nref 接收内部值（inner value）返回响应式 Ref 对象，reactive 返回响应式代理对象;从定义上看 ref 通常用于处理单值的响应式，reactive 用于处理对象类型的数据响应式;两者均是用于构造响应式数据，但是 ref 主要解决原始值的响应式问题;ref 返回的响应式数据在 JS 中使用需要加上.value 才能访问其值，在视图中使用会自动脱 ref，不需要.value；ref 可以接收对象或数组等非原始值，但内部依然是 reactive 实现响应式；reactive 内部如果接收 Ref 对象会自动脱 ref；使用展开运算符(…)展开 reactive 返回的响应式对象会使其失去响应性，可以结合 toRefs()将值转换为 Ref 对象之后再展开;reactive 内部使用 Proxy 代理传入对象并拦截该对象各种操作（trap），从而实现响应式。ref 内部封装一个 RefImpl 类，并设置 get value&#x2F;set value，拦截用户对值的访问，从而实现响应式。\n","slug":"79-ref-reactive","date":"2022-07-31T13:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"fb572294811aa4bb72308e5444a32de5","title":"78、js-cheat-sheet","content":"上传到图床上的4张图:JavaScript-Cheet-Sheet\n\n\n1、图1\n\n\n\n\n\n\n\n\n-document&#x2F;element&#x2F;node&#x2F;attr()&#x2F;event()&#x2F;EventTarget&#x2F;clientRect()\n\n2、图2\n\n\n\n\n\n\n\n\n-window&#x2F;screen&#x2F;console&#x2F;preformance&#x2F;navigator&#x2F;location&#x2F;history\n\n3、图3\n\n\n\n\n\n\n\n\n-Math&#x2F;Object&#x2F;Set&#x2F;Map&#x2F;Promise&#x2F;Generator&#x2F;Proxy&#x2F;Symbol&#x2F;BigInt&#x2F;Modules&#x2F;json&#x2F;\n\n4、图4\n\n\n\n\n\n\n\n\n-number&#x2F;string&#x2F;array&#x2F;date&#x2F;function&#x2F;Reg\n\n","slug":"78-js-cheat","date":"2022-07-30T13:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"bf969e92d7ba92fa02775a6bc262e3f9","title":"77、使用element-ui开发问题清单","content":"整理使用 element-ui 开发时遇到的问题（包含“摘抄”其他开发人员开发遇到的问题 😁）\n\n\n1、去除 el-input 组件 type&#x3D;”number”输入框聚焦时的上下箭头css/* 设置全局 */\n.clear-number-input.el-input::-webkit-outer-spin-button,\n.clear-number-input.el-input::-webkit-inner-spin-button &#123;\n  margin: 0;\n  -webkit-appearance: none !important;\n&#125;\n.clear-number-input.el-input input[type=&quot;number&quot;]::-webkit-outer-spin-button,\n.clear-number-input.el-input input[type=&quot;number&quot;]::-webkit-inner-spin-button &#123;\n  margin: 0;\n  -webkit-appearance: none !important;\n&#125;\n.clear-number-input.el-input &#123;\n  -moz-appearance: textfield;\n&#125;\n.clear-number-input.el-input input[type=&quot;number&quot;] &#123;\n  -moz-appearance: textfield;\n&#125;2、el-input 输入框正则限制，绑定值未更新输入框仅支持数字\nhtml&lt;el-input\n  v-model=&quot;form.num&quot;\n  placeholder=&quot;请输入数字&quot;\n  @keyup.native=&quot;form.num=form.num.replace(/[^\\d.]/g,&#39;&#39;)&quot;\n&gt;&lt;/el-input&gt;3、el-form 回车刷新页面（触发了表单默认的提交行为）html&lt;el-form inline @submit.native.prevent&gt;\n  &lt;el-form-item label=&quot;订单号&quot;&gt;\n    &lt;el-input\n      v-model=&quot;query.orderNo&quot;\n      :placeholder=&quot;输入订单号查询&quot;\n      clearable\n      @keyup.enter.native=&quot;enterInput&quot;\n    /&gt;\n  &lt;/el-form-item&gt;\n&lt;/el-form&gt;4、el-table固定列最后一行显示不完全、表头与内容错位css.el-table__fixed-right &#123;\n  height:100% !important;\n&#125;\n\n// 全局设置 表头内容错位\n.el-table--scrollable-y .el-table__body-wrapper &#123;\n overflow-y: overlay !important;\n&#125;5、表单校验只其中一个字段仅校验手机号码（如果需要多个参数，将参数改为数组形式即可。）\njsthis.$refs[&#39;form&#39;].validateField(&#39;mobile&#39;, valid =&gt; &#123;\n  if (valid) &#123;\n    // do something\n  &#125;\n&#125;)6、el-table跨分页多选html&lt;el-table row-key=&quot;id&quot;&gt;\n  &lt;el-table-column type=&quot;selection&quot; reserve-selection&gt;&lt;/el-table-column&gt;\n&lt;/el-table&gt;7、el-table内嵌el-input focus失效html&lt;el-table&gt;\n  &lt;el-table-column label=&quot;名称&quot;&gt;\n    &lt;template&gt;\n      &lt;el-input ref=&quot;inputRef&quot; /&gt;\n    &lt;/template&gt;\n  &lt;/el-table-column&gt;\n&lt;/el-table&gt;\n\n// 无效\nthis.$refs[&#39;inputRef&#39;].focus()\nthis.$refs[&#39;inputRef&#39;][0].focus()\nthis.$refs[&#39;inputRef&#39;].$el.children[0].focus()\n\n// 有效\n&lt;el-input id=&quot;inputRef&quot; /&gt;\ndocument.getElementById(&#39;inputRef&#39;).focus()8、el-dialog 的 destroy-on-close 属性设置无效html&lt;el-dialog :visible.sync=&quot;visible&quot; v-if=&quot;visible&quot; destroy-on-close&gt;\n&lt;/el-dialog&gt;","slug":"77-element-ui","date":"2022-07-30T12:00:00.000Z","categories_index":"","tags_index":"vue2","author_index":"Jude"},{"id":"859a6db70edc4a7c424a452b2f839384","title":"76、vue3状态管理pinia及使用pinia解构不生效解决方法","content":"使用 pinia 时，解构 store 里的 helloWorld 和 count 时，没有发生响应式数据变化的情况。这是因为在使用 store 的过程中，如果直接进行进行解构的话，会破坏数据的响应，因此可以通过使用 storeToRefs 来解构。\n\n\n一、pinia 的使用时的问题复现1、stores:counter.jsjsimport &#123; defineStore &#125; from &quot;pinia&quot;;\n// defineStore() 第一个参数：相当于为容器取一个名字 第二个参数为配置对象\n// state:存储全局状态  getters:监视、计算状态的变化，具有缓存功能\n// actions：对state里数据变化进行逻辑处理   （修改state全局状态数据）\nexport const mainStore = defineStore(&quot;main&quot;, &#123;\n  state: () =&gt; &#123;\n    return &#123;\n      helloWorld: &quot;hello world !!!&quot;,\n      count: 0,\n    &#125;;\n  &#125;,\n  getters: &#123;&#125;,\n  actions: &#123;&#125;,\n&#125;);2、组件：Test.vuehtml&lt;template&gt;\n  &lt;!-- 非解构 --&gt;\n  &lt;!-- &lt;div&gt;&#123;&#123; store.helloWorld&#125;&#125;&#123;&#123;store.count&#125;&#125;&lt;/div&gt; --&gt;\n  &lt;!-- 解构 --&gt;\n  &lt;div&gt;&#123;&#123; helloWorld &#125;&#125;&#123;&#123; count &#125;&#125;&lt;/div&gt;\n&lt;/template&gt;如果不使用storeToRefs，点击按钮不会生效。storeToRefs的源码中，会先进行vue版本的判断，如果是Vue2版本，会直接返回toRefs(store),非Vue2环境，遍历对象的键值，会过滤掉store中的非ref&#x2F;reactive对象，对于符合ref和reactive类型的值，将其复制到一个新的对象中refs中，最后返回refs\njs&lt;script setup&gt;\n  import &#123;storeToRefs&#125; from &quot;pinia&quot;\n  import &#123;mainStore&#125; from&#39;../stores/counter&#39;\n  const store = mainStore() \n  const &#123;(helloWorld, count)&#125; = storeToRefs(store)\n&lt;/script&gt;3、组件：AddButton.vuehtml&lt;template&gt;\n  &lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;Add&lt;/button&gt;&lt;/div&gt;\n&lt;/template&gt;js&lt;script setup&gt;\n  import &#123;mainStore&#125; from &#39;../stores/counter&#39;\n  const store = mainStore()\n  const handleClick = () =&gt; &#123;store.count++&#125;\n&lt;/script&gt;4、App.vuehtml&lt;template&gt;\n  &lt;header&gt;\n    &lt;img\n      alt=&quot;Vue logo&quot;\n      class=&quot;logo&quot;\n      src=&quot;@/assets/logo.svg&quot;\n      width=&quot;125&quot;\n      height=&quot;125&quot;\n    /&gt;\n    &lt;div class=&quot;wrapper&quot;&gt;\n      &lt;Test&gt;&lt;/Test&gt;\n      &lt;add-button&gt;&lt;/add-button&gt;\n    &lt;/div&gt;\n  &lt;/header&gt;\n  &lt;RouterView /&gt;\n&lt;/template&gt;js&lt;script setup&gt;\n  import &#123;(RouterLink, RouterView)&#125; from &#39;vue-router&#39;\n  import Test from &#39;./components/Test.vue&#39;\n  import AddButton from &quot;./components/AddButton.vue&quot;\n&lt;/script&gt;二、pinia如何修改状态数据1、$patch修改单个或者多个数据html  &lt;div&gt;&lt;button @click=&quot;handleClickPatch&quot;&gt;Add handleClickPatch&lt;/button&gt;&lt;/div&gt;js&lt;script setup&gt;\nimport &#123; mainStore &#125; from &#39;../stores/counter&#39;;\nconst store = mainStore()\nconst handleClick = () =&gt; &#123;\n  store.count++;\n  // store.helloWorld = store.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; : &#39;yq&#39;\n&#125;\n// 1、修改状态数据 $patch  可同时修改多个数据的状态  参数为一个对象\nconst handleClickPatch = () =&gt; &#123;\n  store.$patch(&#123;\n    count:store.count + 2,\n    helloWorld:store.helloWorld === &#39;yq&#39; ? &#39;HelloWorld&#39; : &#39;yq&#39;\n  &#125;)\n&#125;\n&lt;/script&gt;\n2、$patch加函数形式修改状态数据\n\n\n\n\n\n\n\n\n\n适合修改复杂数据，例如数组、对象\n\nhtml  &lt;div&gt;&lt;button @click=&quot;handleClickMethod&quot;&gt;Add handleClickMethod&lt;/button&gt;&lt;/div&gt;\njs&lt;script setup&gt;\nimport &#123; mainStore &#125; from &#39;../stores/counter&#39;;\nconst store = mainStore()\nconst handleClick = () =&gt; &#123;\n  store.count++;\n  // store.helloWorld = store.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; : &#39;yq&#39;\n&#125;\n// 1、修改状态数据 $patch  可同时修改多个数据的状态  参数为一个对象\nconst handleClickPatch = () =&gt; &#123;\n  store.$patch(&#123;\n    count:store.count + 2,\n    helloWorld:store.helloWorld === &#39;yq&#39; ? &#39;HelloWorld&#39; : &#39;yq&#39;\n  &#125;)\n&#125;\n\n// 2、传递函数  适合复杂数据的修改，比如数组、对象的修改\nconst handleClickMethod = () =&gt;&#123;\n  store.$patch((state) =&gt; &#123;\n    state.count++;\n    state.helloWorld = state.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; :&#39;yq&#39;\n  &#125;)\n&#125;\n&lt;/script&gt;3、actions\n\n\n\n\n\n\n\n\n在使用actions的时候，不能使用箭头函数，因为箭头函数绑定的是外部的this\nstores ：counter.js\njsexport const mainStore = defineStore(&#39;main&#39;, &#123;\n  state:()=&gt;&#123;\n    return &#123;\n      helloWorld:&#39;hello world !!!&#39;,\n      count:0\n    &#125;\n  &#125;,\n  getters:&#123;\n\n  &#125;,\n  actions:&#123;\n    changeState()&#123;\n      this.count++\n      this.helloWorld = &#39;yq&#39;\n    &#125;\n  &#125;\n&#125;)组件:AddButton.vue\nhtml  &lt;div&gt;&lt;button @click=&quot;handleClickAction&quot;&gt; Add handleClickAction&lt;/button&gt;&lt;/div&gt;jsconst handleClickAction = () =&gt;&#123;\n  store.changeState()\n&#125;4、gettersstore:counter.js\njsexport const mainStore = defineStore(&#39;main&#39;, &#123;\n  state:()=&gt;&#123;\n    return &#123;\n      helloWorld:&#39;hello world !!!&#39;,\n      count:0,\n      phone:&#39;19542932249&#39;\n    &#125;\n  &#125;,\n  getters:&#123;\n    phoneHidden(state)&#123;\n      console.log(&quot;go  具有缓存 只会调用一次&quot;)\n      // 使用this关键字\n      // return this.phone.toString().replace(/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/, &#39;$1****$2&#39;)\n      return state.phone.toString().replace(/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/, &#39;$1****$2&#39;)\n    &#125;\n  &#125;,\n  actions:&#123;\n    // 在用actions的时候，不能使用箭头函数，因为箭头函数绑定的是外部的this\n    changeState()&#123;\n      this.count++\n      this.helloWorld = &#39;yq&#39;\n    &#125;\n  &#125;\n&#125;)\n\n\n\n\n\n\n\n\n注意：getters里是可以使用this的\n写法如下：\nts  getters:&#123;\n    phoneHidden():String&#123;\n      console.log(&quot;go  具有缓存 只会调用一次&quot;)\n      // 使用this关键字\n      // return this.phone.toString().replace(/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/, &#39;$1****$2&#39;)\n    &#125;\n  &#125;,组件：Test.vue\nhtml&lt;template&gt;\n  &lt;div&gt;\n    &#123;&#123; store.helloWorld&#125;&#125;&#123;&#123;store.count&#125;&#125;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &#123;&#123; phoneHidden &#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\njs&lt;script setup&gt;\nimport &#123; storeToRefs &#125; from &quot;pinia&quot;;\nimport &#123; mainStore &#125; from &#39;../stores/counter&#39;;\nconst store = mainStore()\nconst &#123; helloWorld,count,phoneHidden &#125; = storeToRefs(store)\n&lt;/script&gt;组件：AddButton.vue\nhtml  &lt;div&gt;&lt;button @click=&quot;handleClickChangePhone&quot;&gt;change phone&lt;/button&gt;&lt;/div&gt;\njs&lt;script setup&gt;\nimport &#123; mainStore &#125; from &#39;../stores/counter&#39;;\nconst store = mainStore()\n\nconst handleClickChangePhone = () =&gt; &#123;\n  store.phone = &quot;18775352722&quot;\n&#125;\n&lt;/script&gt;5、Github项目代码：\n\n\n\n\n\n\n\n\ngithub: https://github.com/HeyJudeYQ/pinia-demo\n","slug":"76-pinia","date":"2022-07-29T12:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"d733740f16980d80040043384ba0b43b","title":"75、vue.$data表单暂存","content":"暂存表单信息\n\n\n\nhtml&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;\n      &lt;el-form-item label=&quot;活动名称&quot;&gt;\n        &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;活动区域&quot;&gt;\n        &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;\n          &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;\n          &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;\n        &lt;/el-select&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;活动时间&quot;&gt;\n        &lt;el-col :span=&quot;11&quot;&gt;\n          &lt;el-date-picker\n            type=&quot;date&quot;\n            placeholder=&quot;选择日期&quot;\n            v-model=&quot;form.date1&quot;\n            style=&quot;width: 100%;&quot;\n          &gt;&lt;/el-date-picker&gt;\n        &lt;/el-col&gt;\n        &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;\n        &lt;el-col :span=&quot;11&quot;&gt;\n          &lt;el-time-picker\n            placeholder=&quot;选择时间&quot;\n            v-model=&quot;form.date2&quot;\n            style=&quot;width: 100%;&quot;\n          &gt;&lt;/el-time-picker&gt;\n        &lt;/el-col&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;即时配送&quot;&gt;\n        &lt;el-switch v-model=&quot;form.delivery&quot;&gt;&lt;/el-switch&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;活动性质&quot;&gt;\n        &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt;\n          &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;\n          &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;\n          &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;\n          &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;\n        &lt;/el-checkbox-group&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;特殊资源&quot;&gt;\n        &lt;el-radio-group v-model=&quot;form.resource&quot;&gt;\n          &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;\n          &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;\n        &lt;/el-radio-group&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item label=&quot;活动形式&quot;&gt;\n        &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.desc&quot;&gt;&lt;/el-input&gt;\n      &lt;/el-form-item&gt;\n      &lt;el-form-item&gt;\n        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;\n        &lt;el-button @click=&quot;stash&quot;&gt;暂存&lt;/el-button&gt;\n      &lt;/el-form-item&gt;\n    &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js&lt;script&gt;\n\nexport default &#123;\n    data() &#123;\n        const stashStr = localStorage.getItem(&#39;stash&#39;)\n        const stash = stashStr ? JSON.parse(stashStr) : &#123;&#125;\n        return Object.assign(&#123;\n            form: &#123;\n                name: &#39;&#39;,\n                region: &#39;&#39;,\n                date1: &#39;&#39;,\n                date2: &#39;&#39;,\n                delivery: false,\n                type: [],\n                resource: &#39;&#39;,\n                desc: &#39;&#39;\n            &#125;\n        &#125;, stash)\n    &#125;,\n    methods: &#123;\n        onSubmit() &#123;\n            console.log(&#39;submit!&#39;);\n        &#125;,\n        stash() &#123;\n            localStorage.setItem(&#39;stash&#39;, JSON.stringify(this.$data));\n        &#125;\n    &#125;\n\n&#125;\n&lt;/script&gt;\n","slug":"75-localStorage","date":"2022-07-27T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"2ead6bf51206f6826080a0b86fe13868","title":"74、options-api & composition-api","content":"在Vue2中，我们使用的是Options Api语法，而在Vue3中，编程语法方面改变的最大亮点应该就是Composition Api了。\n\n\n\n一、options api\n\n\n\n\n\n\n\n\noptions api 即选项式api,也就是组件的各个选项，例如：data、methods、computed、watch等等，对应的选项做对应的事情。\n在实际项目的开发过程中，数据定义在data中，方法定义在methods中，当我们的代码多起来，比如达到四、五百行的时候，如果我们想改动某个功能，就要去data中改数据，再去methods中改方法，来回地寻找。\n相同功能的代码被分割，对后期的改动很不友好，如果换了一个新人接手，或者自己过一段时间再去看这段代码，估计没注释的话，那是相当费劲。 而且因为所有的数据都是挂载在this下面，typescript的类型推导也很麻烦，代码的复用、公共组件的导入导出也都很困难。Vue3新增了Composition Api来解决这些痛点。\n二、composition api\n\n\n\n\n\n\n\n\nComposition Api:组合式api,支持将相同的功能模块代码写在一起，甚至可以将某个功能单独的封装成函数，随意导入引用；也可以将任意的数据定义成响应式，再也不用局限于data中，我们只需要将每个实现的功能组合起来就可以了。\nwatch：侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。\n\n\n\n\n\n\n\n\n\nwatch() 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。(immediate:true 立即执行)，包含3个参数：侦听器的源、发生变化的回调函数（这个回调函数接受3个参数：新值、旧值、用于注册副作用清理的回调函数。）、可选参数（immediate：true&#x2F;false 立即触发侦听器回调函数、deep:源是对象，强制深度遍历，flush:调整回调的刷新时机、onTrack&#x2F;onTrigger:调试侦听器的依赖）\n注意：1、watchEffect是立即执行的，不需要添加immediate属性。2、watchEffect不需要指定对某个具体的数据监听，watchEffect会根据内容自动去感知，所以我们也可以在一个watchEffect中添加多个数据的监听处理（如果watchEffect中没有任何响应式数据，会不会执行呢？大家可以试一下）。3、watchEffect不能获取数据改变之前的值。\nref和reactive的区别是什么呢，我们可以这样简单理解，它们都是用来定义响应式数据的，但是ref是用来给简单的数据类型定义响应式数据的，比如number、string、boolean等，而reactive是针对复杂的数据结构的，比如一个对象。\nref定义的数据，修改的时候是需改xxx.value的，而reactive定义的不用\n","slug":"74-composition-api&options-api","date":"2022-07-25T16:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"2b62f986a8cfab1550e4f4c010e2e02c","title":"73、关于使用element-ui的el-table组件：带分页打印表头","content":"使用 command（win : control） + p 打印时，如果页面的 table 分页后，想要将第二页之后的每个页面都加上表头，可以封装一个可复用的组件。\n\n\n一、编写可复用的组件代码如下：\nElTableHeader.vue\njsimport &#123; Table &#125; from &quot;element-ui&quot;;\nexport default &#123;\n  extends: Table,\n  mounted() &#123;\n    this.$nextTick(function () &#123;\n      let thead = this.$el.querySelector(&quot;.el-table__header-wrapper thead&quot;);\n      let theadNew = thead.cloneNode(true);\n      this.$el\n        .querySelector(&quot;.el-table__body-wrapper table&quot;)\n        .appendChild(theadNew);\n    &#125;);\n  &#125;,\n&#125;;css .el-table &gt;&gt;&gt; .el-table__body-wrapper thead &#123;\n        display: none;\n    &#125;\n    @media print &#123;\n        .el-table &gt;&gt;&gt; .el-table__header-wrapper &#123;\n            display: none;\n        &#125;\n        .el-table &gt;&gt;&gt; .el-table__body-wrapper thead &#123;\n            display: table-header-group;\n        &#125;\n    &#125;二、全局注册及使用1、main.js引入txtimport ElTableHeader from &quot;./components/ElTableHeader.vue&quot;\nVue.component(&quot;el-table-header&quot;,ElTableHeader)2、使用html&lt;template&gt;\n  &lt;el-table-header :data=&quot;tableData&quot;&gt;\n\n  &lt;/el-table-header&gt;\n&lt;/template&gt;","slug":"73-print","date":"2022-07-25T02:00:00.000Z","categories_index":"","tags_index":"element-ui","author_index":"Jude"},{"id":"66f175e6293884ca16a025d8a5690310","title":"72、关于使用element-ui的el-select组件下拉框错位问题","content":"使用 element-ui的el-form组件里使用el-selcet组件时，下拉框的el-select-item会出现向右偏移的问题。有2种方法可以解决下拉框错位的问题。\n\n\n一、方法一：margin-left:0px !important在el-select添加一个类名：select-item\ncss.select-item .el-form-item__content&#123;\n  margin-left:0px !important;\n&#125;二、方法二：position:initial;css.select-item .el-form-item__content&#123;\n  position:initial;\n&#125;","slug":"72-el-select","date":"2022-07-11T02:00:00.000Z","categories_index":"","tags_index":"element-ui","author_index":"Jude"},{"id":"a23dc8936d84de856c4062582a9f255d","title":"71、headerSearch组件","content":"headerSearch组件:在指定搜索框中对当前应用中所有页面进行检索，以select形式展示出被检索的页面，以达到快速进入的目的；\n\n\n\n一、原理：1、根据指定内容对所有页面进行检索；2、以select形式展示检索出的页面；3、通过检索页面可快速进入对应页面。\n二、方案：1、创建 headerSearch 组件，用作样式展示和用户输入内容获取2、获取所有的页面数据，用作被检索的数据源3、根据用户输入内容在数据源中进行模糊搜索4、把搜索到的内容以 select 进行展示5、监听 select 的 change 事件，完成对应跳转\n三、代码：\n点击展示js代码\n\nhtml&lt;template&gt;\n  &lt;div :class=&quot;&#123; show: isShow &#125;&quot; class=&quot;header-search&quot;&gt;\n    &lt;svg-icon\n      id=&quot;guide-search&quot;\n      class-name=&quot;search-icon&quot;\n      icon=&quot;search&quot;\n      @click.stop=&quot;onShowClick&quot;\n    /&gt;\n    &lt;el-select\n      ref=&quot;headerSearchSelectRef&quot;\n      class=&quot;header-search-select&quot;\n      v-model=&quot;search&quot;\n      filterable\n      default-first-option\n      remote\n      placeholder=&quot;Search&quot;\n      :remote-method=&quot;querySearch&quot;\n      @change=&quot;onSelectChange&quot;\n    &gt;\n      &lt;el-option\n        v-for=&quot;option in searchOptions&quot;\n        :key=&quot;option.item.path&quot;\n        :label=&quot;option.item.title.join(&#39; &gt; &#39;)&quot;\n        :value=&quot;option.item&quot;\n      &gt;&lt;/el-option&gt;\n    &lt;/el-select&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\njs\n&lt;script setup&gt;\nimport &#123; computed, ref, watch &#125; from &#39;vue&#39;\nimport &#123; generateRoutes &#125; from &#39;./FuseData&#39;\nimport Fuse from &#39;fuse.js&#39;\nimport &#123; filterRouters &#125; from &#39;@/utils/route&#39;\nimport &#123; useRouter &#125; from &#39;vue-router&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@/utils/i18n&#39;\n\n// 控制 search 显示\nconst isShow = ref(false)\n// el-select 实例\nconst headerSearchSelectRef = ref(null)\nconst onShowClick = () =&gt; &#123;\n  isShow.value = !isShow.value\n  headerSearchSelectRef.value.focus()\n&#125;\n\n// search 相关\nconst search = ref(&#39;&#39;)\n// 搜索结果\nconst searchOptions = ref([])\n// 搜索方法\nconst querySearch = query =&gt; &#123;\n  if (query !== &#39;&#39;) &#123;\n    searchOptions.value = fuse.search(query)\n  &#125; else &#123;\n    searchOptions.value = []\n  &#125;\n&#125;\n// 选中回调\nconst onSelectChange = val =&gt; &#123;\n  router.push(val.path)\n  onClose()\n&#125;\n\n// 检索数据源\nconst router = useRouter()\nlet searchPool = computed(() =&gt; &#123;\n  const filterRoutes = filterRouters(router.getRoutes())\n  return generateRoutes(filterRoutes)\n&#125;)\n/**\n * 搜索库相关\n */\nlet fuse\nconst initFuse = searchPool =&gt; &#123;\n  fuse = new Fuse(searchPool, &#123;\n    // 是否按优先级进行排序\n    shouldSort: true,\n    // 匹配算法放弃的时机， 阈值 0.0 需要完美匹配（字母和位置），阈值 1.0 将匹配任何内容。\n    threshold: 0.4,\n    // 匹配长度超过这个值的才会被认为是匹配的\n    minMatchCharLength: 1,\n    // 将被搜索的键列表。 这支持嵌套路径、加权搜索、在字符串和对象数组中搜索。\n    // name：搜索的键\n    // weight：对应的权重\n    keys: [\n      &#123;\n        name: &#39;title&#39;,\n        weight: 0.7\n      &#125;,\n      &#123;\n        name: &#39;path&#39;,\n        weight: 0.3\n      &#125;\n    ]\n  &#125;)\n&#125;\ninitFuse(searchPool.value)\n\n/**\n * 关闭 search 的处理事件\n */\nconst onClose = () =&gt; &#123;\n  headerSearchSelectRef.value.blur()\n  isShow.value = false\n  searchOptions.value = []\n&#125;\n/**\n * 监听 search 打开，处理 close 事件\n */\nwatch(isShow, val =&gt; &#123;\n  if (val) &#123;\n    document.body.addEventListener(&#39;click&#39;, onClose)\n  &#125; else &#123;\n    document.body.removeEventListener(&#39;click&#39;, onClose)\n  &#125;\n&#125;)\n\n// 处理国际化\nwatchSwitchLang(() =&gt; &#123;\n  searchPool = computed(() =&gt; &#123;\n    const filterRoutes = filterRouters(router.getRoutes())\n    return generateRoutes(filterRoutes)\n  &#125;)\n  initFuse(searchPool.value)\n&#125;)\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.header-search &#123;\n  font-size: 0 !important;\n  .search-icon &#123;\n    cursor: pointer;\n    font-size: 18px;\n    vertical-align: middle;\n  &#125;\n  .header-search-select &#123;\n    font-size: 18px;\n    transition: width 0.2s;\n    width: 0;\n    overflow: hidden;\n    background: transparent;\n    border-radius: 0;\n    display: inline-block;\n    vertical-align: middle;\n\n    ::v-deep .el-input__inner &#123;\n      border-radius: 0;\n      border: 0;\n      padding-left: 0;\n      padding-right: 0;\n      box-shadow: none !important;\n      border-bottom: 1px solid #d9d9d9;\n      vertical-align: middle;\n    &#125;\n  &#125;\n  &amp;.show &#123;\n    .header-search-select &#123;\n      width: 210px;\n      margin-left: 10px;\n    &#125;\n  &#125;\n&#125;\n&lt;/style&gt;\n\n\n四、数据源：FuseData.js\n\n点击展示js代码\n\njsimport path from &#39;path&#39;\nimport i18n from &#39;@/i18n&#39;\n/**\n * 筛选出可供搜索的路由对象\n * @param routes 路由表\n * @param basePath 基础路径，默认为 /\n * @param prefixTitle\n */\nexport const generateRoutes = (routes, basePath = &#39;/&#39;, prefixTitle = []) =&gt; &#123;\n  // 创建 result 数据\n  let res = []\n  // 循环 routes 路由\n  for (const route of routes) &#123;\n    // 创建包含 path 和 title 的 item\n    const data = &#123;\n      path: path.resolve(basePath, route.path),\n      title: [...prefixTitle]\n    &#125;\n    // 当前存在 meta 时，使用 i18n 解析国际化数据，组合成新的 title 内容\n    // 动态路由不允许被搜索\n    // 匹配动态路由的正则\n    const re = /.*\\/:.*/\n    if (\n      route.meta &amp;&amp;\n      route.meta.title &amp;&amp;\n      !re.exec(route.path) &amp;&amp;\n      !res.find(item =&gt; item.path === data.path)\n    ) &#123;\n      const i18ntitle = i18n.global.t(`msg.route.$&#123;route.meta.title&#125;`)\n      data.title = [...data.title, i18ntitle]\n      res.push(data)\n    &#125;\n\n    // 存在 children 时，迭代调用\n    if (route.children) &#123;\n      const tempRoutes = generateRoutes(route.children, data.path, data.title)\n      if (tempRoutes.length &gt;= 1) &#123;\n        res = [...res, ...tempRoutes]\n      &#125;\n    &#125;\n  &#125;\n  return res\n&#125;\n\n","slug":"71-headerSearch","date":"2022-06-25T02:00:00.000Z","categories_index":"","tags_index":"element-ui","author_index":"Jude"},{"id":"55312e8233d803ec007c9eef56330218","title":"70、功能引导组件","content":"功能引导组件实现\n\n\n一、功能引导：driver.js实现思路：\n1、定义导航数据html&lt;svg-icon icon=&quot;guide&quot; @click=&quot;onClick&quot; /&gt;let driver &#x3D; null\n2、实例化Driver需要安装driver.js\njsimport Driver from &#39;driver.js&#39;\nimport &#39;driver.js/dist/driver.min.css&#39;\nimport &#123; onMounted &#125; from &#39;vue&#39;\nimport &#123; useI18n &#125; from &#39;vue-i18n&#39;\nimport steps from &#39;./steps&#39;\nimport &#123; watchSwitchLang &#125; from &#39;@/utils/i18n&#39;\n\n\nconst initDriver = () =&gt; &#123;\n  driver = new Driver(&#123;\n    animate: false,\n    // 禁止点击蒙版关闭\n    allowClose: false,\n    closeBtnText: i18n.t(&#39;msg.guide.close&#39;),\n    nextBtnText: i18n.t(&#39;msg.guide.next&#39;),\n    prevBtnText: i18n.t(&#39;msg.guide.prev&#39;)\n  &#125;)\n&#125;\n\n// 语言切换时，重新初始化 Driver\nwatchSwitchLang(initDriver)3、定义触发方法jsconst onClick = () =&gt; &#123;\n  driver.defineSteps(steps(i18n))\n  driver.start()\n&#125;4、steps资源文件\n点击展示js代码\n\njs// 此处不需要导入 @/i18n 使用 i18n.global ，因为我们在 router 中 layout 不是按需加载，所以会在 Guide 会在 I18n 初始化完成之前被直接调用。导致 i18n 为 undefined\nconst steps = i18n =&gt; &#123;\n  return [\n    // 起始\n    &#123;\n      element: &#39;#guide-start&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.guideTitle&#39;),\n        description: i18n.t(&#39;msg.guide.guideDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-hamburger&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.hamburgerTitle&#39;),\n        description: i18n.t(&#39;msg.guide.hamburgerDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-breadcrumb&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.breadcrumbTitle&#39;),\n        description: i18n.t(&#39;msg.guide.breadcrumbDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-search&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.searchTitle&#39;),\n        description: i18n.t(&#39;msg.guide.searchDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-full&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.fullTitle&#39;),\n        description: i18n.t(&#39;msg.guide.fullDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-theme&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.themeTitle&#39;),\n        description: i18n.t(&#39;msg.guide.themeDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-lang&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.langTitle&#39;),\n        description: i18n.t(&#39;msg.guide.langDesc&#39;),\n        position: &#39;bottom-right&#39;\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-tags&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.tagTitle&#39;),\n        description: i18n.t(&#39;msg.guide.tagDesc&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      element: &#39;#guide-sidebar&#39;,\n      popover: &#123;\n        title: i18n.t(&#39;msg.guide.sidebarTitle&#39;),\n        description: i18n.t(&#39;msg.guide.sidebarDesc&#39;),\n        position: &#39;right-center&#39;\n      &#125;\n    &#125;\n  ]\n&#125;\nexport default steps\n\n\n\n5、引导高亮区域添加ID示例：\nhtml&lt;svg-icon id=&quot;guide-hamburger&quot; class=&quot;hamburger&quot; :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;\n\n&lt;!-- 面包屑 --&gt;\n&lt;breadcrumb id=&quot;guide-breadcrumb&quot; class=&quot;breadcrumb-container&quot; /&gt;","slug":"70-guide","date":"2022-06-20T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"0202dbb7e41b5d97a0e20e68e4d674a0","title":"69、screenfull组件","content":"screenfull组件:主要使用的是浏览器的2个API:Document.exitFullscreen():该方法用于请求从全屏模式切换到窗口模式；Element.requestFullscreen()：该方法用于请求浏览器（user agent）将特定元素（甚至延伸到它的后代元素）置为全屏模式。当通过document.getElementById(‘app’).requestFullscreen()在获取id&#x3D;app的DOM之后，把该区域置为全屏\n这种方法存在一定的问题（内容区域的AppMain）区域背景为黑色。\n\n\n实现全屏显示模式，通常可以使用包装库：screenfull。\n一、实现1、安装screenfull\n2、创建全屏组件\nhtml&lt;template&gt;\n  &lt;div&gt;\n    &lt;svg-icon\n      :icon=&quot;isFullscreen ? &#39;exit-fullscreen&#39; : &#39;fullscreen&#39;&quot;\n      @click=&quot;onToggle&quot;\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;js\n&lt;script setup&gt;\nimport &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;\nimport screenfull from &#39;screenfull&#39;\n\n// 是否全屏\nconst isFullscreen = ref(false)\n\n// 监听变化\nconst change = () =&gt; &#123;\n  isFullscreen.value = screenfull.isFullscreen\n&#125;\n\n// 切换事件\nconst onToggle = () =&gt; &#123;\n  screenfull.toggle()\n&#125;\n\n// 设置侦听器\nonMounted(() =&gt; &#123;\n  screenfull.on(&#39;change&#39;, change)\n&#125;)\n\n// 删除侦听器\nonUnmounted(() =&gt; &#123;\n  screenfull.off(&#39;change&#39;, change)\n&#125;)\n&lt;/script&gt;\n3、引入全屏组件\nhtml&lt;screenfull class=&quot;right-menu-item hover-effect&quot; /&gt;jsimport Screenfull from &#39;@/components/Screenfull&#39;","slug":"69-screenfull","date":"2022-06-15T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"d956ecb06d60e9a08e3ce903b3ba33a3","title":"68、ESlint+Prettier+VSCode代码格式规范、git提交规范","content":"ESlint+Prettier+VSCode代码格式规范、git提交规范\n\n一、ESlint规范、Prettier格式化工具规范1.  .eslintrc.jsjs// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象\n// 文档：https://eslint.bootcss.com/docs/user-guide/configuring\nmodule.exports = &#123;\n  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下\n  root: true,\n  // env 表示启用 ESLint 检测的环境\n  env: &#123;\n    // 在 node 环境下启动 ESLint 检测\n    node: true\n  &#125;,\n  // ESLint 中基础配置需要继承的配置\n  extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;@vue/standard&quot;],\n  // 解析器\n  parserOptions: &#123;\n    parser: &quot;babel-eslint&quot;\n  &#125;,\n  // 需要修改的启用规则及其各自的错误级别\n  /**\n   * 错误级别分为三种：\n   * &quot;off&quot; 或 0 - 关闭规则\n   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n   */\n  rules: &#123;\n    &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &#39;space-before-function-paren&#39;: &#39;off&#39;,\n    &#39;no-unused-expressions&#39;: &#39;off&#39;\n  &#125;\n&#125;;\nspace-before-function-paren:off 关闭《方法名后增加空格》的规则\n2、VSCode安装Prettier插件(1)新建.prettierrc  \njs&#123;\n  // 不尾随分号\n  &quot;semi&quot;: false,\n  // 使用单引号\n  &quot;singleQuote&quot;: true,\n  // 多行逗号分割的语法中，最后一行不加逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;(2)打开VSCode设置，搜索save,勾选Format On SaveVSCode默认一个tab是4个空格，可以修改成2个。\n这样我们保存的代码，prettier会帮我们自动格式化成符合ESlint校验规则的代码。\n3、git提交规范(1)、全局安装Commitizenjsnpm install -g commitizen@4.2.4(2)、安装并配置cz-customizabletxtnpm i cz-customizable@6.3.0 --save-dev在package.json中配置\njson  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;\n    &#125;\n  &#125;\n(3)、根目录下创建.cz-config.js自定义提示文件jsmodule.exports = &#123;\n  // 可选类型\n  types: [\n    &#123; value: &#39;feat&#39;, name: &#39;feat:     新功能&#39; &#125;,\n    &#123; value: &#39;fix&#39;, name: &#39;fix:      修复&#39; &#125;,\n    &#123; value: &#39;docs&#39;, name: &#39;docs:     文档变更&#39; &#125;,\n    &#123; value: &#39;style&#39;, name: &#39;style:    代码格式(不影响代码运行的变动)&#39; &#125;,\n    &#123;\n      value: &#39;refactor&#39;,\n      name: &#39;refactor: 重构(既不是增加feature，也不是修复bug)&#39;\n    &#125;,\n    &#123; value: &#39;perf&#39;, name: &#39;perf:     性能优化&#39; &#125;,\n    &#123; value: &#39;test&#39;, name: &#39;test:     增加测试&#39; &#125;,\n    &#123; value: &#39;chore&#39;, name: &#39;chore:    构建过程或辅助工具的变动&#39; &#125;,\n    &#123; value: &#39;revert&#39;, name: &#39;revert:   回退&#39; &#125;,\n    &#123; value: &#39;build&#39;, name: &#39;build:    打包&#39; &#125;\n  ],\n  // 消息步骤\n  messages: &#123;\n    type: &#39;请选择提交类型:&#39;,\n    customScope: &#39;请输入修改范围(可选):&#39;,\n    subject: &#39;请简要描述提交(必填):&#39;,\n    body: &#39;请输入详细描述(可选):&#39;,\n    footer: &#39;请输入要关闭的issue(可选):&#39;,\n    confirmCommit: &#39;确认使用以上信息提交？(y/n/e/h)&#39;\n  &#125;,\n  // 跳过问题\n  skipQuestions: [&#39;body&#39;, &#39;footer&#39;],\n  // subject文字长度默认是72\n  subjectLimit: 72\n&#125;(4)、使用git cz代替git commit并不是所有人都记得使用git cz  还需要加上Git Hooks\n4、Git HooksGit Hooks常用的2个钩子：1、commit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交2、pre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交\n（1）commitlint和husky 2个工具的安装与配置txtnpm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\n创建commitlint.config.js\ntxtecho &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js配置commitlint.config.js\njsmodule.exports = &#123;\n  // 继承的规则\n  extends: [&#39;@commitlint/config-conventional&#39;],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    &#39;type-enum&#39;: [\n      2,\n      &#39;always&#39;,\n      [\n        &#39;feat&#39;, // 新功能 feature\n        &#39;fix&#39;, // 修复 bug\n        &#39;docs&#39;, // 文档注释\n        &#39;style&#39;, // 代码格式(不影响代码运行的变动)\n        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)\n        &#39;perf&#39;, // 性能优化\n        &#39;test&#39;, // 增加测试\n        &#39;chore&#39;, // 构建过程或辅助工具的变动\n        &#39;revert&#39;, // 回退\n        &#39;build&#39; // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    &#39;subject-case&#39;: [0]\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n注意：确保此文件为UTF-8编码格式\n安装husky:\ntxtnpm install husky@7.0.1 --save-dev启动hooks，生成.husky文件夹\ntxtnpx husky install在package.json中生成prepare指令（npm版本 &gt; 7.0）\ntxtnpm set-script prepare &quot;husky install&quot;执行prepare指令\ntxtnpm run prepare添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令\ntxtnpx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;\npre-commit规避格式错误的提交通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：\n执行 npx husky add .husky&#x2F;pre-commit “npx eslint –ext .js,.vue src” 添加 commit 时的 hook （npx eslint –ext .js,.vue src 会在执行到该 hook 时运行）\n该操作会生成对应文件 pre-commit：\nlint-staged 自动修复格式错误\njson  &quot;lint-staged&quot;: &#123;\n    &quot;src/**/*.&#123;js,vue&#125;&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;修改 .husky&#x2F;pre-commit 文件\njs#!/bin/sh\n. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;\n\nnpx lint-staged\n\n5、package.jsontxt  &quot;scripts&quot;: &#123;\n    &quot;prepare&quot;: &quot;husky install&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;\n    &#125;\n  &#125;,\n  &quot;gitHooks&quot;: &#123;\n    &quot;pre-commit&quot;: &quot;lint-staged&quot;\n  &#125;,\n  &quot;lint-staged&quot;: &#123;\n    &quot;src/**/*.&#123;js,vue&#125;&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;","slug":"68-eslint","date":"2022-06-07T07:49:40.000Z","categories_index":"","tags_index":"eslint","author_index":"Jude"},{"id":"8038c5a8d5cbc886bfa9c4368f0a2ac6","title":"67、ant-design-vue-table","content":"column列描述数据对象，customRender:生成复杂数据的渲染函数，参数分别为当前行的值，当前行数据，行索引，@return 里面可以设置表格行&#x2F;列合并。\n\n\n将列表里后端返回的空数据使用”-“填充。\njsconst columns = [&#123;\n    title:&#39;开始时间&#39;，\n    dataIndex:&#39;start_date&#39;,\n    key:&#39;start_date&#39;,\n    align:&#39;center&#39;,\n    ellipsis:true,\n    width:250,\n    customRender: function (text, row, index) &#123;\n        if (row.start_date == null) &#123;\n            return &#39;-&#39;\n        &#125; else &#123;\n            return row.start_date\n        &#125;\n    &#125;,\n&#125;]","slug":"67-ant-design-vue-table","date":"2022-05-10T12:00:00.000Z","categories_index":"","tags_index":"ant-design-vue","author_index":"Jude"},{"id":"7b7501b7603f5fa7dd1b27a67cca3065","title":"66、Mac系统升级后桌面文件夹及文件消失","content":"解决方式：终端输入如下命令即可\nshelldefaults write com.apple.finder CreateDesktop -bool true; killall Finder\n// 显示/隐藏  隐藏文件\ncommand shift + .","slug":"66-mac-finder","date":"2022-04-19T15:30:00.000Z","categories_index":"","tags_index":"other","author_index":"Jude"},{"id":"6aa055f21121350012e80c5eb71d3fcf","title":"65、响应式原理","content":"\n\n1、什么是响应式？\n数据变化可以被检测对这种变化做出响应的机制\n2、Vue为什么需要响应式？\nMVVM框架需要解决的核心问题技术就是连接数据层和视图层，通过数据驱动应用，数据变化，试图更新，要做到这点就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。\n3、响应式的好处？\n通过数据响应式加上虚拟DOM和patch算法，开发人员只需要操作数据，关心业务，完全不用接触繁琐的DOM操作，大大提升开发效率，降低开发难度。\n4、如何实现Vue的响应式？优缺点？\nVue2肿的数据响应式会根据数据类型来做不同处理，如果是对象采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并做出响应；如果是数组则通过覆盖数组对象原型的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化问题，但是也存在一些缺点：初始化时的递归遍历会造成性能损失；新增或者删除属性需要使用Vue.set&#x2F;delete这些特殊的API才能生效；对于es6中新产生的Map、Set这些数据结构不支持。\njsfunction defineReactive(obj,key,val)&#123;\n  Object.defineProperty(obj,key,&#123;\n    get(key)&#123;&#125;,\n    set(key,val)&#123;&#125;\n  &#125;)\n&#125;5、Vue3如何实现响应式？\n利用es6的Proxy代理响应式的数据。好处：不需要特殊的api，初始化性能和内存小号都得到了大幅改善由于响应化的实现代码抽取为独立的reactivity报，使得我们可以灵活的使用它，第三方的扩展开发更加的灵活\nProxy属性拦截的原理：利用get、set、deleteProperty这3个trap实现拦截\njsfunction reactive(obj)&#123;\n  return new Proxy(obj,&#123;\n    get(target,key)&#123;&#125;,\n    set(target,key,val)&#123;&#125;,\n    deleteProperty(target,key)&#123;&#125;\n  &#125;)\n&#125;proxy更快的原因：初始化时懒处理，用户访问才做拦截处理，初始化更快。\nts// https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/baseHandlers.ts\n    if (isObject(res)) &#123;\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res)\n    &#125;轻量的依赖关系保存：利用WeakMap\\Map\\Set保存响应式数据和副作用之间的依赖关系。\n","slug":"65-reactive","date":"2022-04-11T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"d7d0c8cca34ebc843fd94a93b8ff0987","title":"63、ant-design-vue v-model.trim不生效","content":"同element-ui一样，el-input和a-input  均不支持v-model修饰符。\n\n\n解决办法：\nelement-ui示例代码：\nhtml&lt;el-form-item&gt;\n    &lt;el-input\n        placeholder=&quot;请输入内容&quot;\n        v-model=&quot;queryInfo.name&quot;\n        @blur=&quot;queryInfo.name=$event.target.value.trim()&quot;\n        clearable\n        maxlength=&quot;11&quot;\n    &gt;\n\n    &lt;/el-input&gt;\n&lt;/el-form-item&gt;ant-design-vue示例代码：\nhtml&lt;a-form-item label=&quot;租户名称&quot;&gt;\n   &lt;a-input placeholder=&quot;请输入租户名称&quot; v-model=&quot;queryInfo.name&quot; allowClear /&gt;\n&lt;/a-form-item&gt;去空格函数\njsmethods:&#123;\n    tirmHandler(target, prop)&#123;\n        if (target &amp;&amp; target[prop] &amp;&amp; target[prop].trim) &#123;\n            target[prop] = target[prop].trim()\n        &#125;\n    &#125;,\n    handleCnfirm()&#123;\n        this.trimHandler(this.queryInfo.name,&#39;name&#39;)\n    &#125;   \n&#125;","slug":"63-ant-design-vue-trim","date":"2022-04-06T12:00:00.000Z","categories_index":"","tags_index":"ant-design-vue","author_index":"Jude"},{"id":"85b7a16cbec6629594a0f1c58d3348a5","title":"64、ant-design-vue-picker","content":"ant-design-vue 限制时间选择框,展示2天内数据且只能选择7日范围内（截止时间不得超过当日）\n\n\n1、template\nhtml&lt;a-form-item label=&quot;时间&quot;&gt;\n  &lt;a-range-picker\n    v-model=&quot;rangeTime&quot;\n    :allowClear=&quot;false&quot;\n    :disabled-date=&quot;disableDate&quot;\n    @change=&quot;onChange&quot;\n    @openChange=&quot;openChange&quot;\n    :placeholder=&quot;[&#39;开始时间&#39;, &#39;结束时间&#39;]&quot;\n  /&gt;\n&lt;/a-form-item&gt;2、js\njs// data\nrangeTime: [moment(Date.now() - 1 * 24 * 3600 * 1000), moment(Date.now())],\nfirstSelectTime: null,\n\n\n//  methods\n// 日期校验\ndisableDate(current) &#123;\n  let nowDate = new Date()\n  nowDate.setMilliseconds(0)\n  nowDate.setSeconds(0)\n  nowDate.setMinutes(0)\n  nowDate.setHours(0)\n  let isOut30 = false\n  if (this.firstSelectTime) &#123;\n    if (\n      current &gt; this.firstSelectTime + 6 * 24 * 3600 * 1000 ||\n      current &lt; this.firstSelectTime - 6 * 24 * 3600 * 1000\n    ) &#123;\n      isOut30 = true\n    &#125;\n  &#125;\n  return current &amp;&amp; (current &gt; Date.now() || isOut30)\n&#125;,\ncalendarChange(dates, dateStrings) &#123;\n  this.firstSelectTime = moment(Date.now() - 1 * 24 * 3600 * 1000)\n&#125;,\nopenChange(status) &#123;\n  this.firstSelectTime = moment(Date.now() - 1 * 24 * 3600 * 1000)\n&#125;,","slug":"64-ant-design-vue-picker","date":"2022-04-06T12:00:00.000Z","categories_index":"","tags_index":"ant-design-vue","author_index":"Jude"},{"id":"93e6995d69db4365548a7462a9d2113a","title":"62、权限管理","content":"\n权限管理一般需求是页面权限和按钮权限的管理\n具体实现的时候分后端和前端两种方案：前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个 asyncRoutes‘数组，需要认证的页面在其路由的‘meta’中添加一个 roles*字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过‘router.addRoutes(accessRoutes)°方式动态添加路由即可。后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过 addRoutes‘动态添加路由信息按钮权限的控制通常会实现一个指令，例如V-permissin’，将按钮要求角色通过值传给vpermission指令，在指令的 moutned钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。\n纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！\n\n","slug":"62-permmsion","date":"2022-03-11T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"91787eb7e529f909a3a7c06abd6ab596","title":"61、js如何将base64转成16进制","content":"需求：将base64密文解密成16进制。\n\n\n1、原生js的编码(btoa)和解码(atob)\njsvar baseStr = &quot;http://www.baidu.com&quot;\nvar encodedData = window.btoa(baseStr)\nconsole.log(encodedData) //aHR0cDovL3d3dy5iYWlkdS5jb20=\n\nvar decodedData = window.atob(encodedData)\nconsole.log(decodedData) // http://www.baidu.com2、base64转16进制\njs    stringToHex(base64)&#123;\n      var raw = atob(base64)\n      var HEX = &#39;&#39;\n      for (var i = 0; i &lt; raw.length; i++) &#123;\n        var _hex = raw.charCodeAt(i).toString(16)\n        HEX += _hex.length == 2 ? _hex : &#39;0&#39; + _hex\n      &#125;\n      return HEX\n      // return HEX.toUpperCase()  将字符串转换成大写格式\n    &#125;","slug":"61-base64To16","date":"2022-03-01T12:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"078fde9ad4b31fe5df06fa312dcb9f33","title":"60、什么是上位机、下位机?","content":"上位机在系统中起主控作用，主要作为系统的规划控制，属于决策层；而下位机是具体执行层，主要完成系统规划层下达的任务。\n\n\n1.通常上位机和下位机通讯可以采用不同的通讯协议，可以有RS232的串口通讯或者采用RS485串行通讯。当用计算机和PLC通讯的时候，不但可以采用传统的D形式的串行通讯，还可以采用更适合工业控制的双线的PROFIBUS-DP通讯。\n2.上位机与下位机之间的关系：上位机给下位机发送控制命令，下位机收到此命令并执行相应的动作；上位机给下位机发送状态获取命令，下位机收到此命令后调用传感器测量，然后转化为数字信息反馈给上位机；下位机主动发送状态信息或报警信息给上位机。\n3.下位机指直接与机器相连接的计算机或单片机，一般用于接收和反馈上位机的指令，并且根据指令控制机器执行动作以及从机器传感器读取数据。典型设备类型：PLC，stm32，51，FPGA，ARM等各类可编程芯片。\n","slug":"60-Upper-Lower","date":"2022-02-28T12:00:00.000Z","categories_index":"","tags_index":"other","author_index":"Jude"},{"id":"710a8c4c49caf5243e734c5307bc0344","title":"59、ant-design-vue select下拉框组件","content":"问题：选中select的某一项，下拉框不显示已选择项？\n\n\n解决方式：    添加chang事件：\nhtml&lt;a-form-item label=&quot;状态&quot;&gt;\n    &lt;a-select v-model=&quot;queryInfo.statusCode&quot; placeholder=&quot;请选择状态&quot; allowClear @change=&quot;selectChange&quot;&gt;\n        &lt;a-select-option value=&quot;voltageStatusScope3&quot;&gt;一&lt;/a-select-option&gt;\n        &lt;a-select-option value=&quot;voltageStatusScope2&quot;&gt;二&lt;/a-select-option&gt;\n        &lt;a-select-option value=&quot;voltageStatusScope1&quot;&gt;三&lt;/a-select-option&gt;\n    &lt;/a-select&gt;\n&lt;/a-form-item&gt;jsselectChange()&#123;\n    this.$forceUpdate();\n&#125;","slug":"59-ant-design-vue","date":"2022-02-26T12:00:00.000Z","categories_index":"","tags_index":"ant-design-vue","author_index":"Jude"},{"id":"17a317899ff4b14db2de98aeac8d5e18","title":"58、解决Homebrew安装失败","content":"Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。\n\n\n一、安装官网安装方式：\njs/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;官网安装一直失败。。。。(不适合国内用户)\n二、解决方式1、终端输入：\njs/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;2、选择一个镜像\n\n\n\n\n\n\n\n\n\n1、中科大下载源2、清华大学下载源 …\n3、查看本地软件库列表\njsbrew ls","slug":"58-homebrew","date":"2022-02-24T16:00:00.000Z","categories_index":"","tags_index":"tool","author_index":"Jude"},{"id":"aa40af85aceeb30cb2d7f6d5d06d90ef","title":"57、Vue2/Vue3 响应式原理","content":"Vue官网：当把一个普通的对象传入Vue实例作为data选项，Vue将遍历此对象所有的属性，并使用Object.defineProperty把这些数星星全部转化为getter&#x2F;setter。Object.defineProperty是ES5中一个无法shim的特性（查了一下shim的意思：就是可以将新的API引入到旧的环境中，而且仅靠环境中的已有手段实现，Obejct.defineProperty无法在低级浏览器中的方法实现），这也就是Vue不支持IE8以及更低版本浏览器的原因。\n\n\n一、Vue无法检测对象属性添加或删除Object.defineProperty 没有对对象的新属性进⾏属性劫持 \n\n\n\n\n\n\n\n\n\n原因：由于Vue会在初始化实例时对对象的属性执行getter&#x2F;setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。\njsvar vm = new Vue(&#123;\n    data:&#123;\n        a:1\n    &#125;\n&#125;)\n\nvm.a 是响应式\nvm.b 是非响应式解决无法检测对象属性的增加、删除的方法：Vue.set(object,propertyName,value)(增加属性)、Vue.delete()（删除属性）\n二、Vue不能检测数组的变动数组是一个特殊的JavaScript对象，Vue没有对数组进⾏ Object.defineProperty 的属性劫持，所以会存在的问题：\n不能检测数组变动的2类问题：\n\n\n\n\n\n\n\n\n\n1、当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] &#x3D; newValue2、当你修改数组的长度时，例如：vm.items.length &#x3D; newLength\njsvar vm = new Vue(&#123;\n    data:&#123;\n        items: [&#39;a&#39;&#39;,&#39;b&#39;,&#39;c&#39;]\n    &#125;\n&#125;)\n\nvvm.items[1] = &#39;x&#39; // 非响应式\nvm.items.length = 2 // 非响应式解决利用索引值设置一个数组项的方法：\n\n\n\n\n\n\n\n\n\nvm.$set(vm.items, indexOfItem, newValue)\n解决第2个问题：\n\n\n\n\n\n\n\n\n\nvm.items.splice(newLength)  &#x2F;&#x2F; Array.prototype.slice\n三、Vue2 为什么不劫持数组？Vue2使用的Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty是可以监听数组下标变化的，对于javascript来讲，数组也是属于Object。\n尤雨溪说过：为了性能！！！\n原因：\n\n\n\n\n\n\n\n\n\n1、因为数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素。比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。2、数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。3、Vue将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。\nVue3 的 proxyObject.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。\nProxy可以劫持整个对象，并返回一个新的对象。\n所以为什么proxy优于Object.defineProperty？\nObject.defineProperty必须“预先”劫持属性。被劫持的属性才会被监听到。所以后添加的属性，需要手动再次劫持。\n而proxy代理了整个对象，不需要预先劫持属性，而是在获取&#x2F;修改的时候，通过get&#x2F;set方法来告诉你key。所以不管如何新增属性，总是能被捕获到。\n四、Vue响应式原理整体思路是数据劫持+观察者模式：\n对象内部通过 defineReactive ⽅法，使⽤ Object.defineProperty 将属性进⾏劫持（只会劫持已经存在的属性），数组则是通过重写数组⽅法来实现。当⻚⾯使⽤对应属性时，每个属性都拥有⾃⼰的 dep 属性，存放他所依赖的 watcher （依赖收集），当属性变化后会通知⾃⼰对应的 watcher 去更新(派发更新)。\n\n\n\n\n\n\n\n\n\nVue响应式原理的核心：就是Observer、Dep、Watcher。Observer中进行响应式的绑定，在数据被读的时候，触发get方法，执行Dep来收集依赖，也就是收集Watcher。在数据被改的时候，触发set方法，通过对应的所有依赖(Watcher)，去执行更新。比如watch和computed就执行开发者自定义的回调方法。\n五、为什么只对对象劫持，对数组方法进行重写？\n\n\n\n\n\n\n\n\n因为对象最多也就⼏⼗个属性，拦截起来数量不多，但是数组可能会有⼏百⼏千项，拦截起来⾮常耗性能，所以直接重写数组原型上的⽅法，是⽐较节省性能的⽅案\n六、实现一个数据双向绑定js    &lt;input id=&quot;hangdleInput&quot; type=&quot;text&quot;&gt;\n    &lt;span id=&quot;hangdleValue&quot;&gt;&lt;/span&gt;\n    &lt;script&gt;\n        let obj =&#123;&#125;\n        let input = document.getElementById(&#39;hangdleInput&#39;)\n        let span = document.getElementById(&#39;hangdleValue&#39;)\n        Object.defineProperty(obj,&#39;text&#39;,&#123;\n            configurable: true,\n            enumerable: true,\n            get()&#123;\n                console.log(&#39;get data&#39;)\n            &#125;,\n            set(newVal)&#123;\n                console.log(&#39;set data&#39;)\n                input.value = newVal\n                span.innerHTML = newVal\n            &#125;\n        &#125;)\n        input.addEventListener(&#39;keyup&#39;,function(e)&#123;\n            obj.text = e.target.value\n        &#125;)\n    &lt;/script&gt;七、Vue3 Proxy\n\n\n\n\n\n\n\n\nVue2 的响应式是基于 Object.defineProperty 实现的Vue3 的响应式是基于 ES6 的 Proxy 来实现的\n在Vue2.0中，数据双向绑定就是通过Object.defineProperty去监听对象的每一个属性，然后在get&#x2F;set方法中通过发布订阅者模式来实现的数据响应，但是存在一定的缺陷，比如只能监听已存在的属性，对于新增删除属性就无能为力了，同时无法监听数组的变化，所以在Vue3.0中将其换成了功能更强大的ES6 Proxy。\nVue2的响应式函数:\njs// 响应式函数\nfunction reactive(obj, key, value) &#123;\n  Object.defineProperty(data, key, &#123;\n    get() &#123;\n      console.log(`访问了$&#123;key&#125;属性`)\n      return value\n    &#125;,\n    set(val) &#123;\n      console.log(`将$&#123;key&#125;由-&gt;$&#123;value&#125;-&gt;设置成-&gt;$&#123;val&#125;`)\n      if (value !== val) &#123;\n        value = val\n      &#125;\n    &#125;\n  &#125;)\n&#125;\nconst data = &#123;\n  name: &#39;jude&#39;,\n  age: 18\n&#125;\nObject.keys(data).forEach(key =&gt; reactive(data, key, data[key]))\nconsole.log(data.name)\n// 访问了name属性\n// jude\ndata.name = &#39;summer&#39; // 将name由-&gt;jude-&gt;设置成-&gt;summer\nconsole.log(data.name)\n// 访问了name属性\n// summerVue3的响应式函数：\njsconst data = &#123;\n  name: &#39;jude&#39;,\n  age: 18\n&#125;\n\nfunction reactive(target) &#123;\n  const handler = &#123;\n    get(target, key, receiver) &#123;\n      console.log(`访问了$&#123;key&#125;属性`)\n      return Reflect.get(target, key, receiver)\n    &#125;,\n    set(target, key, value, receiver) &#123;\n      console.log(`将$&#123;key&#125;由-&gt;$&#123;target[key]&#125;-&gt;设置成-&gt;$&#123;value&#125;`)\n      Reflect.set(target, key, value, receiver)\n    &#125;\n  &#125;\n\n  return new Proxy(target, handler)\n&#125;\n\nconst proxyData = reactive(data)\n\nconsole.log(proxyData.name)\n// 访问了name属性\n// jude\nproxyData.name = &#39;summer&#39;\n// 将name由-&gt;jude-&gt;设置成-&gt;summer\nconsole.log(proxyData.name)\n// 访问了name属性\n// summerjs/**\n* target: 要兼容的对象，可以是一个对象，数组,函数等等\n* handler: 是一个对象，里面包含了可以监听这个对象的行为函数，比如上面例子里面的get与set\n* 同时会返回一个新的对象proxy, 为了能够触发handler里面的函数，必须要使用返回值去进行其他操作，比如修改值\n*/\nconst proxy = new Proxy(target, handler)\n1、handle.get、handle.set、handle.has、handler.deleteProperty\n\n\n\n\n\n\n\n\n当通过proxy去读取对象里面的属性的时候，会进入到get钩子函数里面当通过proxy去为对象设置修改属性的时候，会进入到set钩子函数里面当使用in判断属性是否在proxy代理对象里面时，会触发has当使用delete去删除对象里面的属性的时候，会进入deleteProperty钩子函数\n2、Reflect\n\n\n\n\n\n\n\n\n在上面，我们获取属性的值或者修改属性的值都是通过直接操作target来实现的，但实际上ES6已经为我们提供了在Proxy内部调用对象的默认行为的API: Reflect。\njsconst obj = &#123;&#125;\nconst proxy = new Proxy(obj, &#123;\n  get(target,key,receiver) &#123;\n    return Reflect.get(target,key,receiver)\n  &#125;\n&#125;)","slug":"57-vue2-defineProperty","date":"2022-02-23T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"6078e843a70df5973b73339f903e8c92","title":"56、HTTP的请求方法、状态码","content":"整理一下HTTP的请求方法、GET&#x2F;POST方法的区别、HTTP状态码、跨域解决方法，最近面试也被问到这些问题。\n\n\n一、HTTP的请求方法\n\n\n\n\n\n\n\n\nGET: 通常是用来获取资源POST： 提交数据PUT： 修改数据DELETE： 删除资源HEAD: 获取资源的元信息\n二、GET和POST请求的区别？从字面意思来讲，GET就是拿、获得，POST就是给、邮寄。\n1、缓存角度： GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会；\n2、编码角度： GET只能进行URL编码，只能接受ASCII字符，而POST没有限制；\n3、参数角度： GET一般将参数放在URL中，存在安全问题，POST放在请求体中，适合传输敏感信息\n4、幂等性角度： GET是幂等，POST则不是。（幂等表示执行相同的操作，结果也是相同的）\n5、TCP角度：GET会将请求报文一次性发出去，而POST会分为2个TCP数据包,先发header部分，如果服务器响应100，再发body部分。（Firefox浏览器的POST请求只会发一个TCP包）。\n三、HTTP状态码\n\n\n\n\n\n\n\n\n1XX: 协议处理的中间状态，还需要后续操作2XX: 成功状态3XX: 重定向状态，资源位置发生变动，需要重新请求4XX: 请求报文有误5XX: 服务端发生错误\n通常在开发过程中，常用到的状态码包括：200：这个最常见，成功的状态码，通常在响应体中放有数据204：与200的区别就在于响应头后没有body数据206：表示部分内容，这个状态码在断点续传中可以看到（响应头字段为：Content-Range）\n301: 永久重定向302: 临时重定向304: 协商缓存命中时返回这个304状态码\n403： 服务器禁止访问404： 资源未找到，在服务器上未找到相应的资源\n500： 服务器出错了，一般将报错信息发送给后端，后端同学来检查\n四、HTTP、HTTP&#x2F;2特点1、http特点1、灵活可拓展。语义自由，只规定了基本格式；传输形式多样性，可传输文本、图片、视频等任意数据。\n2、可靠传输。基于TCP&#x2F;IP，继承了TCP特性。\n3、请求-应答。一发一收、有来有回\n4、无状态。每次的http请求都输独立、无关的，默认不需要保留状态信息。\n2、http缺点1、无状态。区分场景，无状态是优点也是缺点，例如长链接中，无状态就是缺点；如果就是获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，http成了优点。\n2、明文传输：协议里的头部报文不使用二进制数据，而是文本形式。调试便利的同时，http报文信息暴露给了外界，容易被外界攻击。\n3、https&#x2F;2的改进1、头部压缩：针对头部字段，采用压缩算法\n2、多路复用：解决http对头阻塞问题\n3、设置优先级：二进制分帧\n4、服务器推送：不再是被动的接受请求、响应请求，能新建stream给客户端发送信息。\n5、安全性：\n4、三次握手\n\n\n\n\n\n\n\n\n三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。\n第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n五、跨域及解决方式：前后端分离的开发模式中，通常会遇到跨域问题，当一个ajax请求发出去了，服务器也响应了，但是前端拿不到响应数据，这主要是因为浏览器有一个同源策略。\n1、浏览器的同源策略\n\n\n\n\n\n\n\n\n浏览器遵循同源策略，即协议 + host主机 + port端口都相同时，视为同源，不存在跨域。当浏览器发送Ajax请求时，只要当前的URL和目标URL不同源（协议、host、port有一个不相同，就是不同源），就存在跨域请求。\n2、CROS：跨域资源共享CORS是一个W3C标准，需要浏览器和服务器的共同支持。一般在服务端响应头返回Access-Control-Allow-Origin:* (也可以指定具体的源名)\n\n\n\n\n\n\n\n\n\noptions 预检请求\njsOPTIONS / HTTP/1.1\nOrigin: 当前地址\nHost: xxx.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。\n3、Nginx反向代理\n\n\n\n\n\n\n\n\nNginx是高性能的反向代理服务器\n反向代理其实就是拿到客户端的请求，将请求转发给其他服务器，主要场景是维持服务器集群的负载均衡。即：反向代理帮其他的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。\n例如：客户端域名：client.com  服务器域名：server.com,Nginx解决跨域的方法如下：\njsserver &#123;\n  listen  80;\n  server_name  client.com;\n  location /api &#123;\n    proxy_pass server.com;\n  &#125;\n&#125;客户端首先访问client.com&#x2F;api（此时不存在跨域），Nginx服务器作为反向代理，将请求转发给sever.com，响应返回时又将响应给到客户端，完成整个跨域请求。\n4、Jsonp\n\n\n\n\n\n\n\n\n通过给script标签的src填上目标地址发送GET请求（只支持GET请求），实现跨域请求拿到相应数据。\n5、websocket\n\n\n\n\n\n\n\n\nwebsocket实现了客户端与服务端直接的持久连接，本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制\n","slug":"56-http","date":"2022-02-22T16:00:00.000Z","categories_index":"","tags_index":"http","author_index":"Jude"},{"id":"146999a281f0a10064997f50d99317f5","title":"55、大文件断点续传","content":"关于大文件断点续传的问题,解决方案是Blob.prototype.slice方法，和数组的slice方法类似，使用slice方法可以返回源文件的切片。按照要求将源文件切位n个切片，将多个切片同时上传，源文件由一个大文件转换成n个小切片同时上传，可以大大减少上传时间。需要注意的是上传到服务端的切片可能位置会发生改变，需要将切片的位置记录下来。\n\n\n一、服务端（Node.js）服务端需要做的是：接受n个切片，并将这些切片在上传后合并。\n需要注意的是：\n1、合并切片的时间: 即n个切片什么时候上传完成\n\n\n\n\n\n\n\n\n\n前端上传的切片中带有切片的个数，服务端接受到切片的总数后自动合并2、怎么合并切片使用node.js的读写流(readStream&#x2F;writeStream)，将所有切片的流传输到最终文件的流里。\n服务端：\n\n\n\n\n\n\n\n\n\nserver-index.js-controller.js\n\n点我展示代码\n\njs// index.js\nconst Controller = require(&quot;./controller&quot;);\nconst http = require(&quot;http&quot;);\nconst server = http.createServer();\n\nconst controller = new Controller();\n\nserver.on(&quot;request&quot;, async (req, res) =&gt; &#123;\n  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n  // 解决跨域   \n  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);\n  if (req.method === &quot;OPTIONS&quot;) &#123;\n    res.status = 200;\n    res.end();\n    return;\n  &#125;\n//   验证上传文件是否已上传\n  if (req.url === &quot;/verify&quot;) &#123;\n    await controller.handleVerifyUpload(req, res);\n    return;\n  &#125;\n    // 合并切片\n  if (req.url === &quot;/merge&quot;) &#123;\n    await controller.handleMerge(req, res);\n    return;\n  &#125;\n  if (req.url === &quot;/&quot;) &#123;\n    await controller.handleFormData(req, res);\n  &#125;\n&#125;);\n\nserver.listen(3001, () =&gt; console.log(&quot;正在监听 3001 端口&quot;));\njs// controller.js\n// 处理前端传来的FormData\nconst multiparty = require(&quot;multiparty&quot;);\nconst path = require(&quot;path&quot;);\nconst fse = require(&quot;fs-extra&quot;);\n\nconst extractExt = filename =&gt;\n  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名\nconst UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录\n\nconst pipeStream = (path, writeStream) =&gt;\n  new Promise(resolve =&gt; &#123;\n    //   创建可读流\n    const readStream = fse.createReadStream(path);\n    readStream.on(&quot;end&quot;, () =&gt; &#123;\n      fse.unlinkSync(path);\n      resolve();\n    &#125;);\n    readStream.pipe(writeStream);\n  &#125;);\n\n// 合并切片\nconst mergeFileChunk = async (filePath, fileHash, size) =&gt; &#123;\n  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);\n  const chunkPaths = await fse.readdir(chunkDir);\n  // 根据切片下标进行排序\n  // 否则直接读取目录的获得的顺序可能会错乱\n  chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);\n  await Promise.all(\n    chunkPaths.map((chunkPath, index) =&gt;\n      pipeStream(\n        path.resolve(chunkDir, chunkPath),\n        // 指定位置创建可写流\n        fse.createWriteStream(filePath, &#123;\n          start: index * size,\n          end: (index + 1) * size\n        &#125;)\n      )\n    )\n  );\n  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录\n&#125;;\n\nconst resolvePost = req =&gt;\n  new Promise(resolve =&gt; &#123;\n    let chunk = &quot;&quot;;\n    req.on(&quot;data&quot;, data =&gt; &#123;\n      chunk += data;\n    &#125;);\n    req.on(&quot;end&quot;, () =&gt; &#123;\n      resolve(JSON.parse(chunk));\n    &#125;);\n  &#125;);\n\n// 返回已经上传切片名\nconst createUploadedList = async fileHash =&gt;\n  fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))\n    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))\n    : [];\n\nmodule.exports = class &#123;\n  // 合并切片\n  async handleMerge(req, res) &#123;\n    const data = await resolvePost(req);\n    const &#123; fileHash, filename, size &#125; = data;\n    const ext = extractExt(filename);\n    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);\n    await mergeFileChunk(filePath, fileHash, size);\n    res.end(\n      JSON.stringify(&#123;\n        code: 0,\n        message: &quot;file merged success&quot;\n      &#125;)\n    );\n  &#125;\n  // 处理切片\n  async handleFormData(req, res) &#123;\n    const multipart = new multiparty.Form();\n    //下面multipart.parse的回调中 fields 参数保存了FormData中的文件\n    multipart.parse(req, async (err, fields, files) =&gt; &#123;\n      if (err) &#123;\n        console.error(err);\n        res.status = 500;\n        res.end(&quot;process file chunk failed&quot;);\n        return;\n      &#125;\n      const [chunk] = files.chunk;\n      const [hash] = fields.hash;\n      const [fileHash] = fields.fileHash;\n      const [filename] = fields.filename;\n      const filePath = path.resolve(\n        UPLOAD_DIR,\n        `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`\n      );\n      const chunkDir = path.resolve(UPLOAD_DIR, fileHash);\n\n      // 文件存在直接返回\n      if (fse.existsSync(filePath)) &#123;\n        res.end(&quot;file exist&quot;);\n        return;\n      &#125;\n\n      // 切片目录不存在，创建切片目录\n      if (!fse.existsSync(chunkDir)) &#123;\n        await fse.mkdirs(chunkDir);\n      &#125;\n      // fs-extra 专用方法，类似 fs.rename 并且跨平台\n      // fs-extra 的 rename 方法 windows 平台会有权限问题\n      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835\n      await fse.move(chunk.path, path.resolve(chunkDir, hash));\n      res.end(&quot;received file chunk&quot;);\n    &#125;);\n  &#125;\n  // 验证是否已上传/已上传切片下标\n  async handleVerifyUpload(req, res) &#123;\n    const data = await resolvePost(req);\n    const &#123; fileHash, filename &#125; = data;\n    const ext = extractExt(filename);\n    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);\n    if (fse.existsSync(filePath)) &#123;\n      res.end(\n        JSON.stringify(&#123;\n          shouldUpload: false\n        &#125;)\n      );\n    &#125; else &#123;\n      res.end(\n        JSON.stringify(&#123;\n          shouldUpload: true,\n          uploadedList: await createUploadedList(fileHash)\n        &#125;)\n      );\n    &#125;\n  &#125;\n&#125;;\n\n\n\n二、客户端前端使用Vue+elementUI展示界面，当点击上传按钮时，slice方法将源文件做切片处理，将切片放入数组中返回，使用 hash+index 给每个切片做标识，用于上传完成后合并切片。调用uploadChunks上传所有的切片，将切片、切片hash、切片名filename放入FormData中，使用promise.all并发上传所有切片。\n断点续传原理在于前后端需要记住已经上传的切片，继续上传的时候就可以跳过之前已经上传的部分。\n实现的方案：\n\n\n\n\n\n\n\n\n\n服务端保存已经上传的切片hash，前端每次上传前都向服务端获取已经上传的切片。\n这里也可以在前端使用localStorage记录已经上传的切片的hash，但是存在问题，就是换一个浏览器就失去已经上传的切片的hash了。\n客户端、服务端都需要生成文件和切片的hash，根据文件内容生成hash。使用spark-md5根据文件内容计算出文件的hash值。\n当文件比较大的时候，读取文件内容计算hash是非常耗时的，会引起UI阻塞，导致页面假死，解决方式是使用web-worker在worker线程计算hash。\n实例化web-worker，参数是一个js文件路径不能跨域，需要单独创建一个hash.js文件放在public中，在worker中不允许访问dom，使用importScripts函数导入外部脚本spark-md5\njs// hash.js\nself.importScripts(&quot;/spark-md5.min.js&quot;); // 导入脚本\n\n// 生成文件 hash\nself.onmessage = e =&gt; &#123;\n  const &#123; fileChunkList &#125; = e.data;\n  const spark = new self.SparkMD5.ArrayBuffer();\n  let percentage = 0;\n  let count = 0;\n  const loadNext = index =&gt; &#123;\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(fileChunkList[index].file);\n    reader.onload = e =&gt; &#123;\n      count++;\n      spark.append(e.target.result);\n      if (count === fileChunkList.length) &#123;\n        self.postMessage(&#123;\n          percentage: 100,\n          hash: spark.end()\n        &#125;);\n        self.close();\n      &#125; else &#123;\n        percentage += 100 / fileChunkList.length;\n        self.postMessage(&#123;\n          percentage\n        &#125;);\n        loadNext(count);\n      &#125;\n    &#125;;\n  &#125;;\n  loadNext(0);\n&#125;;\n1、template\n\n点我展示代码\n\nhtml    &lt;div&gt;\n      &lt;input\n        type=&quot;file&quot;\n        :disabled=&quot;status !== Status.wait&quot;\n        @change=&quot;handleFileChange&quot;\n      /&gt;\n      &lt;el-button @click=&quot;handleUpload&quot; :disabled=&quot;uploadDisabled&quot;\n        &gt;上传&lt;/el-button\n      &gt;\n      &lt;el-button @click=&quot;handleResume&quot; v-if=&quot;status === Status.pause&quot;\n        &gt;恢复&lt;/el-button\n      &gt;\n      &lt;el-button\n        v-else\n        :disabled=&quot;status !== Status.uploading || !container.hash&quot;\n        @click=&quot;handlePause&quot;\n        &gt;暂停&lt;/el-button\n      &gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;!-- &lt;div&gt;计算文件 hash&lt;/div&gt;\n      &lt;el-progress :percentage=&quot;hashPercentage&quot;&gt;&lt;/el-progress&gt; --&gt;\n      &lt;div&gt;总进度&lt;/div&gt;\n      &lt;el-progress :percentage=&quot;fakeUploadPercentage&quot;&gt;&lt;/el-progress&gt;\n    &lt;/div&gt;\n    &lt;el-table :data=&quot;data&quot;&gt;\n      &lt;el-table-column\n        prop=&quot;hash&quot;\n        label=&quot;切片hash&quot;\n        align=&quot;center&quot;\n      &gt;&lt;/el-table-column&gt;\n      &lt;el-table-column label=&quot;大小(KB)&quot; align=&quot;center&quot; width=&quot;120&quot;&gt;\n        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;\n          &#123;&#123; row.size | transformByte &#125;&#125;\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n      &lt;el-table-column label=&quot;进度&quot; align=&quot;center&quot;&gt;\n        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;\n          &lt;el-progress\n            :percentage=&quot;row.percentage&quot;\n            color=&quot;#909399&quot;\n          &gt;&lt;/el-progress&gt;\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n\n\n2、js部分：设置切片大小 考虑到通用性，简单封装了XMLHttpRequest, 实际使用可以隐藏掉hash进度条\n\n点我展示代码\n\njs&lt;script&gt;\nconst SIZE = 100 * 1024 * 1024; // 切片大小\n\nconst Status = &#123;\n  wait: &quot;wait&quot;,\n  pause: &quot;pause&quot;,\n  uploading: &quot;uploading&quot;\n&#125;;\n\n\nexport default &#123;\n  name: &quot;app&quot;,\n  filters: &#123;\n    transformByte(val) &#123;\n      return Number((val / 1024).toFixed(0));\n    &#125;\n  &#125;,\n  data: () =&gt; (&#123;\n    Status,\n    container: &#123;\n      file: null,\n      hash: &quot;&quot;,\n      worker: null\n    &#125;,\n    hashPercentage: 0,\n    data: [],\n    requestList: [],\n    status: Status.wait,\n    // 当暂停时会取消 xhr 导致进度条后退\n    // 为了避免这种情况，需要定义一个假的进度条\n    fakeUploadPercentage: 0\n  &#125;),\n  computed: &#123;\n    uploadDisabled() &#123;\n      return (\n        !this.container.file ||\n        [Status.pause, Status.uploading].includes(this.status)\n      );\n    &#125;,\n    uploadPercentage() &#123;\n      if (!this.container.file || !this.data.length) return 0;\n      const loaded = this.data\n        .map(item =&gt; item.size * item.percentage)\n        .reduce((acc, cur) =&gt; acc + cur);\n      return parseInt((loaded / this.container.file.size).toFixed(2));\n    &#125;\n  &#125;,\n  watch: &#123;\n    uploadPercentage(now) &#123;\n      if (now &gt; this.fakeUploadPercentage) &#123;\n        this.fakeUploadPercentage = now;\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    // 暂停\n    handlePause() &#123;\n      this.status = Status.pause;\n      this.resetData();\n    &#125;,\n    resetData() &#123;\n      this.requestList.forEach(xhr =&gt; xhr?.abort());\n      this.requestList = [];\n      if (this.container.worker) &#123;\n        this.container.worker.onmessage = null;\n      &#125;\n    &#125;,\n    async handleResume() &#123;\n      this.status = Status.uploading;\n      const &#123; uploadedList &#125; = await this.verifyUpload(\n        this.container.file.name,\n        this.container.hash\n      );\n      await this.uploadChunks(uploadedList);\n    &#125;,\n    // xhr\n    request(&#123;\n      url,\n      method = &quot;post&quot;,\n      data,\n      headers = &#123;&#125;,\n      onProgress = e =&gt; e,\n      requestList\n    &#125;) &#123;\n      return new Promise(resolve =&gt; &#123;\n        const xhr = new XMLHttpRequest();\n        xhr.upload.onprogress = onProgress;\n        xhr.open(method, url);\n        Object.keys(headers).forEach(key =&gt;\n          xhr.setRequestHeader(key, headers[key])\n        );\n        xhr.send(data);\n        xhr.onload = e =&gt; &#123;\n          // 将请求成功的 xhr 从列表中删除\n          if (requestList) &#123;\n            const xhrIndex = requestList.findIndex(item =&gt; item === xhr);\n            requestList.splice(xhrIndex, 1);\n          &#125;\n          resolve(&#123;\n            data: e.target.response\n          &#125;);\n        &#125;;\n        // 暴露当前 xhr 给外部\n        requestList?.push(xhr);\n      &#125;);\n    &#125;,\n    // 生成文件切片\n    createFileChunk(file, size = SIZE) &#123;\n      const fileChunkList = [];\n      let cur = 0;\n      while (cur &lt; file.size) &#123;\n        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);\n        cur += size;\n      &#125;\n      return fileChunkList;\n    &#125;,\n    // 生成文件 hash（web-worker）\n    calculateHash(fileChunkList) &#123;\n      return new Promise(resolve =&gt; &#123;\n        this.container.worker = new Worker(&quot;/hash.js&quot;);\n        this.container.worker.postMessage(&#123; fileChunkList &#125;);\n        this.container.worker.onmessage = e =&gt; &#123;\n          const &#123; percentage, hash &#125; = e.data;\n          this.hashPercentage = percentage;\n          if (hash) &#123;\n            resolve(hash);\n          &#125;\n        &#125;;\n      &#125;);\n    &#125;,\n    handleFileChange(e) &#123;\n      const [file] = e.target.files;\n      if (!file) return;\n      this.resetData();\n      Object.assign(this.$data, this.$options.data());\n      this.container.file = file;\n    &#125;,\n    async handleUpload() &#123;\n      if (!this.container.file) return;\n      this.status = Status.uploading;\n      const fileChunkList = this.createFileChunk(this.container.file);\n      this.container.hash = await this.calculateHash(fileChunkList);\n\n      const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(\n        this.container.file.name,\n        this.container.hash\n      );\n      if (!shouldUpload) &#123;\n        this.$message.success(&quot;秒传：上传成功&quot;);\n        this.status = Status.wait;\n        return;\n      &#125;\n\n      this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;\n        fileHash: this.container.hash,\n        index,\n        hash: this.container.hash + &quot;-&quot; + index,\n        chunk: file,\n        size: file.size,\n        percentage: uploadedList.includes(index) ? 100 : 0\n      &#125;));\n\n      await this.uploadChunks(uploadedList);\n    &#125;,\n    // 上传切片，同时过滤已上传的切片\n    async uploadChunks(uploadedList = []) &#123;\n      const requestList = this.data\n        .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))\n        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;\n          const formData = new FormData();\n          formData.append(&quot;chunk&quot;, chunk);\n          formData.append(&quot;hash&quot;, hash);\n          formData.append(&quot;filename&quot;, this.container.file.name);\n          formData.append(&quot;fileHash&quot;, this.container.hash);\n          return &#123; formData, index &#125;;\n        &#125;)\n        .map(async (&#123; formData, index &#125;) =&gt;\n          this.request(&#123;\n            url: &quot;http://localhost:3001&quot;,\n            data: formData,\n            onProgress: this.createProgressHandler(this.data[index]),\n            requestList: this.requestList\n          &#125;)\n        );\n      await Promise.all(requestList);\n      // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时\n      // 合并切片\n      if (uploadedList.length + requestList.length === this.data.length) &#123;\n        await this.mergeRequest();\n      &#125;\n    &#125;,\n    // 通知服务端合并切片\n    async mergeRequest() &#123;\n      await this.request(&#123;\n        url: &quot;http://localhost:3001/merge&quot;,\n        headers: &#123;\n          &quot;content-type&quot;: &quot;application/json&quot;\n        &#125;,\n        data: JSON.stringify(&#123;\n          size: SIZE,\n          fileHash: this.container.hash,\n          filename: this.container.file.name\n        &#125;)\n      &#125;);\n      this.$message.success(&quot;上传成功&quot;);\n      this.status = Status.wait;\n    &#125;,\n    // 根据 hash 验证文件是否曾经已经被上传过\n    // 没有才进行上传\n    async verifyUpload(filename, fileHash) &#123;\n      const &#123; data &#125; = await this.request(&#123;\n        url: &quot;http://localhost:3001/verify&quot;,\n        headers: &#123;\n          &quot;content-type&quot;: &quot;application/json&quot;\n        &#125;,\n        data: JSON.stringify(&#123;\n          filename,\n          fileHash\n        &#125;)\n      &#125;);\n      return JSON.parse(data);\n    &#125;,\n    // 用闭包保存每个 chunk 的进度数据\n    createProgressHandler(item) &#123;\n      return e =&gt; &#123;\n        item.percentage = parseInt(String((e.loaded / e.total) * 100));\n      &#125;;\n    &#125;\n  &#125;\n&#125;;\n&lt;/script&gt;\n","slug":"55-file-upload","date":"2022-02-20T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"0e6f9408abb4ba4f2d448bd2b550c5ad","title":"54、个人GitHub图床使用webp格式的图片","content":"使用图床，将本地图片上传到个人GitHub image-host 转换成webp格式的图片链接。\n\n\n1、什么是webp？\n\n\n\n\n\n\n\n\nWebP is  是由 Google 公司开发的一种可提供有损和无损压缩的图片格式，支持透明度，目前已支持动图。\n2、PicX图床的使用PicX 是一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了。\n配置链接：https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE\n\n将本地图片上传至图床，上床成功后的图片会生成一个GitHub外链和cdn外链。\n\n","slug":"54-image-host","date":"2022-01-24T12:00:00.000Z","categories_index":"","tags_index":"cdn","author_index":"Jude"},{"id":"db568bb9a5da9f8f320cc5c32823f12e","title":"53、vue使用装饰器descriptor","content":"decorator装饰器通过对类、对象、方法、属性进行修饰，对其添加一些其他行为，即对一段代码进行二次包装。装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n\n\n一、使用方法：jsconst decorator = (target,name,descriptor) =&gt; &#123;\n  var oldValue = descriptor.value\n  descriptor.value = function()&#123;\n    return oldValue.apply(this,arguments)\n  &#125;\n  return descriptor\n&#125;使用装饰器可以不需要关注代码内部的实现，增强了代码的可读性。\nvue中使用装饰器：\n项目中使用eslint，需要开启装饰器相关语法的检测。\njs// .eslintrc.js\n  parserOptions: &#123;\n    parser: &#39;babel-eslint&#39;,\n    ecmaFeatures:&#123;\n      legacyDecorators: true\n    &#125;\n  &#125;,二、Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作：1、工具函数decorator.js\njs// 需安装element-ui\nimport &#123; MessageBox, Message &#125; from &#39;element-ui&#39;\n\n/**\n * 确认框\n * @param &#123;String&#125; title - 标题\n * @param &#123;String&#125; content - 内容\n * @param &#123;String&#125; confirmButtonText - 确认按钮名称\n * @param &#123;Function&#125; callback - 确认按钮名称\n * @returns\n   **/\n\n\nexport function confirm (title, content, confirmButtonText = &#39;确定&#39;) &#123;\n  return function(target, name, descriptor) &#123;\n    // target:test（）  \n    // name:test1   \n    // descriptor: 装饰器属性 \n    // 包括 ：configurable: true \n    // umerable: true\n    // value: ƒ () \n    // writable: true\n    const originValue = descriptor.value\n    descriptor.value = function(...args) &#123;\n      MessageBox.confirm(content, title, &#123;\n        dangerouslyUseHTMLString: true,\n        distinguishCancelAndClose: true,\n        confirmButtonText: confirmButtonText\n      &#125;).then(originValue.bind(this, ...args)).catch(error =&gt; &#123;\n        if (error === &#39;close&#39; || error === &#39;cancel&#39;) &#123;\n          Message.info(&#39;用户取消操作&#39;)\n        &#125; else &#123;\n          Message.info(error)\n        &#125;\n      &#125;)\n    &#125;\n    return descriptor\n  &#125;\n&#125;2、页面引入装饰器函数\nhtml&lt;template&gt;\n  &lt;div class=&quot;about&quot;&gt;\n    &lt;h1&gt;This is an about page&lt;/h1&gt;\n    &lt;p&gt;装饰器&lt;/p&gt;\n    &lt;button @click=&#39;test&#39;&gt;confirm&lt;/button&gt;&lt;button&gt;cancel&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;jsimport &#123; confirm &#125; from &#39;./decorator.js&#39;\n\nexport default &#123;\n  name: &#39;about&#39;,\n  methods: &#123;\n    @confirm(&#39;删除&#39;, &#39;确认删除?&#39;)\n    test () &#123;\n      // do something  调用接口\n\n      this.$message.success(&#39;success!!&#39;)\n    &#125;\n\n  &#125;\n&#125;三、前端API请求缓存前端 API 请求缓存是前端性能优化的一个方案。\n1、key值错误提示jsconst generateKeyError = new Error(&#39;Can not generate key from name and argument&#39;)2、生成key值jsfunction generateKey(name,argument)&#123;\n  // 从argument 中获取数据然后变为数组\n  const params = Array.from(argument).join(&#39;,&#39;)\n  try&#123;\n    return `$&#123;name&#125;:$&#123;params&#125;`\n  &#125;catch&#123;\n    return generateKeyError\n  &#125;\n&#125;\n\n\nfunction decorate(handleDescription,entryArgs) &#123;\n  // 判断当前最后数据是否是descriptor ，如果是descriptor,直接使用\n  if(isDescriptor(entryArgs[entryArgs.length - 1]))&#123;\n    return handleDescription(...entryArgs,[])\n  &#125;else&#123;\n    return function()&#123;\n      return handleDescription(...Array.prototype.slice.call(arguments),entryArgs)\n    &#125;\n  &#125;\n&#125;\n\nfunction handleApiCache(target, name, descriptor, ...config) &#123;\n    // 拿到函数体并保存\n    const fn = descriptor.value\n    // 修改函数体\n    descriptor.value = function () &#123; \n        const key =  generateKey(name, arguments)\n        // key无法生成，直接请求 服务端数据\n        if (key === generateKeyError)  &#123;\n            // 利用刚才保存的函数体进行请求\n            return fn.apply(null, arguments)\n        &#125;\n        let promise = ExpriesCache.get(key)\n        if (!promise) &#123;\n            // 设定promise\n            promise = fn.apply(null, arguments).catch(error =&gt; &#123;\n                 // 在请求回来后，如果出现问题，把promise从cache中删除\n                ExpriesCache.delete(key)\n                // 返回错误\n                return Promise.reject(error)\n            &#125;)\n            // 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求\n            ExpriesCache.set(key, promise, config[0])\n        &#125;\n        return promise \n    &#125;\n    return descriptor;\n&#125;\n\n// 制定 修饰器\nfunction ApiCache(...args) &#123;\n    return decorate(handleApiCache, args)\n&#125;3、api接口处使用ApiCache()jsclass Api&#123;\n  // 缓存10s\n  @ApiCache(10)\n  getData(params1,params2)&#123;\n    return request.get(&#39;/getList&#39;)\n  &#125;\n&#125;\n","slug":"53-decorator","date":"2022-01-20T12:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"09056a65d648cf52e8fee5dfc22cdeae","title":"52、WebRTC音视频","content":"WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。\n\n\n一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()\n\n\n\n\n\n\n\n\nMediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个 MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A&#x2F;D 转换器等等），也可能是其它轨道类型。\njsconst constraints = &#123;\n  video: true,\n  audio: true,\n&#125;;\n//   非安全模式（非https/localhost）下 navigator.mediaDevices 会返回 undefined\ntry &#123;\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  document.querySelector(&quot;video&quot;).srcObject = stream;\n&#125; catch (error) &#123;\n  console.error(error);\n&#125;二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()\n\n\n\n\n\n\n\n\nMediaDevices 的方法 enumerateDevices() 请求一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等。 返回的 Promise (en-US) 完成时，会带有一个描述设备的 MediaDeviceInfo (en-US) 的数组。\njstry &#123;\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  this.videoinputs = devices.filter((device) =&gt; device.kind === &quot;videoinput&quot;);\n  this.audiooutputs = devices.filter((device) =&gt; device.kind === &quot;audiooutput&quot;);\n  this.audioinputs = devices.filter((device) =&gt; device.kind === &quot;audioinput&quot;);\n&#125; catch (error) &#123;\n  console.error(error);\n&#125;三、点对点媒体协商方法媒体协商方法：\n1、createOffer：\n\n\n\n\n\n\n\n\n\ncreateOffer 方法会生成描述信息的一个 blob 对象，它会帮助连接到本地机器。当你已经找到一个远端的 PeerConnection 并且打算设置建立本地的 PeerConnection 时，你可以使用该方法。\njsvar pc = new PeerConnection();\npc.addStream(video);\npc.createOffer(function(desc)&#123;\n  pc.setLocalDescription(desc, function() &#123;\n    // send the offer to a server that can negotiate with a remote client\n  &#125;);\n&#125;2、createAnswer：\n\n\n\n\n\n\n\n\n\n对从远方收到的 offer 进行回答。\njsvar pc = new PeerConnection();\npc.setRemoteDescription(new RTCSessionDescription(offer), function () &#123;\n  pc.createAnswer(function (answer) &#123;\n    pc.setLocalDescription(answer, function () &#123;\n      // send the answer to the remote connection\n    &#125;);\n  &#125;);\n&#125;);四、服务端：Koa + socket.io1、server.js\njs// server 端 server.js\nconst Koa = require(&quot;koa&quot;);\nconst socket = require(&quot;socket.io&quot;);\nconst http = require(&quot;http&quot;);\nconst app = new Koa();\nconst httpServer = http.createServer(app.callback()).listen(3000, () =&gt; &#123;&#125;);\nsocket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;\n  // ....\n&#125;);\n\n// client 端 socket.js\nimport io from &quot;socket.io-client&quot;;\nconst socket = io.connect(window.location.origin);\nexport default socket;2、点对点分别连接信令服务器，信令服务器记录房间信息\njssocket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;\n  // 用户离开房间\n  sock.on(&quot;userLeave&quot;, () =&gt; &#123;\n    // ...\n  &#125;);\n  // 检查房间是否可加入\n  sock.on(&quot;checkRoom&quot;, () =&gt; &#123;\n    // ...\n  &#125;);\n  // ....\n&#125;);\n// client 端 Room.vue\nimport socket from &quot;../utils/socket.js&quot;;\n\n// 服务端告知用户是否可加入房间\nsocket.on(&quot;checkRoomSuccess&quot;, () =&gt; &#123;\n  // ...\n&#125;);\n// 服务端告知用户成功加入房间\nsocket.on(&quot;joinRoomSuccess&quot;, () =&gt; &#123;\n  // ...\n&#125;);\n//....3、A 端作为发起方向接收方 B 端发起视频邀请\n在得到 B 同意视频请求后，双方都会创建本地的 RTCPeerConnection，添加本地视频流，其中发送方会创建 offer 设置本地 sdp 信息描述，并通过信令服务器将自己的 SDP 信息发送给对端\njssocket.on(&quot;answerVideo&quot;, async (user) =&gt; &#123;\n  VIDEO_VIEW.showInvideoModal();\n  // 创建本地视频流信息\n  const localStream = await this.createLocalVideoStream();\n  this.localStream = localStream;\n  document.querySelector(&quot;#echat-local&quot;).srcObject = this.localStream;\n  this.peer = new RTCPeerConnection();\n  this.initPeerListen();\n  this.peer.addStream(this.localStream);\n  if (user.sockId === this.sockId) &#123;\n    // 接收方\n  &#125; else &#123;\n    // 发送方 创建 offer\n    const offer = await this.peer.createOffer(this.offerOption);\n    await this.peer.setLocalDescription(offer);\n    socket.emit(&quot;receiveOffer&quot;, &#123; user: this.user, offer &#125;);\n  &#125;\n&#125;);4、收集自己的网络信息并发送给对方\njsinitPeerListen () &#123;\n      // 收集自己的网络信息并发送给对端\n      this.peer.onicecandidate = (event) =&gt; &#123;\n        if (event.candidate) &#123; socket.emit(&#39;addIceCandidate&#39;, &#123; candidate: event.candidate, user: this.user &#125;); &#125;\n      &#125;;\n      // ....\n    &#125;\n5、当接收方 B 端通过信令服务器拿到对端发送方 A 端的含有 SDP 的 offer 信息后则会调用 setRemoteDescription 存储对端的 SDP 信息，创建及设置本地的 SDP 信息,并通过信令服务器传送含有本地 SDP 信息的 answer\njssocket.on(&quot;receiveOffer&quot;, async (offer) =&gt; &#123;\n  await this.peer.setRemoteDescription(offer);\n  const answer = await this.peer.createAnswer();\n  await this.peer.setLocalDescription(answer);\n  socket.emit(&quot;receiveAnsewer&quot;, &#123; answer, user: this.user &#125;);\n&#125;);6、当发起方 A 通过信令服务器接收到接收方 B 的 answer 信息后则也会调用 setRemoteDescription，这样双方就完成了 SDP 信息的交换\njssocket.on(&quot;receiveAnsewer&quot;, (answer) =&gt; &#123;\n  this.peer.setRemoteDescription(answer);\n&#125;);7、当双方 SDP 信息交换完成并且监听 icecandidate 收集到网络候选者通过信令服务器交换后，则会拿到彼此的视频流。\njssocket.on(&quot;addIceCandidate&quot;, async (candidate) =&gt; &#123;\n  await this.peer.addIceCandidate(candidate);\n&#125;);\nthis.peer.onaddstream = (event) =&gt; &#123;\n  // 拿到对方的视频流\n  document.querySelector(&quot;#remote-video&quot;).srcObject = event.stream;\n&#125;;8、GitHub：https://github.com/HeyJudeYQ/webrtc\n","slug":"52-webrtc","date":"2022-01-19T02:05:56.000Z","categories_index":"","tags_index":"webrtc","author_index":"Jude"},{"id":"ed9ec197f6ba25d2d3c51c5088e0e39d","title":"51、Vue项目中前端导出/导入Excel表格的实现","content":"后台管理系统中，通常有这样的需求:将当前 table 表格导出&#x2F;导入 Excel 表格，实现方式通常为后端主导（后端使用插件，前端通过点击事件生成一个 a 标签，导出 Excel 表格）、前端主导（使用 xlsx、file-saver、script-loader 插件封装工具函数，通过点击事件，获取当前页面后台返回的表格数据)。\n\n\n一、前端导出 Excel 表格的实现1、安装 pluginshellnpm install file-saver script-loader xlsx --save2、Export2Excel 工具函数\n点我展示代码\n\njsimport &#123; saveAs &#125; from &quot;file-saver&quot;;\nimport XLSX from &quot;xlsx&quot;;\n\nfunction generateArray(table) &#123;\n  var out = [];\n  var rows = table.querySelectorAll(&quot;tr&quot;);\n  var ranges = [];\n  for (var R = 0; R &lt; rows.length; ++R) &#123;\n    var outRow = [];\n    var row = rows[R];\n    var columns = row.querySelectorAll(&quot;td&quot;);\n    for (var C = 0; C &lt; columns.length; ++C) &#123;\n      var cell = columns[C];\n      var colspan = cell.getAttribute(&quot;colspan&quot;);\n      var rowspan = cell.getAttribute(&quot;rowspan&quot;);\n      var cellValue = cell.innerText;\n      if (cellValue !== &quot;&quot; &amp;&amp; cellValue == +cellValue) cellValue = +cellValue;\n\n      //Skip ranges\n      ranges.forEach(function (range) &#123;\n        if (\n          R &gt;= range.s.r &amp;&amp;\n          R &lt;= range.e.r &amp;&amp;\n          outRow.length &gt;= range.s.c &amp;&amp;\n          outRow.length &lt;= range.e.c\n        ) &#123;\n          for (var i = 0; i &lt;= range.e.c - range.s.c; ++i) outRow.push(null);\n        &#125;\n      &#125;);\n\n      //Handle Row Span\n      if (rowspan || colspan) &#123;\n        rowspan = rowspan || 1;\n        colspan = colspan || 1;\n        ranges.push(&#123;\n          s: &#123;\n            r: R,\n            c: outRow.length,\n          &#125;,\n          e: &#123;\n            r: R + rowspan - 1,\n            c: outRow.length + colspan - 1,\n          &#125;,\n        &#125;);\n      &#125;\n\n      //Handle Value\n      outRow.push(cellValue !== &quot;&quot; ? cellValue : null);\n\n      //Handle Colspan\n      if (colspan) for (var k = 0; k &lt; colspan - 1; ++k) outRow.push(null);\n    &#125;\n    out.push(outRow);\n  &#125;\n  return [out, ranges];\n&#125;\n\nfunction datenum(v, date1904) &#123;\n  if (date1904) v += 1462;\n  var epoch = Date.parse(v);\n  return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);\n&#125;\n\nfunction sheet_from_array_of_arrays(data, opts) &#123;\n  var ws = &#123;&#125;;\n  var range = &#123;\n    s: &#123;\n      c: 10000000,\n      r: 10000000,\n    &#125;,\n    e: &#123;\n      c: 0,\n      r: 0,\n    &#125;,\n  &#125;;\n  for (var R = 0; R != data.length; ++R) &#123;\n    for (var C = 0; C != data[R].length; ++C) &#123;\n      if (range.s.r &gt; R) range.s.r = R;\n      if (range.s.c &gt; C) range.s.c = C;\n      if (range.e.r &lt; R) range.e.r = R;\n      if (range.e.c &lt; C) range.e.c = C;\n      var cell = &#123;\n        v: data[R][C],\n      &#125;;\n      if (cell.v == null) continue;\n      var cell_ref = XLSX.utils.encode_cell(&#123;\n        c: C,\n        r: R,\n      &#125;);\n\n      if (typeof cell.v === &quot;number&quot;) cell.t = &quot;n&quot;;\n      else if (typeof cell.v === &quot;boolean&quot;) cell.t = &quot;b&quot;;\n      else if (cell.v instanceof Date) &#123;\n        cell.t = &quot;n&quot;;\n        cell.z = XLSX.SSF._table[14];\n        cell.v = datenum(cell.v);\n      &#125; else cell.t = &quot;s&quot;;\n\n      ws[cell_ref] = cell;\n    &#125;\n  &#125;\n  if (range.s.c &lt; 10000000) ws[&quot;!ref&quot;] = XLSX.utils.encode_range(range);\n  return ws;\n&#125;\n\nfunction Workbook() &#123;\n  if (!(this instanceof Workbook)) return new Workbook();\n  this.SheetNames = [];\n  this.Sheets = &#123;&#125;;\n&#125;\n\nfunction s2ab(s) &#123;\n  var buf = new ArrayBuffer(s.length);\n  var view = new Uint8Array(buf);\n  for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;\n  return buf;\n&#125;\n\nexport function export_table_to_excel(id) &#123;\n  var theTable = document.getElementById(id);\n  var oo = generateArray(theTable);\n  var ranges = oo[1];\n\n  /* original data */\n  var data = oo[0];\n  var ws_name = &quot;SheetJS&quot;;\n\n  var wb = new Workbook(),\n    ws = sheet_from_array_of_arrays(data);\n\n  /* add ranges to worksheet */\n  // ws[&#39;!cols&#39;] = [&#39;apple&#39;, &#39;banan&#39;];\n  ws[&quot;!merges&quot;] = ranges;\n\n  /* add worksheet to workbook */\n  wb.SheetNames.push(ws_name);\n  wb.Sheets[ws_name] = ws;\n\n  var wbout = XLSX.write(wb, &#123;\n    bookType: &quot;xlsx&quot;,\n    bookSST: false,\n    type: &quot;binary&quot;,\n  &#125;);\n\n  saveAs(\n    new Blob([s2ab(wbout)], &#123;\n      type: &quot;application/octet-stream&quot;,\n    &#125;),\n    &quot;test.xlsx&quot;\n  );\n&#125;\n\nexport function export_json_to_excel(&#123;\n  multiHeader = [],\n  header,\n  data,\n  filename,\n  merges = [],\n  autoWidth = true,\n  bookType = &quot;xlsx&quot;,\n&#125; = &#123;&#125;) &#123;\n  /* original data */\n  filename = filename || &quot;excel-list&quot;;\n  data = [...data];\n  data.unshift(header);\n\n  for (let i = multiHeader.length - 1; i &gt; -1; i--) &#123;\n    data.unshift(multiHeader[i]);\n  &#125;\n\n  var ws_name = &quot;SheetJS&quot;;\n  var wb = new Workbook(),\n    ws = sheet_from_array_of_arrays(data);\n\n  if (merges.length &gt; 0) &#123;\n    if (!ws[&quot;!merges&quot;]) ws[&quot;!merges&quot;] = [];\n    merges.forEach((item) =&gt; &#123;\n      ws[&quot;!merges&quot;].push(XLSX.utils.decode_range(item));\n    &#125;);\n  &#125;\n\n  if (autoWidth) &#123;\n    /*设置worksheet每列的最大宽度*/\n    const colWidth = data.map((row) =&gt;\n      row.map((val) =&gt; &#123;\n        /*先判断是否为null/undefined*/\n        if (val == null) &#123;\n          return &#123;\n            wch: 10,\n          &#125;;\n        &#125; else if (val.toString().charCodeAt(0) &gt; 255) &#123;\n          /*再判断是否为中文*/\n          return &#123;\n            wch: val.toString().length * 2,\n          &#125;;\n        &#125; else &#123;\n          return &#123;\n            wch: val.toString().length,\n          &#125;;\n        &#125;\n      &#125;)\n    );\n    /*以第一行为初始值*/\n    let result = colWidth[0];\n    for (let i = 1; i &lt; colWidth.length; i++) &#123;\n      for (let j = 0; j &lt; colWidth[i].length; j++) &#123;\n        if (result[j][&quot;wch&quot;] &lt; colWidth[i][j][&quot;wch&quot;]) &#123;\n          result[j][&quot;wch&quot;] = colWidth[i][j][&quot;wch&quot;];\n        &#125;\n      &#125;\n    &#125;\n    ws[&quot;!cols&quot;] = result;\n  &#125;\n\n  /* add worksheet to workbook */\n  wb.SheetNames.push(ws_name);\n  wb.Sheets[ws_name] = ws;\n\n  var wbout = XLSX.write(wb, &#123;\n    bookType: bookType,\n    bookSST: false,\n    type: &quot;binary&quot;,\n  &#125;);\n  saveAs(\n    new Blob([s2ab(wbout)], &#123;\n      type: &quot;application/octet-stream&quot;,\n    &#125;),\n    `$&#123;filename&#125;.$&#123;bookType&#125;`\n  );\n&#125;\n\n3、导出函数a-button 为 ant-design-vue 的 button 组件\nhtml&lt;a-button\n  type=&quot;primary&quot;\n  icon=&quot;export&quot;\n  class=&quot;select-bottom&quot;\n  :loading=&quot;exportLoading&quot;\n  @click=&quot;handleExport&quot;\n  &gt;导出\n&lt;/a-button&gt;handleExport 导出函数\n\n\n\n\n\n\n\n\n\n1、点击导出按钮，去加载在 vendor 文件夹中的 Export2Excel 模块2、import 方法执行完毕返回一个 promise 对象，在 then 方法中我们可以拿到使用的模块对象（excel）3、Excel 导出参数部分的 data，是一个严格的二维数组，header 为导出的数据表头，filename 为导出的文件名，bookType 为导出文件类型，autoWidth 为单元格是否要自适应宽度。\njshandleExport() &#123;\n    //由于是前端导出，所以只能导出当前页的数据\n    this.exportLoading = true;\n      import(&#39;@/vendor/Export2Excel&#39;).then(excel =&gt; &#123;\n        const header = [],\n          filterVal = [];\n        this.tableHead.forEach(item =&gt; &#123;\n          if (item.title != &#39;操作&#39; &amp;&amp; item.title != &#39;序号&#39;) &#123;\n            header.push(item.title);\n            filterVal.push(item.dataIndex);\n          &#125;\n        &#125;);\n        const data = formatJson(this.tableData, filterVal);\n\n        excel.export_json_to_excel(&#123;\n          header,\n          data,\n          filename: &#39;表单统计&#39;\n        &#125;);\n        this.exportLoading = false;\n      &#125;);\n    &#125;二、前端导入 Excel 的实现1、ant-design-vue 上传组件的使用html&lt;div class=&quot;file-wrapper relative&quot;&gt;\n  &lt;input\n    ref=&quot;excel-upload&quot;\n    type=&quot;file&quot;\n    accept=&quot;.xlsx, .xls&quot;\n    @change=&quot;handleChange&quot;\n    style=&quot;display:none&quot;\n  /&gt;\n  &lt;a-button\n    type=&quot;primary&quot;\n    icon=&quot;file-excel&quot;\n    size=&quot;large&quot;\n    style=&quot;z-index:99&quot;\n    @click=&quot;handleUpload&quot;\n    :loading=&quot;loading&quot;\n  &gt;\n    上传Excel\n  &lt;/a-button&gt;\n  &lt;p class=&quot;text&quot;&gt;请选择Excel上传 支持(xlsx,xls)格式&lt;/p&gt;\n&lt;/div&gt;\n&lt;!-- table组件 tableData:[]  tableHead:[] --&gt;\n&lt;a-card\n  :hoverable=&quot;true&quot;\n  :bordered=&quot;false&quot;\n  v-if=&quot;tableHead.length &gt; 0&quot;\n  style=&quot;margin-top:30px&quot;\n&gt;\n  &lt;standard-table\n    :pagination=&quot;false&quot;\n    :tableData=&quot;tableData&quot;\n    :tableHead=&quot;tableHead&quot;\n  /&gt;\n&lt;/a-card&gt;\n\ncss.file-wrapper &#123;\n  width: 100%;\n  height: 350px;\n  line-height: 350px;\n  text-align: center;\n  background: #e6ecf4;\n  .text &#123;\n    position: absolute;\n    top: 50px;\n    left: 50%;\n    transform: translateX(-50%);\n  &#125;\n&#125;2、导入函数js// 引入xlsx table组件\nimport XLSX from &quot;xlsx&quot;;\nimport standardTable from &quot;@/components/standardTable/index&quot;;\n点我展示代码\n\njs    handleChange(e) &#123;\n      const file = e.target.files[0];\n      if (!file) return;\n      //判断格式\n      if (!this.isExcel(file)) &#123;\n        this.$message.warning(&#39;只能选择xlxs,xls文件&#39;);\n        return;\n      &#125;\n      //判断大小\n      if (file.size / 1024 / 1024 &gt; 1) &#123;\n        this.$message.warning(&#39;上传文件大小不能超过1M&#39;);\n        return;\n      &#125;\n      this.loading = true;\n\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(file);\n      reader.onload = e =&gt; &#123;\n        const data = e.target.result;\n        const workbook = XLSX.read(data, &#123; type: &#39;array&#39; &#125;);\n        const firstSheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[firstSheetName];\n\n        setTimeout(() =&gt; &#123;\n          this.loading = false;\n          const head = this.getHeaderRow(worksheet);\n          this.tableHead = head.map(item =&gt; &#123;\n            return &#123;\n              title: item,\n              dataIndex: item\n            &#125;;\n          &#125;);\n          const tableData = XLSX.utils.sheet_to_json(worksheet);\n          tableData.forEach(item =&gt; &#123;\n            item.id = parseInt(Math.random(0, 1) * 10000);\n          &#125;);\n          this.tableData = tableData;\n        &#125;, 500);\n      &#125;;\n    &#125;,\n\n    generateData(&#123; header, results &#125;) &#123;\n      this.excelData.header = header;\n      this.excelData.results = results;\n      this.onSuccess &amp;&amp; this.onSuccess(this.excelData);\n    &#125;,\n\n    //获取表头\n    getHeaderRow(sheet) &#123;\n      const headers = [];\n      const range = XLSX.utils.decode_range(sheet[&#39;!ref&#39;]);\n      let C;\n      const R = range.s.r;\n\n      for (C = range.s.c; C &lt;= range.e.c; ++C) &#123;\n        const cell = sheet[XLSX.utils.encode_cell(&#123; c: C, r: R &#125;)];\n        let hdr = &#39;UNKNOWN &#39; + C;\n        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell);\n        headers.push(hdr);\n      &#125;\n      return headers;\n    &#125;,\n\n    handleUpload() &#123;\n      this.$refs[&#39;excel-upload&#39;].click();\n    &#125;,\n    // 文件类型\n    isExcel(file) &#123;\n      return /\\.(xlsx|xls|csv)$/.test(file.name);\n    &#125;\n\n\n三、table 子组件\n点我展示代码\n\nhtml&lt;div class=&quot;tableCommon-wrapper&quot;&gt;\n  &lt;a-table\n    :columns=&quot;tableHead&quot;\n    :dataSource=&quot;tableData&quot;\n    :loading=&quot;loading&quot;\n    :pagination=&quot;pagination&quot;\n    :row-selection=&quot;rowSelection&quot;\n    @change=&quot;handleTableChange&quot;\n    rowKey=&quot;id&quot;\n    :scroll=&quot;scroll&quot;\n  &gt;\n    &lt;template\n      slot-scope=&quot;text, record, index&quot;\n      :slot=&quot;slot&quot;\n      v-for=&quot;slot in Object.keys($scopedSlots).filter(key =&gt; key !== &#39;expandedRowRender&#39;)&quot;\n    &gt;\n      &lt;slot :name=&quot;slot&quot; v-bind=&quot;&#123; text, record, index &#125;&quot;&gt;&lt;/slot&gt;\n    &lt;/template&gt;\n  &lt;/a-table&gt;\n&lt;/div&gt;jsexport default &#123;\n  name: &quot;standardTable&quot;,\n  props: &#123;\n    tableHead: &#123;\n      type: Array,\n      required: true,\n    &#125;,\n    tableData: &#123;\n      type: Array,\n      required: true,\n    &#125;,\n    loading: &#123;\n      type: Boolean,\n      default: false,\n    &#125;,\n    pagination: &#123;\n      type: Boolean | Object,\n    &#125;,\n    rowSelection: &#123;\n      type: Object,\n    &#125;,\n    scroll: &#123;\n      type: Object,\n    &#125;,\n  &#125;,\n  methods: &#123;\n    handleTableChange(val) &#123;\n      this.$emit(&quot;changeCurrent&quot;, val.current);\n    &#125;,\n  &#125;,\n&#125;;\n","slug":"51-export-excel","date":"2022-01-14T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"0a7516dfe2e2c862662fdf8ac9a3a0e1","title":"50、CountTo:数字动态滚动","content":"vue使用vue-count-to实现数字的动态滚动功能，适用于数据可视化大屏项目中使用数字滚动。\n\n\n\njs// 1、安装vue-count-to\nnpm isntall vue-count-to\n// 2、组件内引入、注册 startVal endVal 类型为Number\n代码如下：\nhtml&lt;template&gt;\n  &lt;countTo :startVal=&#39;startVal&#39; :endVal=&#39;number&#39; :duration=&#39;3000&#39; :decimals=&#39;0&#39;  :autoplay=true&gt;&lt;/countTo&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport countTo from &#39;vue-count-to&#39;;\n  export default&#123;\n    components:&#123;countTo&#125;,\n    props:&#123;\n      number: [Number, String],\n      startVal:&#123;\n        type:Number,\n        default:0\n      &#125;\n    &#125;\n  &#125;\n&lt;/script&gt;","slug":"50-count-to","date":"2022-01-13T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"25d32930e0f2e91a36c0f3813d809188","title":"49、websocket实现客户端和服务端的通信","content":"WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。\n\n\n一、websocket特点：\n\n\n\n\n\n\n\n\n1、建立在 TCP 协议之上，服务器端的实现比较容易。2、与 HTTP 协议有着良好的兼容性，默认端口也是80和443。并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。3、数据格式比较轻量，性能开销小，通信高效。4、可以发送文本，也可以发送二进制数据。5、没有同源限制，客户端可以与任意服务器通信。6、全双工(通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合,例如指 A→B 的同时 B→A ，是瞬时同步的)7、协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n初始化websocket1、创建websocket实例，参数为url2、连接 websocket.onopen3、server响应数据触发 websocket.onmessage4、关闭websocket，websocket.onclose\njs// 构造函数 参数为url\nconst wsurl = &quot;ws://localhost:8080&quot;;\nvar ws = new Websocket(wsurl);\n\n// 连接状态readState 1  准备好发送和接受数据了\nws.onopen = function()&#123;\n  ws.send(&#39;hello server! websocket is open now!&#39;)\n&#125;\n\n// 通过客户端的事件   发送信息给服务端\nws.send(&#39;hello websocket&#39;);\n\n// 发生错误\nws.onerror = function(event)&#123;\n  console.log(&quot;websocket error observed&quot;,event)\n&#125;\n\n// readState CLOSED  关闭websocket\nws.onclose = function(event)&#123;\n  let status_code = event.status;\n  let msg = event.msg;\n  console.log(&quot;websocket is closed now&quot;)\n&#125;\n\n// 响应数据的接收\nws.onmessage = function(event)&#123;\n  let data = event.data;\n&#125;\n\n路由改变，需要断开websocket连接，节省服务器开支。\n\n二、心跳机制\n\n\n\n\n\n\n\n\nwebsocket在连接关闭的情况下触发onclose事件，连接异常触发onerror事件。网络状态不好的情况，onclose事件的触发灵敏度不高，可能会造成断网很久触发onclose事件，客户端又出现重新连接，客户端实时界面不友好。\n为了解决上面的情况，使用心跳重连机制，客户端在websocket连接成功后，执行心跳函数，首先向服务器发送’ping‘信息，服务器收到信息会返回’pong’信息。一定时间内，客户端收到服务器返回的信息，则表示连接正常，重置心跳函数；客户端在一定时间内没有收到心跳函数，表明没有连接成功，客户端关闭websocket,再执行重连操作。\n解决方式：\n\n点我展示代码\n\njsimport &#123; mapActions, mapState &#125; from &#39;vuex&#39;;\nexport default &#123;\n    name: &#39;Websocket&#39;,\n    data() &#123;\n        return &#123;\n            // 是否正在重连\n            lockReconnect: false,\n            socket: null,\n            reconnectTimeout: null,\n            timeout: 10 * 1000,\n            timer: null,\n            serverTimer: null\n        &#125;;\n    &#125;,\n    computed: &#123;\n        ...mapState([&#39;userInfo&#39;]),\n        wsuri() &#123;\n            return `$&#123;process.env.VUE_APP_WEBSOCKET_URI&#125;$&#123;this.userInfo.tenantId&#125;;$&#123;this.userInfo.userId&#125;`;\n        &#125;\n    &#125;,\n    async mounted() &#123;\n        await this.getUserInfo();\n        this.initWebSocket();\n    &#125;,\n    destroyed() &#123;\n        this.socket.close();\n    &#125;,\n    methods: &#123;\n        ...mapActions([&#39;getUserInfo&#39;]),\n        start(ws) &#123;\n            this.reset();\n            this.timer = setTimeout(() =&gt; &#123;\n                // console.log(&#39;发送心跳,后端收到后，返回一个心跳消息&#39;)\n                // onmessage拿到返回的心跳就说明连接正常\n                ws.send(&#39;ping&#39;);\n                this.serverTimer = setTimeout(() =&gt; &#123;\n                    // 如果超过一定时间还没响应(响应后触发重置)，说明后端断开了\n                    ws.close();\n                &#125;, this.timeout);\n            &#125;, this.timeout);\n        &#125;,\n        reset() &#123;\n            this.serverTimer &amp;&amp; clearTimeout(this.serverTimer);\n            this.timer &amp;&amp; clearTimeout(this.timer);\n        &#125;,\n        reconnect() &#123;\n            console.log(&#39;尝试重连&#39;);\n            if (this.lockReconnect) &#123;\n                return;\n            &#125;\n            this.lockReconnect = true;\n            this.reconnectTimeout &amp;&amp; clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = setTimeout(() =&gt; &#123;\n                this.initWebSocket();\n                this.lockReconnect = false;\n            &#125;, 4 * 1000);\n        &#125;,\n        // 初始化websocket\n        initWebSocket() &#123;\n            try &#123;\n                if (&#39;WebSocket&#39; in window) &#123;\n                    this.socket = new WebSocket(this.wsuri);\n                &#125; else &#123;\n                    console.log(&#39;您的浏览器不支持websocket&#39;);\n                &#125;\n                this.socket.onopen = this.websocketOnOpen;\n                this.socket.onerror = this.websocketOnError;\n                this.socket.onmessage = this.websocketOnMessage;\n                this.socket.onclose = this.websocketClose;\n            &#125; catch (e) &#123;\n                this.reconnect();\n            &#125;\n        &#125;,\n        websocketOnOpen() &#123;\n            console.log(&#39;WebSocket连接成功&#39;, this.socket.readyState);\n            this.start(this.socket);\n            this.websocketSend();\n        &#125;,\n        websocketOnError(e) &#123;\n            console.log(&#39;WebSocket连接发生错误&#39;, e);\n            this.reconnect();\n        &#125;,\n        websocketOnMessage(e) &#123;\n            if (e.data === &#39;pong&#39;) &#123;\n                // 消息获取成功，重置心跳\n                this.start(this.socket);\n            &#125;\n        &#125;,\n        websocketClose(e) &#123;\n            console.log(&#39;connection closed (&#39; + e.code + &#39;)&#39;);\n            this.reconnect();\n        &#125;,\n        websocketSend() &#123;\n            this.socket.send(&#39;ping&#39;);\n        &#125;\n    &#125;\n&#125;;\n\n\n\n","slug":"49-websocket","date":"2022-01-03T12:00:00.000Z","categories_index":"","tags_index":"websocket","author_index":"Jude"},{"id":"0d6957d2727610cbc2b8e511c4386db6","title":"48、用hook处理组件内定时器","content":"vue 项目使用 hook 处理组件内定时器的方式。一般是使用生命周期钩子函数beforeDestory来销毁定时器。从Vue源码的lifecycle.js中发现了一种拓展方法，可以提升代码的简洁性，而且还可以减少data里无用变量的定义。\n\n\n一、使用生命周期函数处理定时器通常处理组件内定时器的步骤是下面这样的\njsexport default&#123;\n    mounted()&#123;\n        this.timer = setInterval（() =&gt;&#123;\n            // do something\n        &#125;,1000）\n    &#125;,\n    beforeDestory()&#123;\n        clearInterval(this.timer);\n    &#125;\n&#125;二、使用 hook 处理定时器jsexport default&#123;\n    mounted()&#123;\n        const timer = setInterval(() =&gt; &#123;\n            // do something\n        &#125;,1000);\n        this.$once(&#39;hook:beforeDestory&#39;,()=&gt; clearInterval(timer);)\n    &#125;\n&#125;三、适用场景:处理可视化图表的时候，我们需要在数据渲染到页面之前让页面有 loading 动画，mounted 挂载之后停止 loading，beforeUpdate 时开始 loading，updated 之后停止 loading。\n使用 hook 处理:\ntxt&lt;v-chart&gt;\n  @hook:mounted=&quot;loading = false&quot; @hook:beforeUpdated=&quot;loading = true&quot;\n  @hook:updated=&quot;loading = false&quot; :data=&quot;data&quot;\n&lt;/v-chart&gt;四、补充说明：如何实现父组件监听子组件生命周期？1、方法一：$emit父组件给子组件传递多个回调函数，依赖子组件在自身的生命周期李通过vm.$emit的方式，调用父组件生命的回调函数。\nhtml&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;Child @mounted=&quot;onMounted&quot;\n            @updated=&quot;onUpdated&quot;\n            @beforeDestory=&quot;beforeDestory&quot;\n        &gt;\n        &lt;/Child&gt;\n    &lt;/div&gt;\n&lt;/template&gt;子组件：\njsmounted()&#123;\n    this.$emit(&#39;mounted&#39;)\n&#125;,\nupdated()&#123;\n    this.$emit(&#39;updated&#39;)\n&#125;,\nbeforeDestory()&#123;\n    this.$emit(&#39;beforeDestory&#39;)\n&#125;2、方法二：@hook父组件模板\nhtml&lt;template&gt;\n    &lt;div&gt;\n        &lt;Child @hook:mounted=&quot;onMounted&quot;\n            @hook:updated=&quot;onUpdated&quot;\n            @hook:beforeDestory=&quot;beforeDestory&quot;\n        &gt;\n        &lt;/Child&gt;\n    &lt;/div&gt;\n&lt;/template&gt;vue源码的lifecycle.js中，Vue的生命周期各个阶段都会去调用一个callHook函数，这个函数支持2个参数：实例vm和生命周期钩子名称,callHook里面执行了vm.$emit(‘hook:’+hook)。\nlifecycle.js源码片段（这个文件在Vue源码的src&#x2F;core&#x2F;instance&#x2F;lifecycle.js）\njs// callHook函数\nexport function callHook (vm: Component, hook: string) &#123;\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget()\n  const handlers = vm.$options[hook]\n  const info = `$&#123;hook&#125; hook`\n  if (handlers) &#123;\n    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    &#125;\n  &#125;\n  if (vm._hasHookEvent) &#123;\n    vm.$emit(&#39;hook:&#39; + hook)\n  &#125;\n  popTarget()\n&#125;\n@hook原理：\n\n\n\n\n\n\n\n\n\n当我们在子组件上传了对应的@hook:mounted钩子，也就执行了vm.$on(‘hook:mounted’),vue实例在生命周期里本身就会执行vm.$emit(‘hook:mounted’),也触发了我们绑定给子组件的回调函数。\n","slug":"48-hook","date":"2022-01-01T12:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"9abbc13986764d2e4a75f0464cdeed8d","title":"47、git提交规范","content":"使用commitizen和cz-customizable规范代码提交\n\n\n\n1.安装commitizen和cz-customizablejsnpm install -g commitizen@4.2.4\nnpm i cz-customizable@6.3.0 --save-dev\n2.在package.json中进行新增js&quot;config&quot;: &#123;\n  &quot;commitizen&quot;: &#123;\n    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;\n  &#125;\n&#125;3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit4.使用husky进行强制git代码提交规范jsnpm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4\nnpm install husky@7.0.1 --save-dev\nnpx husky install5.在package.json中新增指令js&quot;prepare&quot;: &quot;husky install&quot;6.并执行jsnpm run prepare7.新增husky配置文件 并往里面写入jsnpx husky add .husky/commit-msg\nnpx --no-install commitlint --edit8、husky规范js// commitlint.config.js\nmodule.exports = &#123;\n  // 继承的规则\n  extends: [&#39;@commitlint/config-conventional&#39;],\n  // 定义规则类型\n  rules: &#123;\n    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内\n    &#39;type-enum&#39;: [\n      2,\n      &#39;always&#39;,\n      [\n        &#39;feat&#39;, // 新功能 feature\n        &#39;fix&#39;, // 修复 bug\n        &#39;docs&#39;, // 文档注释\n        &#39;style&#39;, // 代码格式(不影响代码运行的变动)\n        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)\n        &#39;perf&#39;, // 性能优化\n        &#39;test&#39;, // 增加测试\n        &#39;chore&#39;, // 构建过程或辅助工具的变动\n        &#39;revert&#39;, // 回退\n        &#39;build&#39; // 打包\n      ]\n    ],\n    // subject 大小写不做校验\n    &#39;subject-case&#39;: [0]\n  &#125;\n&#125;\n\n","slug":"47-git","date":"2021-12-22T02:05:56.000Z","categories_index":"","tags_index":"","author_index":"Jude"},{"id":"5f01e00714441c850ac8767634e11763","title":"46、解决GitHub Pages绑定阿里域名CNAME消失","content":"hexo主题使用的是Claudia,部署到GitHub Pages时，CNAME会消失。\n\n\n\n解决方式：\ntxt// 1 cd source\ntouch CNAME\n\n// 2 输入阿里域名\nissummer.cn\n\n// 3 部署\nhexo g &amp;&amp; hexo d","slug":"46-url","date":"2021-10-28T12:00:00.000Z","categories_index":"","tags_index":"hexo","author_index":"Jude"},{"id":"1227bc8f2ff275f2d4ed294192904f19","title":"45、自定义input唤起键盘","content":"自定义 input 唤起键盘。移动端页面自定义 input 唤起键盘 return，有时需要将换行键改为搜索，为了达到更好的用户体验。在 html5 中，我们可以将 input 的 type 修改为 search，这样修改之后，我们的安卓手机会变成搜索或者搜索符号、IOS 则会变成换行。\n\n\n\n1、安卓手机\nhtml&lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot; /&gt;2、苹果 IOS 手机\n与安卓手机不同的是，我们需要在外层包裹一个 form\nhtml    &lt;from action=&quot;javascript:return true&quot;&gt;\n        &lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot;&gt;\n    &lt;/form&gt;3、修改 search 的默认样式\ncssinput[type=&quot;search&quot;] &#123;\n  -webkit-appearance: none;\n&#125;\ninput::-webkit-search-cancel-button &#123;\n  display: none; // 关闭按钮\n&#125;4、禁止输入法弹出的方法\n\n\n\n\n\n\n\n\n\nreadonly 属性的使用\n点击输入框触发 focus 事件弹出时间 picker，将选择的开始时间、结束时间都显示在输入框里，这里加入只读 readonly 属性可以避免输入法的弹出。\nhtml&lt;input v-model=&quot;startDate&quot; readonly @focus=&quot;openStartPicker&quot; /&gt;\n&lt;input v-model=&quot;endDate&quot; readonly @focus=&quot;openEndPicker&quot; /&gt;","slug":"45-input","date":"2021-10-20T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"1730592520848868aeacb0854267d61e","title":"44、vue3 v-model","content":"v-model 在 Vue2 版本的本质上不过是语法糖，v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：text 和 textarea 元素使用 value property 和 input 事件；checkbox 和 radio 使用 checked property 和 change 事件；select 字段将 value 作为 prop 并将 change 作为事件。Vue3 版本的 v-model 做了修改。\n\n\n1、实现方法一\n\n\n\n\n\n\n\n\n1、将内部原生 input 元素的 value attribute（属性） 绑定到 modelValue prop\n2、输入新的值时在 input 元素上触发 update:modelValue 事件\njs&lt;script setup&gt;\ndefineProps([&#39;modelValue&#39;])\ndefineEmits([&#39;update:modelValue&#39;])\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input\n    :value=&quot;modelValue&quot;\n    @input=&quot;$emit(&#39;update:modelValue&#39;, $event.target.value)&quot;\n  /&gt;\n&lt;/template&gt;\n2、实现方法二：利用计算属性:watch 具有 get 和 set 方法，get 方法需要返回 modelValue prop ,而 set 方法触发相应的事件。\njs&lt;script setup&gt;\nimport &#123; computed &#125; from &#39;vue&#39;\n\nconst props = defineProps([&#39;modelValue&#39;])\nconst emit = defineEmits([&#39;update:modelValue&#39;])\n\nconst value = computed(&#123;\n  get() &#123;\n    return props.modelValue\n  &#125;,\n  set(value) &#123;\n    emit(&#39;update:modelValue&#39;, value)\n  &#125;\n&#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input v-model=&quot;value&quot; /&gt;\n&lt;/template&gt;3、多个 v-model 绑定js&lt;script setup&gt;\ndefineProps(&#123;\n  firstName: String,\n  lastName: String\n&#125;)\n\ndefineEmits([&#39;update:firstName&#39;, &#39;update:lastName&#39;])\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;input\n    type=&quot;text&quot;\n    :value=&quot;firstName&quot;\n    @input=&quot;$emit(&#39;update:firstName&#39;, $event.target.value)&quot;\n  /&gt;\n  &lt;input\n    type=&quot;text&quot;\n    :value=&quot;lastName&quot;\n    @input=&quot;$emit(&#39;update:lastName&#39;, $event.target.value)&quot;\n  /&gt;\n&lt;/template&gt;\nhtml&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot; /&gt;","slug":"44-vue3-4-v-model","date":"2021-10-14T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"de1a8291aedc91f3cdf35d957c1c477d","title":"43、vue3-emits","content":"自定义事件不使用 emit:[‘event name’],会出现连续执行 2 次的一个 bug。\n\n\n一、问题复现Emits.vue\nhtml&lt;template&gt;\n  &lt;div @click=&quot;$emit(&#39;click&#39;)&quot;&gt;\n    &lt;p&gt;自定义事件&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;使用 Emits.vue\nhtml&lt;Emits @click=&quot;handleClick&quot;&gt;&lt;/Emits&gt;jsimport Emits from &quot;./Emits.vue&quot;;\nexport default &#123;\n  components: &#123;\n    Emits,\n  &#125;,\n  methods: &#123;\n    handleClick()&#123;\n      console.log(&quot;click me&quot;);\n    &#125;\n  &#125;,\n&#125;;点击自定义事件，会打印2次click me\n二、解决方法：方法1、在Emits.vue中加入以下代码jsemits:[&#39;click&#39;]方法2、不要使用原生事件名称Emits.vue\nhtml&lt;template&gt;\n  &lt;div @click=&quot;$emit(&#39;my-click&#39;)&quot;&gt;\n    &lt;p &gt;自定义事件&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\njs&lt;script&gt;\n  export default &#123;\n    emits:[&#39;my-click&#39;]\n  &#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;引用处：\nhtml  &lt;Emits @my-click=&quot;handleClick&quot;&gt;&lt;/Emits&gt;","slug":"43-vue3-3-emits","date":"2021-10-11T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"74053ec4e428abc9c631c016a2c5a6f1","title":"42、vue3-传送门：teleport","content":"teleport: 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。\n\n\n一、teleport应用场景一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方，最常见的例子就是全屏的模态框。\n二、模态框弹窗组件新建ModalButton.vue组件\nhtml&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;modalOpen = true&quot;&gt;弹出窗口&lt;/button&gt;\n    &lt;teleport to=&#39;body&#39;&gt;\n      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;\n        &lt;div&gt;我是弹窗\n          父元素为body\n          &lt;button @click=&quot;modalOpen=false&quot;&gt;关闭窗口&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/teleport&gt;\n  &lt;/div&gt;\n&lt;/template&gt;jsexport default &#123;\n  // vue3兼容data写法\n  data() &#123;\n    return &#123;\n      modalOpen:true\n    &#125;\n  &#125;,\n&#125;css\n.modal&#123;\n  position: absolute;\n  top: 0;\n  left:0;\n  right:0;\n  bottom: 0;\n  background-color: rgba(0,0,0,0.5);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n&#125;\n.modal div&#123;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: #fff;\n  width: 300px;\n  height: 300px;\n  padding: 5px;\n&#125;三、ModalButton组件的应用html  &lt;ModalButton&gt;&lt;/ModalButton&gt;js// 加上文件类型后缀，不然会出现404 NOT FOUND\nimport ModalButton from &quot;./ModalButton.vue&quot;;\ncomponents:&#123;\n    ModalButton\n&#125;,  当弹窗显示的时候，审查元素.modal与#app位于body下的同一层级\n","slug":"42-vue3-2-teleport","date":"2021-10-02T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"eec7e41cb68a9bfe7d9a6a63e5e0d538","title":"41、vue3-起始和新特性","content":"使用 vite 创建项目，以及 vue3 的 composition API 的使用\n\n\n一、创建项目（vue-cli + vite）使用 vite 可以更加快速的启动项目\njsnpm init vite-app &lt;project-name&gt;\n\ncd project-name\n\nnpm install &amp;&amp; npm run dev二、main.jsjsimport &#123; createApp &#125; from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\nimport &quot;./index.css&quot;;\n\ncreateApp(App).mount(&quot;#app&quot;);三、组合式 API：composition API\n\n\n\n\n\n\n\n\ncomposition api 为 Vue 应用提供更好的逻辑复用和代码组织。\nsetup()钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n1、需要在非单文件组件中使用组合式 API 时。\n2、需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。\n（一）、基本使用js&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nexport default &#123;\n  setup() &#123;\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return &#123;\n      count\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    console.log(this.count) // 0\n  &#125;\n&#125;\n&lt;/script&gt;html&lt;template&gt;\n  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n&lt;/template&gt;\n\n\n\n\n\n\n\n\n\nTip： setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n（二）、创建响应式对象方法1、\nhtml&lt;p&gt;&#123;&#123; data.counter &#125;&#125;&lt;/p&gt;\n&lt;p&gt;&#123;&#123; data.doubleCounter &#125;&#125;&lt;/p&gt;jsimport &#123; computed,reactive,onMounted,onUnmounted,ref,toRefs,watch&#125; from &quot;vue&quot;;\n\nexport default &#123;\n  setup() &#123;\n    const data = reactive(&#123;\n      counter: 1,\n      doubleCounter: computed(() =&gt; data.counter * 2),\n    &#125;);\n\n    const msg1 = ref(&quot;some message&quot;);\n    // setup 最早有onMounted 无created beforeCreate\n\n    &#125;,\n    let timer;\n    onMounted(() =&gt; &#123;\n      timer = setInterval(() =&gt; &#123;\n        data.counter++;\n      &#125;, 1000);\n    &#125;);\n    onUnmounted(() =&gt; &#123;\n      clearInterval(timer);\n    &#125;);\n    return &#123; data, msg1 &#125;;\n  &#125;,\n&#125;;方法 2：toRefs:解构&#x2F;展开返回响应式对象\nhtml  &lt;p&gt;&#123;&#123; msg1 &#125;&#125;&lt;/p&gt;\n  &lt;p&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt;\n  &lt;p&gt;&#123;&#123; doubleCounter &#125;&#125;&lt;/p&gt;\n  &lt;p ref=&quot;desc&quot;&gt;&lt;/p&gt;jsimport &#123; computed,reactive,onMounted,onUnmounted,ref,toRefs,watch&#125; from &quot;vue&quot;;\nexport default &#123;\n  setup() &#123;\n    // useCounter函数使用了toRefs  所以我们可以展开使用counter doubleCounter\n    const &#123; counter, doubleCounter &#125; = useCounter();\n\n    // 单值响应式\n    const msg1 = ref(&quot;some message&quot;);\n\n    // 使用元素\n    const desc = ref(null);\n\n    // watch 侦听器\n    watch(counter, (val, oldVal) =&gt; &#123;\n      // 这里需要加上desc.value\n      const p = desc.value;\n      p.textContent = `counter change from $&#123;oldVal&#125; to $&#123;val&#125;`;\n    &#125;);\n    return &#123; counter, doubleCounter, msg1, desc &#125;;\n  &#125;,\n&#125;;\n\nfunction useCounter() &#123;\n  const data = reactive(&#123;\n    counter: 1,\n    doubleCounter: computed(() =&gt; data.counter * 2),\n  &#125;);\n\n  // setup 最早有onMounted 无created\n  let timer;\n  onMounted(() =&gt; &#123;\n    timer = setInterval(() =&gt; &#123;\n      data.counter++;\n    &#125;, 1000);\n  &#125;);\n  onUnmounted(() =&gt; &#123;\n    clearInterval(timer);\n  &#125;);\n  return toRefs(data);\n&#125;(三)、单值响应式声明：refjsconst msg1 = ref(&quot;some msg&quot;);","slug":"41-vue3-1-start","date":"2021-09-25T02:00:00.000Z","categories_index":"","tags_index":"vue3","author_index":"Jude"},{"id":"57be698d01233b1f38467e1fa2fb6466","title":"40、初识egg.js","content":"egg.js的使用,包括项目的创建、内置ctx对象、路由、controller控制层、post请求。\n\n\n1、创建&#x2F;启动项目直接使用下面的方式，无法创建项目\njs// 无法创建项目\nnpm init egg --type=simple\n\n// 需要在后面指定淘宝源\nnpm init egg --type=simple -r=https://registry.npm.taobao.org\n\nnpm run dev2、内置的ctx对象\n\n\n\n\n\n\n\n\nctx这个对象非常重要，请求来的参数，返回去的消息都需要通过ctx这个对象获取或者设置\n\n\n\n\n\n\n\n\n\nctx是继承koa的context对象通过设置ctx.body， 可以改变返回信息\njsctx &#123; request: \n   &#123; method: &#39;GET&#39;,\n     url: &#39;/&#39;,\n     header: \n      &#123; host: &#39;127.0.0.1:7001&#39;,\n        connection: &#39;keep-alive&#39;,\n        pragma: &#39;no-cache&#39;,\n        &#39;cache-control&#39;: &#39;no-cache&#39;,\n        &#39;sec-ch-ua&#39;: &#39;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#39;,\n        &#39;sec-ch-ua-mobile&#39;: &#39;?0&#39;,\n        &#39;sec-ch-ua-platform&#39;: &#39;&quot;macOS&quot;&#39;,\n        &#39;upgrade-insecure-requests&#39;: &#39;1&#39;,\n        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&#39;,\n        accept: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,\n        &#39;sec-fetch-site&#39;: &#39;none&#39;,\n        &#39;sec-fetch-mode&#39;: &#39;navigate&#39;,\n        &#39;sec-fetch-user&#39;: &#39;?1&#39;,\n        &#39;sec-fetch-dest&#39;: &#39;document&#39;,\n        &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,\n        &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,\n        cookie: &#39;csrfToken=DpyybUjAh9JRzrCgx3itQifi&#39; &#125; &#125;,\n  response: &#123; status: 404, message: &#39;Not Found&#39;, header: &#123;&#125; &#125;,\n  app: \n   &#123; env: &#39;local&#39;,\n     name: &#39;eggjs&#39;,\n     baseDir: &#39;/Users/yq/Desktop/express&#39;,\n     subdomainOffset: 2,\n     config: &#39;&lt;egg config&gt;&#39;,\n     controller: &#39;&lt;egg controller&gt;&#39;,\n     httpclient: &#39;&lt;egg httpclient&gt;&#39;,\n     loggers: &#39;&lt;egg loggers&gt;&#39;,\n     middlewares: &#39;&lt;egg middlewares&gt;&#39;,\n     router: &#39;&lt;egg router&gt;&#39;,\n     serviceClasses: &#39;&lt;egg serviceClasses&gt;&#39; &#125;,\n  originalUrl: &#39;/&#39;,\n  req: &#39;&lt;original node req&gt;&#39;,\n  res: &#39;&lt;original node res&gt;&#39;,\n  socket: &#39;&lt;original node socket&gt;&#39; &#125;\n3、路由在controller的home.js中写一个新的路由,\njs    async list()&#123;\n        const &#123; ctx &#125; = this\n        ctx.body = &#123;\n            code:200,\n            data:[\n                &#123;\n                    id:&#39;1&#39;,\n                    name:&#39;jude&#39;\n                &#125;,\n                &#123;\n                    id:&#39;2&#39;,\n                    name:&#39;summer&#39;\n                &#125;\n            ],\n            msg:&#39;success&#39;\n        &#125;\n    &#125;在router.js中匹配新写的路由\njs    router.get(&#39;/list&#39;,controller.home.list)打开127.0.0.1:7001&#x2F;list即可看到效果\n4、Controller控制层在controller新建一个user.js\njs&#39;use strict&#39;\n\nconst Controller = require(&#39;egg&#39;).Controller\n\nclass UserController extends Controller &#123;\n    async info()&#123;\n        const &#123;ctx&#125; = this\n        ctx.body = &#123;\n            code:200,\n            data:&#123;\n                id:&#39;1&#39;,\n                name:&quot;jude&quot;\n                age:29,\n                gender:&quot;man&quot;\n            &#125;\n            msg::&quot;success&quot;\n        &#125;\n    &#125;\n&#125;\n\nmodule.exports = UserController配置新的路由\njsrouter.get(&#39;/user/info&#39;,controller.user.info)打开127.0.0.1:7001&#x2F;user&#x2F;info 即可看到效果\n5、post请求及配置CSRF跨域安装跨域插件\njsnpm install egg-cors --save配置config下的plugin.js和config.default.js\ntxt// plugin.js\nmoduel.exports = &#123;\n    cors:&#123;\n        enable:true,\n        package:&#39;egg-cors&#39;\n    &#125;\n&#125;\n\n// config.default.js\nconfig.security = &#123;\n    csrf:&#123;\n        enable:true\n    &#125;,\n    domainWhiteList:[]\n&#125;\nconfig.cors = &#123;\n    origin:&quot;*&quot;,\n    allowMethods:&#39;GET,PUT,POST,DELETE.PATCH&#39;\n&#125;6、创建post请求js// user.js\nasync createUser()&#123;\n    const &#123;ctx &#125; = this\n    const result = &#123;\n        username:ctx.request.body.username,\n        age:ctx.request.body.age\n    &#125;\n    ctx.body = &#123;\n        code:200,\n        data:result,\n        msg:&#39;success&#39;\n    &#125;\n&#125;\n此时，打开ApiPost工具，选择post请求，输入请求地址+参数信息，即可看到响应信息。\n","slug":"40-egg","date":"2021-06-20T12:00:00.000Z","categories_index":"","tags_index":"egg","author_index":"Jude"},{"id":"d021f38954ea30651c1dafa01b873dde","title":"39、堆和栈、变量复制、深拷贝与浅拷贝","content":"栈（stack）：主要存放的是基本类型的变量和对象的应用，其优势是存储速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。   \n堆（heap）：用于引用类型（复杂数据类型：如数组对象、object对象）分配空间，运行时动态分配内存，存储速度较慢。\n\n\nJavaScript中，内存分为三种类型：代码空间、栈空间、堆空间，其中代码空间用于存放可执行代码。\n一、堆栈内存空间1、栈内存空间\n\n\n\n\n\n\n\n\n用栈作为数据结构在内存中所申请的空间。\n2、栈的特点：1、后进先出，最后添加进栈的元素最先出\n2、访问栈底元素，必须拿掉它上面的元素\n\njs7种基本数据类型变量保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。\n3、闭包\n\n\n\n\n\n\n\n\n闭包中的基本数据类型变量是保存在堆内存里的，当函数执行完弹出调用栈后，返回内部函数的一个应用，这时候函数的变量就会转移到堆上，因此内部函数依然能访问到上一层函数的变量。\n二、堆内存空间\n\n\n\n\n\n\n\n\n用堆作为数据结构在内存中所申请的空间。通常情况下，我们所说的堆数据结构指的就是二叉堆。\n1、二叉堆的特点：1、它是一颗完全二叉树\n2、二叉堆不是最小堆就是最大堆\n2、引用数据类型\n\n\n\n\n\n\n\n\n引用数据类型存储在堆内存中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。引用数据类型会在栈中存储一个指针，这个指针指向堆内存空间中该实体的起始地址。当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后，从堆中获得实体。\njs// 基本数据类型-栈内存\nlet name = &quot;大白&quot;;\n// 基本数据类型-栈内存\nlet age = 20;\n// 基本数据类型-栈内存\nlet info = null;\n// 对象指针存放在栈内存中，指针指向的对象放在堆内存中\nlet msgObj = &#123;msg: &quot;测试&quot;, id: 5&#125;;\n// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中\nlet ages = [19, 22, 57]\n上面代码中：\ntxt1、创建了两个变量msgObj、ages，它们的值都是引用类型(object、array)\n2、堆内存空间采用二叉堆作为数据结构，msgObj与ages的具体值会存在堆内存空间中\n3、存储完成后，堆内存空间会返回这两个值的引用地址(指针)\n4、拿到引用地址后，这个引用地址会和它的变量名对应起来，存放在栈内存空间中\n5、在查找变量msgObj与ages的具体值时，会先从栈内存空间中获取它的引用地址\n6、获取到引用地址后，通过引用地址在堆内存空间的二叉堆中查找到对应的值。堆内存空间中的object，表示的是存储在空间中的其他对象的引用值\n\n3、栈内存空间与堆内存的区别\n\n\n\n\n\n\n\n\n堆内存空间：相当于一个采用二叉堆作为数据结构的容器。堆内存：指的是一个引用类型的具体值堆内存存在于堆内存空间中\n三、变量复制1、基本数据类型的复制下面代码中，name、alias都是基本类型，值存储在栈内存，分别有各自独立的栈空间，因此修改了alias的值，name是不受影响的。\njslet name =&#39;jude&#39;\nlet alias = name\nalias = &#39;summer&#39;\n\nconsole.log(name) // jude\nconsole.log(alias) // summer相当于复制前是这样的：\n\n\n\n\n\n\n\n\n\nname | jude\n复制后：\n\n\n\n\n\n\n\n\n\nalias | judename  | jude\n修改后:\n\n\n\n\n\n\n\n\n\nalias | summername  | jude\n2、引用类型的复制下面代码中，info、book都是引用类型，它们引用存在栈内存，值存在堆内存，它们的值指向同一块堆内存，栈内存中会复制一份相同的引用。\njslet book = &#123;title:&#39;book&#39;,id:1&#125;\nlet info = book\ninfo.title = &#39;javascript&#39;\nconsole.log(book.title) // javascript四、深拷贝与浅拷贝1、浅拷贝：\n\n\n\n\n\n\n\n\n引用数据类型在复制时，改了其中一个数据的值，另一个数据的值也会跟着改变，这种拷贝方式我们称为浅拷贝。\n1.1 Object.asign()\n\n\n\n\n\n\n\n\nObject.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。\njslet obj1 = &#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;,sports:&#39;basketball&#39; &#125;;\nlet obj2 = Object.assign(&#123;&#125;, obj1);\nobj2.person.name = &quot;wade&quot;;\nobj2.sports = &#39;football&#39;\nconsole.log(obj1); // &#123; person: &#123; name: &#39;wade&#39;, age: 41 &#125;, sports: &#39;basketball&#39; &#125;1.2 扩展运算符jslet obj1 = &#123; name: &#39;Kobe&#39;, address:&#123;x:100,y:100&#125;&#125;\nlet obj2= &#123;... obj1&#125;\nobj1.address.x = 200;\nobj1.name = &#39;wade&#39;\nconsole.log(&#39;obj2&#39;,obj2) // obj2 &#123; name: &#39;Kobe&#39;, address: &#123; x: 200, y: 100 &#125; &#125;1.3 Array.prototype.concat()&#x2F;Array.ptototype.slice()jslet arr = [1, 3, &#123;\n    username: &#39;kobe&#39;\n&#125;];\nlet arr2 = arr.concat();    \narr2[2].username = &#39;wade&#39;;\nconsole.log(arr); //[ 1, 3, &#123; username: &#39;wade&#39; &#125; ]\n\n\nlet arr = [1, 3, &#123;\n    username: &#39; kobe&#39;\n&#125;];\nlet arr3 = arr.slice();\narr3[2].username = &#39;wade&#39;\nconsole.log(arr); // [ 1, 3, &#123; username: &#39;wade&#39; &#125; ]\n2、深拷贝：\n\n\n\n\n\n\n\n\n引用类型复制到新的变量后，二者是独立的，不会因为一个的改变而影响到另一个实际上就是重新在堆内存中开辟一块新的空间，把原对象的数据拷贝到这个新地址空间里来\n2.1 深拷贝方法1：\n\n\n\n\n\n\n\n\n将对象转一遍JSON，缺点是只能转化一般常见的数据，function、undefined、正则等类型无法通过这种方法变回来。\njsconst data = &#123; name: &quot;jude&quot; &#125;;\nconst obj = JSON.parse(JSON.stringify(data));\nobj.age = 20;\nconsole.log(&quot;data = &quot;, data);// data = &#123; name:&quot;jude&quot;&#125;\nconsole.log(&quot;obj = &quot;, obj);// obj = &#123;name:&#39;jude&#39;,age:20&#125;2.2 深拷贝方法2：\n\n\n\n\n\n\n\n\n手动去写循环遍历\njsconst data = [&#123; name: &quot;jude&quot; &#125;];\nlet obj = data.map(item =&gt; item);\nobj.push(&#123; name: &quot;summer&quot; &#125;);\nconsole.log(&quot;data = &quot;, data);// data = [&#123;name:&#39;jude&#39;&#125;]\nconsole.log(&quot;obj = &quot;, obj);// obj = [&#123;name:&#39;jude&#39;,name:&#39;summer&#39;&#125;]\n","slug":"39-stack-heap","date":"2021-05-24T16:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"ed48745b4bff056660d038a8d72cbd83","title":"38、Vue项目中的window.resize","content":"Vue项目中使用ECharts可视化图表时，图表自适应大小。根据窗口大小自动改变ECharts图表的宽度。\n\n\n一、防抖函数页面频繁使用window.resize函数会使得页面非常卡顿，需要使用debounce防抖函数（无论触发了多少次回调，都只执行最后一次）。\njs/**\n * 函数防抖\n * @param &#123;Function&#125; func\n * @param &#123;number&#125; delay\n * @param &#123;boolean&#125; immediate\n * @return &#123;*&#125;\n */\n\nexport function debounce(func, delay, immediate = false) &#123;\n  let timer,context = this;\n  return (...args) =&gt; &#123;\n    if (immediate) &#123;\n      func.apply(context, args);\n      immediate = false;\n      return;\n    &#125;\n    clearTimeout(timer);\n    timer = setTimeout(() =&gt; &#123;\n      func.apply(context, args);\n    &#125;, delay);\n  &#125;;\n&#125;\n二、resize函数js// 工具函数的引入\nimport &#123; debounce &#125; from &#39;@/utils/index.js&#39;;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      myChart: null,\n      resizeHandler: null\n    &#125;;\n  &#125;,\n  computed: &#123;\n    // 侧边栏的收缩\n    open() &#123;\n      return this.$store.state.setting.open;\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.resizeHandler = debounce(() =&gt; &#123;\n      if (this.myChart) &#123;\n        this.myChart.resize();\n      &#125;\n    &#125;, 100);\n    this.initResizeEvent();\n  &#125;,\n\n  methods: &#123;\n    //监听resize\n    initResizeEvent() &#123;\n      window.addEventListener(&#39;resize&#39;, this.resizeHandler);\n    &#125;,\n    //移除resize\n    destroyResizeEvent() &#123;\n      window.removeEventListener(&#39;resize&#39;, this.resizeHandler);\n    &#125;\n  &#125;,\n\n  beforeDestroy() &#123;\n    this.destroyResizeEvent();\n    if (!this.myChart) &#123;\n      return;\n    &#125;\n    this.myChart.dispose();\n    this.myChart.off(&#39;click&#39;);\n    this.myChart = null;\n  &#125;,\n\n  activated() &#123;\n    this.initResizeEvent();\n    if (this.myChart) &#123;\n      this.myChart.resize();\n    &#125;\n  &#125;,\n\n  deactivated() &#123;\n    this.destroyResizeEvent();\n  &#125;,\n  watch: &#123;\n    open() &#123;\n      if (this.myChart) &#123;\n        this.myChart.resize();\n      &#125;\n    &#125;\n  &#125;\n&#125;;\n","slug":"38-resize","date":"2021-05-18T16:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"20ae2dbc09bf46cd7bd91bae36ed8dea","title":"37、typescript基础","content":"typescript基础知识,包括typescript的安装、函数、数组、字符串等。\n\n\n1、typescript的安装\n\n\n\n\n\n\n\n\n1、安装node\n\n\n\n\n\n\n\n\n\n2、安装typescript\nshellsudo npm install typescript -g  //(mac 则需要添加sudo window则不需要)\ntsc -v // 查看版本号\n\n\n\n\n\n\n\n\n3、hello world\nshell# 初始化项目\nnpm init -y\n# typescript配置文件\ntsc --init\n# 安装@type/node(解决模块声明问题)\nnpm install @types/node --save-dev\n# 创建helloworld.ts文件\ntouch helloworld.tsjsvar a:String = &#39;hello world&#39;\nconsole.log(a)\n\n\n\n\n\n\n\n\n4、将helloworld.ts转换成helloworld.js\nshelltsc helloworld.ts  //将ts文件转换成js文件\n# 运行helloworld.js\nnode helloworld.js  // 打印结果hello world2、typescript函数的定义方式1、函数声明    使用function和函数名来定义一个函数\nts    function search(time:number) : string &#123;\n        return &#39;终于找到了丢失&#39; + time + &#39;天的dog--小七&#39;\n    &#125;\n    var time = 1\n    var result : string = search(time)\n    console.log(result)  // 终于找到了丢失一天的dog--小七2、函数表达式    将函数赋值给一个变量，变量名就是函数名。通过变量名来调用函数\nts    var Adc = function(n1:number,n2:number) : number &#123;\n        return n1++ + ++n2\n    &#125;\n    console.log(Adc(2,3))  // 63、箭头函数    typescript是支持ES6的。\nts    var Jungle = (n1:number,n2:number) : number =&gt; &#123;\n        return n1 * n2\n    &#125;\n    console.log(Jungle(12,2) // 24txt将ts文件转换为js文件：tsc function.ts  =&gt;  生成function.js  =&gt; 运行function.js,node function.js3、typescript函数作用域\n\n\n\n\n\n\n\n\ntypescript也是有全局变量和局部变量的\nts    function star():void&#123;\n    var Jay = &#39;周杰伦&#39;\n        console.log(Jay)  // 周杰伦\n    &#125;\n    star()\n    console.log(star) // [Function:star]\n\n    var JayChou = &#39;周杰伦&#39;  // 此时JayChou是全局变量\n    function superstar():void&#123;\n    console.log(&#39;青花瓷是&#39; + JayChou + &#39;演唱的！&#39;) // 青花瓷是周杰伦演唱的！\n    &#125;\n    superstar()\n    console.log(JayChou) // 周杰伦\n4、typescript数组\n\n\n\n\n\n\n\n\nts中数据分为值类型和引用类型。\n1、什么是引用类型？\n\n\n\n\n\n\n\n\n\n引用类型是一种复合类型，引用类型中封装了很多属性，可以通过变量名和属性名来获取属性值或者调用属性的方法。\nts    let Jude = &#123;\n        name: &#39;Jude&#39;,\n        age: 28,\n        saySomething: function () &#123;\n            console.log(&#39;行到水穷处，坐看云起时！&#39;);\n        &#125;\n    &#125;\n    console.log(Jude.name) // Jude2、元祖– 一种特殊的数组\n数组中允许含有多种类型的元素\nts    let arr : [number,string]\n    arr = [123,&#39;123&#39;]\n    // console.log(arr) // [123,&#39;123]当我们写成这个样子，是会报错的\nts    let arr : [number,sting]\n    arr = [&#39;123&#39;,123]txterror1: Type &#39;string&#39; is not assignable to type &#39;number&#39;. \nerror2: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n5、typescript字符串1、Typescript中字符串的两种类型：\n\n\n\n\n\n\n\n\n\n基本类型字符串：由单引号或者双引号’包裹的’一串字符;\n\n\n\n\n\n\n\n\n\n引用类型字符串：由new实例化的String类型。\n2、基本类型的字符串可以直接使用引用类型的属性和方法\nts    let Jude: string = &#39;YQ&#39;\n    let JudeYQ: String = new String(&#39;JudeYQ&#39;)\n    console.log(Jude) // YQ\n    console.log(JudeYQ) // [String:&#39;JudeYQ&#39;]\n    // 基本类型的字符串可以直接使用引用类型的属性和方法\n    console.log(Jude.length) // 2\n    console.log(JudeYQ.length)  // 63、字符串常用的方法\n\n\n\n\n\n\n\n\n\n字符串查找 indexOf()和lastIndexOf()，二者返回的都是字符串的下标。\nts    let word:string = &#39;西虹人瘦，燃烧我的卡路里&#39;\n    let Calorie: string = &#39;卡路里&#39;\n    console.log(word.indexOf(Calorie)) // 9\n    let ST:string = &#39;沈腾&#39;\n    console.log(word.indexOf(ST)) // -1 没有查找到返回-1\n    console.log(word.lastIndexOf(Calorie)) // 9 从字符串尾部开始查找字符串的位置 和indexOf（）返回的都是字符串下标\n\n\n\n\n\n\n\n\n\n字符串的截取， substring()\nts    // 字符串的截取\n    console.log(word.substring(9)) // 卡路里\n    console.log(word.substring(9,12)) // 卡路里3、字符串的替换,replace()\nts    console.log(word.replace(Calorie,&#39;腹肌&#39;))  // 西虹人瘦，燃烧我的腹肌","slug":"37-typescript","date":"2021-05-15T12:00:00.000Z","categories_index":"","tags_index":"typescript","author_index":"Jude"},{"id":"daa58f2a654aa085176188002c2fc65b","title":"36、父子组件的创建和挂载顺序","content":"\n\n1、创建过程自上而下，挂载过程自下而上\n父组件 created子组件created子组件mounted父组件mounted\n2、原因：\nVue创建过程是一个递归过程，先创建父组件，有子组件就会创建子组件，因此创建时先有父组件再有子组件；子组件首次创建会添加mounted钩子到队列，等到patch结束再执行他们，可见子组件的mounted钩子是先进入到队列中的，因此等到patch结束执行这些钩子时也先执行。\n","slug":"36-component-mounted","date":"2021-05-08T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"3712617e1c2f79d3bd6544a83ed493fa","title":"34、iTerms、Node版本管理工具、nrm等的使用方法","content":"一些开发过程中需要使用的工具整理\n\n\niTerm2快捷键\ntxt    commond + t              // 新建标签页\n    commond + w              // 关闭标签\n    commond + enter          // 切换全屏(第一次切换至全屏，再commond + enter恢复到之前窗口) \n    commond + 左右方向键       // 切换标签\n    commond + +              // 窗口和字体变大\n    commond + -              // 窗口和字体变小Node版本管理工具在开发的工程中，我们可能需要经常切换node版本来应对不同的开发环境，所以需要经常使用不同版本的node。\n一、安装npm插件n ,通过n模块来管理node版本\n1、全局安装n模块\ntxt    npm instlal -g n 2、安装当前稳定版本\ntxt    n stable或者sudo n stable3、安装最新版本的\ntxt    n latest或者sudo n latest4、安装指定版本的node\ntxt    n v8.16.05、卸载指定的node版本\ntxt    n rm v8.16.0二、使用nvm管理node版本1、安装nvm \ntxt    brew install nvm2、使用nvm安装node版本\ntxt    // 安装最新版本\n    nvm isntall node\n    // 安装指定版本\n    nvm install 8.16.03、查看所有版本\ntxt    nvm ls4、切换node版本\ntxt    // 使用最新版本\n    nvm use node       \n    // 使用指定版本\n    nvm use 8.16.0通常我会使用第二种方式例如：\n我在一个项目中使用的是node@6.13.2,\n新项目使用的是node@8.16.0,\n先要安装node@8.16.0   nvm install 8.16.0\n然后nvm use 8.16.0\n5、卸载指定版本的node\ntxt    nvm uninstall  v6.13.26、设置系统默认的node版本\ntxt    nvm alias default v8.16.0这样使用的node的默认版本为8.16.0\nnrm切换npm源因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。\n一、切换成淘宝源\n1、config命令的使用\ntxtnpm config set registry https://registry.npm.taobao.org2、命令行指定\ntxtnpm i node --registry https://registry.npm.taobao.org info underscore 3、编辑~&#x2F;.npmrc，加入以下内容：\ntxtregistry = https://registry.npm.taobao.org二、nrm的使用\n\n\n\n\n\n\n\n\n\nnrm是一个可以切换、添加&#x2F;删除&#x2F;测试源的工具\n1、全局安装nrm\ntxtnpm install -g nrm  // mac如果出现权限问题，加上sudo2、安装完成，查看所有的可用源\ntxtnrm ls3、添加源\ntxtnrm add 源的名称  https:// 地址4、删除原\ntxtnrm del 源的名字5、切换到某个源\ntxtnrm use 源的名字6、测试源速度\ntxtnrm test例如，我需要使用淘宝源，只需nrm use taobao就可以了，cnpm不要使用，容易出现莫名其妙的错误。\n前端常用的linux命令常用的Linux命令\ntxt1、vim test.html   创建新的文件 \n   vim + 文件名.后缀\n2、ls     查看当前文件夹下的文件\n    ls -a  列出所有文件，包括隐藏文件\n    ls -1  每行列出一个文件，以单列形式列出\n3、cat test.html  将该文件内容打印显示出来\n   cat test1.html\n   cat test2.html\n   cat test1.html     test2.html&gt;test3.html\n   cat test3.html   将多个文件合并到目标文件中。\n\n   cat test1.html\n   cat test2.html\n   cat test1.html test2.html&gt;&gt;test4.html  将几个文件附加到目录文件中\n4、mv   移动或重命名文件和目录\nmv file1.txt file2.txt   将file1文件命名为file2\n用法：\n cat 1.txt\n mv 1.txt 2.txt\n mv file1.txt file2  将file1文本移动到file2目录  \n5、touch  file   命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。\n touch newfile\n6、mkdir file    创建文件夹\n7、cd ../  返回当前文件夹的上一层\n cd /    返回到根目录下\n8、rm -rf folder  删除文件夹eslint的配置常用的配置\ntxtmodule.exports = &#123;\n  root: true,\n  env: &#123;\n    node: true\n  &#125;,\n  &#39;extends&#39;: [\n    &#39;plugin:vue/essential&#39;,\n    &#39;@vue/standard&#39;\n  ],\n  rules: &#123;\n    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无console.log\n    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无debugger\n    &#39;indent&#39;: &#39;off&#39;,\n    // 函数定义时括号前面要不要有空格\n    &#39;space-before-function-paren&#39;: &#39;off&#39;\n  &#125;,\n  parserOptions: &#123;\n    parser: &#39;babel-eslint&#39;\n  &#125;\n&#125;git提交代码一、初始化本地仓库，提交代码，提交到远程git仓库\n1、初始化代码仓库\ntxt    git init2、将当前目录下的所有文件放到暂存区\ntxt    git add .3、查看文件状态\ntxt    git status4、添加提交的描述信息\ntxt    git commit -m &quot;提交的描述信息&quot;5、远程仓库地址\ntxt    git remote add origin &quot;远程仓库地址&quot;6、推送到远程仓库\ntxt    git push -u origin master二、创建分支，提交代码到分支\n1、创建切换分支\ntxt    git checkout -b dev  dev为分支名称\n    git add .\n    git commit -m &#39;描述&#39;\n    git push --set-upstream origin dev1   将分支推送到远程仓库\n    切换到主分支\n    git checkout master\n    git merge dev  将dev合并到主分支\n    git push origin master  推送到远程仓库三、克隆指定分支\ntxt    git clone -b master git@gitee.com:username/projectname.git\n    git clone -b admin git@gitee.com:username/projectname.git四、git reflog\ntxt查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）\n执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。vscode快捷键\n\n\n快捷键\n功能\n\n\n\ncommond + B\n显示&#x2F;隐藏侧边栏\n\n\ncommond + shift + p\n显示命令窗口\n\n\ncommond +\n创建多个编辑器\n\n\ncommond + 1、2\n聚焦到第1、第2个编辑器\n\n\ncommond + J 或者 Ctrl + &#96;\n显示隐藏控制台\n\n\ncommond + W\n关闭当前文件\n\n\noption + 左右方向键\n单词之间移动光标\n\n\ncommond + 左右方向键\n移动光标至最前、最后\n\n\ncommond + shift + \\\n代码块之间移动光标\n\n\n\n\n\n\n\n\n\n\n\nfileheader插件的使用\ntxtcommond+shift+p -&gt; fileheader -&gt; enter\n\n/*\n * @Author: Jude \n * @Date: 2020-07-24 16:39:41 \n * @Last Modified by: Jude\n * @Last Modified time: 2020-07-24 16:40:34\n */Markdown语法Markdown标题\n使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n1、Markdown段落\n段落的换行是使用两个以上空格加上回车。\n\n\n\n\n\n\n\n\n\n字体:\ntxt*斜体文本*txt_斜体文本_txt**粗体文本**txt__粗体文本__txt***粗斜体文本***txt___粗斜体文本___\n\n\n\n\n\n\n\n\n分割线\ntxt***\n\n* * *\n\n*****\n\n- - -\n\n----------\n\n\n\n\n\n\n\n\n删除线、下划线、脚注\ntxt~~删除线~~\n&lt;u&gt;下划线&lt;/u&gt;\n[^Vue]:Vuejs是目前最流行的web开发框架之一。2、Markdown列表\nMarkdown 支持有序列表和无序列表。\n（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\ntxt* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n\n- 第一项\n- 第二项\n- 第三项（2）、有序列表：有序列表使用数字并加上 . 号来表示。\ntxt1. 第一项\n2. 第二项\n3. 第三项（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可\ntxt1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素4、Markdown区块\nMarkdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\n\n\n\n\n\n\n\n\n\n区块的嵌套\ntxt&gt; 最外层\n&gt; &gt; 第一层嵌套\n&gt; &gt; &gt; 第二层嵌套\n\n\n\n\n\n\n\n\n区块中使用列表\ntxt&gt; 区块中使用列表\n&gt; 1. 第一项\n&gt; 2. 第二项\n&gt; + 第一项\n&gt; + 第二项\n&gt; + 第三项\n\n\n\n\n\n\n\n\n列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进\ntxt* 第一项\n    &gt; vuejs\n    &gt; JavaScript框架\n* 第二项5、Markdown链接和图片\n\n\n\n\n\n\n\n\n\n链接\ntxt[链接名称](链接地址)\n\n或者\n\n&lt;链接地址&gt;\n\n\n\n\n\n\n\n\n图片\ntxt![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)6、Markdown表格\ntxt|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |我们可以设置表格的对齐方式：\ntxt-: 设置内容和标题栏居右对齐。\n\n:- 设置内容和标题栏居左对齐。\n\n:-: 设置内容和标题栏居中对齐。HBuilder真机调试1、小米手机开发者模式如何打开（MIUI 11.0.4）\n步骤：设置–我的设备–全部参数–（点击）MINI版本;\n2、手机连接Mac：\nMac的关于本机–系统报告–USB–你所连接的device–厂商ID\n3、打开Mac终端：\n在终端执行如下命令：\nshell    echo xxxxxx &gt;&gt; ~/.android/adb_usb.ini （“xxxxxx”为厂商ID);4、重启HBuilderX;\n这里如果出现了问题需要切换到HBuilderX自带的adb目录；\n路径为：&#x2F;Applications&#x2F;HBuilderX-Alpha.app&#x2F;Contents&#x2F;HBuilderX&#x2F;plugins&#x2F;launcher&#x2F;tools&#x2F;adbs\n在adbs目录下运行Terminal，输入：\nshell    ./adb kill-server","slug":"34-tool","date":"2021-05-02T12:00:00.000Z","categories_index":"","tags_index":"tool","author_index":"Jude"},{"id":"2da7ef302a482d59240c8e957d385027","title":"35、数组方法","content":"js 常用数组方法整理,包括常用的数组常用方法、高阶函数 forEach、filter、map。\n\n\n1、常用数组方法\n点击展示代码\n\njs// 1、删除数组的最后一项  pop()\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.pop();\nconsole.log(fruits); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;\n\nvar x = fruits.pop(); // Mango\n\n// 2、数组结尾添加一个新元素  push()\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.push(&quot;Kiwi&quot;); //&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;,&quot;Kiwi&quot;\n\nvar x = fruits.push(&quot;Kiwi&quot;); // 5\n\n// 3、删除数组第一个元素    shift()\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.shift(); // &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;\n\n// 4、数组开头返回一个新元素   返回新数组长度   unshift()\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.unshift(&quot;Lemon&quot;); //&quot;Lemon&quot; &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;\n\n// 5、删除元素 delete  会留下数组未定义的空洞  可以使用pop shift替代\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\ndelete fruits[0]; // empty,&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;\n\n// 6、拼接数组  splice()  第一个参数 2 定义了应添加新元素的位置   第二个参数 定义应删除多少元素  其余参数  定义要添加的新元素  返回一个包含已删除项的数组\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;, &quot;Apple&quot;, &quot;Mango&quot;\nfruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;,\n\n// 7、删除元素 splice()  在数组中不留“空洞”的情况下移除元素\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.splice(0, 1); //&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;\n\n// 8、合并数组 concat()\nvar myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];\nvar myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];\nvar myChildren = myGirls.concat(myBoys);\n\n// 9、裁剪数组 slice()   源数组不会删除任何元素   第一个参数  开始选取的元素  第二个参数  结束参数为止（不包含）\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nvar citrus = fruits.slice(1); // &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;\n\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nvar citrus = fruits.slice(1, 3); // &quot;Orange&quot;, &quot;Lemon&quot;   第2个元素 到 第4个元素  截取结果为第2个和第3个元素\n\n// 10、数组元素结合成字符串 join() 和 toString()\nvar fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];\nfruits.join(&quot;,&quot;); // Banana,Orange,Apple,Mango\nfruits.toString(); // Banana,Orange,Apple,Mango\n\n2、高阶函数1、forEach\n\n\n\n\n\n\n\n\nforEach()方法对数组的每个元素执行一次给定的函数。\nfor example：\njsvar array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narray.forEach((e) =&gt; &#123;\n  console.log(e); // &#39;a&#39; &#39;b&#39; &#39;c&#39;\n&#125;);语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg])\n参数介绍：\ntxtcallback：为数组中的每个元素执行的函数，该函数接收1~3个参数\n\ncurrentValue：数组中正在处理的当前元素\n\nindex: 数组中正在处理的当前元素的索引\n\narray: forEach()正在操作的数组   数组对象本身\n\nthisArg：可选参数。当执行回调函数callback时，用作this的值。常见用法：\n（1）稀疏数组\n\n\n\n\n\n\n\n\n不对未初始化的值进行任何操作\njsconst arratSpace = [1, 3, , 7];\nlet numCallbackRuns = 0;\narratSpace.forEach(function (e) &#123;\n  console.log(e);\n  numCallbackRuns++;\n&#125;);\n\nconsole.log(&quot;numCallbackRuns:&quot;, numCallbackRuns);(2)for 循环转换成 forEachjsconst items = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];\nconst copy = [];\n\n//for循环\nfor (let i = 0; i &lt; items.length; i++) &#123;\n  copey.push(items[i]);\n&#125;\n\n// forEach\nitems.forEach(function (itme) &#123;\n  copy.push(item);\n&#125;);(3)thisArg 使用箭头函数 thisArg 参数会被忽略，因为箭头函数绑定了 this 值(4)对象复制器函数jsfunction copy(obj) &#123;\n  const copy = Object.create(Object.getPrototypeOf(obj));\n  const propNames = Object.getOwnPropertyNames(obj);\n\n  propNames.forEach(function (name) &#123;\n    const desc = Object.getOwnPropertyDescriptor(obj, name);\n    Object.defineProperty(copy, name, desc);\n  &#125;);\n\n  return copy;\n&#125;\n\nconst obj1 = &#123; a: 1, b: 2 &#125;;\n\nconst obj2 = copy(obj1); // obj2看起来和obj1一模一样(5)数组在迭代时被修改了，则其他元素会被跳过jsvar words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];\nwords.forEach(function (word) &#123;\n  console.log(word);\n  if (word === &quot;two&quot;) &#123;\n    words.shift();\n  &#125;\n&#125;);(6)promise 或 async 函数的使用jslet ratings = [5, 4, 5];\n\nlet sum = 0;\n\nlet sumFunction = async function (a, b) &#123;\n  return a + b;\n&#125;;\n\nratings.forEach(async function (rating) &#123;\n  sum = await sumFunction(sum, rating);\n&#125;);\n\nconsole.log(sum); // 02、filter\n\n\n\n\n\n\n\n\nfilter()创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回满足条件的新数组，不满足则返回空数组。\nfor example\njsconst words = [&quot;111&quot;, &quot;222&quot;, &quot;333333&quot;, &quot;4444444&quot;, &quot;55555555&quot;];\nconst result = words.filter((word) =&gt; &#123;\n  word.length &gt; 5;\n&#125;);\n\nconsole.log(result); // 333333  4444444    55555555语法：var newArray &#x3D; arr.filter(callback(element[, index[, array]])[, thisArg])\n参数：callback:用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。\ntxtelement:数组中当前正在处理的元素\n\nindex:正在处理的元素在数组中的索引\n\narray:调用filter的数组本身\n\nthisArg:执行callback时，用于this的值返回值：\ntxt一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。用法：\n（1)筛选排除所有较小的值jsfunction isBig(e) &#123;\n  return e &gt;= 10;\n&#125;\nvar filterd = [3, 6, 9, 14, 32].filter(isBig);\n// [14,32](2)过滤 JSON 中的无效条目jsvar arr = [\n  &#123; id: 12 &#125;,\n  &#123; id: -1 &#125;,\n  &#123; id: 0 &#125;,\n  &#123; id: 3 &#125;,\n  &#123; id: 14.4 &#125;,\n  &#123;&#125;,\n  &#123; id: null &#125;,\n  &#123; id: NaN &#125;,\n  &#123; id: &quot;undefined&quot; &#125;,\n];\nvar entries = 0;\nfunction isNumber(obj) &#123;\n  return obj !== undefined &amp;&amp; typeof obj === &quot;number&quot; &amp;&amp; !isNaN(obj);\n&#125;\nfunction filterID(item) &#123;\n  if (isNumber(item.id) &amp;&amp; item.id !== 0) &#123;\n    return true;\n  &#125;\n  entries++;\n  return false;\n&#125;\nvar arrId = arr.filter(filterID);\nconsole.log(arrId); // [&#123;id:12&#125;,&#123;id:-1&#125;,&#123;id:3&#125;,&#123;id:14.4&#125;]\nconsole.log(entries); // 5(3)在数组中搜索：根据搜索条件来过滤数组内容jsvar fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]\nfunction filterItems(query)&#123;\n    return fruits.filter(function(e)&#123;\n        return e.toLowerCase().indexOf(query.toLowerCase()) &gt; -1\n    &#125;)\n&#125;\n\nconsole.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]\nconsole.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]上面是 es5 的写法，下面是 es6 的写法\njsvar fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]\nconst filterItems = (query) =&gt;&#123;\n    return fruits.filter((e) =&gt;\n        e.toLowerCase().indexOf(query,toLowerCase()) &gt; -1\n    )\n&#125;\nconsole.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]\nconsole.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]3、map\n\n\n\n\n\n\n\n\nmap()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 原数组不会改变\njsconst array = [1, 2, 3, 4];\nconst maps = array.map((x) =&gt; x * 2);\nconsole.log(maps); // 2 4 6 8用法：\n(1)格式化数组中的对象jsvar array = [\n  &#123; key: 1, value: 10 &#125;,\n  &#123; key: 2, value: 20 &#125;,\n  &#123; key: 3, value: 30 &#125;,\n];\n\nvar formatterArray = array.map(function (obj) &#123;\n  var o = &#123;&#125;;\n  o[obj.key] = obj.value;\n  return o;\n&#125;);\nconsole.log(formatterArray); // [&#123;1:10&#125;,&#123;2:20&#125;,&#123;3:30&#125;](2)使用包含一个参数的函数来构建一个数字数组jsvar numbers = [1, 4, 9];\nvar double = numbers.map(function (item) &#123;\n  return item * 2;\n&#125;);\nconsole.log(double); // [2,8,18]includes比indexOf好在哪里？\n\n\n\n\n\n\n\n\nincludes可以检测NaN，indexOf不能，includes内部使用了Number.isNaN对NaN进行了匹配\n","slug":"35-array","date":"2021-05-02T12:00:00.000Z","categories_index":"","tags_index":"array","author_index":"Jude"},{"id":"51e01297d5532d721adcbcf196152a02","title":"33、时间格式化","content":"获取时间格式的方式、封装的一些函数方法\n\n\n一、常用时间格式js    // 2021/3/10\n    let time = new Date().toLocaleDateString();\n    // 上午10:30:00\n    let times = new Date().toLocaleTimeString();\n    // 获取当前年份    2021年\n    let year = new Date().getFullYear();\n    // 获取当前月份  月份需要+1   3月份\n    let month = new Date().getMonth()+1;\n    // 获取当前月份日期   10号\n    let day = new Date().getDate();\n    // 获取当前星期几   三\n    let week = new Date().getDay();\n    // 获取当前季度   一季度\n    let season =  Math.floor((this.getMonth()+3)/3);二、Vue3获取当前时间：格式：YYYY-MM-DD hh:mm:ss1、封装工具函数：jsimport &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;\n\nfunction dateFilter (v) &#123;\n  let m = v.getMonth() + 1\n  m = m &lt; 10 ? &#39;0&#39; + m : m\n  let d = v.getDate()\n  d = d &lt; 10 ? &#39;0&#39; + d : d\n  return v.getFullYear() + &#39;-&#39; + m + &#39;-&#39; + d\n&#125;\n\nfunction timeFilter (v) &#123;\n  let h = v.getHours()\n  h = h &lt; 10 ? &#39;0&#39; + h : h\n  let m = v.getMinutes()\n  m = m &lt; 10 ? &#39;0&#39; + m : m\n  let s = v.getSeconds()\n  s = s &lt; 10 ? &#39;0&#39; + s : s\n  return h + &#39;:&#39; + m + &#39;:&#39; + s\n&#125;\n\nexport function clock () &#123;\n  let now = new Date()\n  const date = ref(dateFilter(now))\n  const time = ref(timeFilter(now))\n  let task\n  const start = () =&gt; &#123;\n    task = setInterval(() =&gt; &#123;\n      now = new Date()\n      date.value = dateFilter(now)\n      time.value = timeFilter(now)\n    &#125;, 1000)\n  &#125;\n  onMounted(start)\n  onUnmounted(() =&gt; &#123;\n    task &amp;&amp; clearInterval(task)\n  &#125;)\n  return &#123;\n    date,\n    time,\n    start\n  &#125;\n&#125;2、模板页面中使用template:\nhtml&lt;template&gt;\n  &lt;div class=&quot;time&quot;&gt;\n    &#123;&#123; date &#125;&#125; &#123;&#123; time &#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;javascript:\njs&lt;script&gt;\n  import &#123; clock as useClock &#125; from &#39;../../utils/clock&#39;\n\n  export default &#123;\n    name: &#39;time&#39;,\n    setup () &#123;\n      const &#123; date, time &#125; = useClock()\n\n      return &#123;\n        date,\n        time\n      &#125;\n    &#125;\n  &#125;\n&lt;/script&gt;\n","slug":"33-time","date":"2021-04-28T12:00:00.000Z","categories_index":"","tags_index":"time","author_index":"Jude"},{"id":"3d946e8b4b11c3d4e608423cd2c6cf9c","title":"32、javascript -- 对象","content":"对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？\n\n\n在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是：原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。\n一、字符串方法js// 将字符串的字母转换成小写\nconst str = &quot;Hello world&quot;;\narr = str.split(&quot;&quot;).map(function (item) &#123;\n  return (item + &quot;&quot;).toLowerCase();\n&#125;);\nlowerStr = arr.join(&quot;&quot;);\nconsole.log(lowerStr);\n\n// 挑出大写字母\nconst str = &quot;Permission is &quot;;\nreg = /[A-Z]/g;\nconsole.log(str.match(reg).join(&quot;&quot;));js 数据类型基本数据类型：\n\n\n\n\n\n\n\n\n\nNumber，String，Boolean，null，undefined，symbol，bigint\n引用数据类型:\n\n\n\n\n\n\n\n\n\nobject function\n\n\n\n\n\n\n\n\n\n基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基 本类型值和执行代码的空间。\n引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。\n基本数据类型和引用数据类型的区别：\n\n\n\n\n\n\n\n\n\n\n堆比栈空间大，栈比堆运行速度快。\n堆内存是无序存储，可以根据引用直接获取。\n基础数据类型比较稳定，而且相对来说占用的内存小。\n引用数据类型大小是动态的，而且是无限的。\n\nObject.assign()：合并对象 Object.assign(target, …sources)\n\n\n\n\n\n\n\n\n\n\nObject.assign 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖。\n后续的 source 会覆盖前面的 source 的同名属性。\nObject.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。\n\nConstructor:\n\n\n\n\n\n\n\n\n\n创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。\nmap 和 forEach 区别\n相同点：\n\n\n\n\n\n\n\n\n\n\n都是循环遍历数组中的每一项\n每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）\n匿名函数中的 this 都是指向 window\n只能遍历数组\n\n不同点：\n\n\n\n\n\n\n\n\n\n\nmap()会分配内存空间存储新数组并返回，forEach()不会返回数据。\nforEach()允许 callback 更改原始数组的元素。map()返回新的数组。\n\nfor…of:\n\n\n\n\n\n\n\n\n\nes6 新增的一个遍历方法，但只限于迭代器(iterator), 所以普通的对象用 for..of 遍历是会报错的。\n包括 Array, Map, Set, String, TypedArray, arguments 对象\nindexOf str.indexOf(searchValue [, fromIndex]) searchValue：要被查找的字符串值。\n\n\n\n\n\n\n\n\n\n查找的字符串 searchValue 的第一次出现的索引，如果没有找到，则返回-1。\n若被查找的字符串 searchValue 是一个空字符串，则返回 fromIndex。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样。\n如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）\n严格区分大小写\n在使用 indexOf 检索数组时，用‘&#x3D;&#x3D;&#x3D;’去匹配，意味着会检查数据类型\nIframe 的优缺点？\n优点：\n\n\n\n\n\n\n\n\n\n\niframe 能够原封不动的把嵌入的网页展现出来。\n如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。\n网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。\n如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。\n\n缺点：\n\n\n\n\n\n\n\n\n\n\niframe 会阻塞主页面的 onload 事件；\niframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。\niframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。\n代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。\n很多的移动设备无法完全显示框架，设备兼容性差。\niframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。\n\n作用域：\n\n\n\n\n\n\n\n\n\n作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。\nES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。\njs 的 arguments 相关问题\n\n\n\n\n\n\n\n\n\n在 js 中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js 会把所传的参数全部存到一个叫 arguments 的对象里面。它是一个类数组数据由来\nJavascrip 中每个函数都会有一个 Arguments 对象实例 arguments，引用着函数的实参。它是寄生在 js 函数当中的，不能显式创建，arguments 对象只有函数开始时才可用\ninstanceof 原理：判断实例属于什么类型\njs// 实现方法\nfunction new_instance_of(leftVaule, rightVaule) &#123;\n  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\n  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\n  while (true) &#123;\n    if (leftVaule === null) &#123;\n      return false;\n    &#125;\n    if (leftVaule === rightProto) &#123;\n      return true;\n    &#125;\n    leftVaule = leftVaule.__proto__;\n  &#125;\n&#125;数组去重：\n1、es6 Set 方法\njsfunction unique(arr) &#123;\n  return Array.from(new Set(arr));\n&#125;\n// 无法去除 &#123;&#125; 空对象\n\n// 简写\n[...new Set(arr)];2、es5 利用 for 循环嵌套，然后 splice 去重\njsfunction unique(arr) &#123;\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    for (var j = i + 1; j &lt; arr.length; j++) &#123;\n      if (arr[i] == arr[j]) &#123;\n        //第一个等同于第二个，splice方法删除第二个\n        arr.splice(j, 1);\n        j--;\n      &#125;\n    &#125;\n  &#125;\n  return arr;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr)); //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了3、indexOf\njsfunction unique(arr) &#123;\n  if (!Array.isArray(arr)) &#123;\n    console.log(&quot;type error!&quot;);\n    return;\n  &#125;\n  var array = [];\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    if (array.indexOf(arr[i]) === -1) &#123;\n      array.push(arr[i]);\n    &#125;\n  &#125;\n  return array;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重4、sort\njsfunction unique(arr) &#123;\n  if (!Array.isArray(arr)) &#123;\n    console.log(&quot;type error!&quot;);\n    return;\n  &#125;\n  arr = arr.sort();\n  var arrry = [arr[0]];\n  for (var i = 1; i &lt; arr.length; i++) &#123;\n    if (arr[i] !== arr[i - 1]) &#123;\n      arrry.push(arr[i]);\n    &#125;\n  &#125;\n  return arrry;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重5、includes\njsfunction unique(arr) &#123;\n  if (!Array.isArray(arr)) &#123;\n    console.log(&quot;type error!&quot;);\n    return;\n  &#125;\n  var array = [];\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    if (!array.includes(arr[i])) &#123;\n      //includes 检测数组是否有某个值\n      array.push(arr[i]);\n    &#125;\n  &#125;\n  return array;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重6、hasOwnProperty:利用 hasOwnProperty 判断是否存在对象属性\njsfunction unique(arr) &#123;\n  var obj = &#123;&#125;;\n  return arr.filter(function (item, index, arr) &#123;\n    return obj.hasOwnProperty(typeof item + item)\n      ? false\n      : (obj[typeof item + item] = true);\n  &#125;);\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了7、filter\njsfunction unique(arr) &#123;\n  return arr.filter(function (item, index, arr) &#123;\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  &#125;);\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]8、递归去重\njsfunction unique(arr) &#123;\n  var array = arr;\n  var len = array.length;\n\n  array.sort(function (a, b) &#123;\n    //排序后更加方便去重\n    return a - b;\n  &#125;);\n\n  function loop(index) &#123;\n    if (index &gt;= 1) &#123;\n      if (array[index] === array[index - 1]) &#123;\n        array.splice(index, 1);\n      &#125;\n      loop(index - 1); //递归loop，然后数组去重\n    &#125;\n  &#125;\n  loop(len - 1);\n  return array;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]9、Map 数据结构去重\n\n\n\n\n\n\n\n\n\n创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。\njsfunction arrayNonRepeatfy(arr) &#123;\n  let map = new Map();\n  let array = new Array(); // 数组用于返回结果\n  for (let i = 0; i &lt; arr.length; i++) &#123;\n    if (map.has(arr[i])) &#123;\n      // 如果有该key值\n      map.set(arr[i], true);\n    &#125; else &#123;\n      map.set(arr[i], false); // 如果没有该key值\n      array.push(arr[i]);\n    &#125;\n  &#125;\n  return array;\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]10、利用 reduce+includes\njsfunction unique(arr) &#123;\n  return arr.reduce(\n    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),\n    []\n  );\n&#125;\nvar arr = [\n  1,\n  1,\n  &quot;true&quot;,\n  &quot;true&quot;,\n  true,\n  true,\n  15,\n  15,\n  false,\n  false,\n  undefined,\n  undefined,\n  null,\n  null,\n  NaN,\n  NaN,\n  &quot;NaN&quot;,\n  0,\n  0,\n  &quot;a&quot;,\n  &quot;a&quot;,\n  &#123;&#125;,\n  &#123;&#125;,\n];\nconsole.log(unique(arr));\n// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]null 和 undefined 的区别\n\n\n\n\n\n\n\n\n\nundefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。\nundefined:\n\n声明了一个变量，但没有赋值\n访问对象上不存在的属性\n函数定义了形参，但没有传递实参\n使用 void 对表达式求值\n\nnull:空值\n\n\n\n\n\n\n\n\n\n表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象\ntypeof null 为什么是 object？\n\n\n\n\n\n\n\n\n\nnull 有属于自己的类型 Null，而不属于 Object 类型，typeof 之所以会判定为 Object 类型，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。\n类数组转换为数组的方法：\n\n\n\n\n\n\n\n\n\n\n使用 Array.from()\n使用 Array.prototype.slice.call()\n使用 Array.prototype.forEach()进行属性遍历并组成新的数组\n\n&#x2F;&#x2F; 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。\n数组转树\njsfunction arrayToTree(array) &#123;\n  let root = array[0];\n  array.shift();\n  let tree = &#123;\n    id: root.id,\n    val: root.val,\n    children: array.length &gt; 0 ? toTree(root.id, array) : [],\n  &#125;;\n  return tree;\n&#125;\n\nfunction toTree(parenId, array) &#123;\n  let children = [];\n  let len = array.length;\n  for (let i = 0; i &lt; len; i++) &#123;\n    let node = array[i];\n    if (node.parentId === parenId) &#123;\n      children.push(&#123;\n        id: node.id,\n        val: node.val,\n        children: toTree(node.id, array),\n      &#125;);\n    &#125;\n  &#125;\n  return children;\n&#125;Set、Map、WeakSet 和 WeakMap 的区别\n\n\n\n\n\n\n\n\nSet\n\n成员不能重复；\n只有键值，没有键名，有点类似数组；\n可以遍历，方法有 add、delete、has\n\nWeakSet\n\n成员都是对象（引用）；\n成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；\n不能遍历，方法有 add、delete、has；\n\nMap\n\n本质上是键值对的集合，类似集合；\n可以遍历，方法很多，可以跟各种数据格式转换；\n\nWeakMap\n\n只接收对象为键名（null 除外），不接受其他类型的值作为键名；\n键名指向的对象，不计入垃圾回收机制；\n不能遍历，方法同 get、set、has、delete；\n\n造成内存泄漏的情况\n\n\n\n\n\n\n\n\n\n\n意外的全局变量；\n闭包；\n未被清空的定时器；\n未被销毁的事件监听；\nDOM 引用；\n\n数据类型的判断方法：\n\n\n\n\n\n\n\n\n\n\n使用 typeof 检测当需要判断变量是否是 number, string, boolean, function, undefined 等类型时，可以使用 typeof 进行判断。\n使用 instanceof 检测 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。\n使用 constructor 检测 constructor 本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。\n\n什么是 promise 和 async await 以及它们的区别\n\n\n\n\n\n\n\n\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的\nasync await也是异步编程的一种解决方案，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。\n区别：\n\n\n\n\n\n\n\n\n\n\nPromise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。\nasync await 与 Promise 一样，是非阻塞的。\nasync await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。\n\njs 实现 sleep\njsfunction sleep(time) &#123;\n  return new Promise((resolve) =&gt; setTimeout(resolve, time));\n&#125;\n\nconst t1 = +new Date();\nsleep(3000).then(() =&gt; &#123;\n  const t2 = +new Date();\n  console.log(t2 - t1);\n&#125;);\n\n\n\n\n\n\n\n\n优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。\n缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭\nEvent Loop执行顺序\n\n\n\n\n\n\n\n\n\n\n所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)\n在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务\n一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行\n主线程不断重复上面的第三步\n\n宏任务 Macrotask 宏任务是指 Event Loop 在每个阶段执行的任务\n微任务 Microtask 微任务是指 Event Loop 在每个阶段之间执行的任务\n宏任务队列包含任务: A1, A2 , A3\n微任务队列包含任务: B1, B2 , B3\n执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行 B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务 A2，依次循环。\n宏任务 Macrotask 队列真实包含任务：\n\ntxtscript(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering\n微任务 Microtask 队列真实包含任务:\n\ntxtprocess.nextTick, Promises, Object.observe, MutationObserver\n执行顺序：\n\ntxtscript(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering\n示例：\njsconsole.time(&quot;start&quot;);\n\nsetTimeout(function () &#123;\n  console.log(2);\n&#125;, 10);\n\nsetImmediate(function () &#123;\n  console.log(1);\n&#125;);\n\nnew Promise(function (resolve) &#123;\n  console.log(3);\n  resolve();\n  console.log(4);\n&#125;).then(function () &#123;\n  console.log(5);\n  console.timeEnd(&quot;start&quot;);\n&#125;);\n\nconsole.log(6);\n\nprocess.nextTick(function () &#123;\n  console.log(7);\n&#125;);\n\nconsole.log(8);结果：3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: XXXXms——&gt;1——&gt;2\n","slug":"32-javascript-simple3","date":"2021-04-13T16:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"f18cc13b06f49583aa6612c15444224c","title":"31、解决点击手机虚拟返回键退出应用","content":"如何解决安卓手机点击虚拟返回键退出当前应用。\n\n\n一、问题描述：\n最近的项目是使用Vue全家桶+HBuilder打包开发一个移动端APP。在测试的时候发现，当安卓手机使用虚拟按钮的时候，点击虚拟按钮的返回键，APP会直接退出。这是因为安卓手机自带back虚拟按键，如果不修改其默认事件，点一下app就退出了，所以需要修改这个按键默认事件事件的代码。\n二、解决办法：\n在index.html中加入一个script，加上如下代码：\n\n点我展示代码\n\njavascript&lt;script&gt;\n    document.addEventListener(&#39;plusready&#39;, function () &#123;\n        var first = null;\n        var webview = plus.webview.currentWebview();\n        plus.key.addEventListener(&#39;backbutton&#39;, function () &#123;\n            webview.canBack(function (e) &#123;\n                if (e.canBack) &#123;\n                    webview.back(); //这里不建议修改自己跳转的路径  \n                &#125; else &#123;\n                    //首次按键，提示‘再按一次退出应用’  \n                    if (!first) &#123;\n                      first = new Date().getTime(); //获取第一次点击的时间戳  \n                      plus.nativeUI.toast(&quot;再按一次退出应用&quot;, &#123;\n                        duration: &#39;short&#39;\n                      &#125;); //通过H5+ API 调用Android 上的toast 提示框  \n                      setTimeout(function () &#123;\n                        first = null;\n                      &#125;, 1000);\n                    &#125; else &#123;\n                        // 获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次, \n                      if (new Date().getTime() - first &lt; 1000) &#123;  \n                        plus.runtime.quit(); //退出应用  \n              &#125;\n            &#125;\n          &#125;\n        &#125;)\n      &#125;);\n    &#125;);\n    &lt;/script&gt;","slug":"31-back","date":"2021-03-23T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"411f39ec2fc2f918d06983313497452a","title":"30、v-for 和 v-if 优先级","content":"v-for 和 v-if 优先级在vue2.x和vue3.x是相反的。\n\n\n1、实践中，不应该将v-for和v-if放在一起\n2、Vue2中，v-for的优先级是高于v-if，把他们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这样会比较浪费性能；而在Vue3中则跟Vue2完全相反，v-if的优先级是高于v-for的，所以v-if执行时，它调用的变量哈不存在，会导致异常。\n3、2种场景的应用：（1）为了过滤列表肿的项目（v-for&#x3D;”user in users” v-if&#x3D;”user.isActive”   ）。这种情况，我们可以使用计算属性，定义一个activeUsers，让其返回过滤后的列表即可（“users.filter(u &#x3D;&gt; u.isActive)”）  (2)为了避免渲染本应该被隐藏的列表（v-for&#x3D;”user in users” v-if&#x3D;”shouldShowUsers”）。此时v-if移动到容器元素上（比如ul ol）或者外面包一层template即可\n4、Vue文档明确指出v-if和v-for不要同事用在同一个元素上。\n","slug":"30-v-for-v-if","date":"2021-03-15T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"8b7a4cba80a4355d072b07b5971d183d","title":"29、Vue-虚拟DOM","content":"\n\n虚拟DOM其实就是一棵模拟JavaScript对象作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。\n","slug":"29-vdom","date":"2021-03-11T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"a2249b9bbe96d398497aeead3abf824e","title":"28、vue组件化实践之插槽（二）","content":"插槽：插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用。\n\n\n一、匿名插槽js// comp1\n&lt;div&gt;\n&lt;slot&gt;&lt;/slot&gt;\n&lt;/div&gt;\n\n// parent\n&lt;comp&gt;hello&lt;/comp&gt;二、具名插槽\n\n\n\n\n\n\n\n\n内容分发到子组件指定位置\njs// comp2\n&lt;div&gt;\n&lt;slot&gt;&lt;/slot&gt;\n&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;\n&lt;/div&gt;\n\n// parent\n&lt;comp&gt;\n// 默认插槽用default做参数 具名插槽用插槽名做参数\n&lt;template v-slot:default&gt;具名插槽&lt;/tempalte&gt;\n&lt;template v-slot:content&gt;内容...&lt;/template&gt;\n&lt;/comp&gt;三、作用域插槽\n\n\n\n\n\n\n\n\n分发内容要用到子组件中的数据\njs&lt;div&gt;\n    &lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;\n&lt;/div&gt;\n\n// parent\n&lt;comp&gt;\n// 把v-slot的值指定为作用域上下文对象\n&lt;tempalte v-slot:default=&quot;slotProps&quot;&gt;\n    来自子组件数据：&#123;&#123;slotProps.foo&#125;&#125;\n&lt;/tempalte&gt;\n&lt;/comp&gt;四、实例代码子组件代码如下：\njs// 子组件 Layout.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class=&quot;header&quot;&gt;\n      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;body&quot;&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;footer&quot;&gt;\n      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default &#123;\n    data() &#123;\n      return &#123;\n        remark: [\n          &#39;好好学习，天天向上&#39;,\n          &#39;学习永远不晚&#39;,\n          &#39;学习知识要善于思考,思考,再思考&#39;,\n          &#39;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#39;,\n          &#39;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#39;,\n          &#39;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#39;,\n          &#39;三人行必有我师焉；择其善者而从之，其不善者而改之&#39;\n        ]\n      &#125;\n    &#125;,\n    computed: &#123;\n      footerContent() &#123;\n        return this.remark[new Date().getDay() - 1] \n      &#125;\n    &#125;,\n  &#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n.header &#123;\n  background-color: rgb(252, 175, 175);\n&#125;\n.body &#123;\n  display: flex;\n  background-color: rgb(144, 250, 134);\n  min-height: 100px;\n  align-items: center;\n  justify-content: center;\n&#125;\n.footer &#123;\n  background-color: rgb(114, 116, 255);\n&#125;\n&lt;/style&gt;父组件代码如下：\njs//父组件 index.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;插槽&lt;/h2&gt;\n    &lt;!-- 插槽 --&gt;\n    &lt;Layout&gt;\n      &lt;!-- 具名插槽 --&gt;\n      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;\n      &lt;!-- 匿名插槽 --&gt;\n      &lt;template&gt;content...&lt;/template&gt;\n      &lt;!-- 作用域插槽 --&gt;\n      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;\n    &lt;/Layout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import Layout from &#39;@/components/slots/Layout.vue&#39;\n  \n  export default &#123;\n    components: &#123;\n      Layout\n    &#125;,\n  &#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;","slug":"28-vue-component2","date":"2021-02-23T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"3ab6d240e6d313e0994da92010163b36","title":"27、vue组件化实践之组件通信（一）","content":"vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护性，便于多人协同开发。\n\n\n一、组件通信常用方式1、props\n\n\n\n\n\n\n\n\n\n父组件传给子组件\n父子组件交互，props和$emit\njs// child\nprops:&#123;msg:String&#125;\n// parent\n&lt;HelloWorld msg=&quot;hello vue&quot; /&gt;2、自定义事件\n\n\n\n\n\n\n\n\n\n子传父\njs//child\nthis.$emit(&#39;add&#39;,good)\n// parent\n&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;3、eventBus事件总线\n\n\n\n\n\n\n\n\n\n任意两个组件之间的传值常用事件总线或者vuex\n4、$parent和$root\n\n\n\n\n\n\n\n\n\n兄弟组件之间通信可通过共同父辈搭桥，$parent或$root\njs// brother1\nthis.$parent.$on(&#39;foo&#39;,handle)\n// brother2\nthis.$parent.$emit(&#39;foo&#39;)5、$children\n\n\n\n\n\n\n\n\n\n父组件可通过$children访问子组件实现父子通信\njs// parent\nthis.$children[0].xx=&#39;xxx&#39;6、$attrs、$listeners\n\n\n\n\n\n\n\n\n\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v- bind&#x3D;”$attrs” 传入内部组件——在创建高级别的组件时非常有用。\njs// child:未在props中声明foo\n&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;\n// parent\n&lt;HelloWorld foo=&quot;foo&quot;&gt;7、refs\n\n\n\n\n\n\n\n\n\n获取子节点引用\njs// parent\n&lt;HelloWorld ref=&quot;wrap&quot;&gt;\nmounted()&#123;\n    this.$refs.wrap.xx = &quot;xxx&quot;\n&#125;8、provide&#x2F;inject\n\n\n\n\n\n\n\n\n\n能够实现祖先和后代之间的传值\n","slug":"27-vue-component","date":"2021-02-19T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"d6999d41227cb37b6246d13fc1c11309","title":"26、关于v-for的key值为什么不能是index？","content":"从实际的案例发现到在使用 v-for 时，将 key 值写成了 index，出现的问题。与其使用 index 作为 key ，不如完全不写 key，因为他们的性能是一样。比如一个列表长度为 10，用 index 作为 key ，各 item 的 key 值依次就是 0-9， 然后 reverse() 一下，列表的的 key 还是 0-9。在依次 patch 这 10 个 item 的时候，sameVnode() 全部返回真（因为 tag 和 key 都一样）。再看另外一种情况，如果不写 key ， 那这 10 个 item 的 key 全部是 undefined, 在 sameVnode() 也是全部返回真（因为 tag 相同，key 也相同：key 都是 undefined）。所以得出结论，如果使用 index 作为 key，不如干脆不写 key 了，还能省下代码。\n\n\n一、案例 bug 复现父组件代码：\njs// 父组件\n&lt;Child\n    v-for=&quot;(item,index) in list&quot;\n    :key=&quot;index&quot;\n    :count=&quot;item.count&quot;\n    :name=&quot;item.name&quot;\n    @delete=&quot;handleDelete(index)&quot;\n/&gt;\n\n// data\nlist:[\n    &#123;\n        count:1,\n        name:&quot;1&quot;\n    &#125;,\n    &#123;\n        count:2,\n        name:&quot;2&quot;\n    &#125;,\n       &#123;\n        count:3,\n        name:&quot;3&quot;\n    &#125;,\n]\n// method\nhandelDelete(index)&#123;\n    this.list.splice(index,1)\n&#125;子组件代码：\njs// 子组件\n&lt;div&gt;\n&lt;span&gt;\n    &#123;&#123;name&#125;&#125;\n&lt;/span&gt;\ncount：&#123;&#123; innerCount &#125;&#125;\n&lt;button @click=&quot;$emit(&#39;delete)&quot;&gt;&lt;/button&gt;delete&lt;/button&gt;\n&lt;/div&gt;\n// props\nprops:&#123;\n    count:&#123;\n        type:Number,\n        default:0\n    &#125;,\n    name:&#123;\n        type:String,\n        default:&#39;&#39;\n    &#125;\n&#125;\n// data\ndata()&#123;\n    retrun&#123;\n        // 子组件下面的这行代码定义了自己的状态，无法使用index作为key值\n        innerCount:this.count\n    &#125;\n&#125;\n当删除的时候，看上去是成功了，其实存在问题。加上排序也是存在问题。\n将 v-for 里面的 key 换成 item 后，是正常的。\nVue 官网的描述：\n\n\n\n\n\n\n\n\n\n当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。\n\n\n\n\n\n\n\n\n\n这个默认的模式是高效的，但是只适用于不依赖子组件装填或临时 DOM 状态的列表渲染输出。\n二、总结写列表渲染时，依赖子组件状态或者临时 DOM 状态的情况，如果存在删除、增加、排序这样的功能，不能将 index 作为 key 值。\n这里还包括 diff 算法…(待添加)\n","slug":"26-v-for-index","date":"2021-02-13T16:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"2fca6c367eeec042553aacd0cb248a4e","title":"25、vue使用hls.js处理m3u8格式的视频","content":"m3u8 文件是指 UTF-8 编码格式的 m3u 文件。m3u 文件是记录了一个索引纯文本文件,打开它时播放软件并不是播放它,而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。\n\n\n\n\n\n\n\n\n\n\n\nHLS 与 M3U8 HLS(全称:Http Live Streaming)是由 Apple 公司定义的用于实时流传输的协议\n公司项目中使用了视频监控功能，需要在系统内显示 m3u8 格式的视频。\n1、安装 hls.js 插件或者使用 CDN 引入\njsnpm install hls.js --save\n// 或者\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;2、业务代码如下：\nhtml&lt;video\n  ref=&quot;video&quot;\n  id=&quot;myVideo2&quot;\n  class=&quot;video-js vjs-default-skin vjs-big-play-centered&quot;\n  autoplay=&quot;autoplay&quot;\n  controls\n  style=&quot;width: 100%; height: 280px; margin-top: 5px&quot;\n&gt;&lt;/video&gt;jsimport Hls from &quot;hls.js&quot;;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      hls: null,\n    &#125;;\n  &#125;,\n  methods: &#123;\n    getStream(source) &#123;\n      if (Hls.isSupported()) &#123;\n        this.hls = new Hls();\n        this.hls.loadSource(source);\n        this.hls.attachMedia(this.$refs.video);\n        this.hls.on(Hls.Events.MANIFEST_PARSED, () =&gt; &#123;\n          this.$refs.video.play();\n        &#125;);\n        this.hls.on(Hls.Events.ERROR, (event, data) =&gt; &#123;\n          this.$message(&quot;视频加载失败&quot;);\n        &#125;);\n      &#125;else&#123;\n        this.$message(&quot;格式不支持&quot;)\n      &#125;\n    &#125;,\n  &#125;,\n  // 从接口获取的视频资源应当写在mounted里面，否则容易出现进入视频页面的时候，视频加载不出来的现象\n  mounted() &#123;\n    this.$service.get(&quot;demo/test&quot;).then((res) =&gt; &#123;\n      this.getStream(res.data[1].hls);\n    &#125;);\n  &#125;,\n&#125;;","slug":"25-hls","date":"2021-01-08T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"963b893698da962cbe76459b859486c1","title":"24、CSS3：linear-gradient线性渐变和radial-gradient径向渐变的使用","content":"linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。\n创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。\n\nradial-gradient()径向渐变由它的中心定义。\n为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。\n一、使用方法html// html\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;css.box&#123; \n    width:100px;\n    height:100px;\n    /* 线性渐变 */\n    /* 从上到下 由黄色变为红色变为蓝色 */\n    background:linear-gradient(yellow,red,blue);\n    /* 渐变轴为45度，从蓝色渐变到红色 */\n    background:linear-gradient(45deg, blue, red);\n    /* 从右下到左上、从蓝色渐变到红色 */\n    background:linear-gradient(to left top, blue, red);\n    /* 从下到上，从蓝色开始渐变、到高度40%位置是绿色渐变开始、最后以红色结束 */\n    background:linear-gradient(0deg, blue, green 40%, red); &#125;\n\n    /* 径向渐变 */\n    /* 中心红色 红色周围为黄色 周边为绿色  */\n    background-image: radial-gradient(red, yellow, green)\n二、不同浏览器的支持html&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n// css\n.box&#123; \n    &lt;!-- chrome --&gt;\n    background: -webkit-linear-gradient(to right, red, green); \n    &lt;!-- Opera --&gt;\n    background:-o-linear-gradient(to right,to right, red, green); \n    &lt;!-- Firefox --&gt;\n    background:-moz-linear-gradient (to right, to right, red, green); \n\n    background:linear-gradient(to right, to right, red, green); &#125;三、语法css/* linear-gradient 线性渐变 */\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...);\n/* radial-gradient 径向渐变*/\nbackground-image: radial-gradient(shape size at position, start-color, ..., last-color);\n四、实际应用如dashboard首页有四个盒子，每个盒子的背景渐变色是不同的，使用scss css预处理器的写法。\n1、mixin.scsscss/*  */\n@mixin cardBg($leftColor, $rightColor) &#123;\n  background: -webkit-linear-gradient(to right, $leftColor, $rightColor);\n  background: -o-linear-gradient(to right, $leftColor, $rightColor);\n  background: -moz-linear-gradient (to right, $leftColor, $rightColor);\n  background: linear-gradient(to right, $leftColor, $rightColor);\n&#125;2、页面引入mixin.scss\n\n\n\n\n\n\n\n\n下面的@include 是调用mixin的cardBg变量\ncss@import &#39;&#39;./mixin.scss\n\n.cardList-wrapper&#123;\n    box-sizing:border-box;\n    heitht:150px;\n    padding:15px 15px 0;\n    border-radius:6px;\n    cursor:pointer;\n    margin-bottom:25px;\n    box-shadow:3px 5px 15px rgba(40,40,40,0.36);\n    /* 第一个盒子 */\n    &amp;.card-item-one&#123;\n        @include cardBg(#5171fd,#c97afd);\n        &amp;:hover&#123;\n            box-shadow:0 5px 10px #c97afd;\n        &#125;\n    &#125;\n    /* 第二个盒子 */\n    &amp;.card-item-two &#123;\n      @include cardBg(#3dadf6, #737bfc);\n       &amp;:hover &#123;\n        box-shadow: 0 5px 10px #737bfc;\n      &#125;\n    &#125;\n    /* 第三个盒子 */\n    &amp;.card-item-three &#123;\n      @include cardBg(#ea677c, #ef9b5f);\n       &amp;:hover &#123;\n        box-shadow: 0 5px 10px #ef9b5f;\n      &#125;\n    &#125;\n    /* 第四个盒子 */\n    &amp;.card-item-four &#123;\n      @include cardBg(#42d79b, #a6e25f);\n       &amp;:hover &#123;\n        box-shadow: 0 5px 10px #a6e25f;\n      &#125;\n    &#125;\n    /* 四个盒子在hover时都会变大一些 */\n    &amp;:hover &#123;\n      transform: scale(1.03);\n      transition: all 0.1s ease-out;\n    &#125;\n&#125;","slug":"24-css3-linear-gradient","date":"2020-08-11T16:00:00.000Z","categories_index":"","tags_index":"css","author_index":"Jude"},{"id":"a9718a8b31e3309691af7f5cd712f73b","title":"23、百度地图动画（轨迹动画）","content":"百度地图动画及轨迹动画\n\n\n一、百度地图动画html&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;tools&quot;&gt;\n  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;\n  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;\n&lt;/div&gt;\n点我展开js代码\n\njsvar bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例\nbmap.centerAndZoom(new BMapGL.Point(116.414, 39.915), 20); // 初始化地图，设置中心点坐标和地图级别\nbmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放\nbmap.setTilt(20); // 设置地图初始倾斜角度\nvar keyFrames = [\n  &#123;\n    center: new BMapGL.Point(116.307092, 40.054922),\n    zoom: 20,\n    tilt: 50,\n    heading: 0,\n    percentage: 0,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.307631, 40.055391),\n    zoom: 21,\n    tilt: 70,\n    heading: 0,\n    percentage: 0.1,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.306858, 40.057887),\n    zoom: 21,\n    tilt: 70,\n    heading: 0,\n    percentage: 0.25,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.306858, 40.057887),\n    zoom: 21,\n    tilt: 70,\n    heading: -90,\n    percentage: 0.35,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.307904, 40.058118),\n    zoom: 21,\n    tilt: 70,\n    heading: -90,\n    percentage: 0.45,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.307904, 40.058118),\n    zoom: 21,\n    tilt: 70,\n    heading: -180,\n    percentage: 0.55,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.308902, 40.055954),\n    zoom: 21,\n    tilt: 70,\n    heading: -180,\n    percentage: 0.75,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.308902, 40.055954),\n    zoom: 21,\n    tilt: 70,\n    heading: -270,\n    percentage: 0.85,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.307779, 40.055754),\n    zoom: 21,\n    tilt: 70,\n    heading: -360,\n    percentage: 0.95,\n  &#125;,\n  &#123;\n    center: new BMapGL.Point(116.307092, 40.054922),\n    zoom: 20,\n    tilt: 50,\n    heading: -360,\n    percentage: 1,\n  &#125;,\n];\nvar opts = &#123;\n  duration: 10000, // 设置每次迭代动画持续时间\n  delay: 3000, // 设置动画延迟开始时间\n  interation: &quot;INFINITE&quot;, // 设置动画迭代次数\n&#125;;\nvar animation = new BMapGL.ViewAnimation(keyFrames, opts); // 初始化动画实例\nanimation.addEventListener(&quot;animationstart&quot;, function (e) &#123;\n  // 监听动画开始事件\n  console.log(&quot;start&quot;);\n&#125;);\nanimation.addEventListener(&quot;animationiterations&quot;, function (e) &#123;\n  // 监听动画迭代事件\n  console.log(&quot;onanimationiterations&quot;);\n&#125;);\nanimation.addEventListener(&quot;animationend&quot;, function (e) &#123;\n  // 监听动画结束事件\n  console.log(&quot;end&quot;);\n&#125;);\nanimation.addEventListener(&quot;animationcancel&quot;, function (e) &#123;\n  // 监听动画中途被终止事件\n  console.log(&quot;cancel&quot;);\n&#125;);\ndocument.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;\n  bmap.startViewAnimation(animation); // 开始播放动画\n&#125;);\ndocument.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;\n  bmap.cancelViewAnimation(animation); // 强制停止动画\n&#125;);\n\n二、百度地图轨迹动画js&lt;scrip\n  type=&quot;text/javascript&quot;\n  src=&quot;https://api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js&quot;\n&gt;&lt;/scrip&gt;html&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;tools&quot;&gt;\n  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;\n  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;\n&lt;/div&gt;\n点我展开js代码\n\njsvar bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例\nbmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图，设置中心点坐标和地图级别\nbmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放\nvar path = [\n  &#123;\n    lng: 116.297611,\n    lat: 40.047363,\n  &#125;,\n  &#123;\n    lng: 116.302839,\n    lat: 40.048219,\n  &#125;,\n  &#123;\n    lng: 116.308301,\n    lat: 40.050566,\n  &#125;,\n  &#123;\n    lng: 116.305732,\n    lat: 40.054957,\n  &#125;,\n  &#123;\n    lng: 116.304754,\n    lat: 40.057953,\n  &#125;,\n  &#123;\n    lng: 116.306487,\n    lat: 40.058312,\n  &#125;,\n  &#123;\n    lng: 116.307223,\n    lat: 40.056379,\n  &#125;,\n];\nvar point = [];\nfor (var i = 0; i &lt; path.length; i++) &#123;\n  point.push(new BMapGL.Point(path[i].lng, path[i].lat));\n&#125;\nvar pl = new BMapGL.Polyline(point);\nvar trackAni = new BMapGLLib.TrackAnimation(bmap, pl, &#123;\n  overallView: true, // 动画完成后自动调整视野到总览\n  tilt: 30, // 轨迹播放的角度，默认为55\n  duration: 20000, // 动画持续时长，默认为10000，单位ms\n  delay: 3000, // 动画开始的延迟，默认0，单位ms\n&#125;);\ndocument.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;\n  trackAni.start();\n&#125;);\ndocument.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;\n  trackAni.cancel(); // 强制停止动画\n&#125;);\n","slug":"23-bmap-animate","date":"2020-04-30T12:00:00.000Z","categories_index":"","tags_index":"bmap","author_index":"Jude"},{"id":"b2da7bb75bb559082827be55e9ee2174","title":"22、百度地图LBS云检索","content":"百度地图自定义叠加层\n\n\n\n\n\n\n\n\n\n\n\nLBS 云服务提供海量位置数据的实时存储功能，JavaScript API 支持将用户上传到 LBS 云里的位置数据实时渲染成图层\n1、安装 vue-baidu-map\nbashnpm install vue-baidu-map2、具体业务代码如下:\nhtml&lt;baidu-map\n  id=&quot;container&quot;\n  :scroll-wheel-zoom=&quot;true&quot;\n  :zoom=&quot;zoom&quot;\n  center=&quot;上海&quot;\n  :ak=&quot;selfKey&quot;\n  inertial-dragging\n  @ready=&quot;mapReady&quot;\n&gt;\n&lt;/baidu-map&gt;\n&lt;div class=&quot;menu-search&quot;&gt;\n  &lt;el-input placeholder=&quot;请输入站点名称&quot; v-model=&quot;site_name&quot; clearable&gt;\n    &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot; @click=&quot;search&quot;&gt;&lt;/el-button&gt;\n  &lt;/el-input&gt;\n&lt;/div&gt;\n点我展开js代码\n\njs&lt;script&gt;\n// 在组件中引入vue-baidu-map\nimport BaiduMap from &quot;vue-baidu-map/components/map/Map.vue&quot;;\nexport default&#123;\n    components:&#123;BaiduMap&#125;,\n    data()&#123;\n        return&#123;\n            site_name:&#39;&#39;,\n            center:&#123;lng:121.532325,lat:31.232742&#125;,\n            selfKey:&#39;QloR7bQpWed3VDLbtcxi2NmgUcvXxcbx&#39;,\n            point:&#39;&#39;,\n            zoom:15\n        &#125;\n    &#125;,\n    mounted()&#123;\n        this.mapReady()\n    &#125;,\n    methods:&#123;\n        mapReady()&#123;\n            var map = new BMap.Map(&quot;container&quot;)\n            map.centerAndZoom(new BMap.Point(this.center.lng,ths.center.lat),10)\n            map.enableScrollWheelZoom()\n                  /**\n       *params   q:检索关键字\n       *params   tags：空格分割的多字符\n       *params   filter:过滤条件\n       */\n            var customLayer;\n            customLayer = new BMap.CustomLayer(&#123;\n                geotableId: 183323,\n                q: &quot;&quot;,\n                tags: &quot;&quot;,\n                filter: &quot;&quot;,\n            &#125;);\n            map.addTileLayer(customLayer);\n            // 热点图层\n            customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);\n            function callback(e) &#123;\n                var customPoi = e.customPoi;\n                var content =\n                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +\n                     customPoi.address +\n                    &quot;&lt;br/&gt;&quot; +\n                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +\n                    &quot;&lt;/p&gt;&quot;;\n                var BMapLib = window.BMapLib;\n                var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;\n                        title: customPoi.title,\n                        width: 200,\n                        height: 100,\n                        panel: &quot;panel&quot;,\n                        enableAutoPan: true,\n                        enableSendToPhone: false,\n                        searchTypes: [],\n                &#125;);\n                var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);\n                searchInfoWindow.open(point);\n            &#125;\n        &#125;,\n          search() &#123;\n                var map = new BMap.Map(&quot;container&quot;);\n                map.centerAndZoom(new BMap.Point(this.center.lng, this.center.lat), 10);\n                map.enableScrollWheelZoom();\n                var customLayer;\n                customLayer = new BMap.CustomLayer(&#123;\n                    geotableId: 183323,\n                    q: this.site_name || &quot;新西北物流园&quot;,\n                    tags: &quot;&quot;,\n                    filter: &quot;&quot;,\n                &#125;);\n                // 添加自定义图层\n                map.addTileLayer(customLayer);\n\n                // var mapDom = document.getElementById(&quot;container&quot;)\n                // mapDom.addEventListener(&quot;click&quot;, function () &#123;\n                //   window.location.href = &quot;./monitor/index&quot;;\n                // &#125;);\n                // 热点图层\n                customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);\n                function callback(e) &#123;\n                    var customPoi = e.customPoi;\n                    var content =\n                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +\n                    customPoi.address +\n                    &quot;&lt;br/&gt;&quot; +\n                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +\n                    &quot;&lt;/p&gt;&quot;;\n                    var BMapLib = window.BMapLib;\n                    // console.log(&quot;BMapLib&quot;, BMapLib);\n                    var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;\n                    title: customPoi.title,\n                    width: 200,\n                    height: 100,\n                    panel: &quot;panel&quot;,\n                    enableAutoPan: true,\n                    enableSendToPhone: false,\n                    searchTypes: [],\n                    &#125;);\n                    var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);\n                    searchInfoWindow.open(point);\n                &#125;\n    &#125;,\n    &#125;\n&#125;\n&lt;/script&gt;\n\n&lt;/details&gt;\n","slug":"22-bmap","date":"2020-04-29T12:00:00.000Z","categories_index":"","tags_index":"bmap","author_index":"Jude"},{"id":"cf3bef3f95cd79eeea50dec1d0952a0d","title":"21、v-charts的options","content":"v-charts 的 options 使用 getOptions()而不是使用一个变量\n\n\n\n\n\n\n\n\n\n\n\n\n使用 getOptions()是为了获取数据之后才进行渲染数据，v-chart 的 options 可以直接绑定一个变量,在请求数据的时候，更新变量，图表需要进行重新渲染\n这里的 getOptions()也可以写在 computed 里面的。\nhtml&lt;template&gt;\n    &lt;v-charts :options=&quot;getOptions()&quot;&gt;\n&lt;/template&gt;\n\n点我展示js代码\n\njs getOptions() &#123;\n        return &#123;\n          grid: &#123;\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n          &#125;,\n          xAxis: &#123;\n            type: &#39;value&#39;,\n            show: false\n          &#125;,\n          yAxis: &#123;\n            type: &#39;category&#39;,\n            show: false\n          &#125;,\n          series: [&#123;\n            name: &#39;上月平台用户数&#39;,\n            type: &#39;bar&#39;,\n            stack: &#39;总量&#39;,\n            data: [this.userLastMonth],\n            barWidth: 10,\n            itemStyle: &#123;\n              color: &#39;#45c946&#39;\n            &#125;\n          &#125;, &#123;\n            name: &#39;今日平台用户数&#39;,\n            type: &#39;bar&#39;,\n            stack: &#39;总量&#39;,\n            data: [this.userTodayNumber],\n            itemStyle: &#123;\n              color: &#39;#eee&#39;\n            &#125;\n          &#125;, &#123;\n            type: &#39;custom&#39;,\n            stack: &#39;总量&#39;,\n            data: [this.userLastMonth],\n            renderItem: (params, api) =&gt; &#123;\n              const value = api.value(0)\n              const endPoint = api.coord([value, 0])\n              return &#123;\n                type: &#39;group&#39;,\n                position: endPoint,\n                children: [&#123;\n                  type: &#39;path&#39;,\n                  shape: &#123;\n                    d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,\n                    x: -5,\n                    y: -20,\n                    width: 10,\n                    height: 10,\n                    layout: &#39;cover&#39;\n                  &#125;,\n                  style: &#123;\n                    fill: &#39;#45c946&#39;\n                  &#125;\n                &#125;, &#123;\n                  type: &#39;path&#39;,\n                  shape: &#123;\n                    d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,\n                    x: -5,\n                    y: 10,\n                    width: 10,\n                    height: 10,\n                    layout: &#39;cover&#39;\n                  &#125;,\n                  style: &#123;\n                    fill: &#39;#45c946&#39;\n                  &#125;\n                &#125;]\n              &#125;\n            &#125;\n          &#125;]\n        &#125;\n      &#125;","slug":"21-v-charts","date":"2020-04-28T12:00:00.000Z","categories_index":"","tags_index":"v-charts","author_index":"Jude"},{"id":"3e3d88beb2e4498a6e96fa40e6c682b7","title":"20、axios的封装","content":"\n\n\n\n\n\n\n\n\naxios 基于 promise 的 http 库 特性：拦截请求和响应、取消请求、转换 json、客户端防御 XSRF\n\n\n当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。\n所以记住：\n\n\n\n\n\n\n\n\n\n在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。\njsservice.interceptors.response.use(\n  (response) =&gt; &#123;\n    if (response.status === 200 &amp;&amp; response.data) &#123;\n      return response.data;\n    &#125; else &#123;\n      return Promise.reject(new Error(&quot;请求失败&quot;));\n    &#125;\n  &#125;,\n  (error) =&gt; &#123;\n    return Promise.reject(error);\n  &#125;\n);1、axios 的安装jsnpm install axios2、在 request 文件夹 http.jsjs// http.js\nimport axios from &quot;axios&quot;;\nimport QS from &quot;qs&quot;; // 序列化post类型的数据\nimport &#123; Toast &#125; from &quot;vant&quot;; // 引入vant组件库的toast组件3、环境的切换&#x2F;请求超时&#x2F;post 请求头设置js// 环境的切换\nif (process.env.NODE_ENV == &quot;development&quot;) &#123;\n  axios.defaults.baseURL = &quot;https://www.baidu.com&quot;;\n&#125; else if (process.env.NODE_ENV == &quot;debug&quot;) &#123;\n  axios.defaults.baseURL = &quot;https://www.ceshi.com&quot;;\n&#125; else if (process.env.NODE_ENV == &quot;production&quot;) &#123;\n  axios.defaults.baseURL = &quot;https://www.production.com&quot;;\n&#125;\n\naxios.defaults.timeout = 10000;\n\naxios.defaults.headers.post[&quot;Content-Type&quot;] =\n  &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;;4、请求拦截 响应拦截\n点击展示代码\n\njs// 先导入vuex,因为我们要使用到里面的状态对象\n// vuex的路径根据自己的路径去写\nimport store from &#39;@/store/index&#39;;\n\n// 请求拦截器\naxios.interceptors.request.use(\n    config =&gt; &#123;\n        // 每次发送请求之前判断vuex中是否存在token\n        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况\n        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n        const token = store.state.token;\n        token &amp;&amp; (config.headers.Authorization = token);\n        return config;\n    &#125;,\n    error =&gt; &#123;\n        return Promise.error(error);\n    &#125;\n)\n\n// 响应拦截器\naxios.interceptors.response.use(\n    response =&gt; &#123;\n        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据\n        // 否则的话抛出错误\n        if (response.status === 200) &#123;\n            return Promise.resolve(response);\n        &#125; else &#123;\n            return Promise.reject(response);\n        &#125;\n    &#125;,\n    // 服务器状态码不是2开头的的情况\n    // 这里可以跟你们的后台开发人员协商好统一的错误状态码\n    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等\n    // 下面列举几个常见的操作，其他需求可自行扩展\n    error =&gt; &#123;\n        if (error.response.status) &#123;\n            switch (error.response.status) &#123;\n                // 401: 未登录\n                // 未登录则跳转登录页面，并携带当前页面的路径\n                // 在登录成功后返回当前页面，这一步需要在登录页操作。\n                case 401:\n                    router.replace(&#123;\n                        path: &#39;/login&#39;,\n                        query: &#123;\n                            redirect: router.currentRoute.fullPath\n                        &#125;\n                    &#125;);\n                    break;\n                // 403 token过期\n                // 登录过期对用户进行提示\n                // 清除本地token和清空vuex中token对象\n                // 跳转登录页面\n                case 403:\n                     Toast(&#123;\n                        message: &#39;登录过期，请重新登录&#39;,\n                        duration: 1000,\n                        forbidClick: true\n                    &#125;);\n                    // 清除token\n                    localStorage.removeItem(&#39;token&#39;);\n                    store.commit(&#39;loginSuccess&#39;, null);\n                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面\n                    setTimeout(() =&gt; &#123;\n                        router.replace(&#123;\n                            path: &#39;/login&#39;,\n                            query: &#123;\n                                redirect: router.currentRoute.fullPath\n                            &#125;\n                        &#125;);\n                    &#125;, 1000);\n                    break;\n\n                // 404请求不存在\n                case 404:\n                    Toast(&#123;\n                        message: &#39;网络请求不存在&#39;,\n                        duration: 1500,\n                        forbidClick: true\n                    &#125;);\n                    break;\n                // 其他错误，直接抛出错误提示\n                default:\n                    Toast(&#123;\n                        message: error.response.data.message,\n                        duration: 1500,\n                        forbidClick: true\n                    &#125;);\n            &#125;\n            return Promise.reject(error.response);\n        &#125;\n    &#125;\n&#125;);\n\n5、get、post 请求的封装\n\n\n\n\n\n\n\n\nget 方法：我们通过定义一个 get 函数，get 函数有两个参数，第一个参数表示我们要请求的 url 地址，第二个参数是我们要携带的请求参数。get 函数返回一个 promise 对象，当 axios 其请求成功时 resolve 服务器返回 值，请求失败时 reject 错误值。最后通过 export 抛出 get 函数。\n\n点击展示代码\n\njs/**\n * get方法，对应get请求\n * @param &#123;String&#125; url [请求的url地址]\n * @param &#123;Object&#125; params [请求时携带的参数]\n */\nexport function get(url, params) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    axios\n      .get(url, &#123;\n        params: params,\n      &#125;)\n      .then((res) =&gt; &#123;\n        resolve(res.data);\n      &#125;)\n      .catch((err) =&gt; &#123;\n        reject(err.data);\n      &#125;);\n  &#125;);\n&#125;\n\n\n\n\n\n\n\n\n\n\n原理同 get 基本一样，但是要注意的是，post 方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过 node 的 qs 模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们 import QS from ‘qs’;的原因\n\n点击展示代码\n\njs/**\n * post方法，对应post请求\n * @param &#123;String&#125; url [请求的url地址]\n * @param &#123;Object&#125; params [请求时携带的参数]\n */\nexport function post(url, params) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    axios\n      .post(url, QS.stringify(params))\n      .then((res) =&gt; &#123;\n        resolve(res.data);\n      &#125;)\n      .catch((err) =&gt; &#123;\n        reject(err.data);\n      &#125;);\n  &#125;);\n&#125;\n\n6、axios 完整封装代码:\n点击展示代码\n\njs/**\n * axios封装\n * 请求拦截、响应拦截、错误统一处理\n */\nimport axios from &quot;axios&quot;;\nimport router from &quot;../router&quot;;\nimport store from &quot;../store/index&quot;;\nimport &#123; Toast &#125; from &quot;vant&quot;;\n\n/**\n * 提示函数\n * 禁止点击蒙层、显示一秒后关闭\n */\nconst tip = (msg) =&gt; &#123;\n  Toast(&#123;\n    message: msg,\n    duration: 1000,\n    forbidClick: true,\n  &#125;);\n&#125;;\n\n/**\n * 跳转登录页\n * 携带当前页面路由，以期在登录页面完成登录后返回当前页面\n */\nconst toLogin = () =&gt; &#123;\n  router.replace(&#123;\n    path: &quot;/login&quot;,\n    query: &#123;\n      redirect: router.currentRoute.fullPath,\n    &#125;,\n  &#125;);\n&#125;;\n\n/**\n * 请求失败后的错误统一处理\n * @param &#123;Number&#125; status 请求失败的状态码\n */\nconst errorHandle = (status, other) =&gt; &#123;\n  // 状态码判断\n  switch (status) &#123;\n    // 401: 未登录状态，跳转登录页\n    case 401:\n      toLogin();\n      break;\n    // 403 token过期\n    // 清除token并跳转登录页\n    case 403:\n      tip(&quot;登录过期，请重新登录&quot;);\n      localStorage.removeItem(&quot;token&quot;);\n      store.commit(&quot;loginSuccess&quot;, null);\n      setTimeout(() =&gt; &#123;\n        toLogin();\n      &#125;, 1000);\n      break;\n    // 404请求不存在\n    case 404:\n      tip(&quot;请求的资源不存在&quot;);\n      break;\n    default:\n      console.log(other);\n  &#125;\n&#125;;\n\n// 创建axios实例\nvar instance = axios.create(&#123; timeout: 1000 * 12 &#125;);\n// 设置post请求头\ninstance.defaults.headers.post[&quot;Content-Type&quot;] =\n  &quot;application/x-www-form-urlencoded&quot;;\n/**\n * 请求拦截器\n * 每次请求前，如果存在token则在请求头中携带token\n */\ninstance.interceptors.request.use(\n  (config) =&gt; &#123;\n    // 登录流程控制中，根据本地是否存在token判断用户的登录情况\n    // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token\n    // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码\n    // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。\n    const token = store.state.token;\n    token &amp;&amp; (config.headers.Authorization = token);\n    return config;\n  &#125;,\n  (error) =&gt; Promise.error(error)\n);\n\n// 响应拦截器\ninstance.interceptors.response.use(\n  // 请求成功\n  (res) =&gt; (res.status === 200 ? Promise.resolve(res) : Promise.reject(res)),\n  // 请求失败\n  (error) =&gt; &#123;\n    const &#123; response &#125; = error;\n    if (response) &#123;\n      // 请求已发出，但是不在2xx的范围\n      errorHandle(response.status, response.data.message);\n      return Promise.reject(response);\n    &#125; else &#123;\n      // 处理断网的情况\n      // eg:请求超时或断网时，更新state的network状态\n      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\n      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明\n      if (!window.navigator.onLine) &#123;\n        store.commit(&quot;changeNetwork&quot;, false);\n      &#125; else &#123;\n        return Promise.reject(error);\n      &#125;\n    &#125;\n  &#125;\n);\n\nexport default instance;\n\n7、token 失效及接口国际化\n点击展示代码\n\njs/**\n * 是否超时\n */\nexport function isCheckTimeout() &#123;\n  // 当前时间戳\n  var currentTime = Date.now();\n  // 缓存时间戳\n  var timeStamp = getTimeStamp();\n  return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE;\n&#125;\n\nimport axios from &quot;axios&quot;;\nimport store from &quot;@/store&quot;;\nimport &#123; ElMessage &#125; from &quot;element-plus&quot;;\nimport &#123; isCheckTimeout &#125; from &quot;@/utils/auth&quot;;\n\nconst service = axios.create(&#123;\n  baseURL: process.env.VUE_APP_BASE_API,\n  timeout: 5000,\n&#125;);\n\n// 请求拦截器\nservice.interceptors.request.use(\n  (config) =&gt; &#123;\n    // 在这个位置需要统一的去注入token\n    if (store.getters.token) &#123;\n      if (isCheckTimeout()) &#123;\n        // 登出操作\n        store.dispatch(&quot;user/logout&quot;);\n        return Promise.reject(new Error(&quot;token 失效&quot;));\n      &#125;\n      // 如果token存在 注入token\n      config.headers.Authorization = `Bearer $&#123;store.getters.token&#125;`;\n    &#125;\n    // 配置接口国际化\n    config.headers[&quot;Accept-Language&quot;] = store.getters.language;\n    return config; // 必须返回配置\n  &#125;,\n  (error) =&gt; &#123;\n    return Promise.reject(error);\n  &#125;\n);\n\n// 响应拦截器\nservice.interceptors.response.use(\n  (response) =&gt; &#123;\n    const &#123; success, message, data &#125; = response.data;\n    //   要根据success的成功与否决定下面的操作\n    if (success) &#123;\n      return data;\n    &#125; else &#123;\n      // 业务错误\n      ElMessage.error(message); // 提示错误消息\n      return Promise.reject(new Error(message));\n    &#125;\n  &#125;,\n  (error) =&gt; &#123;\n    // 处理 token 超时问题\n    if (\n      error.response &amp;&amp;\n      error.response.data &amp;&amp;\n      error.response.data.code === 401\n    ) &#123;\n      // token超时\n      store.dispatch(&quot;user/logout&quot;);\n    &#125;\n    ElMessage.error(error.message); // 提示错误信息\n    return Promise.reject(error);\n  &#125;\n);\n\nexport default service;\n","slug":"20-axios","date":"2020-04-23T12:00:00.000Z","categories_index":"","tags_index":"axios","author_index":"Jude"},{"id":"6bb045c84d2ae45d7a93d08a56bc4883","title":"19、关于echarts官方的一个bug -- sublink跳转问题","content":"echarts 官方的一个 bug – sublink 跳转的问题。echarts版本号为4.8.0\n\n\n开发百度地图 scatter 散点图时，副标题链接跳转出错（版本号为 4.8.0），在 GitHub 找到issues。bug 介绍，点击副标题无法跳转到指定连接\njsthis.options = &#123;\n  title: &#123;\n    text: &quot;我是主标题&quot;,\n    subtext: &quot;我是副标题，我可以跳转&quot;,\n    sublink: &quot;https://www.baidu.com&quot;,\n    left: &quot;center&quot;,\n  &#125;,\n&#125;;1、在 main.js 引入 echarts 和 vue-echarts，将 echarts 绑定到 Vue 原型，引入 vue-echarts 通过 vue.component()进行组件注册\n\n\n\n\n\n\n\n\n\n将 echarts 绑定到 Vue 原型上，可以减少代码量，开发过程中需要使用 echarts 里面提供的方法，如果没有全局引入的话，需要在每个使用 echarts 的页面都需要手动引入。将 vue-echarts 使用组件注册后，提供了属性绑定的方式渲染图表就不需要通过调用 echart 的方法了。\necharts1、echarts 的绘图流程\njs// 1、引入echarts js库\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js&quot;&gt;&lt;/script&gt;html&lt;!-- 2、DOM容器 设置宽高（注意）  --&gt;\n&lt;div id=&quot;charts&quot; style=&quot;width:800px;height:600px&quot;&gt;&lt;/div&gt;js// 3、获取渲染DOM对象\nconst chartDom = document.getElementById(&quot;charts&quot;);\n// 4、初始化echarts对象\nconst chart = echarts.init(chartDom);\n// 5、配置option参数  调用setOption完成渲染\nchart.setOption(&#123;\n  title: &#123;\n    text: &quot;Echarts 示例&quot;,\n  &#125;,\n  xAxis: &#123;\n    data: [&quot;食品&quot;, &quot;数码&quot;, &quot;服饰&quot;, &quot;箱包&quot;],\n  &#125;,\n  yAxis: &#123;&#125;,\n  // 系列： 包括图表的类型 包括：line bar pie等\n  series: &#123;\n    type: &quot;bar&quot;,\n    data: [&quot;100&quot;, &quot;120&quot;, &quot;40&quot;, &quot;160&quot;],\n  &#125;,\n&#125;);2、dataset: 数据集\n\n\n\n\n\n\n\n\n\nECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射\n\n点击展示代码\n\njsconst chartDom = document.getElementById(&quot;chart&quot;);\nconst chart = echarts.init(chartDom);\nconst option = &#123;\n  xAxis: &#123;\n    type: &quot;category&quot;,\n  &#125;,\n  yAxis: &#123;&#125;,\n  dataset: &#123;\n    source: [\n      [&quot;1季度&quot;, 80, 100, &quot;分类1&quot;, 50],\n      [&quot;2季度&quot;, 81, 122, &quot;分类1&quot;, 60],\n      [&quot;3季度&quot;, 76, 90, &quot;分类1&quot;, 55],\n      [&quot;4季度&quot;, 65, 123, &quot;分类1&quot;, 70],\n    ],\n  &#125;,\n  // 系列\n  series: [\n    // 系列 0\n    &#123;\n      type: &quot;pie&quot;,\n      center: [&quot;65%&quot;, 60],\n      radius: 35,\n      encode: &#123;\n        itemName: 3,\n        value: 4,\n      &#125;,\n    &#125;,\n    // 系列 1\n    &#123;\n      type: &quot;line&quot;,\n      encode: &#123;\n        x: 0,\n        y: 2,\n      &#125;,\n    &#125;,\n    // 系列 2\n    &#123;\n      type: &quot;bar&quot;,\n      encode: &#123;\n        x: 0,\n        y: 1,\n      &#125;,\n    &#125;,\n  ],\n&#125;;\nchart.setOption(option);\n\n3、基本组件\n\n\n\n\n\n\n\n\n\necharts 基本组件：title、坐标系的 X（xAxis）轴 Y(yAxis）轴、tooltip 提示框、toolbox 工具栏等\n4、定位\njs// 大多数组件都提供了定位属性，我们可以采用类似 CSS absolute 的定位属性来控制组件的位置 left right height bottom的值可以是数值或者百分比\nvar option = &#123;\n  grid: &#123;\n    left: 120,\n    right: &quot;30%&quot;,\n    height: &quot;40%&quot;,\n    bottom: 100,\n  &#125;,\n&#125;;echarts 常用属性（1）使用 ECharts 绘图后没有图像（这个问题会经常出现，一定要设置宽度高度！！！）\n\n\n\n\n\n\n\n\n\nECharts 绘图后没有任何报错，但是没有图像。可以检查容器是否设置了宽高。因为 ECharts 不会设置默认宽高，如果容器没有设置宽高，则不会展示;如果使用的是 v-chart 则没有这个问题，因为 v-chart 默认了 600*400 的宽高。\n（2）使用 element-ui 的按需引入\n\n\n\n\n\n\n\n\n\n安装vue add element，后续会提示是全部引入或者按需引入，选择按需引入，在 App.vue 中会增加一些 element-ui 的示例代码，后续删除。项目目录会增加一个 plugin 文件夹\n\n\n\n\n\n\n\n\n\n注意：按需引入组件后，再删除 App.vue 以及 view 文件夹内、component 文件夹内的不需要的内容。\njs// main.js\nimport &quot;./plugins/element.js&quot;;js// element.js\nimport Vue from &quot;vue&quot;;\nimport &#123; Card, Col, Row &#125; from &quot;element-ui&quot;;\n\nVue.use(Card);\nVue.use(Col);\nVue.use(Row);（3）vue 使用 echarts\njs// main.js 引入echarts 挂载到Vue实例\nimport ECharts from &quot;echarts&quot;;\nVue.prototype.$echarts = ECharts;（4）echarts 的常用属性\n\n\n\n\n\n\n\n\n\n1、隐藏线条 - listStyle\njslistStyle: &#123;\n  width: 0;\n&#125;\n\n\n\n\n\n\n\n\n2、隐藏数据点 - itemStyle\njsitemStyle: &#123;\n  opacity: 0;\n&#125;\n\n\n\n\n\n\n\n\n3、折线图填充面积区域颜色 - areaStyle\njsareaStyle: &#123;\n  color: &quot;purple&quot;;\n&#125;\n\n\n\n\n\n\n\n\n4、折线图平滑显示 - smooth\njssmooth: true;\n\n\n\n\n\n\n\n\n5、柱状图聚合 - stack\njsseries: [\n  &#123;\n    type: &quot;bar&quot;,\n    stack: &quot;总量&quot;,\n    data: [100],\n  &#125;,\n  &#123;\n    type: &quot;bar&quot;,\n    stack: &quot;总量&quot;,\n    data: [250],\n  &#125;,\n];\n\n\n\n\n\n\n\n\n6、自定义绘图(重点)\njs&#123;\n  type: &#39;custom&#39;,\n  stack: &#39;总量&#39;,\n  data: [100],\n  renderItem: (params, api) =&gt; &#123;\n    //  console.log(params,api);\n    const value = api.value(0)\n    const endPoint = api.coord([value, 0])\n    return &#123;\n      type: &#39;group&#39;,\n      position: endPoint,\n      children: [&#123;\n        type: &#39;path&#39;,\n        shape: &#123;\n          d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,// 这里是svg里面的d\n          x: -5,\n          y: -20,\n          width: 10,\n          height: 10,\n          layout: &#39;cover&#39;\n        &#125;,\n        style: &#123;\n          fill: &#39;#45c946&#39;\n        &#125;\n      &#125;, &#123;\n        type: &#39;path&#39;,\n        shape: &#123;\n          d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,\n          x: -5,\n          y: 10,\n          width: 10,\n          height: 10,\n          layout: &#39;cover&#39;\n        &#125;,\n        style: &#123;\n          fill: &#39;#45c946&#39;\n        &#125;\n      &#125;]\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n7、xAxis x 轴\njs// 消除x轴两侧边距\nboundaryGap: false\n// 柱状图宽度\nbarWidth: &#39;60%&#39;\nbarWidth: 10\n// 条形图 type设置方法\nxAxis: &#123;\n  type: &#39;value&#39;\n&#125;,\nyAxis: &#123;\n  type: &#39;category&#39;\n&#125;\n\n\n\n\n\n\n\n\n8、echarts 类目轴和非类目轴\n\n\n\n\n\n\n\n\n\n类目轴的意思就是坐标轴上的展示信息是否是数据连贯，非类目轴就是除了标签类型为类目的其他坐标轴，有 时间（time），数值（value），对数（log）3 种。标签类型为类目是指 type:category\n坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样。类目轴中  boundaryGap  可以配置为  true  和  false。默认为  true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap 是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置  min  和  max  后无效。\n","slug":"19-echarts","date":"2020-04-20T12:00:00.000Z","categories_index":"","tags_index":"ECharts","author_index":"Jude"},{"id":"25faec199e72dbca05cd700593f344e2","title":"18、如何使用canvas压缩图片？","content":"\n\n\n\n\n\n\n\n\ncanvas 是 HTML5 的新特性，它允许我们使用 canvas 元素在网页上通过 JavaScript 绘制图像 （可以在 HTML 页面使用多个 canvas 元素）\n\n\n\n\n\n1、绘图流程:\njs// 1、编写canvas标签，指定宽高（注意）；\n&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;\n// 2、获取canvas DOM对象；\nconst canvas = document.getElementById(&quot;canvas&quot;);\n// 3、获取Canvas对象；\nconst ctx = canvas.getContext(&quot;2d&quot;); // 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法\n// 4、设置绘图属性；\nctx.fillStyle = &quot;red&quot;; //设置填充色\n// 5、调用绘图API。\nctx.fillRect(0, 0, 50, 50); // 绘制矩形2、canvas 路径\n常用的方法：\n（1）moveTo(x,y)–定义线条开始坐标\n（2）lineTo(x,y)–定义线条结束坐标\n示例 1、绘制线段\njs&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;\nvar canvas = document.getElementById(&quot;canvas&quot;);\nvar ctx = canvas.getContext(&quot;2d&quot;);\nctx.beginPath(); // 开始绘制路径\nctx.lineWidth = 1; // 线条宽度\nctx.strokeStyle = &quot;green&quot;; // 线条填充色\nctx.moveTo(0, 0);\nctx.lineTo(200, 100);\nctx.stroke(); // 绘制线段示例 2、绘制圆形\narc(x,y,r,start,stop) x 轴 y 轴 r 半径\njs&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;\nvar canvas = document.getElementById(&quot;canvas&quot;);\nvar ctx = canvas.getContext(&quot;2d&quot;);\nctx.beginPath();\nctx.lineWidth = 2;\nctx.strokeStyle = &quot;green&quot;; // 圆形边框色\nctx.fillStyle = &quot;red&quot;; // 圆形填充色\nctx.arc(95, 50, 40, 0, 2 * Math.PI);\nctx.stroke();示例 3、绘制矩形 （代码见绘图流程）\n3、使用 canvas 压缩图片\nhtml&lt;!--编写input标签 指定type类型为file--&gt;\n&lt;input type=&quot;file&quot; id=&quot;upload&quot; /&gt;\n压缩图片js代码(点击展开)\n\njs// 设置上传图片类型  上传图片的容量大小\nconst ACCEPT = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;]; // 限定图片文件类型\nconst MAXSIZE = 1024 * 1024 * 3; // 限定图片最大容量\nconst MAXSIZE_STR = &quot;3MB&quot;;\n\nfunction convertImageToBase64(file, cb) &#123;\n  let reader = new FileReader();\n  reader.addEventListener(&quot;load&quot;, function (e) &#123;\n    const base64Image = e.target.result; // 获取文件内容，等同于 reader.result\n    cb(base64Image);\n    reader = null;\n  &#125;);\n  reader.readAsDataURL(file); // 读取 file 对象中的内容\n&#125;\n// 图片是否压缩的判断\nfunction compress(base64Image, cb) &#123;\n  let maxW = 1024;\n  let maxH = 1024;\n  const image = new Image();\n  image.addEventListener(&quot;load&quot;, function () &#123;\n    let ratio; // 压缩比\n    let needCompress = false; // 是否需要压缩\n    if (maxW &lt; image.naturalWidth) &#123;\n      needCompress = true;\n      ratio = image.naturalWidth / maxW;\n      maxH = image.naturalHeight / ratio;\n    &#125;\n    if (maxH &lt; image.naturalHeight) &#123;\n      needCompress = true;\n      ratio = image.naturalHeight / maxH;\n      maxW = image.naturalWidth / ratio;\n    &#125;\n    if (!needCompress) &#123;\n      maxW = image.naturalWidth;\n      maxH = image.naturalHeight;\n    &#125;\n    const canvas = document.createElement(&quot;canvas&quot;);\n    canvas.setAttribute(&quot;id&quot;, &quot;__compress__&quot;);\n    canvas.width = maxW;\n    canvas.height = maxH;\n    canvas.style.visibility = &quot;hidden&quot;;\n    document.body.append(canvas);\n    // canvas画布\n    const ctx = canvas.getContext(&quot;2d&quot;);\n    ctx.clearRect(0, 0, maxW, maxH);\n    ctx.drawImage(image, 0, 0, maxW, maxH); // 渲染图片\n    const compressImage = canvas.toDataURL(&quot;image/jpeg&quot;, 0.9); // 压缩图片\n    cb(compressImage);\n    const _image = new Image();\n    _image.src = compressImage;\n    document.body.appendChild(_image);\n    canvas.remove(); // 移除 canvas\n  &#125;);\n  image.src = base64Image; // 将图片设置到 image 的 src 属性中\n  document.body.appendChild(image);\n&#125;\n// 上传给服务端\nfunction uploadImage(compressImage) &#123;\n  console.log(&quot;upload image to server...&quot;, compressImage);\n&#125;\n\nconst upload = document.getElementById(&quot;upload&quot;);\nupload.addEventListener(&quot;change&quot;, function (e) &#123;\n  const file = e.target.files[0];\n  console.log(file);\n  if (!file) &#123;\n    return;\n  &#125;\n  const &#123; type: fileType, size: fileSize &#125; = file;\n  // 图片类型检查\n  if (!ACCEPT.includes(fileType)) &#123;\n    alert(&quot;不支持上传该格式文件！&quot;);\n    upload.value = &quot;&quot;;\n    return;\n  &#125;\n  // 图片大小检查\n  if (fileSize &gt; MAXSIZE) &#123;\n    alert(&quot;文件超出&quot; + MAXSIZE_STR + &quot;！&quot;);\n    upload.value = &quot;&quot;;\n    return;\n  &#125;\n  // 压缩文件\n  convertImageToBase64(file, (base64Image) =&gt;\n    compress(base64Image, uploadImage)\n  );\n&#125;);","slug":"18-canvas","date":"2020-04-10T12:00:00.000Z","categories_index":"","tags_index":"canvas","author_index":"Jude"},{"id":"ee9ffd41f40f397c245b06b54f1c88c1","title":"17、移动端300ms延迟在IOS11中的bug","content":"在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click\n\n\n移动端300ms延迟在IOS11中的bug\n\n\n\n\n\n\n\n\n解决方案\n1、禁用缩放 更改默认视口宽度\njs&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1&quot;&gt;2、fastclick解决300ms延迟问题        首先，需要安装fastclick插件\njsnpm install fastclick3、在main.js文件中引入fastclick，绑定到body上\njsimport FastClick from &quot;fastclick&quot;\nFastClick.attach(document.body);这就是常用来解决移动端300ms延迟的方法。但是这种方法在iOS11的系统中存在bug。\n4、iOS11系统中出现的bug    在iOS11系统下，点击input输入框的时候会出现不灵敏的现象。\n\n\n\n\n\n\n\n\n\n解决方案:\n\n点我展示代码\n\njs&lt;script&gt;\nFastClick.prototype.focus = function (targetElement) &#123;\n  var length;\n  var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;\n  var deviceIsIos = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;\n  //兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError\n  //这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法\n  if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#39;date&#39;) !== 0 &amp;&amp; targetElement.type !== &#39;time&#39; &amp;&amp; targetElement.type !== &#39;month&#39;) &#123;\n    length = targetElement.value.length;\n    // 修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘\n    targetElement.setSelectionRange(length, length);\n  &#125; else &#123;\n    targetElement.focus();\n  &#125;\n&#125;\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n注意：setSelectionRange是HTMLInputElement的一个方法,用来设定input textare的当前文本的起始位置和结束位置。(MDN文档）对setSelectionRange方法只能用于类型为文本、搜索、连接、电话号码、密码的输入，以及在Chrome33开始访问其余类型的属性和方法抛出异常。输入类型为数字时会抛出：“不能从’HTMLInputElement’中读取’selectionStart’属性：输入元素的类型(‘number’)不支持选择（Failed to read the ‘selectionStart’ property from ‘HTMLInputElement’: The input element’s type (‘number’) does not support selection）”。\n","slug":"17-mobile","date":"2020-02-20T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"b96881202a8e21ff190a20667cb33541","title":"16、v-cloak解决页面闪烁问题","content":"这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{ display: none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n\n很多时候，我们页面模板中的数据是异步获取的，在网络不好的情况下，渲染页面的时候会出现页面闪烁的效果，影响用户体验，v-cloak 指令保持在元素上直到关联实例结束编译，利用它的特性，结合 CSS 的规则 [v-cloak] { display: none } 一起使用就可以隐藏掉未编译好的 Mustache 标签，直到实例准备完毕。\nhtml&lt;div class=&quot;#app&quot; v-cloak&gt;\n    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt;\n&lt;/div&gt;css[v-cloak] &#123;\n    display: none;\n&#125;\n\n\n\n\n\n\n\n\n需要注意，虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个loading动画或者骨架屏的效果，提升用户体验。\n","slug":"16-v-cloak","date":"2020-02-12T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"af17b5ba5bc389464bbfb8c9845f67c2","title":"15、解决oh-my-zsh启动时出现多行提示","content":"oh-my-zsh在启动时，出现很多行提示，仔细阅读发现是2个文件夹权限的问题，修改文件夹权限，添加命令即可解决。\n\n\n一、修改文件夹权限jscd /usr/local/share\nsudo chmod 755 zsh\ncd /usr/local/share/zsh\nsudo chmod 755 site-functions二、.zshrc添加命令js// 根目录下添加下面的命令\ncd ~\nsudo vi .zshrc\n#写在  # User configuration  之后\nZSH_DISABLE_COMPFIX=&quot;true&quot; \n#保存并退出\nesc -&gt; :wq ","slug":"15-oh-my-zsh","date":"2020-02-08T16:00:00.000Z","categories_index":"","tags_index":"tool","author_index":"Jude"},{"id":"aab972d78ff662de38b2ac1b45536c81","title":"14、整理javascript知识(二)","content":"JavaScript的闭包、作用域、原型链\n\n\n一、闭包1、什么是闭包？\n\n\n\n\n\n\n\n\n一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。— from MDN\njavascript闭包的本质源自2点：词法作用域和函数当做值传递。\n2、词法作用域\n\n\n\n\n\n\n\n\n按照代码的书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这个变量就登记在相应的数据结构中。\njsfunction init()&#123;\n    // 局部变量\n    var name = &#39;jude&#39;  \n    // 内部函数，一个闭包\n    function displayName()&#123;\n        // 父函数中声明的变量\n        console.log(name)\n    &#125;\n    displayName()\n&#125;\ninit()name、displayName()是init()函数的一个局部变量和一个内部函数，displayName()函数没有自己的局部变量，但是它可以访问到外部函数的变量，所以displayName()可以使用父函数init()中声明的变量name。\n3、函数当做值传递\n\n\n\n\n\n\n\n\n即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。\n闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。\n4、闭包的缺点：造成内存泄漏\n\n\n\n\n\n\n\n\n如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。\n二、作用域1、作用域\n\n\n\n\n\n\n\n\n作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。\n作用域分为函数作用域、全局作用域\n\n\n\n\n\n\n\n\n\n全局作用域：代码在程序任何地方都能访问，例如window对象函数作用域： 固定代码片段中才能被访问\nJavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。\n每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。\n作用域最大的用处：隔离变量，不同作用域下同名变量不会有冲突。\n2、作用域链\n\n\n\n\n\n\n\n\n在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。\n⼀般情况下，变量取值到创建这个变量的函数的作⽤域中取值，但是如果在当前作⽤域中没有查到值，就会向上级作⽤域去查，直到查到全局作⽤域，这么⼀个查找过程形成的链条就叫做作⽤域链。\n三、原型链\n\n\n\n\n\n\n\n\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找， 如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype， 如果还没有找到就会再在构造函数的prototype的__proto__中查找， 这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n","slug":"14-javascript-simple2","date":"2020-01-14T16:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"e7f27203ed31c040bafeb4122b896332","title":"13、整理javascript知识(一)","content":"javascript 数据类型、类型检测、类型检测函数的封装（包括纯粹对象、空对象、window 对象）。\n\n\n一、基础类型及类型检测1、基础类型\n\n\n\n\n\n\n\n\nJavaScript 数据类型包括：Null、Undefined、Boolean、Number、String、Symbol、Bigint(7 种原始类型)、Object(引用类型，包括 Object&#x2F;Array&#x2F;Date&#x2F;Function&#x2F;RegExp 等)\n原始类型保存在栈内存。\n引用类型保存在堆内存，不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。\n引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。\n2、类型检测(1)、typeof\n\n\n\n\n\n\n\n\n7 种原始类型可以使用 typeof 操作符检查数据类型（其中，typeof null &#x3D;&#x3D;&#x3D; ‘object’）\n检查 Object 派生出来的结构类型，使用 typeof 是不行的， 会一直 &#x3D;&#x3D;&#x3D; ‘object’,通常使用 instanceof 检查 Object 种类（这样还是存在误差）。\n（2)、instanceof\n\n\n\n\n\n\n\n\ninstanceof 运算符是用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\nTips: 检测对象不是某个构造函数的实例\njsif (!(mycar instanceof Car)) &#123;\n  // do something\n&#125;\n// 上面代码和下面代码完全不同，下面的代码!mycar会在instanceof之前被验证\nif (!mycar instanceof Car) &#123;\n&#125;（3)、Object.prototype.toString().call()\n\n\n\n\n\n\n\n\n每个对象都有一个 toString()方法，可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。\n调用 Object.prototype.toString 会返回一个由 “[object “ 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。\n(看了别人翻译的es5规范，讲解这个toString（）函数，如下：)当toString方法被调用的时候，执行步骤为：\n\n\n\n\n\n\n\n\n\n1、如果 this 值是 undefined，就返回 [object Undefined]2、如果 this 的值是 null，就返回 [object Null]3、让 O 成为 ToObject(this) 的结果4、让 class 成为 O 的内部属性 [[Class]] 的值5、最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串\njs// 以下是11种：\nvar number = 1; // [object Number]\nvar string = &quot;123&quot;; // [object String]\nvar boolean = true; // [object Boolean]\nvar und = undefined; // [object Undefined]\nvar nul = null; // [object Null]\nvar obj = &#123; a: 1 &#125;; // [object Object]\nvar array = [1, 2, 3]; // [object Array]\nvar date = new Date(); // [object Date]\nvar error = new Error(); // [object Error]\nvar reg = /a/g; // [object RegExp]\nvar func = function a() &#123;&#125;; // [object Function]\n\nfunction checkType() &#123;\n  for (var i = 0; i &lt; arguments.length; i++) &#123;\n    console.log(Object.prototype.toString.call(arguments[i]));\n  &#125;\n&#125;\n\ncheckType(\n  number,\n  string,\n  boolean,\n  und,\n  nul,\n  obj,\n  array,\n  date,\n  error,\n  reg,\n  func\n);\n\n// 除了以上11种，还包括\nconsole.log(Object.prototype.toString.call(Math)); // [object Math]\nconsole.log(Object.prototype.toString.call(JSON)); // [object JSON]\n\n// 还可以这样\nfunction a() &#123;\n  console.log(Object.prototype.toString.call(arguments)); // [object Arguments]\n&#125;\na();（4)、封装一个 type 函数写一个 type 函数检测各种类型的值,考虑到兼容性（IE6，null 和 undefined 会被 Obejct.prototype.toString 识别为[object Obejct]）\njsvar class2type = &#123;&#125;;\n\n// 生成class2type映射\n&quot;Boolean Number String Function Array Date RegExp Object Error&quot;\n  .split(&quot; &quot;)\n  .map(function (item, index) &#123;\n    class2type[&quot;[object &quot; + item + &quot;]&quot;] = item.toLowerCase();\n  &#125;);\n\nfunction type(obj) &#123;\n  // 一箭双雕\n  if (obj == null) &#123;\n    return obj + &quot;&quot;;\n  &#125;\n  return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;\n    ? class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;\n    : typeof obj;\n&#125;（5)、函数类型的检测js// type函数\nfunction isFunction(obj) &#123;\n  return type(obj) === &quot;function&quot;;\n&#125;（6)、纯粹对象的检测什么是纯粹对象？\n\n\n\n\n\n\n\n\n\n该对象是通过 “{}” 或 “new Object” 创建的，该对象含有零个或者多个键值对。\njs// 上面写 type 函数时，用来存放 toString 映射结果的对象\nvar class2type = &#123;&#125;;\n\n// 相当于 Object.prototype.toString\nvar toString = class2type.toString;\n\n// 相当于 Object.prototype.hasOwnProperty\nvar hasOwn = class2type.hasOwnProperty;\n\nfunction isPlainObject(obj) &#123;\n  var proto, Ctor;\n\n  // 排除掉明显不是obj的以及一些宿主对象如Window\n  if (!obj || toString.call(obj) !== &quot;[object Object]&quot;) &#123;\n    return false;\n  &#125;\n\n  /**\n   * getPrototypeOf es5 方法，获取 obj 的原型\n   * 以 new Object 创建的对象为例的话\n   * obj.__proto__ === Object.prototype\n   */\n  proto = Object.getPrototypeOf(obj);\n\n  // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true\n  if (!proto) &#123;\n    return true;\n  &#125;\n\n  /**\n   * 以下判断通过 new Object 方式创建的对象\n   * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor\n   * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数\n   */\n  Ctor = hasOwn.call(proto, &quot;constructor&quot;) &amp;&amp; proto.constructor;\n\n  // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数\n  return (\n    typeof Ctor === &quot;function&quot; &amp;&amp;\n    hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object)\n  );\n&#125;（7)、空对象的判断jsfunction isEmptyObject(obj) &#123;\n  var name;\n  for (name in obj) &#123;\n    return false;\n  &#125;\n  return true;\n&#125;（8)、window 对象的判断jsfunction isWindow(obj) &#123;\n  return obj != null &amp;&amp; obj === obj.window;\n&#125;（9)、数组类型的检测js// 判断Array.isArray()方法是否存在，如果存在就使用该方法，不存在就使用type函数\nvar isArray =\n  Array.isArray ||\n  function (obj) &#123;\n    return type(obj) === &quot;array&quot;;\n  &#125;;（10)、类数组的判断满足的三个条件：\n\n\n\n\n\n\n\n\n\n1、是数组2、长度为 03、lengths 属性是大于 0 的数字类型，并且 obj[length - 1]必须存在\njsfunction isArrayLike(obj) &#123;\n  // obj 必须有 length属性\n  var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length;\n  var typeRes = type(obj);\n\n  // 排除掉函数和 Window 对象\n  if (typeRes === &quot;function&quot; || isWindow(obj)) &#123;\n    return false;\n  &#125;\n\n  return (\n    typeRes === &quot;array&quot; ||\n    length === 0 ||\n    (typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; length - 1 in obj)\n  );\n&#125;函数库的实现，如：underscore\njsvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\nvar isArrayLike = function (collection) &#123;\n  var length = getLength(collection);\n  return typeof length == &quot;number&quot; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;\n&#125;;(11)、判断是不是 DOM 元素jsvar isElement = function (obj) &#123;\n  return !!(obj &amp;&amp; obj.nodeType === 1);\n&#125;;","slug":"13-javascript-simple","date":"2020-01-11T16:00:00.000Z","categories_index":"","tags_index":"js","author_index":"Jude"},{"id":"ccf6952caa2a63224f44029f48443260","title":"12、下拉框select银行卡号格式处理","content":"银行卡号显示为 6217 **** 0000 的格式\n\n\n\n以选择银行卡为例：\njs    &lt;select v-model=&quot;selected&quot; class=&quot;selected&quot;&gt;\n        &lt;option disabled value v-show=&quot;showBankCard&quot;&gt;请选择提现到账的银行卡&lt;/option&gt;\n        &lt;option\n            v-for=&quot;item in BankCardList&quot;\n            :key=&quot;item.id&quot;\n            v-bind:value=&quot;item.id&quot;\n        &gt;\n            &#123;&#123; item.card_no &#125;&#125;\n        &lt;/option&gt;\n    &lt;/select&gt;jsitem.card_no ? item.card_no.replace(/^(\\d&#123;4&#125;)\\d+(\\d&#123;4&#125;)$/,&quot;$1****$2&quot;):&quot;&quot;\n// 银行卡号显示为 6217 **** 0000 的格式。","slug":"12-select","date":"2019-12-29T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"305474c5192f2cb44a35555f258cd08e","title":"11、二维码的生成","content":"使用 qrcode 生成二维码\n\n\n一、下载插件 qrcode 插件\njs    npm install qrcode --save二、在 main.js 中引用\njsimport QRCode from &quot;qrcode&quot;;\nVue.use(QRCode);三、组件中引入 QRCode\n \n 点我展示代码\n \nhtml    &lt;template&gt;\n        &lt;div&gt;\n            &lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/template&gt;js    &lt;script&gt;\n      import QRCode from &#39;qrcode&#39;;\n      mounted()&#123;\n          this.CreateQrcode();\n      &#125;,\n      method:&#123;\n          setTimeout(() =&gt; &#123;\n              // 获取DOM节点\n              let dom = document.getElementById(&#39;qrcode);\n              // 路由传参\n              const res = this.$route.params;\n              const lbsid = res.id;\n              // 二维码包含的URL 需要将URL和id做一下字符串的拼接\n              let url = &#39;http://*********&#39;;\n              let URL = url.concat(lbsid);\n              let qrCode = new QRCode(dom,&#123;\n                  width:260, // 图像宽度\n                  height:260,  // 图像高度\n                  colorDark:&quot;#000000&quot;,  // 前景色\n                  colorLight:&quot;#ffffff&quot;, // 背景色\n                  correctLevel: QRCode.CorrectLevel.H  // 容错等级\n              &#125;);\n              qrCode.clear();\n              qrCode.makeCode(URL);\n          &#125;,100)\n      &#125;\n    &lt;/script&gt;\n    &lt;style lang=&quot;less&quot; scoped&gt;\n        #qrcode &#123;\n            display: inline-block;\n            margin-top: 6rem;\n            img &#123;\n                width: 60%;\n                height: 60%;\n                background-color: #fff; //设置白色背景色\n                padding: 6px; // 利用padding的特性，挤出白边\n  &#125;\n&#125;\n    &lt;/style&gt;\n","slug":"11-qrcode","date":"2019-12-28T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"a02ddc5c71902c14b366a37989f821e2","title":"10、微信公众号网页使用popstate事件","content":"如何在h5移动端禁止某一些页面使用虚拟返回键。\n\n\n1、popstate事件MDN上是这样介绍popstate的：    当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。    需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）    不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会。    我负责的一个项目中，在微信公众号网页的某一个页面需要禁止使用微信浏览器的返回键。\n2、解决方式：\n点我展示代码\n\njs// 在禁止返回的组件的methods中写一个方法forbidBack\nforbidBack()&#123;\n    window.history.pushState(&quot;forward&quot;,null,&quot;#&quot;);\n    window.history.forward(1);\n&#125;\n\n// 监听返回键，禁止返回之前的路由\nif(window.history &amp;&amp; window.history.pushState)&#123;\n    window.addEventListener(&quot;popstate&quot;,this.forbidBack,false);\n    this.forbidBack();\n&#125;\n\n//离开页面需要销毁监听\nwindow.removeEventListener(&quot;popstate&quot;,this.forbidBack,fasle);","slug":"10-popstate","date":"2019-12-23T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"66b773f5ea2d0fd7877b90a347385c98","title":"9、h5扫码功能的实现","content":"使用H5 API barcode实现扫码。\n\n\nhtml&lt;template&gt;\n    &lt;div&gt;\n        &lt;div @click=&quot;handleCloseScan&quot;&gt;X&lt;/div&gt;\n        &lt;div class=&quot;scan&quot;&gt;\n            &lt;div id=&quot;bcid&quot;&gt;&lt;/div&gt;\n            &lt;div&gt;\n                &lt;button @click=&quot;handleStartScan&quot;&gt;扫 码&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n点击展示js代码\n\njs    &lt;script&gt;\n        // 扫描对象\n        var scan = null;\n        methods:&#123;\n            // 开始扫描\n            handleStartScan()&#123;\n                const that = this;\n                if(!window.plus) return;\n                scan = new plus.barcode.Barcode(&#39;bcid&#39;);\n                // 开始扫描\n                scan.start();\n                // 扫码成功之后的回调函数 type是类型 result 结果\n                scan.onmarked = function(type,result)&#123;\n                    const text = &#39;&#39;;\n                    switch(type)&#123;\n                        case plus.barcode.QR:\n                            type = &#39;QR&#39;;\n                            break;\n                        case plus.barcode.EAN13:\n                            type = &quot;EAN13&quot;;\n                            break;\n                        case plus.barcode.EAN8:\n                            type = &quot;EAN8&quot;;\n                            break;\n                        default:\n                            type = &quot;其它&quot; + type;\n                            break;\n                    &#125;\n                    result = result.replace(/\\n/g,&quot;&quot;);\n                    const id = result.match(/\\d+/)[0];\n                    that.$router.push(&#123;\n                        name:&#39;ComponentName&#39;,\n                        params: &#123;\n                            id:id\n                        &#125;\n                    &#125;);\n                    scan.close();\n                &#125;\n            &#125;,\n            // 关闭扫描控件\n            handleCloseScan()&#123;\n                 if(!window.plus) return;\n                 scan.close();\n                 this.$router.push(&#39;/&#39;);\n            &#125;\n        &#125;\n&#125;\n    &lt;/script&gt;\n","slug":"9-h5-scan","date":"2019-12-20T12:00:00.000Z","categories_index":"","tags_index":"h5","author_index":"Jude"},{"id":"d744e261b67622d7a554778fbe8d666f","title":"8、解决Vue项目热更新打包时间过长","content":"维护公司一个项目的时候，发现在项目启动、热更新和打包项目的时候，时间长的“感人”。\n\n当你改动项目的一些地方想要立即看到效果的时候，却发现热更新的编译过程却花了你很长时间，“心态崩了。。。”。\n1、解决Vue项目热更新打包时间过长解决方法：\n1、使用html-webpack-plugin-for-multihtml插件\n2、在build-webpack.dev.conf.js文件中\njs    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n    // 替换成\n    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin-for-multihtml&#39;);3、multihtmlCache:true  解决多页热部署的关键\njsfor (var pathname in pages) &#123;\n  // 配置生成的html文件，定义路径等\n  var conf = &#123;\n    filename: pathname + &#39;.html&#39;,\n    template: pages[pathname],   // 模板路径\n    inject: true,              // js插入位置\n    multihtmlCache: true,    // 解决多页热部署的关键 这里这里这里这里这里很重要！！！\n    // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n    chunksSortMode: &#39;dependency&#39;\n  &#125;;\n\n  if (pathname in devWebpackConfig.entry) &#123;\n    conf.chunks = [&#39;manifest&#39;,&#39;vendor&#39;, pathname];\n    conf.hash = false;\n  &#125;\n  devWebpackConfig.plugins.push(new HtmlWebpackPlugin(conf));\n&#125;4、router.js中使用路由懒加载\n这时候再启动项目，热更新、编译和打包的速度会大大提升。\n2、项目打包由4M变为1M公司有一个H5微信公众号网页的项目，项目打包之后文件有4M；\n修改webpack.prod.conf.js里的UglifyJsPlugin，这里的意思是打包后不产生后缀名为.map的文件。\njavascriptwebpack.prod.conf.js\n    new UglifyJsPlugin(&#123;\n      uglifyOptions: &#123;\n        compress: &#123;\n          warnings: false\n        &#125;\n      &#125;,\n      // sourceMap: config.build.productionSourceMap, 将这行代码注释掉。\n      parallel: true\n    &#125;)处理后打包的文件的大小为1M\n","slug":"8-hot","date":"2019-12-11T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"8043aa771423d32acc708d099583647c","title":"7、markdown语法","content":"markdown语法整理\n\n\nMarkdown标题\n使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n1、Markdown段落\n段落的换行是使用两个以上空格加上回车。\n\n\n\n\n\n\n\n\n\n字体:\ntxt*斜体文本*txt_斜体文本_txt**粗体文本**txt__粗体文本__txt***粗斜体文本***txt___粗斜体文本___\n\n\n\n\n\n\n\n\n分割线\ntxt***\n\n* * *\n\n*****\n\n- - -\n\n----------\n\n\n\n\n\n\n\n\n删除线、下划线、脚注\ntxt~~删除线~~\n&lt;u&gt;下划线&lt;/u&gt;\n[^Vue]:Vuejs是目前最流行的web开发框架之一。2、Markdown列表\nMarkdown 支持有序列表和无序列表。\n（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\ntxt* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n\n- 第一项\n- 第二项\n- 第三项（2）、有序列表：有序列表使用数字并加上 . 号来表示。\ntxt1. 第一项\n2. 第二项\n3. 第三项（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可\ntxt1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素4、Markdown区块\nMarkdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号\n\n\n\n\n\n\n\n\n\n区块的嵌套\ntxt&gt; 最外层\n&gt; &gt; 第一层嵌套\n&gt; &gt; &gt; 第二层嵌套\n\n\n\n\n\n\n\n\n区块中使用列表\ntxt&gt; 区块中使用列表\n&gt; 1. 第一项\n&gt; 2. 第二项\n&gt; + 第一项\n&gt; + 第二项\n&gt; + 第三项\n\n\n\n\n\n\n\n\n列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进\ntxt* 第一项\n    &gt; vuejs\n    &gt; JavaScript框架\n* 第二项5、Markdown链接和图片\n\n\n\n\n\n\n\n\n\n链接\ntxt[链接名称](链接地址)\n\n或者\n\n&lt;链接地址&gt;\n\n\n\n\n\n\n\n\n图片\ntxt![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)6、Markdown表格\ntxt|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |我们可以设置表格的对齐方式：\ntxt-: 设置内容和标题栏居右对齐。\n\n:- 设置内容和标题栏居左对齐。\n\n:-: 设置内容和标题栏居中对齐。","slug":"7-markdown","date":"2019-12-05T12:00:00.000Z","categories_index":"","tags_index":"markdown","author_index":"Jude"},{"id":"8b9b57a48cf21782c7b4b709b601605a","title":"6、Vue实现模糊搜索","content":"利用computed计算属性实现模糊搜索\n\n\nhtml  &lt;div id=&quot;app&quot;&gt;\n    &lt;input type=&quot;text&quot; placeholder=&quot;搜索&quot; v-model=&quot;sousuo&quot;&gt;\n    &lt;table border=&quot;1&quot;&gt;\n      &lt;th&gt;编号&lt;/th&gt;\n      &lt;th&gt;英雄&lt;/th&gt;\n      &lt;th&gt;技能&lt;/th&gt;\n      &lt;tr v-for=&quot;(item,index) in sousuo1()&quot; :key=&quot;item.id&quot;&gt;\n        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;\n        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;\n        &lt;td&gt;&#123;&#123;item.jn&#125;&#125;&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;利用computed计算属性\n\n点我展示代码\n\njavascriptvar app = new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    sousuo: &#39;&#39;,\n    list: [&#123;\n        &quot;id&quot;: 1,\n        &quot;name&quot;: &quot;艾希&quot;,\n        &quot;jn&quot;: &quot;射箭&quot;\n      &#125;, &#123;\n        &quot;id&quot;: 2,\n        &quot;name&quot;: &quot;狐狸&quot;,\n        &quot;jn&quot;: &quot;魅惑&quot;\n      &#125;, &#123;\n        &quot;id&quot;: 3,\n        &quot;name&quot;: &quot;猴子&quot;,\n        &quot;jn&quot;: &quot;棍子&quot;\n      &#125;, &#123;\n        &quot;id&quot;: 4,\n        &quot;name&quot;: &quot;盖伦&quot;,\n        &quot;jn&quot;: &quot;大宝剑&quot;\n      &#125;, &#123;\n        &quot;id&quot;: 5,\n        &quot;name&quot;: &quot;德邦&quot;,\n        &quot;jn&quot;: &quot;尖枪&quot;\n      &#125;, &#123;\n        &quot;id&quot;: 6,\n        &quot;name&quot;: &quot;皇子&quot;,\n        &quot;jn&quot;: &quot;旗子&quot;\n      &#125;,\n\n    ]\n  &#125;,\n  computed: &#123; //设置计算属性\n    Search() &#123;\n      if (this.sousuo) &#123;\n        return this.list.filter((value) =&gt; &#123; //过滤数组元素  this.list就是上面的那个死数据\n          return value.name.includes(this.sousuo); // 查看value.name里面包含不包含输入的字体  \n        &#125;); //this.sousuo跟上面的输入框是双重绑定\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    sousuo1() &#123;\n      if (!this.sousuo) &#123;\n        return this.list;\n      &#125;\n      return this.Search\n    &#125;\n  &#125;,\n&#125;)","slug":"6-mohu-search","date":"2019-11-13T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"2d72f36e7e873f400f2d34d162042379","title":"5、Vue2基础知识","content":"Vue基础知识点，包括常用指令、计算属性、侦听属性等。\n\n\nVuejs响应式原理txt编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。\n收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）\n通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。vue优点轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；\n简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n双向数据绑定：保留了angular的特点，在数据操作方面更为简单；\n组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；\n视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；\n运行速度更快: 相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。\nvue生命周期在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。\n载入前&#x2F;后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。\n更新前&#x2F;后：当data变化时，会触发beforeUpdate和updated方法\n销毁前&#x2F;后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\nvue组件中data必须是一个函数？官网上是这样写的：\n\n\n\n\n\n\n\n\n\n一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，可能会影响到其它所有实例。\n当创建Vue实例时，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。\nv-if和v-show有什么区别？v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:\n1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。\n2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。\ncomputed和watch的区别计算属性computed：\n支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n侦听属性watch：\n不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：immediate：组件加载立即触发回调函数执行\njswatch: &#123;\n  firstName: &#123;\n    handler(newName, oldName) &#123;\n      this.fullName = newName + &#39; &#39; + this.lastName;\n    &#125;,\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  &#125;\n&#125;deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\njswatch: &#123;\n  obj: &#123;\n    handler(newName, oldName) &#123;\n      console.log(&#39;obj.a changed&#39;);\n    &#125;,\n    immediate: true,\n    deep: true\n  &#125;\n&#125;优化：我们可以使用字符串的形式监听\njswatch: &#123;\n  &#39;obj.a&#39;: &#123;\n    handler(newName, oldName) &#123;\n      console.log(&#39;obj.a changed&#39;);\n    &#125;,\n    immediate: true,\n    // deep: true\n  &#125;\n&#125;这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。\n$nextTick是什么？vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM\nv-for key的作用当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。\n\n\n\n\n\n\n\n\n\nkey 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复&#x2F;再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。\nv-for提升性能的原因:\nkey相同时，两个VNode会相同，可以避免不必要的DOM更新；而且在diff内部，也会根据key来跟踪VNode。\n双向数据绑定原理是什么？\n\n\n\n\n\n\n\n\nvue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n主要分为以下几个步骤：\n1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。\nvue-router路由页面管理\n\n\n\n\n\n\n\n\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。\n包含的功能有：\n1、嵌套的路由&#x2F;视图表\n2、模块化的、基于组件的路由配置\n3、路由参数、查询、通配符\n4、基于 Vue.js 过渡系统的视图过渡效果\n5、细粒度的导航控制\n6、带有自动激活的 CSS class 的链接\n7、HTML5 历史模式或 hash 模式，在 IE9 中自动降级\n8、自定义的滚动条行为\n\n\n\n\n\n\n\n\n\n1、动态路由匹配\n例如：对不同ID的用户，使用同一个组件来渲染。\njsconst User = &#123;\n  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;\n&#125;\nconst router = new VueRouter(&#123;\n  routes: [\n    // 动态路径参数 以冒号开头\n    &#123; path: &#39;/user/:id&#39;, component: User &#125;\n  ]\n&#125;)这样&#x2F;user&#x2F;foo 和 &#x2F;user&#x2F;bar 都将映射到相同的路由User。\n一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：\njsconst User = &#123;\n  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;\n&#125;\n\n\n\n\n\n\n\n\n2、编程式的导航router.push({name:””,params:{}})\njs  （1）this.$router.push\n  // 带参数\n  this.$router.push(&#123;\n    name:&quot;User&quot;,\n    params:&#123;\n      userId:&quot;123&quot;\n    &#125;\n  &#125;)router.push({path:””,query:””})\njs  (2) this.$router.push(&#123;\n    path:&quot;/user&quot;,\n    query:&#123;\n      plan:&quot;private&quot;\n    &#125;\n  &#125;)router.replace()使用方法跟router.push()很像，不会向history添加新纪录，替换掉当前的history记录。router.go()在history记录中向前或者向后多少步。正数为向前多少步，负数为向后多少步\n\n\n\n\n\n\n\n\n\n3、滚动行为\n使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。\n\n\n\n\n\n\n\n\n\n注意：这个功能只在支持 history.pushState 的浏览器中可用。\njsscrollBehavior (to, from, savedPosition) &#123;\n  if (savedPosition) &#123;\n    return savedPosition\n  &#125; else &#123;\n    return &#123; x: 0, y: 0 &#125;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n4、路由懒加载\n有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名chunk，一个特殊的注释语法来提供chunk name(需要 Webpack &gt; 2.4)。\njsconst Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)\nconst Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)\nconst Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)表单输入控制\n\n\n\n\n\n\n\n\n表单修饰符：如果是简单的控制输入一定是数字或者去掉用户输入的收尾空白符，可以直接使用 Vue 提供的表单修饰符 .number 和 .trim\n1、如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：\nvue&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;2、如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：\nvue&lt;input v-model.trim=&quot;msg&quot;&gt;\n\n\n\n\n\n\n\n\nchange事件:给表单绑定事件，在事件处理中进行表单输入控制\nhtml&lt;input v-model=&quot;value2&quot; type=&quot;text&quot; @change=&quot;inputChange(value2)&quot; /&gt;jsmethods: &#123;\n  inputChange: function(val) &#123;\n    if (!val) return &#39;&#39;\n    val = val.toString()\n    this.value2 = val.charAt(0).toUpperCase() + val.slice(1)\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\nfilter过滤器\nhtml&lt;input v-model=&quot;value1&quot;  type=&quot;text&quot; /&gt;jsVue.filter(&#39;capitalize&#39;, function (value) &#123;\n  if (!value) return &#39;&#39;\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n&#125;)jswatch: &#123;\n  value1(val) &#123;\n     this.value1 = this.$options.filters.capitalize(val);\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n指令:声明一个全局指令\n\n点击展示代码\n\njs// 只能输入正整数,0-9的数字\nVue.directive(&#39;enterIntNumber&#39;, &#123;\n  inserted: function (el) &#123;\n    let trigger = (el, type) =&gt; &#123;\n      const e = document.createEvent(&#39;HTMLEvents&#39;)\n      e.initEvent(type, true, true)\n      el.dispatchEvent(e)\n    &#125;\n    el.addEventListener(&quot;keyup&quot;, function (e) &#123;\n      let input = e.target;\n      let reg = new RegExp(&#39;^\\\\d&#123;1&#125;\\\\d*$&#39;);  //正则验证是否是数字\n      let correctReg = new RegExp(&#39;\\\\d&#123;1&#125;\\\\d*&#39;);  //正则获取是数字的部分\n      let matchRes = input.value.match(reg);\n      if (matchRes === null) &#123;\n        // 若不是纯数字 把纯数字部分用正则获取出来替换掉\n        let correctMatchRes = input.value.match(correctReg);\n        if (correctMatchRes) &#123;\n          input.value = correctMatchRes[0];\n        &#125; else &#123;\n          input.value = &quot;&quot;;\n        &#125;\n      &#125;\n      trigger(input, &#39;input&#39;)\n    &#125;);\n  &#125;\n&#125;);\n\nhtml&lt;!--限制输入正整数--&gt;\n&lt;input v-enterIntNumber placeholder=&quot;0&quot; type=&quot;number&quot;&gt;Vue渲染目标元素的6种方法1、直接创建Vue实例\n\n点击展示代码\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;vue&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  &lt;!-- 这里直接引入cdn源码 --&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n  var app = new Vue(&#123;\n    el: &quot;#app&quot;,\n    template: &quot;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&quot;,\n    data()&#123;\n      return&#123;\n        message:&#39;Hello Vue.js!&#39;\n      &#125;\n    &#125;\n  &#125;);\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n2、Vue.extend\n\n\n\n\n\n\n\n\n\nVue.extend(options) 方式是使用Vue构造器的一个“子类”，其参数同Vue(options)一模一样，唯一的不同是没有 el 属性来指定挂载的DOM元素，所以这里需要通过 $mount() 方法，来手动实现挂载。\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n  var app = Vue.extend(&#123;\n    el: &quot;#app&quot;,\n    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,\n    data() &#123;\n      return &#123;\n        msg: &#39;hello extend&#39;\n      &#125;\n    &#125;\n  &#125;)\n  // 注意这里 Vue.extend 方式是生成了一个 Vue 子类，所以需要 new关键字来重新创建，然后手动挂载。\n  new app().$mount(&#39;#app&#39;);\n  &lt;/script&gt;\n\n3.Vue.component\n\n\n\n\n\n\n\n\n\nVue.component(id, [definition])方式是注册一个名称为id的全局组件，然后我们可以通过使用该组件来，实现目标元素渲染。其中definition 参数同 Vue.extend 中的参数一模一样，方法一样，需要使用$mount()方法手动挂载。\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n  // var app = Vue.component(&#39;hello&#39;, &#123;\n  // \ttemplate:&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,\n  //   data() &#123;\n  //     return &#123;\n  //       msg: &#39;hello component&#39;\n  //     &#125;\n  //   &#125;\n  // &#125;)\n  // new app().$mount(&#39;#app&#39;)\n  //1、 注册组件\n  Vue.component(&#39;hello&#39;, &#123;\n    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,\n    data() &#123;\n      return &#123;\n        msg: &#39;hello component&#39;\n      &#125;\n    &#125;\n  &#125;)\n  // 2、创建Vue实例\n  new Vue(&#123;\n    el: &quot;#app&quot;,\n    template: &#39;&lt;hello /&gt;&#39;\n  &#125;)\n  &lt;/script&gt;\n\n\n\n\n\n\n\n\n仅仅注册组件式不够的，我们还要通过创建一个Vue实例，才能使用该组件。\n\n\n4、Vue.directive自定义指令\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;\n    &lt;div v-hello=&quot;msg&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n  Vue.directive(&#39;hello&#39;, &#123;\n    bind: function(el, binding) &#123;\n      el.innerHTML = &quot;&lt;h1&gt;&quot; + binding.value + &quot;&lt;/h1&gt;&quot;\n    &#125;\n  &#125;)\n  new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        msg: &quot;hello directive 自定义指令&quot;\n      &#125;\n    &#125;\n  &#125;)\n  &lt;/script&gt;\n\n5、Vue.compile\n\n\n\n\n\n\n\n\n\nVue.compile(template) 参数也就是 template 模板字符串属性，然后通过替换 Vue实例的 render 函数，来实现渲染。\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n      // 参数就是template模板字符串  然后通过替换Vue实例的render函数来实现渲染\n  var tpl = Vue.compile(&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;&#39;)\n  new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        msg: &quot;hello,compile&quot;\n      &#125;\n    &#125;,\n    render: tpl.render\n  &#125;)\n  &lt;/script&gt;\n\n6、render\n\n\n\n\n\n\n\n\n\nVue实例在创建的过程中也会调用 render 函数，render 函数默认会传递一个参数,我们可以通过 createElement 来动态创建一个 VNode，以此来渲染目标元素\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n  new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        msg: &#39;hello,render&#39;\n      &#125;\n    &#125;,\n    render: function(createElement) &#123;\n      return createElement(&#39;h1&#39;, this.msg)\n    &#125;\n  &#125;)\n  &lt;/script&gt;\n\n\ndata&#x2F;computed&#x2F;watch1、data\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;\n    &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;\n        &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n  var app = new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        count: 1,\n        list: [&#123;\n          name: &#39;vue js&#39;,\n          url: &#39;https://cn.vuejs.org&#39;\n        &#125;, &#123;\n          name: &#39;github&#39;,\n          url: &#39;https://github.com&#39;\n        &#125;, &#123;\n          name: &#39;blog&#39;,\n          url: &#39;issummer.cn&#39;\n        &#125;]\n      &#125;\n    &#125;,\n    methods: &#123;\n      addItem() &#123;\n        this.count++\n        this.list.push(&#123;\n          name: &#39;baidu&#39; + this.count,\n          url: &#39;https://www.baidu.com&#39;\n        &#125;)\n      &#125;\n    &#125;\n  &#125;)\n  &lt;/script&gt;\n\n2、computed\n\n\n\n\n\n\n\n\n\ncomputed 中的属性是需要先进行计算，然后再返回想要的数据的。当我们输出某个属性，必须依赖另外一个 data 中的属性来动态计算获得的，此时使用 computed 就非常简单了。\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;\n      &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;\n      &lt;ul&gt;\n          &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;\n              &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;\n          &lt;/li&gt;\n      &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n  var app = new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        count: 1,\n        // 这里是后台数据\n        requestList: [\n          &#39;vuejs https://cn.vuejs.org&#39;,\n          &#39;github https://github.com&#39;,\n          &#39;blog https://issummer.cn&#39;\n        ]\n      &#125;\n    &#125;,\n    computed: &#123;\n      list: function() &#123;\n        var list = []\n        this.requestList.map(function(item, index) &#123;\n          var tempArr = item.split(&#39;-&#39;)\n          list.push(&#123;\n            name: tempArr[0],\n            url: tempArr[1]\n          &#125;)\n        &#125;)\n        return list\n      &#125;\n    &#125;,\n    methods: &#123;\n      addItem() &#123;\n        this.count++\n        this.requestList.push(&#39;blog&#39; + this.count + &#39;issummer.cn&#39;)\n      &#125;\n    &#125;\n  &#125;)\n  &lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n计算是可以修改的,计算属性不仅可以定义为一个函数，也可以定义为一个含有 get&#x2F;set 属性的对象。当我们定义为一个函数是，Vue 内部会默认将这个函数赋值给 get 属性，一般 set 是未定义的。当我们定义 set 属性后，就可以对它进行修改了。\n\n点击展示代码\n\nhtml  &lt;div id=&quot;app&quot;&gt;\n    &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;\n    &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n  var app = new Vue(&#123;\n    el: &quot;#app&quot;,\n    data() &#123;\n      return &#123;\n        firstName: &#39;Jude&#39;,\n        lastName: &#39;Summer&#39;\n      &#125;\n    &#125;,\n    computed: &#123;\n      username: &#123;\n        get: function() &#123;\n          return this.firstName + &#39; &#39; + this.lastName\n        &#125;,\n        set: function(newVal) &#123;\n          var names = newVal.split(&#39; &#39;);\n          this.firstName = names[0];\n          this.lastName = names[1];\n        &#125;\n      &#125;\n    &#125;,\n    methods:&#123;\n        changeName()&#123;\n            if(this.username === &#39;Jude Summer&#39;)&#123;\n                this.username = &quot;YQ&quot;\n            &#125;else&#123;\n                this.username = &#39;Jude Summer&#39;\n            &#125;\n        &#125;\n    &#125;\n  &#125;)\n  &lt;/script&gt;\n\n3、watch侦听器\n\n\n\n\n\n\n\n\n\n创建 Vue 应用时，我们还提到过 watch 这个属性，它其实是个对象，键是需要观察的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。和上面的计算属性类似，他可以监听 值&#x2F;表达式 的变化来执行回调函数。\n\n点击展示代码\n\nhtml    &lt;div id=&quot;app&quot;&gt;\n        &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;\n        &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        var app = new Vue(&#123;\n            el: &quot;#app&quot;,\n            data() &#123;\n                return &#123;\n                    firstName: &#39;Jude&#39;,\n                    lastName: &#39;Summer&#39;,\n                    username: &#39;Jude Summer&#39;\n                &#125;\n            &#125;,\n            watch: &#123;\n                firstName: function (val, oldVal) &#123;\n                    this.username = val + &#39; &#39; + this.lastName;\n                &#125;,\n                lastName: function (val, oldVal) &#123;\n                    this.username = this.firstName + &#39; &#39; + val;\n                &#125;\n            &#125;,\n            methods: &#123;\n                changeName() &#123;\n                    if (this.username === &#39;Jude Summer&#39;) &#123;\n                        this.firstName = &quot;Y&quot;;\n                        this.lastName = &quot;Q&quot;;\n                    &#125; else &#123;\n                        this.firstName = &quot;Jude&quot;;\n                        this.lastName = &quot;Summer&quot;;\n                    &#125;\n                &#125;\n            &#125;,\n        &#125;)\n\n    &lt;/script&gt;\n    // 监听对象属性\n    &lt;script&gt;\n        var app = new Vue(&#123;\n            el: &quot;#app&quot;,\n            data() &#123;\n                return &#123;\n                    userinfo: &#123;\n                        firstName: &#39;Jude&#39;,\n                        lastName: &#39;Summer&#39;\n                    &#125;,\n                    username: &quot;Jude Summer&quot;\n                &#125;\n            &#125;,\n            watch: &#123;\n                // 此时无论我们如何点击按钮，都无法改变 username 的值，因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听\n                userinfo: function (val, oldVal) &#123;\n                    this.username = val.firstName + &#39; &#39; + val.lastName;\n                &#125;\n            &#125;,\n            methods: &#123;\n                changeName: function () &#123;\n                    if (this.username === &#39;Jude Summer&#39;) &#123;\n                        this.userinfo.firstName = &#39;Y&#39;\n                        this.userinfo.lastName = &#39;Q&#39;\n                    &#125; else &#123;\n                        this.userinfo.firstName = &quot;Jude&quot;\n                        this.userinfo.lastName = &quot;Summer&quot;\n                    &#125;\n                &#125;\n            &#125;,\n        &#125;)\n    &lt;/script&gt;\n    // 上面的方法是无法修改username的值 因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听。实际上对于侦听的值是可以为一个对象的，它还有个 deep 属性，用来设置是否侦听内部属性的变化，而回调函数是通过 handler 来设置的\n     &lt;script&gt;\n        var app = new Vue(&#123;\n            el: &quot;#app&quot;,\n            data() &#123;\n                return &#123;\n                    userinfo: &#123;\n                        firstName: &#39;Jude&#39;,\n                        lastName: &#39;Summer&#39;\n                    &#125;,\n                    username: &quot;Jude Summer&quot;\n                &#125;\n            &#125;,\n            watch: &#123;\n                // depp属性用来侦听内部属性变化，回调函数是通过hander来设置\n                // 适用于非整体赋值  也就是适用于局部修改属性，这个时候通过设置deep属性为true，来达到侦听目的。\n                userinfo: &#123;\n                    deep: true,\n                    handler: function (val, oldVal) &#123;\n                        this.username = val.firstName + &quot; &quot; + val.lastName;\n                    &#125;\n                &#125;\n            &#125;,\n            methods: &#123;\n                // 修改名字\n                changeName: function () &#123;\n                    if (this.username === &#39;Jude Summer&#39;) &#123;\n                        this.userinfo.firstName = &#39;Y&#39;\n                        this.userinfo.lastName = &#39;Q&#39;\n                    &#125; else &#123;\n                        this.userinfo.firstName = &quot;Jude&quot;\n                        this.userinfo.lastName = &quot;Summer&quot;\n                    &#125;\n                &#125;\n            &#125;,\n        &#125;)\n    &lt;/script&gt;\n    // 写成对象属性访问表达式的    当侦听对象包含很多属性，而我们只是需要监听其中的一个或某几个属性，这时如果我们通过这种方式侦听所有内部属性的变化，自然就会造成内存的浪费。那么我们可以只侦听单一内部属性的变化\n    &lt;script&gt;\n        var app = new Vue(&#123;\n            el: &quot;#app&quot;,\n            data() &#123;\n                return &#123;\n                    userinfo: &#123;\n                        firstName: &#39;Jude&#39;,\n                        lastName: &#39;Summer&#39;\n                    &#125;,\n                    username: &quot;Jude Summer&quot;\n                &#125;\n            &#125;,\n            watch: &#123;\n                // 侦听对象的某个属性\n                &#39;userinfo.lastName&#39;:function(val,oldVal)&#123;\n                    this.username = this.userinfo.firstName + &#39; &#39; + val;\n                &#125;\n            &#125;,\n            methods: &#123;\n                // 修改名字\n                changeName: function () &#123;\n                    if (this.username === &#39;Jude Summer&#39;) &#123;\n                        // this.userinfo.firstName = &#39;Y&#39;\n                        this.userinfo.lastName = &#39;Q&#39;\n                    &#125; else &#123;\n                        // this.userinfo.firstName = &quot;Jude&quot;\n                        this.userinfo.lastName = &quot;Summer&quot;\n                    &#125;\n                &#125;\n            &#125;,\n        &#125;)\n    &lt;/script&gt;\n\nv-on对象语法\n\n\n\n\n\n\n\n\n绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。\n通常的写法：\nhtml&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;对象语法: \nhtml&lt;div v-on=&quot;&#123; mouseenter: ShowInfo, mouseleave: HideInfo &#125;&quot;&gt;\n  &lt;div&gt;我是title&lt;/div&gt;\n  &lt;div v-show=&quot;ShowWrapper&quot;&gt;我是显示的内容！&lt;/div&gt;\n&lt;/div&gt;axios的封装router-link\n\n\n\n\n\n\n\n\n有时候，我们需要将router-link渲染成某种标签，例如&lt;li&gt;&lt;/li&gt;使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航\n示例:\nhtml&lt;ul class=&quot;nav-list&quot;&gt;\n  &lt;router-link tag=&quot;li&quot; to=&quot;home&quot;&gt;home&lt;/router-link&gt;\n&lt;/ul&gt;\n&lt;!-- 渲染的结果为 --&gt;\n&lt;li&gt;home&lt;/li&gt;v-slot\n\n\n\n\n\n\n\n\n可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。提供具名插槽或需要接收 prop 的插槽。\nhtml&lt;!-- 父组件 --&gt;\n&lt;template&gt;\n    &lt;div class=&quot;common-card&quot;&gt;\n    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;\n    &lt;div class=&quot;value&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt;\n    &lt;div class=&quot;chart&quot;&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;total&quot;&gt;\n      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;html&lt;!-- 子组件 --&gt;\n  &lt;common-card title=&quot;今日交易用户数&quot; :value=&quot;1234567890&quot;&gt;\n    &lt;template&gt;\n      &lt;v-chart :options=&quot;getOptions()&quot; /&gt;\n    &lt;/template&gt;\n    &lt;template v-slot:footer&gt;\n      &lt;span&gt;退货率&lt;/span&gt;\n      &lt;span class=&quot;emphasis&quot;&gt;12%&lt;/span&gt;\n    &lt;/template&gt;\n  &lt;/common-card&gt;props\n\n\n\n\n\n\n\n\nprops 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n\n\n\n\n\n\n\n\n\n常用于父组件与子组件的通信对象语法选项包括:\n1、type：原生构造函数的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。\n2、default: any 默认值\n3、required:Boolean 该prop是否是必填项\n4、validator: Function 校验函数\njs  props: &#123;\n    // 检测类型\n    title: String,\n    // 检测类型 + 其他验证\n    age: &#123;\n      type: Number, //类型\n      default: 0,// 默认值\n      required: true,// 是否是必填项\n      // 校验函数\n      validator: function (value) &#123;\n        return value &gt;= 0\n      &#125;\n    &#125;\n  &#125;mixin 混入\n\n\n\n\n\n\n\n\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n1、实现原理\n\n\n\n\n\n\n\n\n\n将用户传入的对象与 Vue 自身的options属性合并，合并后的对象将会覆盖原来的Vue.options。因为 mixin 方法修改了Vue.options属性，之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。\n注意：如果用户传入的对象与组件有相同的数据对象，将会发生合并，并且遵循组件数据优先的原则。对于钩子函数来说，如果相同，将会合并为一个数组，所以都会被调用，只是混入对象的钩子会被先调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。\njs// vue源码 vue/src/core/global-api/mixin.js\nimport &#123; mergeOptions &#125; from &#39;../util/index&#39;\n\nexport function initMixin (Vue: GlobalAPI) &#123;\n  Vue.mixin = function (mixin: Object) &#123;\n    this.options = mergeOptions(this.options, mixin)\n    return this\n  &#125;\n&#125;2、如何理解mixin?\n可以将mixin理解为数组，数组中有单个或者多个mixin，mixin的本质就是js对象，拥有Vue实例的所有属性，例如：data,created,methods等，还可以在mixin中再次嵌套mixin\n注意\u001d：在组件中引入的方式为 mixins:[myMixin]\n3、mixin的实现\n\n\n\n\n\n\n\n\n\n当Vue在实例的时候，会调用mergeOptions函数进行options的合并\n\n点击展示代码\n\njs// vue源码 core/util/options.js\nexport function mergeOptions(\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object &#123;\n  ...\n  // 如果有 child.extends 递归调用 mergeOptions 实现属性拷贝\n  const extendsFrom = child.extends\n  if (extendsFrom) &#123;\n    parent = mergeOptions(parent, extendsFrom, vm)\n  &#125;\n  // 如果有 child.mixins 递归调用 mergeOptions 实现属性拷贝\n  if (child.mixins) &#123;\n    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    &#125;\n  &#125;\n  // 申明 options 空对象，用来保存属性拷贝结果\n  const options = &#123;&#125;\n  let key\n  // 遍历 parent 对象，调用 mergeField 进行属性拷贝\n  for (key in parent) &#123;\n    mergeField(key)\n  &#125;\n  // 遍历 child 对象，调用 mergeField 进行属性拷贝\n  for (key in child) &#123;\n    if (!hasOwn(parent, key)) &#123;\n      mergeField(key)\n    &#125;\n  &#125;\n  // 属性拷贝实现方法 mergeField 函数接收一个 key，首先会申明 strat 变量，如果 strats[key] 为真，就将 strats[key] 赋值给 strat。\n  function mergeField(key) &#123;\n    // 穿透赋值，默认为 defaultStrat\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  &#125;\n  return options\n&#125;\n\n\n\n\n\n\n\n\n\n\nvue 中 mixins 的优先级，component &gt; mixins &gt; extends。\n边界处理：inject&#x2F;provide类型：\n\n\n\n\n\n\n\n\n\nprovide：Object | () &#x3D;&gt; Object\n\n\n\n\n\n\n\n\n\ninject：Array | { [key: string]: string | Symbol | Object }\nprovide和inject需要一起使用，可以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件的层次有多深，并在其上下游关系成立的时间里始终生效。\n同react的上下文特性相似\n\n点击展示代码\n\njs// 父级组件提供 &#39;foo&#39;\nvar Provider = &#123;\n  provide: &#123;\n    foo: &#39;bar&#39;\n  &#125;,\n  // ...\n&#125;\n\n// 子组件注入 &#39;foo&#39;\nvar Child = &#123;\n  inject: [&#39;foo&#39;],\n  created () &#123;\n    console.log(this.foo) // =&gt; &quot;bar&quot;\n  &#125;\n  // ...\n&#125;\n\n\nvuex\n\n\n\n\n\n\n\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单的说，vuex就是一个状态管理器。\n开发过程，通常会遇到多个视图依赖同一个状态，不同视图的行为需要变更为同一状态（例如：后台管理系统的侧边栏的收缩功能。）\nVuex的核心就是store，它就是一个仓库容器，包含了驱动应用的数据源（state），不同于单纯的全局对象，vuex的状态存储是响应式的，当 Vue组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n","slug":"5-vue-simple","date":"2019-09-26T12:00:00.000Z","categories_index":"","tags_index":"vue","author_index":"Jude"},{"id":"c7406f8b3858eb2fa2b3ad7a9a8abb89","title":"4、DOMContentLoaded","content":"DOMContentLoaded顾名思义就是DOM内容加载完毕。\n\n\n当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 这里有一个常见的错误，就是在本应使用 DOMContentLoaded 会更加合适的情况下，却选择使用 load，所以要谨慎。注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。\n在Vue项目的App.vue中，我们可以这样设置字体。\n1、获取HTML元素；\n2、根据屏幕宽度动态计算fontSize\n3、当fontSize大于50时，设置最大值为50\n4、设置HTML的fontSize属性，使rem生效，1rem &#x3D; fontSize + “px”\njs&lt;script&gt;\n// DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。\n  document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;\n    // 获取html元素\n    const html = document.querySelector(&#39;html&#39;)\n    // 根据屏幕宽度动态计算fontSize\n    let fontSize = window.innerWidth / 10\n    // 当fontSize大于50时，设置最大值为50\n    fontSize = fontSize &gt; 50 ? 50 : fontSize\n    // 设置html的fontSize属性，使rem生效，1rem = fontSize + &#39;px&#39;\n    html.style.fontSize = fontSize + &#39;px&#39;\n  &#125;)\n&lt;/script&gt;","slug":"4-DOMContentLoaded","date":"2019-08-18T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"1ad36476bc6958df3ba1c341f1e34288","title":"3、如何使用CSS画三角形?","content":"三角形的画法,一般经常使用三角形作为提示框、下拉菜单等功能。\n\n\n一、CSS 画三角形实现方式1、HTML 结构\nhtml&lt;div class=&quot;item0&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;item1&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;item2&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;item3&quot;&gt;&lt;/div&gt;2、将类名为 item 的块级元素的 width、height 设置为 0\ncss.item0 &#123;\n  width: 0;\n  height: 0;\n&#125;3、将类名为 item 的元素的 3 个 border 的颜色设置为 transparent，箭头指向的对面 border 设置颜色；\ncss.item0 &#123;\n  width: 0px;\n  height: 0px;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-bottom: 80px solid blue;\n  background: white;\n&#125;上面的为方向向上的三角形4、依次类推可以画出方向向左、右、下的三角形\ncss.item1 &#123;\n  width: 0px;\n  height: 0px;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 80px solid green;\n  border-bottom: 50px solid transparent;\n  background: white;\n&#125;\n.item2 &#123;\n  width: 0px;\n  height: 0px;\n  border-left: 50px solid transparent;\n  border-right: 80px solid violet;\n  border-top: 50px solid transparent;\n  border-bottom: 50px solid transparent;\n  background: white;\n&#125;\n.item3 &#123;\n  width: 0px;\n  height: 0px;\n  border-left: 80px solid purple;\n  border-right: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-bottom: 50px solid transparent;\n  background: white;\n&#125;二、网页变成灰色的方法：csshtml &#123;\n  filter: grayscale(100%);\n  -webkit-filter: grayscale(100%);\n  -moz-filter: grayscale(100%);\n  -ms-filter: grayscale(100%);\n  -o-filter: grayscale(100%);\n&#125;三、position 定位\n\n\n\n\n\n\n\n\nstatic: 默认值relative: 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中absolute: 绝对定位 相对于最近的已定位的祖先元素fixed: 固定定位 相对于视窗来定位\n四、浮动、清楚浮动cssdisplay: table;\ncontent: &quot;&quot;;\nclear: both;一、HTML\n新增选择器 document.querySelector、document.querySelectorAll\n\n拖拽释放(Drag and drop) API\n\n媒体播放的 video 和 audio\n\n本地存储 localStorage 和 sessionStorage\n\n离线应用 manifest\n\n桌面通知 Notifications\n\n语意化标签 article、footer、header、nav、section\n\n增强表单控件 calendar、date、time、email、url、search\n\n地理位置 Geolocation\n\n多任务 webworker\n\n全双工通信协议 websocket\n\n\n\n\n\n\n\n\n\n客户端和服务端双向通信\n\n历史管理 history\n\n跨域资源共享(CORS) Access-Control-Allow-Origin\n\n页面可见性改变事件 visibilitychange\n\n跨窗口通信 PostMessage\n\nForm Data 对象\n\n绘画 canvas\n\n\nHTML 的语义化：\nhtml&lt;title&gt;      &lt;!--：页面主体内容。--&gt;\n&lt;hn&gt;         &lt;!--：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。--&gt;\n&lt;ul&gt;         &lt;!--：无序列表。--&gt;\n&lt;li&gt;         &lt;!--：有序列表。--&gt;\n&lt;header&gt;     &lt;!--：页眉通常包括网站标志、主导航、全站链接以及搜索框。--&gt;\n&lt;nav&gt;         &lt;!--：标记导航，仅对文档中重要的链接群使用。--&gt;\n&lt;main&gt;         &lt;!--：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。--&gt;\n&lt;article&gt;    &lt;!--：定义外部的内容，其中的内容独立于文档的其余部分。--&gt;\n&lt;section&gt;    &lt;!--：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。--&gt;\n&lt;aside&gt;         &lt;!--：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。--&gt;\n&lt;footer&gt;     &lt;!--：页脚，只有当父级是body时，才是整个页面的页脚。--&gt;\n&lt;small&gt;      &lt;!--：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。--&gt;\n&lt;strong&gt;     &lt;!--：和 em 标签一样，用于强调文本，但它强调的程度更强一些。--&gt;\n&lt;em&gt;         &lt;!--：将其中的文本表示为强调的内容，表现为斜体。--&gt;\n&lt;mark&gt;       &lt;!--：使用黄色突出显示部分文本。--&gt;\n&lt;figure&gt;     &lt;!--：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。--&gt;\n&lt;figcaption&gt;&lt;!--：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。--&gt;\n&lt;cite&gt;       &lt;!--：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。--&gt;\n&lt;blockquoto&gt;&lt;!--：定义块引用，块引用拥有它们自己的空间。--&gt;\n&lt;q&gt;          &lt;!--：短的引述（跨浏览器问题，尽量避免使用）。--&gt;\n&lt;time&gt;       &lt;!--：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。--&gt;\n&lt;abbr&gt;       &lt;!--：简称或缩写。--&gt;\n&lt;dfn&gt;       &lt;!--：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。--&gt;\n&lt;address&gt;    &lt;!--：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。--&gt;\n&lt;del&gt;        &lt;!--：移除的内容。--&gt;\n&lt;ins&gt;        &lt;!--：添加的内容。--&gt;\n&lt;code&gt;       &lt;!--：标记代码。--&gt;\n&lt;meter&gt;      &lt;!--：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）--&gt;\n&lt;progress&gt;    &lt;!--：定义运行中的进度（进程）。--&gt;\n语义化的优点：\n\n\n\n\n\n\n\n\n\n\n易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。\n有利于 SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。\n方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页\n有利于开发和维护，语义化更具可读性，代码更好维护，与 CSS3 关系更和谐。\n\n二、CSScss 的继承：\n无继承性的属性：1、display:规定元素应该生成的框的类型\n2、文本属性：\n​ vertical-align:垂直文本对齐\n​ text-decoration:规定添加到文本的修饰\n​ text-shadow:文本阴影效果\n​ white-space:空白符处理\n​ unicode-bidi:设置文本方向\n3、盒子模型属性：\n\n\n\n\n\n\n\n\n\nwidth、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left\n4、背景属性：\n\n\n\n\n\n\n\n\n\nbackgroun、background-color、background-image、background-repeat、background-position、background-attachment\n5、定位属性：\n\n\n\n\n\n\n\n\n\nfloat、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n其他。。。\n有继承性属性1、字体系列：\n\n\n\n\n\n\n\n\n\nfont：组合字体\nfont-family：规定元素的字体系列\nfont-weight：设置字体的粗细\nfont-size：设置字体的尺寸\nfont-style：定义字体的风格\n2、文本系列属性：\n\n\n\n\n\n\n\n\n\ntext-indent：文本缩进\ntext-align：文本水平对齐\nline-height：行高\nword-spacing：增加或减少单词间的空白（即字间隔）\nletter-spacing：增加或减少字符间的空白（字符间距）\ntext-transform：控制文本大小写\ndirection：规定文本的书写方向\ncolor：文本颜色 a 元素除外\n3、元素可见性\n\n\n\n\n\n\n\n\n\nvisibility\n其他。。。\n块级元素哪些属性可以继承？\n\n\n\n\n\n\n\n\n\ntext-indent、text-align、visibility、cursor\n盒模型：\n\n\n\n\n\n\n\n\n\n标准盒模型：盒子总宽度&#x2F;高度 &#x3D;width&#x2F;height + padding + border + margin。（ 即 width&#x2F;height 只是 内容高度，不包含 padding 和 border 值 ）IE 盒子模型：盒子总宽度&#x2F;高度 &#x3D;width&#x2F;height + margin &#x3D; (内容区宽度&#x2F;高度 + padding + border) + margin。（ 即 width&#x2F;height 包含了 padding 和 border 值 ）\nBFC 是什么？(边距重叠解决方案)\n\n\n\n\n\n\n\n\n\nBFC 是 CSS 布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。父子元素和兄弟元素边距重叠，重叠原则取最大值。空元素的边距重叠是取 margin 与 padding 的最大值。\nBFC 原理？\n\n\n\n\n\n\n\n\n\n（1）内部的 Box 会在垂直方向，从顶部开始一个接着一个地放置；（2）Box 垂直方向的距离由 margin(外边距)决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；（3）每个元素的 margin Box 的左边， 与包含块 border Box 的左边相接触，（对于从左到右的格式化，否则相反）。即使存在浮动也是如此；（4）BFC 在页面上是一个隔离的独立容器，外面的元素不会影响里面的元素，反之亦然。文字环绕效果，设置 float；（5）BFC 的区域不会与 float Box 重叠（清浮动）;（6）计算 BFC 的高度时，浮动元素也参与计算。\nCSS 在什么情况下会创建出 BFC？\n\n\n\n\n\n\n\n\n\n0、根元素，即 HTML 元素（最大的一个 BFC）1、浮动（float 的值不为 none）2、绝对定位元素（position 的值为 absolute 或 fixed）3、行内块（display 为 inline-block）4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性)5、弹性盒（display 为 flex 或 inline-flex）6、默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible）\n样式优先级：\n\n\n\n\n\n\n\n\n\n!important\n内联  1000\nid 选择器 #content  100\n类选择器（伪类和属性选择器） .content  10\n类型选择器和伪元素选择器 div p  1\n通配符（*）、子选择器（&gt;）、相邻选择器(+) 0\n继承的样式没有权值\n盒子塌陷\n\n\n\n\n\n\n\n\n\n本应该在父盒子内部的元素跑到了外部。\n当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为 auto 时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS 高度塌陷。\n解决盒子塌陷的方法：\n\n\n\n\n\n\n\n\n\n1、设置盒子的宽高\n2、给外部的父盒子也添加浮动，让其脱离标准文档流\n3、父盒子添加 overflow 属性\n4、父盒子最下方引入清除浮动块 clear:both\n5、after 伪元素清除浮动\n6、父盒子添加 border\n7、父盒子设置 padding-top\n伪类和伪元素的区别\n\n\n\n\n\n\n\n\n\n伪类：\n\n其核⼼就是⽤来选择 DOM 树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。\n⽐如:hover :active :visited :link :visited :first-child :focus :lang 等\n由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。\n由此可以看出，它的功能和 class 有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。\n\n伪元素：\n\nDOM 树没有定义的虚拟元素\n核⼼就是需要创建通常不存在于⽂档中的元素，\n⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。\n伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n\n总结：\n\n\n\n\n\n\n\n\n\n\n伪类和伪元素都是⽤来表示⽂档树以外的”元素”。\n伪类和伪元素分别⽤单冒号:和双冒号::来表示。\n伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，\n是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类\n伪类和伪元素都不出现在源⽂件和 DOM 树中。也就是说在 html 源⽂件中是看不到伪类和伪元素的。\n伪类其实就是基于普通 DOM 元素⽽产⽣的不同状态，他是 DOM 元素的某⼀特征。\n伪元素能够创建在 DOM 树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。\n\n行内元素的 margin padding\n\n\n\n\n\n\n\n\n\n\n水平方向：水平方向上，都有效；\n垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响）\n\nmin-height 和 max-height min-width 和 max-width\n\n\n\n\n\n\n\n\n\n\nmax-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。\nmin-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；\n\n布局：\n未知高度元素垂直居中、垂直居中的实现方式有哪些？1、绝对定位+css3 transform:translate(-50%,50%)\ncss.wrap &#123;\n  position: relative;\n&#125;\n.child &#123;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  -webkit-transform: translate(-50%, -50%);\n&#125;2、css 的 flex 布局\ncss.wrap &#123;\n  display: flex;\n  justify-content: center;\n&#125;\n.child &#123;\n  align-self: center;\n&#125;3、table 布局\ncss&lt;div\n  class=&quot;wrap&quot;\n  &gt; &lt;div\n  class=&quot;child&quot;\n  &gt; &lt;div\n  &gt; sadgsdgasgd&lt;/div\n  &gt; &lt;/div\n  &gt; &lt;/div\n  &gt; .wrap &#123;\n  display: table;\n  text-align: center;\n&#125;\n.child &#123;\n  background: #ccc;\n  display: table-cell;\n  vertical-align: middle;\n&#125;\n.child div &#123;\n  width: 300px;\n  height: 150px;\n  background: red;\n  margin: 0 auto;\n&#125;图片垂直居中的方法\nhtml// flex\n&lt;style&gt;\n  body &#123;\n    background: #999;\n  &#125;\n  .flexbox &#123;\n    width: 300px;\n    height: 250px;\n    background: #fff;\n    display: flex;\n    align-items: center;\n  &#125;\n  .flexbox img &#123;\n    width: 100px;\n    height: 100px;\n    align-items: center;\n  &#125;\n&lt;/style&gt;\n&lt;div class=&quot;flexbox&quot;&gt;\n  &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; /&gt;\n&lt;/div&gt;\n// 绝对定位\n&lt;style&gt;\n  body &#123;\n    background: #ccc;\n  &#125;\n  .posdiv &#123;\n    width: 300px;\n    height: 250px;\n    background: #fff;\n    position: relative;\n    margin: 0 auto;\n  &#125;\n  .posdiv img &#123;\n    width: 100px;\n    position: absolute;\n    top: 50%;\n    margin-top: -50px;\n  &#125;\n&lt;/style&gt;rem 适配\njs&lt;head&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;\n  &lt;script&gt;\n    const WIDTH = 750 //设计稿尺寸\n    const setView = () =&gt; &#123;\n      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + &#39;px&#39;\n    &#125;\n    window.onorientationchange = setView\n    setView()\n  &lt;/script&gt;\n&lt;/head&gt;清除浮动的方法：\n1、clear：both 添加了无意义的标 签，结构化比较差\n2、overflow:hidden 内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素。\n3、伪元素：after 伪元素清除浮动\ncss.clearfix:after &#123;\n  content: &quot;.&quot;; /*尽量不要为空，一般写一个点*/\n  height: 0; /*盒子高度为0，看不见*/\n  display: block; /*插入伪元素是行内元素，要转化为块级元素*/\n  visibility: hidden; /*content有内容，将元素隐藏*/\n  clear: both;\n&#125;\n\n.clearfix &#123;\n  *zoom: 1; /*  *只有IE6,7识别 */\n&#125;4、after 伪元素空余字符法\ncss.clearfix::after &#123;\n  content: &quot;\\200B&quot;; /* content:&#39;\\0200&#39;; 也可以 */\n  display: block;\n  height: 0;\n  clear: both;\n&#125;\n\n.clearfix &#123;\n  *zoom: 1;\n&#125;5、使用 before 和 after 双伪元素清除浮动\ncss.clearfix:before,\n.clearfix:after &#123;\n  content: &quot;&quot;;\n  display: table;\n&#125;\n.clearfix:after &#123;\n  clear: both;\n&#125;\n.clearfix &#123;\n  *zoom: 1;\n&#125;px:绝对长度单位\nem:相对长度单位 值不固定，继承父元素的字体大小 相对父元素的大小\nrem：相对长度单位 相对于根元素换算\n","slug":"3-css","date":"2019-06-20T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"76e67b321d5ea32b1e2e48c964f6f63c","title":"2、微信小程序checkbox-group","content":"checkbox-group多项选择器，内部由多个checkbox组成；属性bindchange   说明checkbox-group中选中项发生改变时触发 change 事件，detail &#x3D; {value:[选中的checkbox的value的数组]};\n\n\n\nhtml&lt;checkbox-group  class=&quot;checkbox_group&quot; bindchange=&quot;checkboxChange&quot;&gt;\n    &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;item&quot;&gt;\n        &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot;  checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot; /&gt;\n        &#123;&#123;item.value&#125;&#125;\n    &lt;/label&gt;\n&lt;/checkbox-group&gt;每一次修改选中项，都需要一个空数组去存放选中项。\n\n点我展示代码\n\njs  checkboxChange(e) &#123;\n    const items = this.data.items; \n    const values = e.detail.value;\n    // 设置选中的数组为空  选中的id push到数组里面\n    this.data.vehicle_arr = [];\n    for (let i = 0, lenI = items.length; i &lt; lenI; ++i) &#123;\n      items[i].checked = false // 遍历items，让所有的选中状态都为false\n      for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123;\n        if (items[i].value === values[j]) &#123;\n          items[i].checked = true;\n          const List = items[i].name.toString().split();\n          for (let k in List) &#123;\n            this.data.vehicle_arr.push(List[k]);\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n    // 选中的id\n    this.data.unique = [...new Set(this.data.vehicle_arr)];\n    this.setData(&#123;\n      driverarr: e.detail.value.join(&quot;,&quot;), // 多选的数组\n      items,\n    &#125;);\n  &#125;,","slug":"2-check-group","date":"2019-01-20T12:00:00.000Z","categories_index":"","tags_index":"dev","author_index":"Jude"},{"id":"f8d2a312d32d896df5351526b3b10ad7","title":"1、Hexo常用命令","content":"hexo常用命令\n\n\nQuick Start新建文件js$ hexo new &quot;My New Post&quot;More info: Writing\n启动本地服务js$ hexo serverMore info: Server\n生成本地静态文件js$ hexo generateMore info: Generating\n发布bash$ hexo deployMore info: Deployment\n\n\n打包发布的命令行可以直接这样写：\nbashhexo g &amp;&amp; hexo d","slug":"1-hello-world","date":"2019-01-02T12:00:00.000Z","categories_index":"","tags_index":"","author_index":"Jude"}]
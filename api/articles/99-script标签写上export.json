{"title":"99、script标签写export为什么会报错?","uid":"480d09ccf327606485d7ffb7e81e17c3","slug":"99-script标签写上export","date":"2022-11-27T12:00:00.000Z","updated":"2023-01-30T08:52:38.000Z","comments":true,"path":"api/articles/99-script标签写上export.json","keywords":null,"cover":null,"content":"<span id=\"more\"></span>\n\n<h4 id=\"一、脚本和模块\"><a href=\"#一、脚本和模块\" class=\"headerlink\" title=\"一、脚本和模块\"></a>一、脚本和模块</h4><p>​ JavaScript 有 2 种源文件，一种叫做脚本，一种叫做模块。这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前版本中，就只有一种源文件格式，即脚本。</p>\n<p>​ 脚本是可以由浏览器或者 node 环境引入执行的，而模块智能有 JavaScript 代码用 import 引入执行。</p>\n<p>​ 脚本具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块是被动行的 JavaScript 代码段，是等待被调用的库。</p>\n<p>​ 实际上，<code>模块和脚本之间的区别仅仅在于是否包含import和export</code>。</p>\n<p>​ 脚本是一种兼容之前的版本的定义，在这个模式下，没有 import 就不需要处理加载.js 文件问题。</p>\n<p>​ 现代浏览器可以支持用 script 标签引入模块或者脚本，如果需要引入模块，必须给 script 标签添加 type&#x3D;”module”。如果引入脚本，则不需要 type。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">&lt;script type=&quot;module&quot; scr=&quot;XXX.js&quot;&gt;&lt;/script&gt;</span></span></code></pre></div><p>​ script 标签如果不加 type&#x3D;“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会抛错。</p>\n<p>​ 脚本可以包含语句。模块包含 3 中内容：import 声明、export 声明、语句。</p>\n<p>​ <code>import声明</code>用法有 2 种：一个是<code>直接import一个模块</code>、另一个是&#96;&#96;带from的import&#96;（能引入模块里的一些信息）</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">import &quot;module&quot;; // 引入一个模块</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">import m from &quot;module&quot;; // 把模块默认的导出值放入变量m</span></span></code></pre></div><p>​ 用法 1 直接 import 一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。</p>\n<p>​ 用法 2 带 from 的 import 意思是引入模块中的一部分信息，可以把他们变成本地的变量。</p>\n<p>​ 带 from 的 import 又分为 3 种用法：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">import x from &quot;./a.js&quot;; // 引入模块中导出的默认值</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">import &#123; a as x, modify &#125; from &quot;./a.js&quot;; // 引入模块中的变量</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">import * as x from &quot;./a.js&quot;; // 把模块中所有的变量以类型对象属性的方式引入</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">// 第一种方式还可以跟后两种组合使用</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">import d, &#123; a as x, modify &#125; from &quot;./a.js&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">import d, * as x from &quot;./a.js&quot;;</span></span></code></pre></div><p>​ 语法要求不带 as 的默认值永远在最前。注意，这里的变量实际上仍然可以受到原来模块的控制。</p>\n<p>示例代码：</p>\n<p><code>模块a</code></p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">export var a = 1;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">export function modify() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  a = 2;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p><code>模块b</code></p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">import &#123; a, modify &#125; from &quot;./a.js&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">console.log(a);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">modify();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">console.log(a);</span></span></code></pre></div><p>​ 当我们调用修改变量的函数后，b 模块变量也跟着发生了改变。这说明导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。</p>\n<p><code>export声明</code>：承担的是导出的任务。</p>\n<p>​ 模块中导出变量的方式有两种，一种是独立使用 export 声明，一种是直接在声明型语句前添加 export 关键字。</p>\n<p>​ 独立使用 export 声明就是一个 export 关键字加上变量名列表。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">export &#123; a, b, c &#125;;</span></span></code></pre></div><p>​ 我们也可以直接在声明型语句前添加 export 关键字，这里的 export 可以加在任何声明性质的语句之前</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function(含async 和generator)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">class</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">let</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">const</span></span></code></pre></div><p>​ export 还有一种特殊的用法，就是跟 default 联合使用。export default 表示到处一个默认变量值，它可以用于 function 和 class。这里导出的变量是没有名称的，可以使用 import x from ‘.&#x2F;a.js’ 这样的语法，在模块中引入。</p>\n<p>​ export default 还支持一种语法，后面跟一个表达式</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var a = &#123;&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">export default a;</span></span></code></pre></div><p>​ 但是，这里的行为跟导出变量是不一致，这里导出的是值，<code>导出的就是普通变量a的值，以后a的变化与导出的值就无关了</code>，修改变量 a，不会使得其他模块中引入的 default 值发生改变。</p>\n<p>​ 在 import 语句前无法加入 export，但是我们可以直接使用 export from 语法</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">export a from &quot;a.js&quot;;</span></span></code></pre></div><p>​ JavaScript 引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处。</p>\n<h4 id=\"二、函数体\"><a href=\"#二、函数体\" class=\"headerlink\" title=\"二、函数体\"></a>二、函数体</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>执行函数的行为通常是在 JavaScript 代码执行时，注册宿主环境的某些事件触发的，而执行的过程，就是执行函数体（函数的花括号中间的部分）。</p></blockquote>\n<p>下面的 setTimeout 函数注册了一个函数给宿主，当一定时间之后，宿主就会执行这个函数。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">setTimeout(function () &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;go&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;, 10000);</span></span></code></pre></div><p>宿主会为这样的函数创建宏任务。宏任务中可能会执行的代码包括脚本、模块、函数体。</p>\n<p>函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了 return 语句可以用。</p>\n<p><code>普通函数体</code>：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  //function body</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p><code>异步函数体</code>：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">async function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  // function body</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p><code>生成器函数体</code>：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function* foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  // function body</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p><code>异步生成器函数体</code>：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">async function* foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  // function body</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p>上面的 4 种函数体的区别在于：能否使用 await 或者 yield</p>\n<p>类型 yield await return import&amp;export</p>\n<p>普通函数体 X X √ X</p>\n<p>异步函数体 X √ √ X</p>\n<p>生成器函数体 √ X √ X</p>\n<p>异步生成器函数体 √ √ √ X</p>\n<p>脚本 X X X X</p>\n<p>模块 X X X √</p>\n<h4 id=\"三、预处理机制\"><a href=\"#三、预处理机制\" class=\"headerlink\" title=\"三、预处理机制\"></a>三、预处理机制</h4><p>JavaScript 语法的全局机制：预处理和指令序言。这 2 个机制对于我们解释一些 JavaScript 的语法现象非常重要。预处理机制可以理解 var 等声明类语句行为，指令序言可以解释严格模式。</p>\n<p><code>预处理</code>：JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p>\n<p><code>var声明</code>：var 声明永远作用于脚本、模块和函数体，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var a = 1;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(a); // undefined</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  var a = 2;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">foo();</span></span></code></pre></div><p>上面的代码声明了一个脚本级别的 a，又声明了 foo 函数体级别的 a，函数体级的 var 出现在 console.log 语句之后。</p>\n<p>预处理过程在执行前，所以有函数体级的变量 a，就不会去访问外层作用域中的变量 a 了，而函数体级的变量 a 此时还没有复制，所以是 undefined。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var a = 1;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(a);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  if (false) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    var a = 2;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">foo();</span></span></code></pre></div><p>这段代码比上一段代码在 var a &#x3D; 2 之外多了一段 if，我们知道 if(false) 中的代码永远不会被执行，但是预处理阶段并不管这个，var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。所以这里结果跟前一段代码完全一样，我们会得到 undefined。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var a = 1;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  var o = &#123; a: 3 &#125;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  with (o) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    var a = 2;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(o.a);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(a);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">foo();</span></span></code></pre></div><p>引入 with 语句，with(o)创建了一个作用域，并把 o 对象加入词法环境，在其中使用了 var a &#x3D; 2 语句。</p>\n<p>在预处理阶段，只认 var 中声明的变量，所以同样为 foo 的作用域创建了 a 这个变量，但是没有赋值。在执行阶段，当执行到 var a &#x3D; 2 时，作用域变成了 with 语句内，这时候的 a 被认为访问到了对象 o 的属性 a，所以最终执行的结果，我们得到了 2 和 undefined。</p>\n<p><code>function声明</code>：function 声明的行为，在全局（脚本、模块和函数体），function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">console.log(foo);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;&#125;</span></span></code></pre></div><p>在声明函数 foo 之前，打印函数 foo,我们可以发现，已经是函数 foo 的值了。</p>\n<p>下面示例不再被提前赋值：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">console.log(foo); // undefined</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">if (true) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  function foo() &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p>function 声明出现在 if 等语句中，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值。</p>\n<p>上述打印结果为 undefined，声明 function 在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。</p>\n<p>出现在 if 等语句中的 function，在 if 创建的作用域中仍然会被提前，产生赋值效果。</p>\n<p><code>class声明</code>：在全局的行为跟 function 和 var 都不一样。</p>\n<p>在 class 声明前使用 class 类名，会抛出错误：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">console.log(c); // c is not defined</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">class c &#123;&#125;</span></span></code></pre></div><p>这个抛错很像是 class 没有预处理，但实际上并非如此。</p>\n<p>复杂一点的例子：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var c = 1;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(c);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  class c &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">foo();</span></span></code></pre></div><p>上面的代码，把 class 放进了一个函数体中，在外层作用域中有变量 c。</p>\n<p>执行后，我们看到，仍然抛出了错误，如果去掉 class 声明，则会正常打印出 1，也就是说，出现在后面的 class 声明影响了前面语句的结果。这说明，class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。</p>\n<p>class 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。</p>\n<h4 id=\"四、指令序言机制\"><a href=\"#四、指令序言机制\" class=\"headerlink\" title=\"四、指令序言机制\"></a>四、指令序言机制</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>脚本和模块都支持一种特别的语法，指令序言最早是为了 use strict 设计的，它规定了一种给 JavaScript 代码添加元信息的方式。</p></blockquote>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">&quot;use strict&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function f() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(this);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">f.call(null);</span></span></code></pre></div><p>null 原封不动地被当做 this 值打印了出来，这是严格模式的特征。</p>\n<p>去掉严格模式，打印结果会变成 global。</p>\n<p>‘use strict’是 JavaScript 标准中规定的唯一一种指令序言，但是设计指令序言的目的是留给 JavaScript 的引擎和实现者一些统一的表达式，在静态规定扫描时指定 JavaScript 代码的一些特性。</p>\n<p>JavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function doSth() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  //</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">(&quot;use strict&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">var a = 1;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">// .....</span></span></code></pre></div><p>‘use strct’没有出现在最前，所以不是指令序言。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">&quot;use strict&quot;; // 单引号也是指令序言</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">function doSth() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  // ....</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div>","text":" 一、脚本和模块​ JavaScript 有 2 种源文件，一种叫做脚本，一种叫做模块。这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前版本中，就...","permalink":"/post/99-script标签写上export","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"js","slug":"js","count":11,"path":"api/tags/js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%84%9A%E6%9C%AC%E5%92%8C%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">一、脚本和模块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E4%BD%93\"><span class=\"toc-text\">二、函数体</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">三、预处理机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%8C%87%E4%BB%A4%E5%BA%8F%E8%A8%80%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">四、指令序言机制</span></a></li></ol>","author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"100、vuex的缺点及从0写一个vuex的思路","uid":"5eacc1a76b17657b3d8adae27636584f","slug":"100-vuex","date":"2022-11-29T12:00:00.000Z","updated":"2023-02-01T02:32:43.000Z","comments":true,"path":"api/articles/100-vuex.json","keywords":null,"cover":null,"text":" 1、用过 module，项目规模变大之后，单独一个 store 对象会过于庞大臃肿，通过模块方式可以拆分开来便于维护 2、可以按之前规则单独编写子模块代码，然...","permalink":"/post/100-vuex","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"vuex","slug":"vuex","count":1,"path":"api/tags/vuex.json"}],"author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"98、基于JavaScript开发灵活的数据应用--基本数据处理(一)","uid":"ac9377bb15e422a5f96baff96a68759d","slug":"98-js-string-number-array","date":"2022-11-26T12:00:00.000Z","updated":"2023-01-30T03:46:46.000Z","comments":true,"path":"api/articles/98-js-string-number-array.json","keywords":null,"cover":null,"text":"现代编程语言中，最基本的数据格式都会是字符串和数字。字符串用于表达人类文明的自然语言，数字用于表达量化世界的各种数值。 一、字符串字符串的运用包括，字符串的创建...","permalink":"/post/98-js-string-number-array","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"js","slug":"js","count":11,"path":"api/tags/js.json"}],"author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
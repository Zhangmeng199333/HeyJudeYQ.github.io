{"title":"97、promise代码为什么比setTimeout先执行？","uid":"e929ef3d125c37b460b3ea3c3fcb86e1","slug":"97-promise","date":"2022-11-23T12:00:00.000Z","updated":"2022-12-06T08:10:05.000Z","comments":true,"path":"api/articles/97-promise.json","keywords":null,"cover":null,"content":"<p>​ 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"一、JavaScript-的执行\"><a href=\"#一、JavaScript-的执行\" class=\"headerlink\" title=\"一、JavaScript 的执行\"></a>一、JavaScript 的执行</h4><p>​ 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。</p>\n<p>​ 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。</p>\n<p>​ JavaScript 语言，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>\n<h4 id=\"二、宏观任务与微观任务\"><a href=\"#二、宏观任务与微观任务\" class=\"headerlink\" title=\"二、宏观任务与微观任务\"></a>二、宏观任务与微观任务</h4><p>​ JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>宏观任务的队列就相当于事件循环</p></blockquote>\n<p>​ 在宏观任务中，JavaScript 的 promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此每个宏观任务中又包含一个微观任务队列。</p>\n<p>MacroTask</p>\n<p>​ microTask microTask microTask</p>\n<p>MacroTask</p>\n<p>​ microTask microTask microTask</p>\n<p>MacroTask</p>\n<p>​ 有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：<code>Promise 永远在队列尾部添加微观任务</code>。setTimeout 等宿主 API，则会添加宏观任务。</p>\n<h4 id=\"三、Promise\"><a href=\"#三、Promise\" class=\"headerlink\" title=\"三、Promise\"></a>三、Promise</h4><p>​ Promise 是 JavaScript 语言提供的一种标准化的异步管理方式。promise 总体思想是，需要进行 IO、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（promise 的 then 方法回调）</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function sleep(duration) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  return new Promise((resolve, reject) =&gt; &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    setTimeout(resolve, duration);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">sleep(1000).then(() =&gt; console.log(&quot;finished&quot;));</span></span></code></pre></div><p>sleep 函数的作用：等候传入参数指定的时长。</p>\n<p>Promise 的 then 回调是一个异步的执行过程。示例代码：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var test = new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;a&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  resolve();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">test.then(() =&gt; console.log(&quot;c&quot;));</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">console.log(&quot;b&quot;);</span></span></code></pre></div><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>打印顺序：a &gt; b &gt; c</p></blockquote>\n<p>​ 在进入 console.log(‘b’)之前，毫无疑问 test 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。</p>\n<p>当 setTimeout 和 Promise 混用，设置两段互不相干的异步操作：通过 setTimeout 执行 console.log(‘d’)，通过 Promise 执行 console.log(‘c’)</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">var test = new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;a&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  resolve();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">setTimeout(() =&gt; console.log(&quot;d&quot;), 0);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">test.then(() =&gt; console.log(&quot;c&quot;));</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">console.log(&quot;b&quot;);</span></span></code></pre></div><p>我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。</p>\n<p>理解<code>微任务始终先于宏任务</code>，示例：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">// 执行一个耗时1秒的Promise</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">setTimeout(() =&gt; console.log(&quot;d&quot;), 0);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">var r = new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  resolve();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">r.then(() =&gt; &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  var begin = Date.now();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  while (Date.now() - begin &lt; 1000);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;c1&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    resolve();</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;).then(() =&gt; console.log(&quot;c2&quot;));</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;);</span></span></code></pre></div><p>执行顺序：c1 &gt; c2 &gt; d 。 即使耗时 1 秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行，这可以很好的解释了<code>微任务优先</code>的原理。</p>\n<p>异步执行的顺序：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1、分析有多少个宏任务</p>\n<p>2、在每个宏任务中，分析有多少个微任务</p>\n<p>3、根据调用次序，确定宏任务中的微任务执行次序</p>\n<p>4、根据宏任务的触发规则和调用次序，确定宏任务的执行次序</p>\n<p>5、确定整个顺序</p></blockquote>\n<p>复杂的例子：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function sleep(duration) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  return new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    console.log(&quot;b&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    setTimeout(resolve, duration);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">console.log(&quot;a&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">sleep(5000).then(() =&gt; console.log(&quot;c&quot;));</span></span></code></pre></div><p>执行顺序：a &gt; b &gt; c 。setTimeout 把整个代码分割成了 2 个宏观任务，，不论是 5 秒还是 0 秒，都是一样。</p>\n<p>第一个宏观任务中，包含了先后同步执行的 console.log(‘a’)和 console.log(‘b’)</p>\n<p>setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(‘c’),最终输出的顺序为： a b c 。</p>\n<p>​ Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async&#x2F;await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。</p>\n<h4 id=\"四、async-await\"><a href=\"#四、async-await\" class=\"headerlink\" title=\"四、async&#x2F;await\"></a>四、async&#x2F;await</h4><p>​ async&#x2F;await 是 ES2016 新加入的特性，它提供了用 for、if 等结构来编写异步的方式。</p>\n<p>它的运行时基础是 Promise。</p>\n<p>​ async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。</p>\n<p>async 函数是一种特殊语法，特征是在 function 关键字之前加上一个 async 关键字，这样就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function sleep(duration) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  return new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    setTimeout(resolve, duration);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">async function foo() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;a&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  await sleep(2000);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(&quot;b&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">foo();</span></span></code></pre></div><p>​ async 函数强大之处在于，它是可以嵌套的。</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">function sleep(duration) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  return new Promise(function (resolve, reject) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    setTimeout(resolve, duration);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  &#125;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">async function foo(name) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  await sleep(2000);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  console.log(name);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">async function foo2() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  await foo(&quot;a&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  await foo(&quot;b&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div>","text":"​ 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 Jav...","permalink":"/post/97-promise","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"promise","slug":"promise","count":1,"path":"api/tags/promise.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81JavaScript-%E7%9A%84%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">一、JavaScript 的执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%AE%8F%E8%A7%82%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E8%A7%82%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">二、宏观任务与微观任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Promise\"><span class=\"toc-text\">三、Promise</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81async-await\"><span class=\"toc-text\">四、async&#x2F;await</span></a></li></ol>","author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"98、基于JavaScript开发灵活的数据应用--基本数据处理(一)","uid":"ac9377bb15e422a5f96baff96a68759d","slug":"98-js-string-number-array","date":"2022-11-26T12:00:00.000Z","updated":"2023-01-30T03:46:46.000Z","comments":true,"path":"api/articles/98-js-string-number-array.json","keywords":null,"cover":null,"text":"现代编程语言中，最基本的数据格式都会是字符串和数字。字符串用于表达人类文明的自然语言，数字用于表达量化世界的各种数值。 一、字符串字符串的运用包括，字符串的创建...","permalink":"/post/98-js-string-number-array","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"js","slug":"js","count":11,"path":"api/tags/js.json"}],"author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"96、vue3的使用transition时，不写根标签的警告","uid":"84e16524d6625869d4ec840ccc50d079","slug":"96-transition","date":"2022-11-22T12:00:00.000Z","updated":"2022-11-26T14:58:01.000Z","comments":true,"path":"api/articles/96-transition.json","keywords":null,"cover":null,"text":"terminal 中的警告：[Vue warn]: Component inside renders non-element root node that ca...","permalink":"/post/96-transition","photos":[],"count_time":{"symbolsCount":176,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"vue3","slug":"vue3","count":24,"path":"api/tags/vue3.json"}],"author":{"name":"Jude","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
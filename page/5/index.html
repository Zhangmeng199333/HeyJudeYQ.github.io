<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;issummer.cn&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta property="og:type" content="website">
<meta property="og:title" content="Jude">
<meta property="og:url" content="http://issummer.cn/page/5/index.html">
<meta property="og:site_name" content="Jude">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://issummer.cn/page/5/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<title>Jude</title><script data-pjax src="/js/load-config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Jude</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://issummer.cn/2022/12/12/106.ref/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jude">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/12/106.ref/" class="post-title-link" itemprop="url">106、ref小技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-12 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-12T20:00:00+08:00">2022-12-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-28 10:46:23" itemprop="dateModified" datetime="2023-02-28T10:46:23+08:00">2023-02-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 console.log 输出一个 ref 对象时，控制台查看结果时很不方便，Chrome 浏览器对此有一个格式化的处理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/12/106.ref/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://issummer.cn/2022/12/10/105-ts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jude">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/10/105-ts/" class="post-title-link" itemprop="url">105、typescript函数Class类型：函数重载和面向对象(三)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-10 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-10T20:00:00+08:00">2022-12-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-07 11:37:29" itemprop="dateModified" datetime="2023-02-07T11:37:29+08:00">2023-02-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：<strong>函数</strong>。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。</p>
<p>介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如<strong>重载</strong>与<strong>面向对象的编程</strong>等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的类型签名"><a href="#函数的类型签名" class="headerlink" title="函数的类型签名"></a>函数的类型签名</h3><p>如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了<strong>函数入参类型与函数返回值类型</strong>，它们同样使用<code>:</code>的语法进行类型标注。我们直接看最简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在函数类型中同样存在着类型推导。比如在这个例子中，你可以不写返回值处的类型，它也能被正确推导为 number 类型。</p>
<p>在 JavaScript 中，我们称 <code>function name () &#123;&#125;</code> 这一声明函数的方式为<strong>函数声明（*Function Declaration*）</strong>。除了函数声明以外，我们还可以通过<strong>函数表达式（*Function Expression*）</strong>，即 <code>const foo = function()&#123;&#125;</code> 的形式声明一个函数。在表达式中进行类型声明的方式是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们也可以像对变量进行类型标注那样，对 <code>foo</code> 这个变量进行类型声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> foo: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>(name: string) =&gt; number</code> 看起来很眼熟，对吧？它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 TypeScript 中的<strong>函数类型签名</strong>。而实际的箭头函数，我们的类型标注也是类似的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">const</span> foo = (name: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">const</span> foo: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性会非常差。因此，一般不推荐这么使用，要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> FuncFoo = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">const</span> foo: FuncFoo = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> FuncFooStruct &#123;<br>  (name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这时的 interface 被称为 <strong>Callable Interface</strong>，看起来可能很奇怪，但我们可以这么认为，interface 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型罢了。</p>
<h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 没有调用 return 语句</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 调用了 return 语句，但没有返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因和我们在原始类型与对象类型一节中讲到的：<strong>在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。</strong> 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数<strong>没有进行返回操作</strong>。但在上面的第二个例子中，其实更好的方式是使用 undefined ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>): <span class="hljs-title">undefined</span> </span>&#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时我们想表达的则是，这个函数<strong>进行了返回操作，但没有返回实际的值</strong>。</p>
<h3 id="可选参数与-rest-参数"><a href="#可选参数与-rest-参数" class="headerlink" title="可选参数与 rest 参数"></a>可选参数与 rest 参数</h3><p>在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 <code>?</code> 描述一个可选属性一样，在函数类型中我们也使用 <code>?</code> 描述一个可选参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在函数逻辑中注入可选参数默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age || <span class="hljs-number">18</span>; <span class="hljs-comment">// 或使用 age ?? 18</span><br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br><br><span class="hljs-comment">// 直接为可选参数声明默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age;<br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。毕竟在 JavaScript 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用 <code>?</code> 了，因为既然都有默认值，那肯定是可选参数啦。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age || <span class="hljs-number">18</span>;<br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在某些情况下，这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。</p>
<p>对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：</p>
<blockquote>
<p>对于 any 类型，你可以简单理解为它包含了一切可能的类型，我们会在下一节详细介绍。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>当然，你也可以使用我们前面学习的元祖类型进行标注：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>]</span>) </span>&#123;&#125;<br><br>foo(<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (bar) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">599</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个实例中，函数的返回类型基于其入参 <code>bar</code> 的值，并且从其内部逻辑中我们知道，当 <code>bar</code> 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。</p>
<p>要想实现与入参关联的返回值类型，我们可以使用 TypeScript 提供的<strong>函数重载签名（*Overload Signature*）</strong>，将以上的例子使用重载改写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar: <span class="hljs-literal">true</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-literal">false</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (bar) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">599</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> res1 = func(<span class="hljs-number">599</span>); <span class="hljs-comment">// number</span><br><span class="hljs-keyword">const</span> res2 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// string</span><br><span class="hljs-keyword">const</span> res3 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure>

<p>这里我们的三个 <code>function func</code> 其实具有不同的意义：</p>
<ul>
<li><code>function func(foo: number, bar: true): string</code>，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。</li>
<li><code>function func(foo: number, bar?: false): number</code>，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。</li>
<li><code>function func(foo: number, bar?: boolean): string | number</code>，函数的实现签名，会包含重载签名的所有可能情况。</li>
</ul>
<p>基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。</p>
<p>这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。</p>
<blockquote>
<p>你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。</p>
</blockquote>
<p>实际上，TypeScript 中的重载更像是伪重载，<strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。而在如 C++ 等语言中，重载体现在多个<strong>名称一致但入参不同的函数实现上</strong>，这才是更广义上的函数重载。</p>
<h3 id="异步函数、Generator-函数等类型签名"><a href="#异步函数、Generator-函数等类型签名" class="headerlink" title="异步函数、Generator 函数等类型签名"></a>异步函数、Generator 函数等类型签名</h3><p>对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">asyncGenFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">AsyncIterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>其中，Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。而对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 <code>Promise&lt;T&gt;</code>（关于泛型我们会在后面进行详细了解）。</p>
<p>在函数这一节中，我们主要关注函数的类型标注。因为 TypeScript 中的函数实际上相比 JavaScript 也只是多在重载这一点上，我们需要着重掌握的仍然是类型标注。但在 Class 中，我们的学习重点其实更侧重于其语法与面向对象的编程理念。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="类与类成员的类型签名"><a href="#类与类成员的类型签名" class="headerlink" title="类与类成员的类型签名"></a>类与类成员的类型签名</h3><p>一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有<strong>构造函数</strong>、<strong>属性</strong>、<strong>方法</strong>和<strong>访问符（*Accessor*）</strong>，我们也只需要关注这三个部分即可。这里我要说明一点，有的同学可能认为装饰器也是 Class 的结构，但我个人认为它并不是 Class 携带的逻辑，不应该被归类在这里。</p>
<blockquote>
<p>而对于这些结构的具体意义以及 Class 的入门语法，你可以阅读阮一峰老师的 ES6 标准入门。</p>
</blockquote>
<p>属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">propA</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span>+A`</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">propA</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-built_in">this</span>.prop = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>+A`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>唯一需要注意的是，setter 方法<strong>不允许进行返回值的类型标注</strong>，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致，这里我们不再赘述。</p>
<p>就像函数可以通过<strong>函数声明</strong>与<strong>函数表达式</strong>创建一样，类也可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建。很明显上面的写法即是类声明，而使用类表达式的语法则是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> Foo = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 TypeScript 中我们能够为 Class 成员添加这些修饰符：<code>public</code> / <code>private</code> / <code>protected</code> / <code>readonly</code>。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。</p>
<p>这些修饰符应用的位置在成员命名前：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> prop: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> <span class="hljs-title">propA</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span>+A`</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">set</span> <span class="hljs-title">propA</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-built_in">this</span>.propA = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>+A`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们通常不会为构造函数添加修饰符，而是让它保持默认的 public。在扩展阅读中我们会讲到 private 修饰构造函数的场景。</p>
</blockquote>
<p>如果没有其他语言学习经验，你可能不太理解 public / private / protected 的意义，我们简单做个解释。</p>
<ul>
<li>public：此类成员在<strong>类、类的实例、子类</strong>中都能被访问。</li>
<li>private：此类成员仅能在<strong>类的内部</strong>被访问。</li>
<li>protected：此类成员仅能在<strong>类与子类中</strong>被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即<strong>不允许再访问受保护的成员</strong>。</li>
</ul>
<p>当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以<strong>在构造函数中对参数应用访问性修饰符</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> arg1: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">private</span> arg2: <span class="hljs-built_in">boolean</span></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Foo(<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">staticHandler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">instanceHandler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 <code>Foo.staticHandler</code> 这种形式进行访问。我们可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Foo = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  Foo.staticHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  Foo.prototype.instanceHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  <span class="hljs-keyword">return</span> Foo;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>从中我们可以看到，<strong>静态成员直接被挂载在函数体上</strong>，而<strong>实例成员挂载在原型上</strong>，这就是二者的最重要差异：<strong>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）</strong>。而原型对象上的实例成员则会<strong>沿着原型链进行传递</strong>，也就是能够被继承。</p>
<p>而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如我会用<strong>类 + 静态成员</strong>来收敛变量与 utils 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identifier = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">makeUHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Utils.studyWithU();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">studyWithU</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br>Utils.makeUHappy();<br></code></pre></td></tr></table></figure>

<h3 id="继承、实现、抽象类"><a href="#继承、实现、抽象类" class="headerlink" title="继承、实现、抽象类"></a>继承、实现、抽象类</h3><p>既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>对于这里的两个类，比较严谨的称呼是 <strong>基类（*Base*）</strong> 与 <strong>派生类（*Derived*）</strong>。当然，如果你觉得叫父类与子类更容易理解也没问题。关于基类与派生类，我们需要了解的主要是<strong>派生类对基类成员的访问与覆盖操作</strong>。</p>
<p>基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。我们在上面其实已经介绍过，派生类中可以访问到使用 <code>public</code> 或 <code>protected</code> 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但我们仍然可以通过 super 访问到基类中的方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.print();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在派生类中覆盖基类方法时，我们并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？所以，TypeScript 4.3 新增了 <code>override</code> 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">printWithLove</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>  override <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里 TS 将会给出错误，因为<strong>尝试覆盖的方法并未在基类中声明</strong>。通过这一关键字我们就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。</p>
<p>除了基类与派生类以外，还有一个比较重要的概念：<strong>抽象类</strong>。抽象类是对类结构与方法的抽象，简单来说，<strong>一个抽象类描述了一个类中应当有哪些成员（属性、方法等）</strong>，<strong>一个抽象方法描述了这一方法在实际实现中的结构</strong>。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的<strong>入参类型</strong>与<strong>返回值类型</strong>。</p>
<p>抽象类使用 abstract 关键字声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsFoo</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> absProp: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>(): <span class="hljs-title">string</span>;<br>  <span class="hljs-title">abstract</span> <span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。我们可以实现（implements）一个抽象类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-title">implements</span> <span class="hljs-title">AbsFoo</span> </span>&#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;linbudu&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中<strong>无法声明静态的抽象成员</strong>。</p>
<p>对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的。interface 不仅可以声明函数结构，也可以声明类的结构：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> FooStruct &#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>(): <span class="hljs-title">string</span>;<br>  <span class="hljs-title">absMethod</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span>;<br>&#125;<br><br><span class="hljs-title">class</span> <span class="hljs-title">Foo</span> <span class="hljs-title">implements</span> <span class="hljs-title">FooStruct</span> &#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;linbudu&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，我们让类去实现了一个接口。这里接口的作用和抽象类一样，都是<strong>描述这个类的结构</strong>。除此以外，我们还可以使用 <strong>Newable Interface</strong> 来描述一个类的结构（类似于描述函数结构的 <strong>Callable Interface</strong>）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">interface</span> FooStruct &#123;<br>  <span class="hljs-keyword">new</span> (): Foo;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> NewableFoo: FooStruct;<br><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> NewableFoo();<br></code></pre></td></tr></table></figure>

<h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类，实际上我们了解的更多是新的语法，如访问性修饰符 <code>public</code> / <code>private</code> / <code>protected</code> ，操作修饰符 <code>readonly</code> ，静态成员 static ，抽象类 abstract ，以及 override 等在 JavaScript（ECMAScript）中不存在或实现并不完全的能力。</p>
<p>对于函数与类，你需要更多地实际使用才能掌握得更好。不妨继续对你手上的 JavaScript 进行改造，让函数与类都能披上类型的铠甲，获得完整的类型能力。</p>
<p>在下一节，我们将要接触的就是 JavaScript 中完全没有类似概念的新朋友了，它们是 TypeScript 类型编程最基础的一部分，包括了 any 、 unknown 、never 内置类型，以及类型断言等概念，这些类型工具会是你以后玩转类型编程时最常打交道的一部分。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来好像没什么问题，但是当你想要实例化这个类时，一行美丽的操作就会出现：<strong>类的构造函数被标记为私有，且只允许在类内部访问</strong>。</p>
<p>那这就很奇怪了，我们要一个不能实例化的类有啥用？摆设吗？</p>
<p>还真不是，有些场景下私有构造函数确实有奇妙的用法，比如像我一样把类作为 utils 方法时，此时 Utils 类内部全部都是静态成员，我们也并不希望真的有人去实例化这个类。此时就可以使用私有构造函数来阻止它被错误地实例化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identifier = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">makeUHappy</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者在一个类希望把实例化逻辑通过方法来实现，而不是通过 new 的形式时，也可以使用私有构造函数来达成目的。</p>
<p>你可能会想到，既然有私有构造函数，那没道理没有受保护的构造函数（<code>protected</code>）啊？还真有。但这里我想留给你自己去探寻，你可以先查找下这么做的意义，再想想，什么场景下我们非用它不可？</p>
<h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。</p>
<p>S，<strong>单一功能原则</strong>，<strong>一个类应该仅具有一种职责</strong>，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和写操作也应当被视为两种不同的职责，并被分配到两个类中。更进一步，对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来。</p>
<p>O，<strong>开放封闭原则</strong>，<strong>一个类应该是可扩展但不可修改的</strong>。即假设我们的业务中支持通过微信、支付宝登录，原本在一个 login 方法中进行 if else 判断，假设后面又新增了抖音登录、美团登录，难道要再加 else if 分支（或 switch case）吗？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> LoginType &#123;<br>  WeChat,<br>  TaoBao,<br>  TikTok,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: LoginType</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.WeChat) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.TikTok) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.TaoBao) &#123;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invalid Login Type!&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然不，基于开放封闭原则，我们应当将登录的基础逻辑抽离出来，不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> handler(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChatLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaoBaoLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TikTokLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> handlerMap: Record&lt;LoginType, LoginHandler&gt; = &#123;<br>    [LoginType.TaoBao]: <span class="hljs-keyword">new</span> TaoBaoLoginHandler(),<br>    [LoginType.TikTok]: <span class="hljs-keyword">new</span> TikTokLoginHandler(),<br>    [LoginType.WeChat]: <span class="hljs-keyword">new</span> WeChatLoginHandler(),<br>  &#125;;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: LoginType</span>)</span> &#123;<br>    Login.handlerMap[<span class="hljs-keyword">type</span>].handler();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>L，<strong>里式替换原则</strong>，<strong>一个派生类可以在程序的任何一处对其基类进行替换</strong>。这也就意味着，子类完全继承了父类的一切，对父类进行了功能地扩展（而非收窄）。</p>
<p>I，<strong>接口分离原则</strong>，<strong>类的实现方应当只需要实现自己需要的那部分接口</strong>。比如微信登录支持指纹识别，支付宝支持指纹识别和人脸识别，这个时候微信登录的实现类应该不需要实现人脸识别方法才对。这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对。</p>
<p>D，<strong>依赖倒置原则</strong>，这是实现开闭原则的基础，它的核心思想即是<strong>对功能的实现应该依赖于抽象层</strong>，即不同的逻辑通过实现不同的抽象类。还是登录的例子，我们的登录提供方法应该基于共同的登录抽象类实现（LoginHandler），最终调用方法也基于这个抽象类，而不是在一个高阶登录方法中去依赖多个低阶登录提供方。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://issummer.cn/2022/12/07/104-ts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jude">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/07/104-ts/" class="post-title-link" itemprop="url">104、typescript字面量类型和枚举(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-07 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-07T20:00:00+08:00">2022-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-07 11:22:07" itemprop="dateModified" datetime="2023-02-07T11:22:07+08:00">2023-02-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>了解了原始类型与对象类型以后，我们已经能完成简单场景的类型标注了。但这还远远不够，我们还可以让这些类型标注更精确一些。比如，有一个接口结构，它描述了响应的消息结构：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IRes &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>  status: <span class="hljs-built_in">string</span>;<br>  data: <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在大多数情况下，这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 / 10001 / 50000，status 可能是 <code>&quot;success&quot;</code> / <code>&quot;failure&quot;</code>。而上面的类型只给出了一个宽泛的 number（string），此时我们既不能在访问 code 时获得精确的提示，也失去了 TypeScript 类型即文档的功能。</p>
<p>这个时候要怎么做？</p>
<h2 id="字面量类型与联合类型"><a href="#字面量类型与联合类型" class="headerlink" title="字面量类型与联合类型"></a>字面量类型与联合类型</h2><p>我们可以使用联合类型加上字面量类型，把上面的例子改写成这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Res &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-number">10000</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">50000</span>;<br>  status: <span class="hljs-string">&quot;success&quot;</span> | <span class="hljs-string">&quot;failure&quot;</span>;<br>  data: <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个时候，我们就能在访问时获得精确地类型推导了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428d95d0eee4c269302df47bf45e7b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>对于 <code>declare var res: Res</code>，你可以认为它其实就是快速生成一个符合指定类型，但没有实际值的变量，同时它也不存在于运行时中。上面引入了一些新的概念，我们来一个一个了解。</p>
<h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>最开始你可能觉得很神奇，<code>&quot;success&quot;</code> 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做<strong>字面量类型（Literal Types）</strong>，它代表着比原始类型更精确的类型，同时也是原始类型的子类型（关于类型层级，我们会在后面详细了解）。</p>
<p>字面量类型主要包括<strong>字符串字面量类型</strong>、<strong>数字字面量类型</strong>、<strong>布尔字面量类型</strong>和<strong>对象字面量类型</strong>，它们可以直接作为类型标注：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> str: <span class="hljs-string">&quot;linbudu&quot;</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><span class="hljs-keyword">const</span> num: <span class="hljs-number">599</span> = <span class="hljs-number">599</span>;<br><span class="hljs-keyword">const</span> bool: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>为什么说字面量类型比原始类型更精确？我们可以看这么个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 报错！不能将类型“&quot;linbudu599&quot;”分配给类型“&quot;linbudu&quot;”。</span><br><span class="hljs-keyword">const</span> str1: <span class="hljs-string">&quot;linbudu&quot;</span> = <span class="hljs-string">&quot;linbudu599&quot;</span>;<br><br><span class="hljs-keyword">const</span> str2: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><span class="hljs-keyword">const</span> str3: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu599&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>上面的代码，原始类型的值可以包括任意的同类型值，而字面量类型要求的是<strong>值级别的字面量一致</strong>。</p>
<p>单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 <code>|</code>）一起使用，表达一组字面量类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Tmp &#123;<br>  <span class="hljs-attr">bool</span>: <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>;<br>  num: <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;<br>  str: <span class="hljs-string">&quot;lin&quot;</span> | <span class="hljs-string">&quot;bu&quot;</span> | <span class="hljs-string">&quot;du&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>而联合类型你可以理解为，它代表了<strong>一组类型的可用集合</strong>，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，我们还可以将各种类型混合到一起：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Tmp &#123;<br>  <span class="hljs-attr">mixed</span>: <span class="hljs-literal">true</span> | <span class="hljs-built_in">string</span> | <span class="hljs-number">599</span> | &#123;&#125; | (<span class="hljs-function">() =&gt;</span> &#123;&#125;) | (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有几点需要注意的：</p>
<ul>
<li>对于联合类型中的函数类型，需要使用括号<code>()</code>包裹起来</li>
<li>函数类型并不存在字面量类型，因此这里的 <code>(() =&gt; &#123;&#125;)</code> 就是一个合法的函数类型</li>
<li>你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中</li>
</ul>
<p>联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Tmp &#123;<br>  <span class="hljs-attr">user</span>:<br>    | &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-literal">true</span>;<br>        expires: <span class="hljs-built_in">string</span>;<br>      &#125;<br>    | &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-literal">false</span>;<br>        promotion: <span class="hljs-built_in">string</span>;<br>      &#125;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> tmp: Tmp;<br><br><span class="hljs-keyword">if</span> (tmp.user.vip) &#123;<br>  <span class="hljs-built_in">console</span>.log(tmp.user.expires);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true ，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）。这一能力的使用涉及类型守卫与类型控制流分析，我们会在后面的章节详细来说。</p>
<p>我们也可以通过类型别名来复用一组字面量联合类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Code = <span class="hljs-number">10000</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">50000</span>;<br><br><span class="hljs-keyword">type</span> Status = <span class="hljs-string">&quot;success&quot;</span> | <span class="hljs-string">&quot;failure&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>除了原始类型的字面量类型以外，对象类型也有着对应的字面量类型。</p>
<h3 id="对象字面量类型"><a href="#对象字面量类型" class="headerlink" title="对象字面量类型"></a>对象字面量类型</h3><p>类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Tmp &#123;<br>  <span class="hljs-attr">obj</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span>;<br>    age: <span class="hljs-number">18</span>;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> tmp: Tmp = &#123;<br>  <span class="hljs-attr">obj</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。对象字面量类型在实际开发中的使用较少，我们只需要了解。</p>
<p>总的来说，在需要更精确类型的情况下，我们可以使用字面量类型加上联合类型的方式，将类型从 string 这种宽泛的原始类型直接收窄到 <code>&quot;resolved&quot; | &quot;pending&quot; | &quot;rejected&quot;</code> 这种精确的字面量类型集合。</p>
<p>需要注意的是，<strong>无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值</strong>。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。</p>
<p>如果说字面量类型是对原始类型的进一步扩展（对象字面量类型的使用较少），那么枚举在某些方面则可以理解为是对对象类型的扩展。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举并不是 JavaScript 中原生的概念，在其他语言中它都是老朋友了（Java、C#、Swift 等）。目前也已经存在给 JavaScript（ECMAScript）引入枚举支持的 <a href="https://link.juejin.cn/?target=https://github.com/rbuckton/proposal-enum">proposal-enum</a> 提案，但还未被提交给 TC39 ，仍处于 Stage 0 阶段。</p>
<p>如果要和 JavaScript 中现有的概念对比，我想最贴切的可能就是你曾经写过的 constants 文件了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">Home_Page_Url</span>: <span class="hljs-string">&quot;url1&quot;</span>,<br>  <span class="hljs-attr">Setting_Page_Url</span>: <span class="hljs-string">&quot;url2&quot;</span>,<br>  <span class="hljs-attr">Share_Page_Url</span>: <span class="hljs-string">&quot;url3&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 或是这样：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PageUrl = &#123;<br>  <span class="hljs-attr">Home_Page_Url</span>: <span class="hljs-string">&quot;url1&quot;</span>,<br>  <span class="hljs-attr">Setting_Page_Url</span>: <span class="hljs-string">&quot;url2&quot;</span>,<br>  <span class="hljs-attr">Share_Page_Url</span>: <span class="hljs-string">&quot;url3&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果把这段代码替换为枚举，会是如下的形式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> PageUrl &#123;<br>  Home_Page_Url = <span class="hljs-string">&quot;url1&quot;</span>,<br>  Setting_Page_Url = <span class="hljs-string">&quot;url2&quot;</span>,<br>  Share_Page_Url = <span class="hljs-string">&quot;url3&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> home = PageUrl.Home_Page_Url;<br></code></pre></td></tr></table></figure>

<p>这么做的好处非常明显。首先，你拥有了更好的类型提示。其次，这些常量被真正地<strong>约束在一个命名空间</strong>下（上面的对象声明总是差点意思）。如果你没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Items &#123;<br>  Foo,<br>  Bar,<br>  Baz,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Items.Foo</code> , <code>Items.Bar</code> , <code>Items.Baz</code>的值依次是 0，1，2 。</p>
<p>如果你只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Items &#123;<br>  <span class="hljs-comment">// 0</span><br>  Foo,<br>  Bar = <span class="hljs-number">599</span>,<br>  <span class="hljs-comment">// 600</span><br>  Baz,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在数字型枚举中，你可以使用延迟求值的枚举值，比如函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> returnNum = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">100</span> + <span class="hljs-number">499</span>;<br><br><span class="hljs-built_in">enum</span> Items &#123;<br>  Foo = returnNum(),<br>  Bar = <span class="hljs-number">599</span>,<br>  Baz,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但要注意，延迟求值的枚举值是有条件的。<strong>如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后（如上例），或者放在第一位</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Items &#123;<br>  Baz,<br>  Foo = returnNum(),<br>  Bar = <span class="hljs-number">599</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>TypeScript 中也可以同时使用字符串枚举值和数字枚举值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Mixed &#123;<br>  Num = <span class="hljs-number">599</span>,<br>  Str = <span class="hljs-string">&quot;linbudu&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举和对象的重要差异在于，<strong>对象是单向映射的</strong>，我们只能从键映射到键值。而<strong>枚举是双向映射的</strong>，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Items &#123;<br>  Foo,<br>  Bar,<br>  Baz,<br>&#125;<br><br><span class="hljs-keyword">const</span> fooValue = Items.Foo; <span class="hljs-comment">// 0</span><br><span class="hljs-keyword">const</span> fooKey = Items[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &quot;Foo&quot;</span><br></code></pre></td></tr></table></figure>

<p>要了解这一现象的本质，我们需要来看一看枚举的编译产物，如以上的枚举会被编译为以下 JavaScript 代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> Items;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Items</span>) </span>&#123;<br>  Items[(Items[<span class="hljs-string">&quot;Foo&quot;</span>] = <span class="hljs-number">0</span>)] = <span class="hljs-string">&quot;Foo&quot;</span>;<br>  Items[(Items[<span class="hljs-string">&quot;Bar&quot;</span>] = <span class="hljs-number">1</span>)] = <span class="hljs-string">&quot;Bar&quot;</span>;<br>  Items[(Items[<span class="hljs-string">&quot;Baz&quot;</span>] = <span class="hljs-number">2</span>)] = <span class="hljs-string">&quot;Baz&quot;</span>;<br>&#125;)(Items || (Items = &#123;&#125;));<br></code></pre></td></tr></table></figure>

<p><code>obj[k] = v</code> 的返回值即是 v，因此这里的 <code>obj[obj[k] = v] = k</code> 本质上就是进行了 <code>obj[k] = v</code> 与 <code>obj[v] = k</code> 这样两次赋值。</p>
<p>但需要注意的是，仅有值为数字的枚举成员才能够进行这样的双向枚举，<strong>字符串枚举成员仍然只会进行单次映射</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Items &#123;<br>  Foo,<br>  Bar = <span class="hljs-string">&quot;BarValue&quot;</span>,<br>  Baz = <span class="hljs-string">&quot;BazValue&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 编译结果，只会进行 键-值 的单向映射</span><br>(<span class="hljs-string">&quot;use strict&quot;</span>);<br><span class="hljs-keyword">var</span> Items;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Items</span>) </span>&#123;<br>  Items[(Items[<span class="hljs-string">&quot;Foo&quot;</span>] = <span class="hljs-number">0</span>)] = <span class="hljs-string">&quot;Foo&quot;</span>;<br>  Items[<span class="hljs-string">&quot;Bar&quot;</span>] = <span class="hljs-string">&quot;BarValue&quot;</span>;<br>  Items[<span class="hljs-string">&quot;Baz&quot;</span>] = <span class="hljs-string">&quot;BazValue&quot;</span>;<br>&#125;)(Items || (Items = &#123;&#125;));<br></code></pre></td></tr></table></figure>

<p>除了数字枚举与字符串枚举这种分类以外，其实还存在着普通枚举与常量枚举这种分类方式。</p>
<h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>常量枚举和枚举相似，只是其声明多了一个 const：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Items &#123;<br>  Foo,<br>  Bar,<br>  Baz,<br>&#125;<br><br><span class="hljs-keyword">const</span> fooValue = Items.Foo; <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<p>它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，你<strong>只能通过枚举成员访问枚举值</strong>（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象（如上面的 Items 对象），对枚举成员的访问会被<strong>直接内联替换为枚举的值</strong>。以上的代码会被编译为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fooValue = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Foo */</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>实际上，常量枚举的表现、编译产物还受到配置项 <code>--isolatedModules</code> 以及 <code>--preserveConstEnums</code> 等的影响，我们会在后面的 TSConfig 详解中了解更多。</p>
</blockquote>
<h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们了解了字面量类型和枚举的使用，包括字面量类型的分类，与联合类型的结合使用，以及枚举与其编译产物等等。</p>
<p>对于字面量类型，我们可以使用它来提供更精确的类型标注。比如，你可以将如用户类型与请求状态码这一类属性的类型，都使用<strong>字面量类型＋联合类型</strong>的形式改写，获得更详细的类型信息与更严格的类型约束。</p>
<p>而对于枚举，我们可以使用它来替换掉之前使用对象进行常量收敛的代码，而如果你希望减少编译后的代码，可以进一步地使用在编译后会被完全抹除的常量枚举。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型控制流分析中的字面量类型"><a href="#类型控制流分析中的字面量类型" class="headerlink" title="类型控制流分析中的字面量类型"></a>类型控制流分析中的字面量类型</h3><p>除了手动声明字面量类型以外，实际上 TypeScript 也会在某些情况下将变量类型推导为字面量类型，看这个例子：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eecde2e8de214264a42dd74da8c8e17b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6931f3897d674a8d9803164e5f4d7f2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>你会发现，使用 const 声明的变量，其类型会从值推导出最精确的字面量类型。而对象类型则只会推导至符合其属性结构的接口，不会使用字面量类型：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742ad435155e41e293abedf0fe8d053e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>要解答这个现象，需要你回想 let 和 const 声明的意义。我们知道，使用 let 声明的变量是可以再次赋值的，在 TypeScript 中要求赋值类型始终与原类型一致（如果声明了的话）。因此对于 let 声明，<strong>只需要推导至这个值从属的类型即可</strong>。而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型，但对象类型变量仍可变（但同样会要求其属性值类型保持一致）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://issummer.cn/2022/12/06/103-ts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jude">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/06/103-ts/" class="post-title-link" itemprop="url">103、typescript理解原始类型和对象类型(一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-06 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-06T20:00:00+08:00">2022-12-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-07 11:19:38" itemprop="dateModified" datetime="2023-02-07T11:19:38+08:00">2023-02-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="原始类型的类型标注"><a href="#原始类型的类型标注" class="headerlink" title="原始类型的类型标注"></a>原始类型的类型标注</h2><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures%23%E5%8E%9F%E5%A7%8B%E5%80%BC_primitive_values">JavaScript 的内置原始类型</a>,除了最常见的 number / string / boolean / null / undefined， ECMAScript 2015（ES6）、2020 (ES11) 又分别引入了 2 个新的原始类型：symbol 与 bigint 。在 TypeScript 中它们都有对应的类型注解：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><span class="hljs-keyword">const</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">24</span>;<br><span class="hljs-keyword">const</span> male: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">const</span> undef: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">const</span> nul: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> obj: <span class="hljs-built_in">object</span> = &#123; name, age, male &#125;;<br><span class="hljs-keyword">const</span> bigintVar1: bigint = <span class="hljs-number">9007199254740991n</span>;<br><span class="hljs-keyword">const</span> bigintVar2: bigint = <span class="hljs-built_in">BigInt</span>(<span class="hljs-number">9007199254740991</span>);<br><span class="hljs-keyword">const</span> symbolVar: symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;unique&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>其中，除了 null 与 undefined 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念，因此这里我们只对 null 与 undefined 展开介绍。</p>
<h3 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h3><p>在 JavaScript 中，null 与 undefined 分别表示“<strong>这里有值，但是个空值</strong>”和“<strong>这里没有值</strong>”。而在 TypeScript 中，null 与 undefined 类型都是<strong>有具体意义的类型</strong>。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 <code>strictNullChecks</code> 检查的情况下，会<strong>被视作其他类型的子类型</strong>，比如 string 类型会被认为包含了 null 与 undefined 类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tmp1: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> tmp2: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><br><span class="hljs-keyword">const</span> tmp3: <span class="hljs-built_in">string</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 仅在关闭 strictNullChecks 时成立，下同</span><br><span class="hljs-keyword">const</span> tmp4: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>

<p>除了上面介绍的原始类型以及 null、undefined 类型以外，在 TypeScript 中还存在着一个特殊的类型：void，它和 JavaScript 中的 void 同样不是一回事，我们接着往下看。</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>你是否看到过以下的 JavaScript 代码呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;a href=<span class="hljs-string">&quot;javascript:void(0)&quot;</span>&gt;清除缓存&lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>void(0)</code> 等价于 <code>void 0</code>，即 <code>void expression</code> 的语法。void 操作符会执行后面跟着的表达式并返回一个 undefined，如你可以使用它来执行一个立即执行函数（IIFE）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">void</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iife</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Invoked!&quot;</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>能这么做是因为，void 操作符强制<strong>将后面的函数声明转化为了表达式</strong>，因此整体其实相当于：<code>void((function iife()&#123;&#125;)())</code>。</p>
<p>事实上，TypeScript 的原始类型标注中也有 void，但与 JavaScript 中不同的是，这里的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值，如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func3</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，func1 与 func2 的返回值类型都会被隐式推导为 void，只有显式返回了 undefined 值的 func3 其返回值类型才被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。</p>
<blockquote>
<p>虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。</p>
</blockquote>
<p>这里可能有点绕，你可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型（注意与它们在 JavaScript 中的意义区分）。而 undefined 能够被赋值给 void 类型的变量，就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined 。null 类型也可以，但需要在关闭 <code>strictNullChecks</code> 配置的情况下才能成立。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> voidVar1: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;<br><br><span class="hljs-keyword">const</span> voidVar2: <span class="hljs-built_in">void</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 需要关闭 strictNullChecks</span><br></code></pre></td></tr></table></figure>

<p>到这里，我们了解了 JavaScript 中原始数据类型到 TypeScript 原始类型概念地映射，你应当能感觉到 TypeScript 对 JavaScript 开发者的友好，大部分概念都能比较自然地过渡，下面的数组与对象的类型标注同样如此。</p>
<h2 id="数组的类型标注"><a href="#数组的类型标注" class="headerlink" title="数组的类型标注"></a>数组的类型标注</h2><p>数组同样是我们最常用的类型之一，在 TypeScript 中有两种方式来声明一个数组类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr1: <span class="hljs-built_in">string</span>[] = [];<br><br><span class="hljs-keyword">const</span> arr2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [];<br></code></pre></td></tr></table></figure>

<p>这两种方式是完全等价的，但其实更多是以前者为主，如果你将鼠标悬浮在 <code>arr2</code> 上，会发现它显示的类型签名是 <code>string[]</code>。数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用 <strong>元组（Tuple）</strong> 来代替数组要更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度地访问：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr3: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;lin&quot;</span>, <span class="hljs-string">&quot;bu&quot;</span>, <span class="hljs-string">&quot;du&quot;</span>];<br><br><span class="hljs-built_in">console</span>.log(arr3[<span class="hljs-number">599</span>]);<br></code></pre></td></tr></table></figure>

<p>这种情况肯定是不符合预期的，因为我们能确定这个数组中只有三个成员，并希望在越界访问时给出类型报错。这时我们可以使用元组类型进行类型标注：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr4: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-string">&quot;lin&quot;</span>, <span class="hljs-string">&quot;bu&quot;</span>, <span class="hljs-string">&quot;du&quot;</span>];<br><br><span class="hljs-built_in">console</span>.log(arr4[<span class="hljs-number">599</span>]);<br></code></pre></td></tr></table></figure>

<p>此时将会产生一个类型错误：**<em>长度为“3”的元组类型“[string, string, string]”在索引“599“处没有元素</em>**。除了同类型的元素以外，元组内部也可以声明多个与其位置强绑定的，不同类型的元素：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr5: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-number">599</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure>

<p>在这种情况下，对数组合法边界内的索引访问（即 0、1、2）将精确地获得对应位置上的类型。同时元组也支持了在某一个位置上的可选成员：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr6: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>?, <span class="hljs-built_in">boolean</span>?] = [<span class="hljs-string">&quot;linbudu&quot;</span>];<br><span class="hljs-comment">// 下面这么写也可以</span><br><span class="hljs-comment">// const arr6: [string, number?, boolean?] = [&#x27;linbudu&#x27;, , ,];</span><br></code></pre></td></tr></table></figure>

<p>对于标记为可选的成员，在 <code>--strictNullCheckes</code> 配置下会被视为一个 <code>string | undefined</code> 的类型。此时元组的长度属性也会发生变化，比如上面的元组 arr6 ，其长度的类型为 <code>1 | 2 | 3</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> TupleLength = <span class="hljs-keyword">typeof</span> arr6.length; <span class="hljs-comment">// 1 | 2 | 3</span><br></code></pre></td></tr></table></figure>

<p>也就是说，这个元组的长度可能为 1、2、3。</p>
<blockquote>
<p>关于类型别名（type）、类型查询（typeof）以及联合类型，我们会在后面讲到，这里你只需要简单了解即可。</p>
</blockquote>
<p>你可能会觉得，元组的可读性实际上并不好。比如对于 <code>[string, number, boolean]</code>来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式。而在 TypeScript 4.0 中，有了具名元组（<a href="https://link.juejin.cn/?target=https://github.com/Microsoft/TypeScript/issues/28259">Labeled Tuple Elements</a>）的支持，使得我们可以为元组中的元素打上类似属性的标记：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr7: [name: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">male</span>: <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-number">599</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure>

<p>有没有很酷？考虑到某些拼装对象太麻烦，我们完全可以使用具名元组来做简单替换。具名元组可选元素的修饰符将成为以下形式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr7: [name: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, male?: <span class="hljs-built_in">boolean</span>] = [<br>  <span class="hljs-string">&quot;linbudu&quot;</span>,<br>  <span class="hljs-number">599</span>,<br>  <span class="hljs-literal">true</span>,<br>];<br></code></pre></td></tr></table></figure>

<p>实际上除了显式地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr1: <span class="hljs-built_in">string</span>[] = [];<br><br><span class="hljs-keyword">const</span> [ele1, ele2, ...rest] = arr1;<br></code></pre></td></tr></table></figure>

<p>对于数组，此时仍然无法检查出是否存在隐式访问，因为类型层面并不知道它到底有多少个元素。但对于元组，隐式的越界访问也能够被揪出来给一个警告：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> arr5: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-number">599</span>, <span class="hljs-literal">true</span>];<br><br><span class="hljs-comment">// 长度为 &quot;3&quot; 的元组类型 &quot;[string, number, boolean]&quot; 在索引 &quot;3&quot; 处没有元素。</span><br><span class="hljs-keyword">const</span> [name, age, male, other] = arr5;<br></code></pre></td></tr></table></figure>

<p>JavaScript 的开发者对元组 Tuple 的概念可能比较陌生，毕竟在 JavaScript 中我们很少声明定长的数组。但使用元组确实能帮助我们进一步提升<strong>数组结构的严谨性</strong>，包括基于位置的类型标注、避免出现越界访问等等。除了通过数组类型提升数组结构的严谨性，TypeScript 中的对象类型也能帮助我们提升对象结构的严谨性。接下来我们就一起来看看。</p>
<h2 id="对象的类型标注"><a href="#对象的类型标注" class="headerlink" title="对象的类型标注"></a>对象的类型标注</h2><p>作为 JavaScript 中使用最频繁的数据结构，对象的类型标注是我们本节要重点关注的部分。接下来我们会学习如何在 TypeScript 中声明对象、修饰对象属性，以及了解可能存在的使用误区。这些内容能够帮助你建立起对 TypeScript 中立体类型（我们可以理解为前面的原始类型是“<strong>平面类型</strong>”）的了解，正式入门 TypeScript 。</p>
<p>类似于数组类型，在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 interface ，你可以理解为它代表了这个对象对外提供的接口结构。</p>
<p>首先我们使用 interface 声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDescription &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  male: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj1: IDescription = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">599</span>,<br>  <span class="hljs-attr">male</span>: <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里的“描述”指：</p>
<ul>
<li>每一个属性的值必须<strong>一一对应</strong>到接口的属性类型</li>
<li>不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 <code>obj1.other = &#39;xxx&#39;</code> 这样属性访问赋值的形式</li>
</ul>
<p>除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括<strong>可选（Optional）</strong> 与 <strong>只读（Readonly）</strong> 这两种。</p>
<h3 id="修饰接口属性"><a href="#修饰接口属性" class="headerlink" title="修饰接口属性"></a>修饰接口属性</h3><p>类似于上面的元组可选，在接口结构中同样通过 <code>?</code> 来标记一个属性为可选：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDescription &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  male?: <span class="hljs-built_in">boolean</span>;<br>  func?: <span class="hljs-built_in">Function</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj2: IDescription = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">599</span>,<br>  <span class="hljs-attr">male</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 无需实现 func 也是合法的</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在这种情况下，即使你在 obj2 中定义了 male 属性，但当你访问 <code>obj2.male</code> 时，它的类型仍然会是 <code>boolean | undefined</code>，因为毕竟这是我们自己定义的类型嘛。</p>
<p>假设新增一个可选的函数类型属性，然后进行调用：<code>obj2.func()</code> ，此时将会产生一个类型报错：**<em>不能调用可能是未定义的方法</em>**。但可选属性标记不会影响你对这个属性进行赋值，如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript">obj2.male = <span class="hljs-literal">false</span>;<br>obj2.func = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br></code></pre></td></tr></table></figure>

<p>即使你对可选属性进行了赋值，TypeScript 仍然会使用<strong>接口的描述为准</strong>进行类型检查，你可以使用类型断言、非空断言或可选链解决（别急，我们在后面会讲到）。</p>
<p>除了标记一个属性为可选以外，你还可以标记这个属性为只读：<code>readonly</code>。很多同学对这一关键字比较陌生，因为以往 JavaScript 中并没有这一类概念，它的作用是<strong>防止对象的属性被再次赋值</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDescription &#123;<br>  <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj3: IDescription = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">599</span>,<br>&#125;;<br><br><span class="hljs-comment">// 无法分配到 &quot;name&quot; ，因为它是只读属性</span><br>obj3.name = <span class="hljs-string">&quot;林不渡&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同。</p>
<ul>
<li>你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。</li>
<li>一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是<strong>类型 xxx 上不存在属性“push”这种</strong>。这一实现的本质是<strong>只读数组与只读元组的类型实际上变成了 ReadonlyArray，而不再是 Array。</strong></li>
</ul>
<h3 id="type-与-interface"><a href="#type-与-interface" class="headerlink" title="type 与 interface"></a>type 与 interface</h3><p>我也知道，很多同学更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而我更推荐的方式是，interface 用来描述<strong>对象、类的结构</strong>，而类型别名用来<strong>将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型</strong>。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题。</p>
<h3 id="object、Object-以及"><a href="#object、Object-以及" class="headerlink" title="object、Object 以及 { }"></a>object、Object 以及 { }</h3><p><code>object</code>、<code>Object</code> 以及<code>&#123;&#125;</code>（一个空对象）这三者的使用可能也会让部分同学感到困惑，所以我也专门解释下。</p>
<p>首先是 Object 的使用。被 JavaScript 原型链折磨过的同学应该记得，原型链的顶端是 Object 以及 Function，这也就意味着所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 对于 undefined、null、void 0 ，需要关闭 strictNullChecks</span><br><span class="hljs-keyword">const</span> tmp1: <span class="hljs-built_in">Object</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">const</span> tmp2: <span class="hljs-built_in">Object</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> tmp3: <span class="hljs-built_in">Object</span> = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> tmp4: <span class="hljs-built_in">Object</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><span class="hljs-keyword">const</span> tmp5: <span class="hljs-built_in">Object</span> = <span class="hljs-number">599</span>;<br><span class="hljs-keyword">const</span> tmp6: <span class="hljs-built_in">Object</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> tmp7: <span class="hljs-built_in">Object</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br><span class="hljs-keyword">const</span> tmp8: <span class="hljs-built_in">Object</span> = [];<br></code></pre></td></tr></table></figure>

<p>和 Object 类似的还有 Boolean、Number、String、Symbol，这几个<strong>装箱类型（Boxed Types）</strong> 同样包含了一些超出预期的类型。以 String 为例，它同样包括 undefined、null、void，以及代表的 <strong>拆箱类型（Unboxed Types）</strong> string，但并不包括其他装箱类型对应的拆箱类型，如 boolean 与 基本对象类型，我们看以下的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tmp9: <span class="hljs-built_in">String</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">const</span> tmp10: <span class="hljs-built_in">String</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> tmp11: <span class="hljs-built_in">String</span> = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> tmp12: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br><span class="hljs-comment">// 以下不成立，因为不是字符串类型的拆箱类型</span><br><span class="hljs-keyword">const</span> tmp13: <span class="hljs-built_in">String</span> = <span class="hljs-number">599</span>; <span class="hljs-comment">// X</span><br><span class="hljs-keyword">const</span> tmp14: <span class="hljs-built_in">String</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span> &#125;; <span class="hljs-comment">// X</span><br><span class="hljs-keyword">const</span> tmp15: <span class="hljs-built_in">String</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;; <span class="hljs-comment">// X</span><br><span class="hljs-keyword">const</span> tmp16: <span class="hljs-built_in">String</span> = []; <span class="hljs-comment">// X</span><br></code></pre></td></tr></table></figure>

<p><strong>在任何情况下，你都不应该使用这些装箱类型。</strong></p>
<p>object 的引入就是为了解决对 Object 类型的错误使用，它代表<strong>所有非原始类型的类型，即数组、对象与函数类型这些</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tmp17: <span class="hljs-built_in">object</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">const</span> tmp18: <span class="hljs-built_in">object</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> tmp19: <span class="hljs-built_in">object</span> = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> tmp20: <span class="hljs-built_in">object</span> = <span class="hljs-string">&quot;linbudu&quot;</span>; <span class="hljs-comment">// X 不成立，值为原始类型</span><br><span class="hljs-keyword">const</span> tmp21: <span class="hljs-built_in">object</span> = <span class="hljs-number">599</span>; <span class="hljs-comment">// X 不成立，值为原始类型</span><br><br><span class="hljs-keyword">const</span> tmp22: <span class="hljs-built_in">object</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> tmp23: <span class="hljs-built_in">object</span> = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br><span class="hljs-keyword">const</span> tmp24: <span class="hljs-built_in">object</span> = [];<br></code></pre></td></tr></table></figure>

<p>最后是<code>&#123;&#125;</code>，一个奇奇怪怪的空对象，如果你了解过字面量类型，可以认为<code>&#123;&#125;</code>就是一个对象字面量类型（对应到字符串字面量类型这样）。否则，你可以认为使用<code>&#123;&#125;</code>作为类型签名就是一个合法的，但<strong>内部无属性定义的空对象</strong>，这类似于 Object（想想 <code>new Object()</code>），它意味着任何非 null / undefined 的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tmp25: &#123;&#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 仅在关闭 strictNullChecks 时成立，下同</span><br><span class="hljs-keyword">const</span> tmp26: &#123;&#125; = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> tmp27: &#123;&#125; = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// void 0 等价于 undefined</span><br><br><span class="hljs-keyword">const</span> tmp28: &#123;&#125; = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><span class="hljs-keyword">const</span> tmp29: &#123;&#125; = <span class="hljs-number">599</span>;<br><span class="hljs-keyword">const</span> tmp30: &#123;&#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> tmp31: &#123;&#125; = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br><span class="hljs-keyword">const</span> tmp32: &#123;&#125; = [];<br></code></pre></td></tr></table></figure>

<p>虽然能够将其作为变量的类型，但你实际上<strong>无法对这个变量进行任何赋值操作</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tmp30: &#123;&#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linbudu&quot;</span> &#125;;<br><br>tmp30.age = <span class="hljs-number">18</span>; <span class="hljs-comment">// X 类型“&#123;&#125;”上不存在属性“age”。</span><br></code></pre></td></tr></table></figure>

<p>这是因为它就是纯洁的像一张白纸一样的空对象，上面没有任何的属性（除了 toString 这种与生俱来的）。在类型层级一节我们还会再次见到它，不过那个时候它已经被称为“万物的起源”了。</p>
<p>最后，为了更好地区分 <code>Object</code>、<code>object</code> 以及<code>&#123;&#125;</code>这三个具有迷惑性的类型，我们再做下总结：</p>
<ul>
<li>在任何时候都<strong>不要，不要，不要使用</strong> Object 以及类似的装箱类型。</li>
<li>当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 <code>Record&lt;string, unknown&gt;</code> 或 <code>Record&lt;string, any&gt;</code> 表示对象，<code>unknown[]</code> 或 <code>any[]</code> 表示数组，<code>(...args: any[]) =&gt; any</code>表示函数这样。</li>
<li>我们同样要避免使用<code>&#123;&#125;</code>。<code>&#123;&#125;</code>意味着任何非 <code>null / undefined</code> 的值，从这个层面上看，使用它和使用 <code>any</code> 一样恶劣。</li>
</ul>
<h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们一起学习了 TypeScript 中原始类型、对象类型、数组（元组）的类型标注，以及对数组的只读、对象类型属性的访问性修饰。这里的知识其实可以分为两类：</p>
<ul>
<li>与 JavaScript 概念基本一致的部分，如原始类型与数组类型需要重点掌握，但因为思维方式基本没有变化，所以你可以认为你就是在写<strong>更严格一些的 JavaScript</strong>。</li>
<li>一些全新的概念，比如元组与 readonly 修饰等，这一部分你可能不会很快适应，需要稍微转换一下思维方式。我建议你可以从现在开始，有意识地在日常开发中去多多使用它们。</li>
</ul>
<p>另外，对于 readonly 这一修饰符，JavaScript 开发者可能需要一定的时间来理解和习惯，但它在工程层面确实是非常推荐的一种实践，可以使用只读标记来避免数组和对象被错误修改。当然，TypeScript 目前只能够帮助你在编译时做检查，类型信息在编译后都会被擦除，所以 readonly 并不会在实际运行时报错。</p>
<p>学习完这一小节后，不妨找出你曾经的 JavaScript 项目，试试用本章学到的知识为这些 JavaScript 代码添加一些类型，再把某些场景下的数组换成元组，为部分对象类型的属性添加 readonly，来感受 TypeScript 代码的严格之美。</p>
<p>在下一节我们要介绍的字面量类型以及枚举，在某些方面其实可以理解为是原始类型与对象类型的进一步延伸，也同样是日常会被重度使用的语法。在完成下一节的学习后，你就可以开始进一步地改造你的 JavaScript 项目，让那些类型变得更精确一些！</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h3><p>Symbol 在 JavaScript 中代表着一个唯一的值类型，它类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象 / Class 内部属性的情况。而在 TypeScript 中，symbol 类型并不具有这一特性，一百个具有 symbol 类型的对象，它们的 symbol 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 unique symbol 这一类型声明，它是 symbol 类型的子类型，每一个 unique symbol 类型都是独一无二的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> uniqueSymbolFoo: unique symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;linbudu&quot;</span>);<br><br><span class="hljs-comment">// 类型不兼容</span><br><span class="hljs-keyword">const</span> uniqueSymbolBar: unique symbol = uniqueSymbolFoo;<br></code></pre></td></tr></table></figure>

<p>在 JavaScript 中，我们可以用 <code>Symbol.for</code> 方法来复用已创建的 Symbol，如 <code>Symbol.for(&quot;linbudu&quot;)</code> 会首先查找全局是否已经有使用 <code>linbudu</code> 作为 key 的 Symbol 注册，如果有，则返回这个 Symbol，否则才会创建新的 Symbol 。</p>
<p>在 TypeScript 中，如果要引用已创建的 unique symbol 类型，则需要使用类型查询操作符 typeof ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> uniqueSymbolFoo: unique symbol;<br><br><span class="hljs-keyword">const</span> uniqueSymbolBaz: <span class="hljs-keyword">typeof</span> uniqueSymbolFoo = uniqueSymbolFoo;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>以上代码实际执行时会报错，这是因为 uniqueSymbolFoo 是一个仅存在于类型空间的值，这里只是为了进行示例~</p>
</blockquote>
<blockquote>
<p>这里的 declare、typeof 等使用，都会在后面有详细地讲解。同时 unique symbol 在日常开发的使用非常少见，这里做了解就好~</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://issummer.cn/2022/12/03/102-deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jude">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/03/102-deploy/" class="post-title-link" itemprop="url">102、项目部署通用方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-03 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-03T20:00:00+08:00">2022-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-01 12:04:24" itemprop="dateModified" datetime="2023-02-01T12:04:24+08:00">2023-02-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前用过阿里巴巴的云效（codeup）管理代码及部署，通过搭建流水线的方式，前端提交完代码之后(前端提交代码时不用 npm run build)，可以按照简单的步骤将前端代码打包、发布(包括开发环境、测试环境)。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/03/102-deploy/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>

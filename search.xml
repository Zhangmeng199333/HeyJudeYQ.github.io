<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大文件断点续传</title>
      <link href="/2022/02/21/file-upload/"/>
      <url>/2022/02/21/file-upload/</url>
      
        <content type="html"><![CDATA[<p>关于大文件断点续传的问题,解决方案是Blob.prototype.slice方法，和数组的slice方法类似，使用slice方法可以返回源文件的切片。按照要求将源文件切位n个切片，将多个切片同时上传，源文件由一个大文件转换成n个小切片同时上传，可以大大减少上传时间。<br>需要注意的是上传到服务端的切片可能位置会发生改变，需要将切片的位置记录下来。</p><span id="more"></span><h2 id="一、服务端（Node-js）"><a href="#一、服务端（Node-js）" class="headerlink" title="一、服务端（Node.js）"></a>一、服务端（Node.js）</h2><p>服务端需要做的是：接受n个切片，并将这些切片在上传后合并。</p><p>需要注意的是：</p><p>1、合并切片的时间: 即n个切片什么时候上传完成</p><blockquote><p>前端上传的切片中带有切片的个数，服务端接受到切片的总数后自动合并<br>2、怎么合并切片<br>使用node.js的读写流(readStream/writeStream)，将所有切片的流传输到最终文件的流里。</p></blockquote><p>服务端：</p><blockquote><p>server<br>-index.js<br>-controller.js</p></blockquote><details><summary>点我展示代码</summary><pre><code class="js">// index.jsconst Controller = require(&quot;./controller&quot;);const http = require(&quot;http&quot;);const server = http.createServer();const controller = new Controller();server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  // 解决跨域     res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);  if (req.method === &quot;OPTIONS&quot;) &#123;    res.status = 200;    res.end();    return;  &#125;//   验证上传文件是否已上传  if (req.url === &quot;/verify&quot;) &#123;    await controller.handleVerifyUpload(req, res);    return;  &#125;    // 合并切片  if (req.url === &quot;/merge&quot;) &#123;    await controller.handleMerge(req, res);    return;  &#125;  if (req.url === &quot;/&quot;) &#123;    await controller.handleFormData(req, res);  &#125;&#125;);server.listen(3001, () =&gt; console.log(&quot;正在监听 3001 端口&quot;));</code></pre><pre><code class="js">// controller.js// 处理前端传来的FormDataconst multiparty = require(&quot;multiparty&quot;);const path = require(&quot;path&quot;);const fse = require(&quot;fs-extra&quot;);const extractExt = filename =&gt;  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录const pipeStream = (path, writeStream) =&gt;  new Promise(resolve =&gt; &#123;    //   创建可读流    const readStream = fse.createReadStream(path);    readStream.on(&quot;end&quot;, () =&gt; &#123;      fse.unlinkSync(path);      resolve();    &#125;);    readStream.pipe(writeStream);  &#125;);// 合并切片const mergeFileChunk = async (filePath, fileHash, size) =&gt; &#123;  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);  const chunkPaths = await fse.readdir(chunkDir);  // 根据切片下标进行排序  // 否则直接读取目录的获得的顺序可能会错乱  chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);  await Promise.all(    chunkPaths.map((chunkPath, index) =&gt;      pipeStream(        path.resolve(chunkDir, chunkPath),        // 指定位置创建可写流        fse.createWriteStream(filePath, &#123;          start: index * size,          end: (index + 1) * size        &#125;)      )    )  );  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录&#125;;const resolvePost = req =&gt;  new Promise(resolve =&gt; &#123;    let chunk = &quot;&quot;;    req.on(&quot;data&quot;, data =&gt; &#123;      chunk += data;    &#125;);    req.on(&quot;end&quot;, () =&gt; &#123;      resolve(JSON.parse(chunk));    &#125;);  &#125;);// 返回已经上传切片名const createUploadedList = async fileHash =&gt;  fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))    : [];module.exports = class &#123;  // 合并切片  async handleMerge(req, res) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename, size &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    await mergeFileChunk(filePath, fileHash, size);    res.end(      JSON.stringify(&#123;        code: 0,        message: &quot;file merged success&quot;      &#125;)    );  &#125;  // 处理切片  async handleFormData(req, res) &#123;    const multipart = new multiparty.Form();    //下面multipart.parse的回调中 fields 参数保存了FormData中的文件    multipart.parse(req, async (err, fields, files) =&gt; &#123;      if (err) &#123;        console.error(err);        res.status = 500;        res.end(&quot;process file chunk failed&quot;);        return;      &#125;      const [chunk] = files.chunk;      const [hash] = fields.hash;      const [fileHash] = fields.fileHash;      const [filename] = fields.filename;      const filePath = path.resolve(        UPLOAD_DIR,        `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`      );      const chunkDir = path.resolve(UPLOAD_DIR, fileHash);      // 文件存在直接返回      if (fse.existsSync(filePath)) &#123;        res.end(&quot;file exist&quot;);        return;      &#125;      // 切片目录不存在，创建切片目录      if (!fse.existsSync(chunkDir)) &#123;        await fse.mkdirs(chunkDir);      &#125;      // fs-extra 专用方法，类似 fs.rename 并且跨平台      // fs-extra 的 rename 方法 windows 平台会有权限问题      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835      await fse.move(chunk.path, path.resolve(chunkDir, hash));      res.end(&quot;received file chunk&quot;);    &#125;);  &#125;  // 验证是否已上传/已上传切片下标  async handleVerifyUpload(req, res) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    if (fse.existsSync(filePath)) &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: false        &#125;)      );    &#125; else &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: true,          uploadedList: await createUploadedList(fileHash)        &#125;)      );    &#125;  &#125;&#125;;</code></pre></details><h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><p>前端使用Vue+elementUI展示界面，当点击上传按钮时，slice方法将源文件做切片处理，将切片放入数组中返回，使用 hash+index 给每个切片做标识，用于上传完成后合并切片。<br>调用uploadChunks上传所有的切片，将切片、切片hash、切片名filename放入FormData中，使用promise.all并发上传所有切片。</p><p>断点续传原理在于前后端需要记住已经上传的切片，继续上传的时候就可以跳过之前已经上传的部分。</p><p>实现的方案：</p><blockquote><p>服务端保存已经上传的切片hash，前端每次上传前都向服务端获取已经上传的切片。</p></blockquote><p>这里也可以在前端使用localStorage记录已经上传的切片的hash，但是存在问题，就是换一个浏览器就失去已经上传的切片的hash了。</p><p>客户端、服务端都需要生成文件和切片的hash，根据文件内容生成hash。使用spark-md5根据文件内容计算出文件的hash值。</p><p>当文件比较大的时候，读取文件内容计算hash是非常耗时的，会引起UI阻塞，导致页面假死，解决方式是使用web-worker在worker线程计算hash。</p><p>实例化web-worker，参数是一个js文件路径不能跨域，需要单独创建一个hash.js文件放在public中，在worker中不允许访问dom，使用importScripts函数导入外部脚本spark-md5</p><pre><code class="js">// hash.jsself.importScripts(&quot;/spark-md5.min.js&quot;); // 导入脚本// 生成文件 hashself.onmessage = e =&gt; &#123;  const &#123; fileChunkList &#125; = e.data;  const spark = new self.SparkMD5.ArrayBuffer();  let percentage = 0;  let count = 0;  const loadNext = index =&gt; &#123;    const reader = new FileReader();    reader.readAsArrayBuffer(fileChunkList[index].file);    reader.onload = e =&gt; &#123;      count++;      spark.append(e.target.result);      if (count === fileChunkList.length) &#123;        self.postMessage(&#123;          percentage: 100,          hash: spark.end()        &#125;);        self.close();      &#125; else &#123;        percentage += 100 / fileChunkList.length;        self.postMessage(&#123;          percentage        &#125;);        loadNext(count);      &#125;    &#125;;  &#125;;  loadNext(0);&#125;;</code></pre><p>1、template</p><details><summary>点我展示代码</summary><pre><code class="html">    &lt;div&gt;      &lt;input        type=&quot;file&quot;        :disabled=&quot;status !== Status.wait&quot;        @change=&quot;handleFileChange&quot;      /&gt;      &lt;el-button @click=&quot;handleUpload&quot; :disabled=&quot;uploadDisabled&quot;        &gt;上传&lt;/el-button      &gt;      &lt;el-button @click=&quot;handleResume&quot; v-if=&quot;status === Status.pause&quot;        &gt;恢复&lt;/el-button      &gt;      &lt;el-button        v-else        :disabled=&quot;status !== Status.uploading || !container.hash&quot;        @click=&quot;handlePause&quot;        &gt;暂停&lt;/el-button      &gt;    &lt;/div&gt;    &lt;div&gt;      &lt;!-- &lt;div&gt;计算文件 hash&lt;/div&gt;      &lt;el-progress :percentage=&quot;hashPercentage&quot;&gt;&lt;/el-progress&gt; --&gt;      &lt;div&gt;总进度&lt;/div&gt;      &lt;el-progress :percentage=&quot;fakeUploadPercentage&quot;&gt;&lt;/el-progress&gt;    &lt;/div&gt;    &lt;el-table :data=&quot;data&quot;&gt;      &lt;el-table-column        prop=&quot;hash&quot;        label=&quot;切片hash&quot;        align=&quot;center&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;大小(KB)&quot; align=&quot;center&quot; width=&quot;120&quot;&gt;        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;          &#123;&#123; row.size | transformByte &#125;&#125;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;进度&quot; align=&quot;center&quot;&gt;        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;          &lt;el-progress            :percentage=&quot;row.percentage&quot;            color=&quot;#909399&quot;          &gt;&lt;/el-progress&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;</code></pre></details><p>2、js部分：设置切片大小 考虑到通用性，简单封装了XMLHttpRequest, 实际使用可以隐藏掉hash进度条</p><details><summary>点我展示代码</summary><pre><code class="js">&lt;script&gt;const SIZE = 100 * 1024 * 1024; // 切片大小const Status = &#123;  wait: &quot;wait&quot;,  pause: &quot;pause&quot;,  uploading: &quot;uploading&quot;&#125;;export default &#123;  name: &quot;app&quot;,  filters: &#123;    transformByte(val) &#123;      return Number((val / 1024).toFixed(0));    &#125;  &#125;,  data: () =&gt; (&#123;    Status,    container: &#123;      file: null,      hash: &quot;&quot;,      worker: null    &#125;,    hashPercentage: 0,    data: [],    requestList: [],    status: Status.wait,    // 当暂停时会取消 xhr 导致进度条后退    // 为了避免这种情况，需要定义一个假的进度条    fakeUploadPercentage: 0  &#125;),  computed: &#123;    uploadDisabled() &#123;      return (        !this.container.file ||        [Status.pause, Status.uploading].includes(this.status)      );    &#125;,    uploadPercentage() &#123;      if (!this.container.file || !this.data.length) return 0;      const loaded = this.data        .map(item =&gt; item.size * item.percentage)        .reduce((acc, cur) =&gt; acc + cur);      return parseInt((loaded / this.container.file.size).toFixed(2));    &#125;  &#125;,  watch: &#123;    uploadPercentage(now) &#123;      if (now &gt; this.fakeUploadPercentage) &#123;        this.fakeUploadPercentage = now;      &#125;    &#125;  &#125;,  methods: &#123;    // 暂停    handlePause() &#123;      this.status = Status.pause;      this.resetData();    &#125;,    resetData() &#123;      this.requestList.forEach(xhr =&gt; xhr?.abort());      this.requestList = [];      if (this.container.worker) &#123;        this.container.worker.onmessage = null;      &#125;    &#125;,    async handleResume() &#123;      this.status = Status.uploading;      const &#123; uploadedList &#125; = await this.verifyUpload(        this.container.file.name,        this.container.hash      );      await this.uploadChunks(uploadedList);    &#125;,    // xhr    request(&#123;      url,      method = &quot;post&quot;,      data,      headers = &#123;&#125;,      onProgress = e =&gt; e,      requestList    &#125;) &#123;      return new Promise(resolve =&gt; &#123;        const xhr = new XMLHttpRequest();        xhr.upload.onprogress = onProgress;        xhr.open(method, url);        Object.keys(headers).forEach(key =&gt;          xhr.setRequestHeader(key, headers[key])        );        xhr.send(data);        xhr.onload = e =&gt; &#123;          // 将请求成功的 xhr 从列表中删除          if (requestList) &#123;            const xhrIndex = requestList.findIndex(item =&gt; item === xhr);            requestList.splice(xhrIndex, 1);          &#125;          resolve(&#123;            data: e.target.response          &#125;);        &#125;;        // 暴露当前 xhr 给外部        requestList?.push(xhr);      &#125;);    &#125;,    // 生成文件切片    createFileChunk(file, size = SIZE) &#123;      const fileChunkList = [];      let cur = 0;      while (cur &lt; file.size) &#123;        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);        cur += size;      &#125;      return fileChunkList;    &#125;,    // 生成文件 hash（web-worker）    calculateHash(fileChunkList) &#123;      return new Promise(resolve =&gt; &#123;        this.container.worker = new Worker(&quot;/hash.js&quot;);        this.container.worker.postMessage(&#123; fileChunkList &#125;);        this.container.worker.onmessage = e =&gt; &#123;          const &#123; percentage, hash &#125; = e.data;          this.hashPercentage = percentage;          if (hash) &#123;            resolve(hash);          &#125;        &#125;;      &#125;);    &#125;,    handleFileChange(e) &#123;      const [file] = e.target.files;      if (!file) return;      this.resetData();      Object.assign(this.$data, this.$options.data());      this.container.file = file;    &#125;,    async handleUpload() &#123;      if (!this.container.file) return;      this.status = Status.uploading;      const fileChunkList = this.createFileChunk(this.container.file);      this.container.hash = await this.calculateHash(fileChunkList);      const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(        this.container.file.name,        this.container.hash      );      if (!shouldUpload) &#123;        this.$message.success(&quot;秒传：上传成功&quot;);        this.status = Status.wait;        return;      &#125;      this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;        fileHash: this.container.hash,        index,        hash: this.container.hash + &quot;-&quot; + index,        chunk: file,        size: file.size,        percentage: uploadedList.includes(index) ? 100 : 0      &#125;));      await this.uploadChunks(uploadedList);    &#125;,    // 上传切片，同时过滤已上传的切片    async uploadChunks(uploadedList = []) &#123;      const requestList = this.data        .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;          const formData = new FormData();          formData.append(&quot;chunk&quot;, chunk);          formData.append(&quot;hash&quot;, hash);          formData.append(&quot;filename&quot;, this.container.file.name);          formData.append(&quot;fileHash&quot;, this.container.hash);          return &#123; formData, index &#125;;        &#125;)        .map(async (&#123; formData, index &#125;) =&gt;          this.request(&#123;            url: &quot;http://localhost:3001&quot;,            data: formData,            onProgress: this.createProgressHandler(this.data[index]),            requestList: this.requestList          &#125;)        );      await Promise.all(requestList);      // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时      // 合并切片      if (uploadedList.length + requestList.length === this.data.length) &#123;        await this.mergeRequest();      &#125;    &#125;,    // 通知服务端合并切片    async mergeRequest() &#123;      await this.request(&#123;        url: &quot;http://localhost:3001/merge&quot;,        headers: &#123;          &quot;content-type&quot;: &quot;application/json&quot;        &#125;,        data: JSON.stringify(&#123;          size: SIZE,          fileHash: this.container.hash,          filename: this.container.file.name        &#125;)      &#125;);      this.$message.success(&quot;上传成功&quot;);      this.status = Status.wait;    &#125;,    // 根据 hash 验证文件是否曾经已经被上传过    // 没有才进行上传    async verifyUpload(filename, fileHash) &#123;      const &#123; data &#125; = await this.request(&#123;        url: &quot;http://localhost:3001/verify&quot;,        headers: &#123;          &quot;content-type&quot;: &quot;application/json&quot;        &#125;,        data: JSON.stringify(&#123;          filename,          fileHash        &#125;)      &#125;);      return JSON.parse(data);    &#125;,    // 用闭包保存每个 chunk 的进度数据    createProgressHandler(item) &#123;      return e =&gt; &#123;        item.percentage = parseInt(String((e.loaded / e.total) * 100));      &#125;;    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人GitHub图床使用webp格式的图片</title>
      <link href="/2022/01/24/image-host/"/>
      <url>/2022/01/24/image-host/</url>
      
        <content type="html"><![CDATA[<p>使用图床，将本地图片上传到个人GitHub image-host 转换成webp格式的图片链接。</p><span id="more"></span><h3 id="1、什么是webp？"><a href="#1、什么是webp？" class="headerlink" title="1、什么是webp？"></a>1、什么是webp？</h3><blockquote><p>WebP is  是由 Google 公司开发的一种可提供有损和无损压缩的图片格式，支持透明度，目前已支持动图。</p></blockquote><h3 id="2、PicX图床的使用"><a href="#2、PicX图床的使用" class="headerlink" title="2、PicX图床的使用"></a>2、PicX图床的使用</h3><p>PicX 是一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了。</p><p>配置链接：<a href="https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE">https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE</a></p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.1fp31abnh9sw.webp"></image></p><p>将本地图片上传至图床，上床成功后的图片会生成一个GitHub外链和cdn外链。</p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.27ywn4r0zskk.webp"></image></p>]]></content>
      
      
      
        <tags>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用装饰器descriptor</title>
      <link href="/2022/01/20/decorator/"/>
      <url>/2022/01/20/decorator/</url>
      
        <content type="html"><![CDATA[<p>decorator装饰器通过对类、对象、方法、属性进行修饰，对其添加一些其他行为，即对一段代码进行二次包装。<br>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><span id="more"></span><p>使用方法：</p><pre><code class="js">const decorator = (target,name,descriptor) =&gt; &#123;  var oldValue = descriptor.value  descriptor.value = function()&#123;    return oldValue.apply(this,arguments)  &#125;  return descriptor&#125;</code></pre><p>使用装饰器可以不需要关注代码内部的实现，增强了代码的可读性。</p><p>vue中使用装饰器：</p><p>项目中使用eslint，需要开启装饰器相关语法的检测。</p><pre><code class="js">// .eslintrc.js  parserOptions: &#123;    parser: &#39;babel-eslint&#39;,    ecmaFeatures:&#123;      legacyDecorators: true    &#125;  &#125;,</code></pre><p>Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作：</p><p>1、工具函数decorator.js</p><pre><code class="js">// 需安装element-uiimport &#123; MessageBox, Message &#125; from &#39;element-ui&#39;/** * 确认框 * @param &#123;String&#125; title - 标题 * @param &#123;String&#125; content - 内容 * @param &#123;String&#125; confirmButtonText - 确认按钮名称 * @param &#123;Function&#125; callback - 确认按钮名称 * @returns   **/export function confirm (title, content, confirmButtonText = &#39;确定&#39;) &#123;  return function(target, name, descriptor) &#123;    // target:test（）      // name:test1       // descriptor: 装饰器属性     // 包括 ：configurable: true     // umerable: true    // value: ƒ ()     // writable: true    const originValue = descriptor.value    descriptor.value = function(...args) &#123;      MessageBox.confirm(content, title, &#123;        dangerouslyUseHTMLString: true,        distinguishCancelAndClose: true,        confirmButtonText: confirmButtonText      &#125;).then(originValue.bind(this, ...args)).catch(error =&gt; &#123;        if (error === &#39;close&#39; || error === &#39;cancel&#39;) &#123;          Message.info(&#39;用户取消操作&#39;)        &#125; else &#123;          Message.info(error)        &#125;      &#125;)    &#125;    return descriptor  &#125;&#125;</code></pre><p>2、页面引入装饰器函数</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;about&quot;&gt;    &lt;h1&gt;This is an about page&lt;/h1&gt;    &lt;p&gt;装饰器&lt;/p&gt;    &lt;button @click=&#39;test&#39;&gt;confirm&lt;/button&gt;&lt;button&gt;cancel&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">import &#123; confirm &#125; from &#39;./decorator.js&#39;export default &#123;  name: &#39;about&#39;,  methods: &#123;    @confirm(&#39;删除&#39;, &#39;确认删除?&#39;)    test () &#123;      // do something  调用接口      this.$message.success(&#39;success!!&#39;)    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC音视频</title>
      <link href="/2022/01/19/webrtc/"/>
      <url>/2022/01/19/webrtc/</url>
      
        <content type="html"><![CDATA[<p>WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p><span id="more"></span><h3 id="一、WebRTC-音视频采集-API：MediaDevices-getUserMedia"><a href="#一、WebRTC-音视频采集-API：MediaDevices-getUserMedia" class="headerlink" title="一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()"></a>一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()</h3><blockquote><p>MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个 MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D 转换器等等），也可能是其它轨道类型。</p></blockquote><pre><code class="js">const constraints = &#123;  video: true,  audio: true,&#125;;//   非安全模式（非https/localhost）下 navigator.mediaDevices 会返回 undefinedtry &#123;  const stream = await navigator.mediaDevices.getUserMedia(constraints);  document.querySelector(&quot;video&quot;).srcObject = stream;&#125; catch (error) &#123;  console.error(error);&#125;</code></pre><h3 id="二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices"><a href="#二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices" class="headerlink" title="二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()"></a>二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()</h3><blockquote><p>MediaDevices 的方法 enumerateDevices() 请求一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等。 返回的 Promise (en-US) 完成时，会带有一个描述设备的 MediaDeviceInfo (en-US) 的数组。</p></blockquote><pre><code class="js">try &#123;  const devices = await navigator.mediaDevices.enumerateDevices();  this.videoinputs = devices.filter((device) =&gt; device.kind === &quot;videoinput&quot;);  this.audiooutputs = devices.filter((device) =&gt; device.kind === &quot;audiooutput&quot;);  this.audioinputs = devices.filter((device) =&gt; device.kind === &quot;audioinput&quot;);&#125; catch (error) &#123;  console.error(error);&#125;</code></pre><h3 id="三、点对点媒体协商方法"><a href="#三、点对点媒体协商方法" class="headerlink" title="三、点对点媒体协商方法"></a>三、点对点媒体协商方法</h3><p>媒体协商方法：</p><p>1、createOffer：</p><blockquote><p>createOffer 方法会生成描述信息的一个 blob 对象，它会帮助连接到本地机器。当你已经找到一个远端的 PeerConnection 并且打算设置建立本地的 PeerConnection 时，你可以使用该方法。</p></blockquote><pre><code class="js">var pc = new PeerConnection();pc.addStream(video);pc.createOffer(function(desc)&#123;  pc.setLocalDescription(desc, function() &#123;    // send the offer to a server that can negotiate with a remote client  &#125;);&#125;</code></pre><p>2、createAnswer：</p><blockquote><p>对从远方收到的 offer 进行回答。</p></blockquote><pre><code class="js">var pc = new PeerConnection();pc.setRemoteDescription(new RTCSessionDescription(offer), function () &#123;  pc.createAnswer(function (answer) &#123;    pc.setLocalDescription(answer, function () &#123;      // send the answer to the remote connection    &#125;);  &#125;);&#125;);</code></pre><h3 id="四、服务端：Koa-socket-io-搭建信令服务器"><a href="#四、服务端：Koa-socket-io-搭建信令服务器" class="headerlink" title="四、服务端：Koa + socket.io 搭建信令服务器"></a>四、服务端：Koa + socket.io 搭建信令服务器</h3><p>1、server.js</p><pre><code class="js">// server 端 server.jsconst Koa = require(&quot;koa&quot;);const socket = require(&quot;socket.io&quot;);const http = require(&quot;http&quot;);const app = new Koa();const httpServer = http.createServer(app.callback()).listen(3000, () =&gt; &#123;&#125;);socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;  // ....&#125;);// client 端 socket.jsimport io from &quot;socket.io-client&quot;;const socket = io.connect(window.location.origin);export default socket;</code></pre><p>2、点对点分别连接信令服务器，信令服务器记录房间信息</p><pre><code class="js">socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;  // 用户离开房间  sock.on(&quot;userLeave&quot;, () =&gt; &#123;    // ...  &#125;);  // 检查房间是否可加入  sock.on(&quot;checkRoom&quot;, () =&gt; &#123;    // ...  &#125;);  // ....&#125;);// client 端 Room.vueimport socket from &quot;../utils/socket.js&quot;;// 服务端告知用户是否可加入房间socket.on(&quot;checkRoomSuccess&quot;, () =&gt; &#123;  // ...&#125;);// 服务端告知用户成功加入房间socket.on(&quot;joinRoomSuccess&quot;, () =&gt; &#123;  // ...&#125;);//....</code></pre><p>3、A 端作为发起方向接收方 B 端发起视频邀请</p><p>在得到 B 同意视频请求后，双方都会创建本地的 RTCPeerConnection，添加本地视频流，其中发送方会创建 offer 设置本地 sdp 信息描述，并通过信令服务器将自己的 SDP 信息发送给对端</p><pre><code class="js">socket.on(&quot;answerVideo&quot;, async (user) =&gt; &#123;  VIDEO_VIEW.showInvideoModal();  // 创建本地视频流信息  const localStream = await this.createLocalVideoStream();  this.localStream = localStream;  document.querySelector(&quot;#echat-local&quot;).srcObject = this.localStream;  this.peer = new RTCPeerConnection();  this.initPeerListen();  this.peer.addStream(this.localStream);  if (user.sockId === this.sockId) &#123;    // 接收方  &#125; else &#123;    // 发送方 创建 offer    const offer = await this.peer.createOffer(this.offerOption);    await this.peer.setLocalDescription(offer);    socket.emit(&quot;receiveOffer&quot;, &#123; user: this.user, offer &#125;);  &#125;&#125;);</code></pre><p>4、收集自己的网络信息并发送给对方</p><pre><code class="js">initPeerListen () &#123;      // 收集自己的网络信息并发送给对端      this.peer.onicecandidate = (event) =&gt; &#123;        if (event.candidate) &#123; socket.emit(&#39;addIceCandidate&#39;, &#123; candidate: event.candidate, user: this.user &#125;); &#125;      &#125;;      // ....    &#125;</code></pre><p>5、当接收方 B 端通过信令服务器拿到对端发送方 A 端的含有 SDP 的 offer 信息后则会调用 setRemoteDescription 存储对端的 SDP 信息，创建及设置本地的 SDP 信息,并通过信令服务器传送含有本地 SDP 信息的 answer</p><pre><code class="js">socket.on(&quot;receiveOffer&quot;, async (offer) =&gt; &#123;  await this.peer.setRemoteDescription(offer);  const answer = await this.peer.createAnswer();  await this.peer.setLocalDescription(answer);  socket.emit(&quot;receiveAnsewer&quot;, &#123; answer, user: this.user &#125;);&#125;);</code></pre><p>6、当发起方 A 通过信令服务器接收到接收方 B 的 answer 信息后则也会调用 setRemoteDescription，这样双方就完成了 SDP 信息的交换</p><pre><code class="js">socket.on(&quot;receiveAnsewer&quot;, (answer) =&gt; &#123;  this.peer.setRemoteDescription(answer);&#125;);</code></pre><p>7、当双方 SDP 信息交换完成并且监听 icecandidate 收集到网络候选者通过信令服务器交换后，则会拿到彼此的视频流。</p><pre><code class="js">socket.on(&quot;addIceCandidate&quot;, async (candidate) =&gt; &#123;  await this.peer.addIceCandidate(candidate);&#125;);this.peer.onaddstream = (event) =&gt; &#123;  // 拿到对方的视频流  document.querySelector(&quot;#remote-video&quot;).srcObject = event.stream;&#125;;</code></pre><p>8、GitHub：<a href="https://github.com/HeyJudeYQ/webrtc">https://github.com/HeyJudeYQ/webrtc</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中前端导出/导入Excel表格的实现</title>
      <link href="/2022/01/15/export-excel/"/>
      <url>/2022/01/15/export-excel/</url>
      
        <content type="html"><![CDATA[<p>后台管理系统中，通常有这样的需求:将当前 table 表格导出/导入 Excel 表格，实现方式通常为后端主导（后端使用插件，前端通过点击事件生成一个 a 标签，导出 Excel 表格）、前端主导（使用 xlsx、file-saver、script-loader 插件封装工具函数，通过点击事件，获取当前页面后台返回的表格数据)。</p><span id="more"></span><h2 id="一、前端导出-Excel-表格的实现"><a href="#一、前端导出-Excel-表格的实现" class="headerlink" title="一、前端导出 Excel 表格的实现"></a>一、前端导出 Excel 表格的实现</h2><h3 id="1、安装-plugin"><a href="#1、安装-plugin" class="headerlink" title="1、安装 plugin"></a>1、安装 plugin</h3><pre><code class="shell">npm install file-saver script-loader xlsx --save</code></pre><h3 id="2、Export2Excel-工具函数"><a href="#2、Export2Excel-工具函数" class="headerlink" title="2、Export2Excel 工具函数"></a>2、Export2Excel 工具函数</h3><details><summary>点我展示代码</summary><pre><code class="js">import &#123; saveAs &#125; from &quot;file-saver&quot;;import XLSX from &quot;xlsx&quot;;function generateArray(table) &#123;  var out = [];  var rows = table.querySelectorAll(&quot;tr&quot;);  var ranges = [];  for (var R = 0; R &lt; rows.length; ++R) &#123;    var outRow = [];    var row = rows[R];    var columns = row.querySelectorAll(&quot;td&quot;);    for (var C = 0; C &lt; columns.length; ++C) &#123;      var cell = columns[C];      var colspan = cell.getAttribute(&quot;colspan&quot;);      var rowspan = cell.getAttribute(&quot;rowspan&quot;);      var cellValue = cell.innerText;      if (cellValue !== &quot;&quot; &amp;&amp; cellValue == +cellValue) cellValue = +cellValue;      //Skip ranges      ranges.forEach(function (range) &#123;        if (          R &gt;= range.s.r &amp;&amp;          R &lt;= range.e.r &amp;&amp;          outRow.length &gt;= range.s.c &amp;&amp;          outRow.length &lt;= range.e.c        ) &#123;          for (var i = 0; i &lt;= range.e.c - range.s.c; ++i) outRow.push(null);        &#125;      &#125;);      //Handle Row Span      if (rowspan || colspan) &#123;        rowspan = rowspan || 1;        colspan = colspan || 1;        ranges.push(&#123;          s: &#123;            r: R,            c: outRow.length,          &#125;,          e: &#123;            r: R + rowspan - 1,            c: outRow.length + colspan - 1,          &#125;,        &#125;);      &#125;      //Handle Value      outRow.push(cellValue !== &quot;&quot; ? cellValue : null);      //Handle Colspan      if (colspan) for (var k = 0; k &lt; colspan - 1; ++k) outRow.push(null);    &#125;    out.push(outRow);  &#125;  return [out, ranges];&#125;function datenum(v, date1904) &#123;  if (date1904) v += 1462;  var epoch = Date.parse(v);  return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#125;function sheet_from_array_of_arrays(data, opts) &#123;  var ws = &#123;&#125;;  var range = &#123;    s: &#123;      c: 10000000,      r: 10000000,    &#125;,    e: &#123;      c: 0,      r: 0,    &#125;,  &#125;;  for (var R = 0; R != data.length; ++R) &#123;    for (var C = 0; C != data[R].length; ++C) &#123;      if (range.s.r &gt; R) range.s.r = R;      if (range.s.c &gt; C) range.s.c = C;      if (range.e.r &lt; R) range.e.r = R;      if (range.e.c &lt; C) range.e.c = C;      var cell = &#123;        v: data[R][C],      &#125;;      if (cell.v == null) continue;      var cell_ref = XLSX.utils.encode_cell(&#123;        c: C,        r: R,      &#125;);      if (typeof cell.v === &quot;number&quot;) cell.t = &quot;n&quot;;      else if (typeof cell.v === &quot;boolean&quot;) cell.t = &quot;b&quot;;      else if (cell.v instanceof Date) &#123;        cell.t = &quot;n&quot;;        cell.z = XLSX.SSF._table[14];        cell.v = datenum(cell.v);      &#125; else cell.t = &quot;s&quot;;      ws[cell_ref] = cell;    &#125;  &#125;  if (range.s.c &lt; 10000000) ws[&quot;!ref&quot;] = XLSX.utils.encode_range(range);  return ws;&#125;function Workbook() &#123;  if (!(this instanceof Workbook)) return new Workbook();  this.SheetNames = [];  this.Sheets = &#123;&#125;;&#125;function s2ab(s) &#123;  var buf = new ArrayBuffer(s.length);  var view = new Uint8Array(buf);  for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;  return buf;&#125;export function export_table_to_excel(id) &#123;  var theTable = document.getElementById(id);  var oo = generateArray(theTable);  var ranges = oo[1];  /* original data */  var data = oo[0];  var ws_name = &quot;SheetJS&quot;;  var wb = new Workbook(),    ws = sheet_from_array_of_arrays(data);  /* add ranges to worksheet */  // ws[&#39;!cols&#39;] = [&#39;apple&#39;, &#39;banan&#39;];  ws[&quot;!merges&quot;] = ranges;  /* add worksheet to workbook */  wb.SheetNames.push(ws_name);  wb.Sheets[ws_name] = ws;  var wbout = XLSX.write(wb, &#123;    bookType: &quot;xlsx&quot;,    bookSST: false,    type: &quot;binary&quot;,  &#125;);  saveAs(    new Blob([s2ab(wbout)], &#123;      type: &quot;application/octet-stream&quot;,    &#125;),    &quot;test.xlsx&quot;  );&#125;export function export_json_to_excel(&#123;  multiHeader = [],  header,  data,  filename,  merges = [],  autoWidth = true,  bookType = &quot;xlsx&quot;,&#125; = &#123;&#125;) &#123;  /* original data */  filename = filename || &quot;excel-list&quot;;  data = [...data];  data.unshift(header);  for (let i = multiHeader.length - 1; i &gt; -1; i--) &#123;    data.unshift(multiHeader[i]);  &#125;  var ws_name = &quot;SheetJS&quot;;  var wb = new Workbook(),    ws = sheet_from_array_of_arrays(data);  if (merges.length &gt; 0) &#123;    if (!ws[&quot;!merges&quot;]) ws[&quot;!merges&quot;] = [];    merges.forEach((item) =&gt; &#123;      ws[&quot;!merges&quot;].push(XLSX.utils.decode_range(item));    &#125;);  &#125;  if (autoWidth) &#123;    /*设置worksheet每列的最大宽度*/    const colWidth = data.map((row) =&gt;      row.map((val) =&gt; &#123;        /*先判断是否为null/undefined*/        if (val == null) &#123;          return &#123;            wch: 10,          &#125;;        &#125; else if (val.toString().charCodeAt(0) &gt; 255) &#123;          /*再判断是否为中文*/          return &#123;            wch: val.toString().length * 2,          &#125;;        &#125; else &#123;          return &#123;            wch: val.toString().length,          &#125;;        &#125;      &#125;)    );    /*以第一行为初始值*/    let result = colWidth[0];    for (let i = 1; i &lt; colWidth.length; i++) &#123;      for (let j = 0; j &lt; colWidth[i].length; j++) &#123;        if (result[j][&quot;wch&quot;] &lt; colWidth[i][j][&quot;wch&quot;]) &#123;          result[j][&quot;wch&quot;] = colWidth[i][j][&quot;wch&quot;];        &#125;      &#125;    &#125;    ws[&quot;!cols&quot;] = result;  &#125;  /* add worksheet to workbook */  wb.SheetNames.push(ws_name);  wb.Sheets[ws_name] = ws;  var wbout = XLSX.write(wb, &#123;    bookType: bookType,    bookSST: false,    type: &quot;binary&quot;,  &#125;);  saveAs(    new Blob([s2ab(wbout)], &#123;      type: &quot;application/octet-stream&quot;,    &#125;),    `$&#123;filename&#125;.$&#123;bookType&#125;`  );&#125;</code></pre></details><h3 id="3、导出函数"><a href="#3、导出函数" class="headerlink" title="3、导出函数"></a>3、导出函数</h3><p>a-button 为 ant-design-vue 的 button 组件</p><pre><code class="html">&lt;a-button  type=&quot;primary&quot;  icon=&quot;export&quot;  class=&quot;select-bottom&quot;  :loading=&quot;exportLoading&quot;  @click=&quot;handleExport&quot;  &gt;导出&lt;/a-button&gt;</code></pre><p>handleExport 导出函数</p><blockquote><p>1、点击导出按钮，去加载在 vendor 文件夹中的 Export2Excel 模块<br>2、import 方法执行完毕返回一个 promise 对象，在 then 方法中我们可以拿到使用的模块对象（excel）<br>3、Excel 导出参数部分的 data，是一个严格的二维数组，header 为导出的数据表头，filename 为导出的文件名，bookType 为导出文件类型，autoWidth 为单元格是否要自适应宽度。</p></blockquote><pre><code class="js">handleExport() &#123;    //由于是前端导出，所以只能导出当前页的数据    this.exportLoading = true;      import(&#39;@/vendor/Export2Excel&#39;).then(excel =&gt; &#123;        const header = [],          filterVal = [];        this.tableHead.forEach(item =&gt; &#123;          if (item.title != &#39;操作&#39; &amp;&amp; item.title != &#39;序号&#39;) &#123;            header.push(item.title);            filterVal.push(item.dataIndex);          &#125;        &#125;);        const data = formatJson(this.tableData, filterVal);        excel.export_json_to_excel(&#123;          header,          data,          filename: &#39;表单统计&#39;        &#125;);        this.exportLoading = false;      &#125;);    &#125;</code></pre><h2 id="二、前端导入-Excel-的实现"><a href="#二、前端导入-Excel-的实现" class="headerlink" title="二、前端导入 Excel 的实现"></a>二、前端导入 Excel 的实现</h2><h3 id="1、ant-design-vue-上传组件的使用"><a href="#1、ant-design-vue-上传组件的使用" class="headerlink" title="1、ant-design-vue 上传组件的使用"></a>1、ant-design-vue 上传组件的使用</h3><pre><code class="html">&lt;div class=&quot;file-wrapper relative&quot;&gt;  &lt;input    ref=&quot;excel-upload&quot;    type=&quot;file&quot;    accept=&quot;.xlsx, .xls&quot;    @change=&quot;handleChange&quot;    style=&quot;display:none&quot;  /&gt;  &lt;a-button    type=&quot;primary&quot;    icon=&quot;file-excel&quot;    size=&quot;large&quot;    style=&quot;z-index:99&quot;    @click=&quot;handleUpload&quot;    :loading=&quot;loading&quot;  &gt;    上传Excel  &lt;/a-button&gt;  &lt;p class=&quot;text&quot;&gt;请选择Excel上传 支持(xlsx,xls)格式&lt;/p&gt;&lt;/div&gt;&lt;!-- table组件 tableData:[]  tableHead:[] --&gt;&lt;a-card  :hoverable=&quot;true&quot;  :bordered=&quot;false&quot;  v-if=&quot;tableHead.length &gt; 0&quot;  style=&quot;margin-top:30px&quot;&gt;  &lt;standard-table    :pagination=&quot;false&quot;    :tableData=&quot;tableData&quot;    :tableHead=&quot;tableHead&quot;  /&gt;&lt;/a-card&gt;</code></pre><!-- 样式 --><pre><code class="css">.file-wrapper &#123;  width: 100%;  height: 350px;  line-height: 350px;  text-align: center;  background: #e6ecf4;  .text &#123;    position: absolute;    top: 50px;    left: 50%;    transform: translateX(-50%);  &#125;&#125;</code></pre><h3 id="2、导入函数"><a href="#2、导入函数" class="headerlink" title="2、导入函数"></a>2、导入函数</h3><pre><code class="js">// 引入xlsx table组件import XLSX from &quot;xlsx&quot;;import standardTable from &quot;@/components/standardTable/index&quot;;</code></pre><details><summary>点我展示代码</summary><pre><code class="js">    handleChange(e) &#123;      const file = e.target.files[0];      if (!file) return;      //判断格式      if (!this.isExcel(file)) &#123;        this.$message.warning(&#39;只能选择xlxs,xls文件&#39;);        return;      &#125;      //判断大小      if (file.size / 1024 / 1024 &gt; 1) &#123;        this.$message.warning(&#39;上传文件大小不能超过1M&#39;);        return;      &#125;      this.loading = true;      const reader = new FileReader();      reader.readAsArrayBuffer(file);      reader.onload = e =&gt; &#123;        const data = e.target.result;        const workbook = XLSX.read(data, &#123; type: &#39;array&#39; &#125;);        const firstSheetName = workbook.SheetNames[0];        const worksheet = workbook.Sheets[firstSheetName];        setTimeout(() =&gt; &#123;          this.loading = false;          const head = this.getHeaderRow(worksheet);          this.tableHead = head.map(item =&gt; &#123;            return &#123;              title: item,              dataIndex: item            &#125;;          &#125;);          const tableData = XLSX.utils.sheet_to_json(worksheet);          tableData.forEach(item =&gt; &#123;            item.id = parseInt(Math.random(0, 1) * 10000);          &#125;);          this.tableData = tableData;        &#125;, 500);      &#125;;    &#125;,    generateData(&#123; header, results &#125;) &#123;      this.excelData.header = header;      this.excelData.results = results;      this.onSuccess &amp;&amp; this.onSuccess(this.excelData);    &#125;,    //获取表头    getHeaderRow(sheet) &#123;      const headers = [];      const range = XLSX.utils.decode_range(sheet[&#39;!ref&#39;]);      let C;      const R = range.s.r;      for (C = range.s.c; C &lt;= range.e.c; ++C) &#123;        const cell = sheet[XLSX.utils.encode_cell(&#123; c: C, r: R &#125;)];        let hdr = &#39;UNKNOWN &#39; + C;        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell);        headers.push(hdr);      &#125;      return headers;    &#125;,    handleUpload() &#123;      this.$refs[&#39;excel-upload&#39;].click();    &#125;,    // 文件类型    isExcel(file) &#123;      return /\.(xlsx|xls|csv)$/.test(file.name);    &#125;</code></pre></details><h2 id="三、table-子组件"><a href="#三、table-子组件" class="headerlink" title="三、table 子组件"></a>三、table 子组件</h2><details><summary>点我展示代码</summary><pre><code class="html">&lt;div class=&quot;tableCommon-wrapper&quot;&gt;  &lt;a-table    :columns=&quot;tableHead&quot;    :dataSource=&quot;tableData&quot;    :loading=&quot;loading&quot;    :pagination=&quot;pagination&quot;    :row-selection=&quot;rowSelection&quot;    @change=&quot;handleTableChange&quot;    rowKey=&quot;id&quot;    :scroll=&quot;scroll&quot;  &gt;    &lt;template      slot-scope=&quot;text, record, index&quot;      :slot=&quot;slot&quot;      v-for=&quot;slot in Object.keys($scopedSlots).filter(key =&gt; key !== &#39;expandedRowRender&#39;)&quot;    &gt;      &lt;slot :name=&quot;slot&quot; v-bind=&quot;&#123; text, record, index &#125;&quot;&gt;&lt;/slot&gt;    &lt;/template&gt;  &lt;/a-table&gt;&lt;/div&gt;</code></pre><pre><code class="js">export default &#123;  name: &quot;standardTable&quot;,  props: &#123;    tableHead: &#123;      type: Array,      required: true,    &#125;,    tableData: &#123;      type: Array,      required: true,    &#125;,    loading: &#123;      type: Boolean,      default: false,    &#125;,    pagination: &#123;      type: Boolean | Object,    &#125;,    rowSelection: &#123;      type: Object,    &#125;,    scroll: &#123;      type: Object,    &#125;,  &#125;,  methods: &#123;    handleTableChange(val) &#123;      this.$emit(&quot;changeCurrent&quot;, val.current);    &#125;,  &#125;,&#125;;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountTo:数字动态滚动</title>
      <link href="/2022/01/13/count-to/"/>
      <url>/2022/01/13/count-to/</url>
      
        <content type="html"><![CDATA[<p>vue使用vue-count-to实现数字的动态滚动功能，适用于数据可视化大屏项目中使用数字滚动。</p><span id="more"></span><pre><code class="js">// 1、安装vue-count-tonpm isntall vue-count-to// 2、组件内引入、注册 startVal endVal 类型为Number</code></pre><p>代码如下：</p><pre><code class="html">&lt;template&gt;  &lt;countTo :startVal=&#39;startVal&#39; :endVal=&#39;number&#39; :duration=&#39;3000&#39; :decimals=&#39;0&#39;  :autoplay=true&gt;&lt;/countTo&gt;&lt;/template&gt;&lt;script&gt;import countTo from &#39;vue-count-to&#39;;  export default&#123;    components:&#123;countTo&#125;,    props:&#123;      number: [Number, String],      startVal:&#123;        type:Number,        default:0      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用hook处理组件内定时器</title>
      <link href="/2022/01/01/hook/"/>
      <url>/2022/01/01/hook/</url>
      
        <content type="html"><![CDATA[<p>vue 项目使用 hook 处理组件内定时器的方式。一般是使用生命周期钩子函数beforeDestory来销毁定时器。从Vue源码的lifecycle.js中发现了一种拓展方法，可以提升代码的简洁性，而且还可以减少data里无用变量的定义。</p><span id="more"></span><h2 id="一、使用生命周期函数处理定时器"><a href="#一、使用生命周期函数处理定时器" class="headerlink" title="一、使用生命周期函数处理定时器"></a>一、使用生命周期函数处理定时器</h2><p>通常处理组件内定时器的步骤是下面这样的</p><pre><code class="js">export default&#123;    mounted()&#123;        this.timer = setInterval（() =&gt;&#123;            // do something        &#125;,1000）    &#125;,    beforeDestory()&#123;        clearInterval(this.timer);    &#125;&#125;</code></pre><h2 id="二、使用-hook-处理定时器"><a href="#二、使用-hook-处理定时器" class="headerlink" title="二、使用 hook 处理定时器"></a>二、使用 hook 处理定时器</h2><pre><code class="js">export default&#123;    mounted()&#123;        const timer = setInterval(() =&gt; &#123;            // do something        &#125;,1000);        this.$once(&#39;hook:beforeDestory&#39;,()=&gt; clearInterval(timer);)    &#125;&#125;</code></pre><h2 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景:"></a>三、适用场景:</h2><p>处理可视化图表的时候，我们需要在数据渲染到页面之前让页面有 loading 动画，mounted 挂载之后停止 loading，beforeUpdate 时开始 loading，updated 之后停止 loading。</p><p>使用 hook 处理:</p><pre><code class="tempalte">&lt;v-chart&gt;  @hook:mounted=&quot;loading = false&quot; @hook:beforeUpdated=&quot;loading = true&quot;  @hook:updated=&quot;loading = false&quot; :data=&quot;data&quot;&lt;/v-chart&gt;</code></pre><h2 id="四、补充说明：如何实现父组件监听子组件生命周期？"><a href="#四、补充说明：如何实现父组件监听子组件生命周期？" class="headerlink" title="四、补充说明：如何实现父组件监听子组件生命周期？"></a>四、补充说明：如何实现父组件监听子组件生命周期？</h2><h3 id="1、方法一：-emit"><a href="#1、方法一：-emit" class="headerlink" title="1、方法一：$emit"></a>1、方法一：$emit</h3><p>父组件给子组件传递多个回调函数，依赖子组件在自身的生命周期李通过vm.$emit的方式，调用父组件生命的回调函数。</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div&gt;        &lt;Child @mounted=&quot;onMounted&quot;            @updated=&quot;onUpdated&quot;            @beforeDestory=&quot;beforeDestory&quot;        &gt;        &lt;/Child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code class="js">mounted()&#123;    this.$emit(&#39;mounted&#39;)&#125;,updated()&#123;    this.$emit(&#39;updated&#39;)&#125;,beforeDestory()&#123;    this.$emit(&#39;beforeDestory&#39;)&#125;</code></pre><h3 id="2、方法二：-hook"><a href="#2、方法二：-hook" class="headerlink" title="2、方法二：@hook"></a>2、方法二：@hook</h3><p>父组件模板</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;Child @hook:mounted=&quot;onMounted&quot;            @hook:updated=&quot;onUpdated&quot;            @hook:beforeDestory=&quot;beforeDestory&quot;        &gt;        &lt;/Child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>vue源码的lifecycle.js中，Vue的生命周期各个阶段都会去调用一个callHook函数，这个函数支持2个参数：实例vm和生命周期钩子名称,callHook里面执行了vm.$emit(‘hook:’+hook)。</p><p>lifecycle.js源码片段（这个文件在Vue源码的src/core/instance/lifecycle.js）</p><pre><code class="js">// callHook函数export function callHook (vm: Component, hook: string) &#123;  // #7573 disable dep collection when invoking lifecycle hooks  pushTarget()  const handlers = vm.$options[hook]  const info = `$&#123;hook&#125; hook`  if (handlers) &#123;    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;      invokeWithErrorHandling(handlers[i], vm, null, vm, info)    &#125;  &#125;  if (vm._hasHookEvent) &#123;    vm.$emit(&#39;hook:&#39; + hook)  &#125;  popTarget()&#125;</code></pre><p>@hook原理：</p><blockquote><p>当我们在子组件上传了对应的@hook:mounted钩子，也就执行了vm.$on(‘hook:mounted’),vue实例在生命周期里本身就会执行vm.$emit(‘hook:mounted’),也触发了我们绑定给子组件的回调函数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交规范</title>
      <link href="/2021/12/22/git/"/>
      <url>/2021/12/22/git/</url>
      
        <content type="html"><![CDATA[<p>使用commitizen和cz-customizable规范代码提交</p><span id="more"></span><h3 id="1-安装commitizen和cz-customizable"><a href="#1-安装commitizen和cz-customizable" class="headerlink" title="1.安装commitizen和cz-customizable"></a>1.安装commitizen和cz-customizable</h3><pre><code class="js">npm install -g commitizen@4.2.4npm i cz-customizable@6.3.0 --save-dev</code></pre><h3 id="2-在package-json中进行新增"><a href="#2-在package-json中进行新增" class="headerlink" title="2.在package.json中进行新增"></a>2.在package.json中进行新增</h3><pre><code class="js">&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;  &#125;&#125;</code></pre><h3 id="3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit"><a href="#3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit" class="headerlink" title="3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit"></a>3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit</h3><h3 id="4-使用husky进行强制git代码提交规范"><a href="#4-使用husky进行强制git代码提交规范" class="headerlink" title="4.使用husky进行强制git代码提交规范"></a>4.使用husky进行强制git代码提交规范</h3><pre><code class="js">npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4npm install husky@7.0.1 --save-devnpx husky install</code></pre><h3 id="5-在package-json中新增指令"><a href="#5-在package-json中新增指令" class="headerlink" title="5.在package.json中新增指令"></a>5.在package.json中新增指令</h3><pre><code class="js">&quot;prepare&quot;: &quot;husky install&quot;</code></pre><h3 id="6-并执行"><a href="#6-并执行" class="headerlink" title="6.并执行"></a>6.并执行</h3><pre><code class="js">npm run prepare</code></pre><h3 id="7-新增husky配置文件-并往里面写入"><a href="#7-新增husky配置文件-并往里面写入" class="headerlink" title="7.新增husky配置文件 并往里面写入"></a>7.新增husky配置文件 并往里面写入</h3><pre><code class="js">npx husky add .husky/commit-msgnpx --no-install commitlint --edit</code></pre><h3 id="8、husky规范"><a href="#8、husky规范" class="headerlink" title="8、husky规范"></a>8、husky规范</h3><pre><code class="js">// commitlint.config.jsmodule.exports = &#123;  // 继承的规则  extends: [&#39;@commitlint/config-conventional&#39;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;, // 新功能 feature        &#39;fix&#39;, // 修复 bug        &#39;docs&#39;, // 文档注释        &#39;style&#39;, // 代码格式(不影响代码运行的变动)        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)        &#39;perf&#39;, // 性能优化        &#39;test&#39;, // 增加测试        &#39;chore&#39;, // 构建过程或辅助工具的变动        &#39;revert&#39;, // 回退        &#39;build&#39; // 打包      ]    ],    // subject 大小写不做校验    &#39;subject-case&#39;: [0]  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决GitHub Pages绑定阿里域名CNAME消失</title>
      <link href="/2021/10/28/url/"/>
      <url>/2021/10/28/url/</url>
      
        <content type="html"><![CDATA[<p>hexo主题使用的是Claudia,部署到GitHub Pages时，CNAME会消失。</p><span id="more"></span><p>解决方式：</p><pre><code>// 1 cd sourcetouch CNAME// 2 输入阿里域名issummer.cn// 3 部署hexo g &amp;&amp; hexo d</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义input唤起键盘</title>
      <link href="/2021/10/20/input/"/>
      <url>/2021/10/20/input/</url>
      
        <content type="html"><![CDATA[<p>自定义 input 唤起键盘。移动端页面自定义 input 唤起键盘 return，有时需要将换行键改为搜索，为了达到更好的用户体验。<br>在 html5 中，我们可以将 input 的 type 修改为 search，这样修改之后，我们的安卓手机会变成搜索或者搜索符号、IOS 则会变成换行。</p><span id="more"></span><p>1、安卓手机</p><pre><code class="html">&lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot; /&gt;</code></pre><p>2、苹果 IOS 手机</p><p>与安卓手机不同的是，我们需要在外层包裹一个 form</p><pre><code class="html">    &lt;from action=&quot;javascript:return true&quot;&gt;        &lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot;&gt;    &lt;/form&gt;</code></pre><p>3、修改 search 的默认样式</p><pre><code class="css">input[type=&quot;search&quot;] &#123;  -webkit-appearance: none;&#125;input::-webkit-search-cancel-button &#123;  display: none; // 关闭按钮&#125;</code></pre><p>4、禁止输入法弹出的方法</p><blockquote><p>readonly 属性的使用</p></blockquote><p>点击输入框触发 focus 事件弹出时间 picker，将选择的开始时间、结束时间都显示在输入框里，这里加入只读 readonly 属性可以避免输入法的弹出。</p><pre><code class="html">&lt;input v-model=&quot;startDate&quot; readonly @focus=&quot;openStartPicker&quot; /&gt;&lt;input v-model=&quot;endDate&quot; readonly @focus=&quot;openEndPicker&quot; /&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket实现客户端和服务端的通信</title>
      <link href="/2021/09/20/websocket/"/>
      <url>/2021/09/20/websocket/</url>
      
        <content type="html"><![CDATA[<p>传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。</p><span id="more"></span><p>初始化websocket<br>1、创建websocket实例，参数为url<br>2、连接 websocket.onopen<br>3、server响应数据触发 websocket.onmessage<br>4、关闭websocket，websocket.onclose</p><pre><code class="js">// 构造函数 参数为urlconst wsurl = &quot;ws://localhost:8080&quot;;var ws = new Websocket(wsurl);// 连接状态readState 1  准备好发送和接受数据了ws.onopen = function()&#123;  ws.send(&#39;hello server! websocket is open now!&#39;)&#125;// 通过客户端的事件   发送信息给服务端ws.send(&#39;hello websocket&#39;);// 发生错误ws.onerror = function(event)&#123;  console.log(&quot;websocket error observed&quot;,event)&#125;// readState CLOSED  关闭websocketws.onclose = function(event)&#123;  let status_code = event.status;  let msg = event.msg;  console.log(&quot;websocket is closed now&quot;)&#125;// 响应数据的接收ws.onmessage = function(event)&#123;  let data = event.data;&#125;</code></pre><ul><li>路由改变，需要断开websocket连接，节省服务器开支。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识egg.js</title>
      <link href="/2021/06/20/egg/"/>
      <url>/2021/06/20/egg/</url>
      
        <content type="html"><![CDATA[<p>egg.js的使用,包括项目的创建、内置ctx对象、路由、controller控制层、post请求。</p><span id="more"></span><h3 id="1、创建-启动项目"><a href="#1、创建-启动项目" class="headerlink" title="1、创建/启动项目"></a>1、创建/启动项目</h3><p>直接使用下面的方式，无法创建项目</p><pre><code class="js">// 无法创建项目npm init egg --type=simple// 需要在后面指定淘宝源npm init egg --type=simple -r=https://registry.npm.taobao.orgnpm run dev</code></pre><h3 id="2、内置的ctx对象"><a href="#2、内置的ctx对象" class="headerlink" title="2、内置的ctx对象"></a>2、内置的ctx对象</h3><blockquote><p>ctx这个对象非常重要，请求来的参数，返回去的消息都需要通过ctx这个对象获取或者设置</p></blockquote><blockquote><p>ctx是继承koa的context对象通过设置ctx.body， 可以改变返回信息</p></blockquote><pre><code class="js">ctx &#123; request:    &#123; method: &#39;GET&#39;,     url: &#39;/&#39;,     header:       &#123; host: &#39;127.0.0.1:7001&#39;,        connection: &#39;keep-alive&#39;,        pragma: &#39;no-cache&#39;,        &#39;cache-control&#39;: &#39;no-cache&#39;,        &#39;sec-ch-ua&#39;: &#39;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#39;,        &#39;sec-ch-ua-mobile&#39;: &#39;?0&#39;,        &#39;sec-ch-ua-platform&#39;: &#39;&quot;macOS&quot;&#39;,        &#39;upgrade-insecure-requests&#39;: &#39;1&#39;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&#39;,        accept: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,        &#39;sec-fetch-site&#39;: &#39;none&#39;,        &#39;sec-fetch-mode&#39;: &#39;navigate&#39;,        &#39;sec-fetch-user&#39;: &#39;?1&#39;,        &#39;sec-fetch-dest&#39;: &#39;document&#39;,        &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,        &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,        cookie: &#39;csrfToken=DpyybUjAh9JRzrCgx3itQifi&#39; &#125; &#125;,  response: &#123; status: 404, message: &#39;Not Found&#39;, header: &#123;&#125; &#125;,  app:    &#123; env: &#39;local&#39;,     name: &#39;eggjs&#39;,     baseDir: &#39;/Users/yq/Desktop/express&#39;,     subdomainOffset: 2,     config: &#39;&lt;egg config&gt;&#39;,     controller: &#39;&lt;egg controller&gt;&#39;,     httpclient: &#39;&lt;egg httpclient&gt;&#39;,     loggers: &#39;&lt;egg loggers&gt;&#39;,     middlewares: &#39;&lt;egg middlewares&gt;&#39;,     router: &#39;&lt;egg router&gt;&#39;,     serviceClasses: &#39;&lt;egg serviceClasses&gt;&#39; &#125;,  originalUrl: &#39;/&#39;,  req: &#39;&lt;original node req&gt;&#39;,  res: &#39;&lt;original node res&gt;&#39;,  socket: &#39;&lt;original node socket&gt;&#39; &#125;</code></pre><h3 id="3、路由"><a href="#3、路由" class="headerlink" title="3、路由"></a>3、路由</h3><p>在controller的home.js中写一个新的路由,</p><pre><code class="js">    async list()&#123;        const &#123; ctx &#125; = this        ctx.body = &#123;            code:200,            data:[                &#123;                    id:&#39;1&#39;,                    name:&#39;jude&#39;                &#125;,                &#123;                    id:&#39;2&#39;,                    name:&#39;summer&#39;                &#125;            ],            msg:&#39;success&#39;        &#125;    &#125;</code></pre><p>在router.js中匹配新写的路由</p><pre><code class="js">    router.get(&#39;/list&#39;,controller.home.list)</code></pre><p>打开127.0.0.1:7001/list即可看到效果</p><h3 id="4、Controller控制层"><a href="#4、Controller控制层" class="headerlink" title="4、Controller控制层"></a>4、Controller控制层</h3><p>在controller新建一个user.js</p><pre><code class="js">&#39;use strict&#39;const Controller = require(&#39;egg&#39;).Controllerclass UserController extends Controller &#123;    async info()&#123;        const &#123;ctx&#125; = this        ctx.body = &#123;            code:200,            data:&#123;                id:&#39;1&#39;,                name:&quot;jude&quot;                age:29,                gender:&quot;man&quot;            &#125;            msg::&quot;success&quot;        &#125;    &#125;&#125;module.exports = UserController</code></pre><p>配置新的路由</p><pre><code class="js">router.get(&#39;/user/info&#39;,controller.user.info)</code></pre><p>打开127.0.0.1:7001/user/info 即可看到效果</p><h3 id="5、post请求及配置CSRF跨域"><a href="#5、post请求及配置CSRF跨域" class="headerlink" title="5、post请求及配置CSRF跨域"></a>5、post请求及配置CSRF跨域</h3><p>安装跨域插件</p><pre><code class="js">npm install egg-cors --save</code></pre><p>配置config下的plugin.js和config.default.js</p><pre><code>// plugin.jsmoduel.exports = &#123;    cors:&#123;        enable:true,        package:&#39;egg-cors&#39;    &#125;&#125;// config.default.jsconfig.security = &#123;    csrf:&#123;        enable:true    &#125;,    domainWhiteList:[]&#125;config.cors = &#123;    origin:&quot;*&quot;,    allowMethods:&#39;GET,PUT,POST,DELETE.PATCH&#39;&#125;</code></pre><h3 id="6、创建post请求"><a href="#6、创建post请求" class="headerlink" title="6、创建post请求"></a>6、创建post请求</h3><pre><code class="js">// user.jsasync createUser()&#123;    const &#123;ctx &#125; = this    const result = &#123;        username:ctx.request.body.username,        age:ctx.request.body.age    &#125;    ctx.body = &#123;        code:200,        data:result,        msg:&#39;success&#39;    &#125;&#125;</code></pre><p>此时，打开ApiPost工具，选择post请求，输入请求地址+参数信息，即可看到响应信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中的window.resize</title>
      <link href="/2021/05/19/resize/"/>
      <url>/2021/05/19/resize/</url>
      
        <content type="html"><![CDATA[<p>Vue项目中使用ECharts可视化图表时，图表自适应大小。根据窗口大小自动改变ECharts图表的宽度。</p><span id="more"></span><h3 id="一、防抖函数"><a href="#一、防抖函数" class="headerlink" title="一、防抖函数"></a>一、防抖函数</h3><p>页面频繁使用window.resize函数会使得页面非常卡顿，需要使用debounce防抖函数（无论触发了多少次回调，都只执行最后一次）。</p><pre><code class="js">/** * 函数防抖 * @param &#123;Function&#125; func * @param &#123;number&#125; delay * @param &#123;boolean&#125; immediate * @return &#123;*&#125; */export function debounce(func, delay, immediate = false) &#123;  let timer,context = this;  return (...args) =&gt; &#123;    if (immediate) &#123;      func.apply(context, args);      immediate = false;      return;    &#125;    clearTimeout(timer);    timer = setTimeout(() =&gt; &#123;      func.apply(context, args);    &#125;, delay);  &#125;;&#125;</code></pre><h3 id="二、resize函数"><a href="#二、resize函数" class="headerlink" title="二、resize函数"></a>二、resize函数</h3><pre><code class="js">// 工具函数的引入import &#123; debounce &#125; from &#39;@/utils/index.js&#39;;export default &#123;  data() &#123;    return &#123;      myChart: null,      resizeHandler: null    &#125;;  &#125;,  computed: &#123;    // 侧边栏的收缩    open() &#123;      return this.$store.state.setting.open;    &#125;  &#125;,  mounted() &#123;    this.resizeHandler = debounce(() =&gt; &#123;      if (this.myChart) &#123;        this.myChart.resize();      &#125;    &#125;, 100);    this.initResizeEvent();  &#125;,  methods: &#123;    //监听resize    initResizeEvent() &#123;      window.addEventListener(&#39;resize&#39;, this.resizeHandler);    &#125;,    //移除resize    destroyResizeEvent() &#123;      window.removeEventListener(&#39;resize&#39;, this.resizeHandler);    &#125;  &#125;,  beforeDestroy() &#123;    this.destroyResizeEvent();    if (!this.myChart) &#123;      return;    &#125;    this.myChart.dispose();    this.myChart.off(&#39;click&#39;);    this.myChart = null;  &#125;,  activated() &#123;    this.initResizeEvent();    if (this.myChart) &#123;      this.myChart.resize();    &#125;  &#125;,  deactivated() &#123;    this.destroyResizeEvent();  &#125;,  watch: &#123;    open() &#123;      if (this.myChart) &#123;        this.myChart.resize();      &#125;    &#125;  &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript基础</title>
      <link href="/2021/05/15/typescript/"/>
      <url>/2021/05/15/typescript/</url>
      
        <content type="html"><![CDATA[<p>typescript基础知识,包括typescript的安装、函数、数组、字符串等。</p><span id="more"></span><h3 id="1、typescript的安装"><a href="#1、typescript的安装" class="headerlink" title="1、typescript的安装"></a>1、typescript的安装</h3><blockquote><p>1、安装node</p></blockquote><blockquote><p>2、安装typescript</p></blockquote><pre><code class="shell">sudo npm install typescript -g  //(mac 则需要添加sudo window则不需要)tsc -v // 查看版本号</code></pre><blockquote><p>3、hello world</p></blockquote><pre><code class="shell"># 初始化项目npm init -y# typescript配置文件tsc --init# 安装@type/node(解决模块声明问题)npm install @types/node --save-dev# 创建helloworld.ts文件touch helloworld.ts</code></pre><pre><code class="js">var a:String = &#39;hello world&#39;console.log(a)</code></pre><blockquote><p>4、将helloworld.ts转换成helloworld.js</p></blockquote><pre><code class="shell">tsc helloworld.ts  //将ts文件转换成js文件# 运行helloworld.jsnode helloworld.js  // 打印结果hello world</code></pre><h3 id="2、typescript函数的定义方式"><a href="#2、typescript函数的定义方式" class="headerlink" title="2、typescript函数的定义方式"></a>2、typescript函数的定义方式</h3><p>1、函数声明<br>    使用function和函数名来定义一个函数</p><pre><code class="ts">    function search(time:number) : string &#123;        return &#39;终于找到了丢失&#39; + time + &#39;天的dog--小七&#39;    &#125;    var time = 1    var result : string = search(time)    console.log(result)  // 终于找到了丢失一天的dog--小七</code></pre><p>2、函数表达式<br>    将函数赋值给一个变量，变量名就是函数名。通过变量名来调用函数</p><pre><code class="ts">    var Adc = function(n1:number,n2:number) : number &#123;        return n1++ + ++n2    &#125;    console.log(Adc(2,3))  // 6</code></pre><p>3、箭头函数<br>    typescript是支持ES6的。</p><pre><code class="ts">    var Jungle = (n1:number,n2:number) : number =&gt; &#123;        return n1 * n2    &#125;    console.log(Jungle(12,2) // 24</code></pre><pre><code>将ts文件转换为js文件：tsc function.ts  =&gt;  生成function.js  =&gt; 运行function.js,node function.js</code></pre><h3 id="3、typescript函数作用域"><a href="#3、typescript函数作用域" class="headerlink" title="3、typescript函数作用域"></a>3、typescript函数作用域</h3><blockquote><p>typescript也是有全局变量和局部变量的</p></blockquote><pre><code class="ts">    function star():void&#123;    var Jay = &#39;周杰伦&#39;        console.log(Jay)  // 周杰伦    &#125;    star()    console.log(star) // [Function:star]    var JayChou = &#39;周杰伦&#39;  // 此时JayChou是全局变量    function superstar():void&#123;    console.log(&#39;青花瓷是&#39; + JayChou + &#39;演唱的！&#39;) // 青花瓷是周杰伦演唱的！    &#125;    superstar()    console.log(JayChou) // 周杰伦</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119154050226-530021968.png"></p><h3 id="4、typescript数组"><a href="#4、typescript数组" class="headerlink" title="4、typescript数组"></a>4、typescript数组</h3><blockquote><p>ts中数据分为值类型和引用类型。</p></blockquote><p>1、什么是引用类型？</p><blockquote><p>引用类型是一种复合类型，引用类型中封装了很多属性，可以通过变量名和属性名来获取属性值或者调用属性的方法。</p></blockquote><pre><code class="ts">    let Jude = &#123;        name: &#39;Jude&#39;,        age: 28,        saySomething: function () &#123;            console.log(&#39;行到水穷处，坐看云起时！&#39;);        &#125;    &#125;    console.log(Jude.name) // Jude</code></pre><p>2、元祖– 一种特殊的数组</p><p>数组中允许含有多种类型的元素</p><pre><code class="ts">    let arr : [number,string]    arr = [123,&#39;123&#39;]    // console.log(arr) // [123,&#39;123]</code></pre><p>当我们写成这个样子，是会报错的</p><pre><code class="ts">    let arr : [number,sting]    arr = [&#39;123&#39;,123]</code></pre><pre><code>error1: Type &#39;string&#39; is not assignable to type &#39;number&#39;. error2: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119172755771-1404695424.png"></p><h3 id="5、typescript字符串"><a href="#5、typescript字符串" class="headerlink" title="5、typescript字符串"></a>5、typescript字符串</h3><p>1、Typescript中字符串的两种类型：</p><blockquote><p>基本类型字符串：由单引号或者双引号’包裹的’一串字符;</p></blockquote><blockquote><p>引用类型字符串：由new实例化的String类型。</p></blockquote><p>2、基本类型的字符串可以直接使用引用类型的属性和方法</p><pre><code class="ts">    let Jude: string = &#39;YQ&#39;    let JudeYQ: String = new String(&#39;JudeYQ&#39;)    console.log(Jude) // YQ    console.log(JudeYQ) // [String:&#39;JudeYQ&#39;]    // 基本类型的字符串可以直接使用引用类型的属性和方法    console.log(Jude.length) // 2    console.log(JudeYQ.length)  // 6</code></pre><p>3、字符串常用的方法</p><blockquote><p>字符串查找 indexOf()和lastIndexOf()，二者返回的都是字符串的下标。</p></blockquote><pre><code class="ts">    let word:string = &#39;西虹人瘦，燃烧我的卡路里&#39;    let Calorie: string = &#39;卡路里&#39;    console.log(word.indexOf(Calorie)) // 9    let ST:string = &#39;沈腾&#39;    console.log(word.indexOf(ST)) // -1 没有查找到返回-1    console.log(word.lastIndexOf(Calorie)) // 9 从字符串尾部开始查找字符串的位置 和indexOf（）返回的都是字符串下标</code></pre><blockquote><p>字符串的截取， substring()</p></blockquote><pre><code class="ts">    // 字符串的截取    console.log(word.substring(9)) // 卡路里    console.log(word.substring(9,12)) // 卡路里</code></pre><p>3、字符串的替换,replace()</p><pre><code class="ts">    console.log(word.replace(Calorie,&#39;腹肌&#39;))  // 西虹人瘦，燃烧我的腹肌</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组方法</title>
      <link href="/2021/05/02/array/"/>
      <url>/2021/05/02/array/</url>
      
        <content type="html"><![CDATA[<p>js 常用数组方法整理,包括常用的数组常用方法、高阶函数 forEach、filter、map。</p><span id="more"></span><h3 id="1、常用数组方法"><a href="#1、常用数组方法" class="headerlink" title="1、常用数组方法"></a>1、常用数组方法</h3><details><summary>点击展示代码</summary><pre><code class="js">// 1、删除数组的最后一项  pop()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop();console.log(fruits); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;var x = fruits.pop(); // Mango// 2、数组结尾添加一个新元素  push()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;); //&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;,&quot;Kiwi&quot;var x = fruits.push(&quot;Kiwi&quot;); // 5// 3、删除数组第一个元素    shift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 4、数组开头返回一个新元素   返回新数组长度   unshift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); //&quot;Lemon&quot; &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 5、删除元素 delete  会留下数组未定义的空洞  可以使用pop shift替代var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // empty,&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 6、拼接数组  splice()  第一个参数 2 定义了应添加新元素的位置   第二个参数 定义应删除多少元素  其余参数  定义要添加的新元素  返回一个包含已删除项的数组var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;, &quot;Apple&quot;, &quot;Mango&quot;fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;,// 7、删除元素 splice()  在数组中不留“空洞”的情况下移除元素var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); //&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 8、合并数组 concat()var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var myChildren = myGirls.concat(myBoys);// 9、裁剪数组 slice()   源数组不会删除任何元素   第一个参数  开始选取的元素  第二个参数  结束参数为止（不包含）var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1); // &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // &quot;Orange&quot;, &quot;Lemon&quot;   第2个元素 到 第4个元素  截取结果为第2个和第3个元素// 10、数组元素结合成字符串 join() 和 toString()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.join(&quot;,&quot;); // Banana,Orange,Apple,Mangofruits.toString(); // Banana,Orange,Apple,Mango</code></pre></details><h3 id="2、高阶函数"><a href="#2、高阶函数" class="headerlink" title="2、高阶函数"></a>2、高阶函数</h3><h4 id="1、forEach"><a href="#1、forEach" class="headerlink" title="1、forEach"></a>1、forEach</h4><blockquote><p>forEach()方法对数组的每个元素执行一次给定的函数。</p></blockquote><p>for example：</p><pre><code class="js">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];array.forEach((e) =&gt; &#123;  console.log(e); // &#39;a&#39; &#39;b&#39; &#39;c&#39;&#125;);</code></pre><p>语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</p><p>参数介绍：</p><pre><code>callback：为数组中的每个元素执行的函数，该函数接收1~3个参数currentValue：数组中正在处理的当前元素index: 数组中正在处理的当前元素的索引array: forEach()正在操作的数组   数组对象本身thisArg：可选参数。当执行回调函数callback时，用作this的值。</code></pre><p>常见用法：</p><h5 id="（1）稀疏数组"><a href="#（1）稀疏数组" class="headerlink" title="（1）稀疏数组"></a>（1）稀疏数组</h5><blockquote><p>不对未初始化的值进行任何操作</p></blockquote><pre><code class="js">const arratSpace = [1, 3, , 7];let numCallbackRuns = 0;arratSpace.forEach(function (e) &#123;  console.log(e);  numCallbackRuns++;&#125;);console.log(&quot;numCallbackRuns:&quot;, numCallbackRuns);</code></pre><h5 id="2-for-循环转换成-forEach"><a href="#2-for-循环转换成-forEach" class="headerlink" title="(2)for 循环转换成 forEach"></a>(2)for 循环转换成 forEach</h5><pre><code class="js">const items = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];const copy = [];//for循环for (let i = 0; i &lt; items.length; i++) &#123;  copey.push(items[i]);&#125;// forEachitems.forEach(function (itme) &#123;  copy.push(item);&#125;);</code></pre><h5 id="3-thisArg-使用箭头函数-thisArg-参数会被忽略，因为箭头函数绑定了-this-值"><a href="#3-thisArg-使用箭头函数-thisArg-参数会被忽略，因为箭头函数绑定了-this-值" class="headerlink" title="(3)thisArg 使用箭头函数 thisArg 参数会被忽略，因为箭头函数绑定了 this 值"></a>(3)thisArg 使用箭头函数 thisArg 参数会被忽略，因为箭头函数绑定了 this 值</h5><h5 id="4-对象复制器函数"><a href="#4-对象复制器函数" class="headerlink" title="(4)对象复制器函数"></a>(4)对象复制器函数</h5><pre><code class="js">function copy(obj) &#123;  const copy = Object.create(Object.getPrototypeOf(obj));  const propNames = Object.getOwnPropertyNames(obj);  propNames.forEach(function (name) &#123;    const desc = Object.getOwnPropertyDescriptor(obj, name);    Object.defineProperty(copy, name, desc);  &#125;);  return copy;&#125;const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = copy(obj1); // obj2看起来和obj1一模一样</code></pre><h5 id="5-数组在迭代时被修改了，则其他元素会被跳过"><a href="#5-数组在迭代时被修改了，则其他元素会被跳过" class="headerlink" title="(5)数组在迭代时被修改了，则其他元素会被跳过"></a>(5)数组在迭代时被修改了，则其他元素会被跳过</h5><pre><code class="js">var words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];words.forEach(function (word) &#123;  console.log(word);  if (word === &quot;two&quot;) &#123;    words.shift();  &#125;&#125;);</code></pre><h5 id="6-promise-或-async-函数的使用"><a href="#6-promise-或-async-函数的使用" class="headerlink" title="(6)promise 或 async 函数的使用"></a>(6)promise 或 async 函数的使用</h5><pre><code class="js">let ratings = [5, 4, 5];let sum = 0;let sumFunction = async function (a, b) &#123;  return a + b;&#125;;ratings.forEach(async function (rating) &#123;  sum = await sumFunction(sum, rating);&#125;);console.log(sum); // 0</code></pre><h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><blockquote><p>filter()创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回满足条件的新数组，不满足则返回空数组。</p></blockquote><p>for example</p><pre><code class="js">const words = [&quot;111&quot;, &quot;222&quot;, &quot;333333&quot;, &quot;4444444&quot;, &quot;55555555&quot;];const result = words.filter((word) =&gt; &#123;  word.length &gt; 5;&#125;);console.log(result); // 333333  4444444    55555555</code></pre><p>语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p><p>参数：<br>callback:用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。</p><pre><code>element:数组中当前正在处理的元素index:正在处理的元素在数组中的索引array:调用filter的数组本身thisArg:执行callback时，用于this的值</code></pre><p>返回值：</p><pre><code>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</code></pre><p>用法：</p><h4 id="（1-筛选排除所有较小的值"><a href="#（1-筛选排除所有较小的值" class="headerlink" title="（1)筛选排除所有较小的值"></a>（1)筛选排除所有较小的值</h4><pre><code class="js">function isBig(e) &#123;  return e &gt;= 10;&#125;var filterd = [3, 6, 9, 14, 32].filter(isBig);// [14,32]</code></pre><h4 id="2-过滤-JSON-中的无效条目"><a href="#2-过滤-JSON-中的无效条目" class="headerlink" title="(2)过滤 JSON 中的无效条目"></a>(2)过滤 JSON 中的无效条目</h4><pre><code class="js">var arr = [  &#123; id: 12 &#125;,  &#123; id: -1 &#125;,  &#123; id: 0 &#125;,  &#123; id: 3 &#125;,  &#123; id: 14.4 &#125;,  &#123;&#125;,  &#123; id: null &#125;,  &#123; id: NaN &#125;,  &#123; id: &quot;undefined&quot; &#125;,];var entries = 0;function isNumber(obj) &#123;  return obj !== undefined &amp;&amp; typeof obj === &quot;number&quot; &amp;&amp; !isNaN(obj);&#125;function filterID(item) &#123;  if (isNumber(item.id) &amp;&amp; item.id !== 0) &#123;    return true;  &#125;  entries++;  return false;&#125;var arrId = arr.filter(filterID);console.log(arrId); // [&#123;id:12&#125;,&#123;id:-1&#125;,&#123;id:3&#125;,&#123;id:14.4&#125;]console.log(entries); // 5</code></pre><h4 id="3-在数组中搜索：根据搜索条件来过滤数组内容"><a href="#3-在数组中搜索：根据搜索条件来过滤数组内容" class="headerlink" title="(3)在数组中搜索：根据搜索条件来过滤数组内容"></a>(3)在数组中搜索：根据搜索条件来过滤数组内容</h4><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]function filterItems(query)&#123;    return fruits.filter(function(e)&#123;        return e.toLowerCase().indexOf(query.toLowerCase()) &gt; -1    &#125;)&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><p>上面是 es5 的写法，下面是 es6 的写法</p><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]const filterItems = (query) =&gt;&#123;    return fruits.filter((e) =&gt;        e.toLowerCase().indexOf(query,toLowerCase()) &gt; -1    )&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><h3 id="3、map"><a href="#3、map" class="headerlink" title="3、map"></a>3、map</h3><blockquote><p>map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 原数组不会改变</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4];const maps = array.map((x) =&gt; x * 2);console.log(maps); // 2 4 6 8</code></pre><p>用法：</p><h4 id="1-格式化数组中的对象"><a href="#1-格式化数组中的对象" class="headerlink" title="(1)格式化数组中的对象"></a>(1)格式化数组中的对象</h4><pre><code class="js">var array = [  &#123; key: 1, value: 10 &#125;,  &#123; key: 2, value: 20 &#125;,  &#123; key: 3, value: 30 &#125;,];var formatterArray = array.map(function (obj) &#123;  var o = &#123;&#125;;  o[obj.key] = obj.value;  return o;&#125;);console.log(formatterArray); // [&#123;1:10&#125;,&#123;2:20&#125;,&#123;3:30&#125;]</code></pre><h4 id="2-使用包含一个参数的函数来构建一个数字数组"><a href="#2-使用包含一个参数的函数来构建一个数字数组" class="headerlink" title="(2)使用包含一个参数的函数来构建一个数字数组"></a>(2)使用包含一个参数的函数来构建一个数字数组</h4><pre><code class="js">var numbers = [1, 4, 9];var double = numbers.map(function (item) &#123;  return item * 2;&#125;);console.log(double); // [2,8,18]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerms、Node版本管理工具、nrm等的使用方法</title>
      <link href="/2021/05/02/tool/"/>
      <url>/2021/05/02/tool/</url>
      
        <content type="html"><![CDATA[<p>一些开发过程中需要使用的工具整理</p><span id="more"></span><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>快捷键</p><pre><code>    commond + t              // 新建标签页    commond + w              // 关闭标签    commond + enter          // 切换全屏(第一次切换至全屏，再commond + enter恢复到之前窗口)     commond + 左右方向键       // 切换标签    commond + +              // 窗口和字体变大    commond + -              // 窗口和字体变小</code></pre><h2 id="Node版本管理工具"><a href="#Node版本管理工具" class="headerlink" title="Node版本管理工具"></a>Node版本管理工具</h2><p>在开发的工程中，我们可能需要经常切换node版本来应对不同的开发环境，所以需要经常使用不同版本的node。</p><p>一、安装npm插件n ,通过n模块来管理node版本</p><p>1、全局安装n模块</p><pre><code>    npm instlal -g n </code></pre><p>2、安装当前稳定版本</p><pre><code>    n stable或者sudo n stable</code></pre><p>3、安装最新版本的</p><pre><code>    n latest或者sudo n latest</code></pre><p>4、安装指定版本的node</p><pre><code>    n v8.16.0</code></pre><p>5、卸载指定的node版本</p><pre><code>    n rm v8.16.0</code></pre><p>二、使用nvm管理node版本<br>1、安装nvm </p><pre><code>    brew install nvm</code></pre><p>2、使用nvm安装node版本</p><pre><code>    // 安装最新版本    nvm isntall node    // 安装指定版本    nvm install 8.16.0</code></pre><p>3、查看所有版本</p><pre><code>    nvm ls</code></pre><p>4、切换node版本</p><pre><code>    // 使用最新版本    nvm use node           // 使用指定版本    nvm use 8.16.0</code></pre><p>通常我会使用第二种方式<br>例如：</p><p>我在一个项目中使用的是<code>node@6.13.2</code>,</p><p>新项目使用的是<code>node@8.16.0</code>,</p><p>先要安装<code>node@8.16.0   nvm install 8.16.0</code></p><p>然后<code>nvm use 8.16.0</code></p><p>5、卸载指定版本的node</p><pre><code>    nvm uninstall  v6.13.2</code></pre><p>6、设置系统默认的node版本</p><pre><code>    nvm alias default v8.16.0</code></pre><p>这样使用的node的默认版本为8.16.0</p><h2 id="nrm切换npm源"><a href="#nrm切换npm源" class="headerlink" title="nrm切换npm源"></a>nrm切换npm源</h2><p>因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。</p><p>一、切换成淘宝源</p><p>1、config命令的使用</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><p>2、命令行指定</p><pre><code>npm i node --registry https://registry.npm.taobao.org info underscore </code></pre><p>3、编辑~/.npmrc，加入以下内容：</p><pre><code>registry = https://registry.npm.taobao.org</code></pre><p>二、nrm的使用</p><blockquote><p>nrm是一个可以切换、添加/删除/测试源的工具</p></blockquote><p>1、全局安装nrm</p><pre><code>npm install -g nrm  // mac如果出现权限问题，加上sudo</code></pre><p>2、安装完成，查看所有的可用源</p><pre><code>nrm ls</code></pre><p>3、添加源</p><pre><code>nrm add 源的名称  https:// 地址</code></pre><p>4、删除原</p><pre><code>nrm del 源的名字</code></pre><p>5、切换到某个源</p><pre><code>nrm use 源的名字</code></pre><p>6、测试源速度</p><pre><code>nrm test</code></pre><p>例如，我需要使用淘宝源，只需nrm use taobao就可以了，cnpm不要使用，容易出现莫名其妙的错误。</p><h2 id="前端常用的linux命令"><a href="#前端常用的linux命令" class="headerlink" title="前端常用的linux命令"></a>前端常用的linux命令</h2><p>常用的Linux命令</p><pre><code>1、vim test.html   创建新的文件    vim + 文件名.后缀2、ls     查看当前文件夹下的文件    ls -a  列出所有文件，包括隐藏文件    ls -1  每行列出一个文件，以单列形式列出3、cat test.html  将该文件内容打印显示出来   cat test1.html   cat test2.html   cat test1.html     test2.html&gt;test3.html   cat test3.html   将多个文件合并到目标文件中。   cat test1.html   cat test2.html   cat test1.html test2.html&gt;&gt;test4.html  将几个文件附加到目录文件中4、mv   移动或重命名文件和目录mv file1.txt file2.txt   将file1文件命名为file2用法： cat 1.txt mv 1.txt 2.txt mv file1.txt file2  将file1文本移动到file2目录  5、touch  file   命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。 touch newfile6、mkdir file    创建文件夹7、cd ../  返回当前文件夹的上一层 cd /    返回到根目录下8、rm -rf folder  删除文件夹</code></pre><h2 id="eslint的配置"><a href="#eslint的配置" class="headerlink" title="eslint的配置"></a>eslint的配置</h2><p>常用的配置</p><pre><code>module.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  &#39;extends&#39;: [    &#39;plugin:vue/essential&#39;,    &#39;@vue/standard&#39;  ],  rules: &#123;    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无console.log    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无debugger    &#39;indent&#39;: &#39;off&#39;,    // 函数定义时括号前面要不要有空格    &#39;space-before-function-paren&#39;: &#39;off&#39;  &#125;,  parserOptions: &#123;    parser: &#39;babel-eslint&#39;  &#125;&#125;</code></pre><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><p>一、初始化本地仓库，提交代码，提交到远程git仓库</p><p>1、初始化代码仓库</p><pre><code>    git init</code></pre><p>2、将当前目录下的所有文件放到暂存区</p><pre><code>    git add .</code></pre><p>3、查看文件状态</p><pre><code>    git status</code></pre><p>4、添加提交的描述信息</p><pre><code>    git commit -m &quot;提交的描述信息&quot;</code></pre><p>5、远程仓库地址</p><pre><code>    git remote add origin &quot;远程仓库地址&quot;</code></pre><p>6、推送到远程仓库</p><pre><code>    git push -u origin master</code></pre><p>二、创建分支，提交代码到分支</p><p>1、创建切换分支</p><pre><code>    git checkout -b dev  dev为分支名称    git add .    git commit -m &#39;描述&#39;    git push --set-upstream origin dev1   将分支推送到远程仓库    切换到主分支    git checkout master    git merge dev  将dev合并到主分支    git push origin master  推送到远程仓库</code></pre><p>三、克隆指定分支</p><pre><code>    git clone -b master git@gitee.com:username/projectname.git    git clone -b admin git@gitee.com:username/projectname.git</code></pre><p>四、git reflog</p><pre><code>查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。</code></pre><h2 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键"></a>vscode快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>commond + B</td><td>显示/隐藏侧边栏</td></tr><tr><td>commond + shift + p</td><td>显示命令窗口</td></tr><tr><td>commond +</td><td>创建多个编辑器</td></tr><tr><td>commond + 1、2</td><td>聚焦到第1、第2个编辑器</td></tr><tr><td>commond + J 或者 Ctrl + `</td><td>显示隐藏控制台</td></tr><tr><td>commond + W</td><td>关闭当前文件</td></tr><tr><td>option + 左右方向键</td><td>单词之间移动光标</td></tr><tr><td>commond + 左右方向键</td><td>移动光标至最前、最后</td></tr><tr><td>commond + shift + \</td><td>代码块之间移动光标</td></tr></tbody></table><blockquote><p>fileheader插件的使用</p></blockquote><pre><code>commond+shift+p -&gt; fileheader -&gt; enter/* * @Author: Jude  * @Date: 2020-07-24 16:39:41  * @Last Modified by: Jude * @Last Modified time: 2020-07-24 16:40:34 */</code></pre><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><h2 id="HBuilder真机调试"><a href="#HBuilder真机调试" class="headerlink" title="HBuilder真机调试"></a>HBuilder真机调试</h2><p>1、小米手机开发者模式如何打开（MIUI 11.0.4）</p><p>步骤：设置–我的设备–全部参数–（点击）MINI版本;</p><p>2、手机连接Mac：</p><p>Mac的关于本机–系统报告–USB–你所连接的device–厂商ID</p><p>3、打开Mac终端：</p><p>在终端执行如下命令：</p><pre><code class="shell">    echo xxxxxx &gt;&gt; ~/.android/adb_usb.ini （“xxxxxx”为厂商ID);</code></pre><p>4、重启HBuilderX;</p><p>这里如果出现了问题需要切换到HBuilderX自带的adb目录；</p><p>路径为：/Applications/HBuilderX-Alpha.app/Contents/HBuilderX/plugins/launcher/tools/adbs</p><p>在adbs目录下运行Terminal，输入：</p><pre><code class="shell">    ./adb kill-server</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决点击手机虚拟返回键退出应用</title>
      <link href="/2021/03/23/back/"/>
      <url>/2021/03/23/back/</url>
      
        <content type="html"><![CDATA[<p>如何解决安卓手机点击虚拟返回键退出当前应用。</p><span id="more"></span><p>一、问题描述：</p><p>最近的项目是使用Vue全家桶+HBuilder打包开发一个移动端APP。<br>在测试的时候发现，当安卓手机使用虚拟按钮的时候，点击虚拟按钮的返回键，APP会直接退出。<br>这是因为安卓手机自带back虚拟按键，如果不修改其默认事件，点一下app就退出了，<br>所以需要修改这个按键默认事件事件的代码。</p><p>二、解决办法：</p><p>在index.html中加入一个script，加上如下代码：</p><details><summary>点我展示代码</summary><pre><code class="javascript">&lt;script&gt;    document.addEventListener(&#39;plusready&#39;, function () &#123;        var first = null;        var webview = plus.webview.currentWebview();        plus.key.addEventListener(&#39;backbutton&#39;, function () &#123;            webview.canBack(function (e) &#123;                if (e.canBack) &#123;                    webview.back(); //这里不建议修改自己跳转的路径                  &#125; else &#123;                    //首次按键，提示‘再按一次退出应用’                      if (!first) &#123;                      first = new Date().getTime(); //获取第一次点击的时间戳                        plus.nativeUI.toast(&quot;再按一次退出应用&quot;, &#123;                        duration: &#39;short&#39;                      &#125;); //通过H5+ API 调用Android 上的toast 提示框                        setTimeout(function () &#123;                        first = null;                      &#125;, 1000);                    &#125; else &#123;                        // 获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次,                       if (new Date().getTime() - first &lt; 1000) &#123;                          plus.runtime.quit(); //退出应用                &#125;            &#125;          &#125;        &#125;)      &#125;);    &#125;);    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件化实践之插槽（二）</title>
      <link href="/2021/02/24/vue-component2/"/>
      <url>/2021/02/24/vue-component2/</url>
      
        <content type="html"><![CDATA[<p>插槽：插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用。</p><span id="more"></span><h3 id="一、匿名插槽"><a href="#一、匿名插槽" class="headerlink" title="一、匿名插槽"></a>一、匿名插槽</h3><pre><code class="js">// comp1&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;hello&lt;/comp&gt;</code></pre><h3 id="二、具名插槽"><a href="#二、具名插槽" class="headerlink" title="二、具名插槽"></a>二、具名插槽</h3><blockquote><p>内容分发到子组件指定位置</p></blockquote><pre><code class="js">// comp2&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;// 默认插槽用default做参数 具名插槽用插槽名做参数&lt;template v-slot:default&gt;具名插槽&lt;/tempalte&gt;&lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/comp&gt;</code></pre><h3 id="三、作用域插槽"><a href="#三、作用域插槽" class="headerlink" title="三、作用域插槽"></a>三、作用域插槽</h3><blockquote><p>分发内容要用到子组件中的数据</p></blockquote><pre><code class="js">&lt;div&gt;    &lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;// 把v-slot的值指定为作用域上下文对象&lt;tempalte v-slot:default=&quot;slotProps&quot;&gt;    来自子组件数据：&#123;&#123;slotProps.foo&#125;&#125;&lt;/tempalte&gt;&lt;/comp&gt;</code></pre><h3 id="四、实例代码"><a href="#四、实例代码" class="headerlink" title="四、实例代码"></a>四、实例代码</h3><p>子组件代码如下：</p><pre><code class="js">// 子组件 Layout.vue&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;header&quot;&gt;      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;body&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        remark: [          &#39;好好学习，天天向上&#39;,          &#39;学习永远不晚&#39;,          &#39;学习知识要善于思考,思考,再思考&#39;,          &#39;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#39;,          &#39;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#39;,          &#39;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#39;,          &#39;三人行必有我师焉；择其善者而从之，其不善者而改之&#39;        ]      &#125;    &#125;,    computed: &#123;      footerContent() &#123;        return this.remark[new Date().getDay() - 1]       &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;.header &#123;  background-color: rgb(252, 175, 175);&#125;.body &#123;  display: flex;  background-color: rgb(144, 250, 134);  min-height: 100px;  align-items: center;  justify-content: center;&#125;.footer &#123;  background-color: rgb(114, 116, 255);&#125;&lt;/style&gt;</code></pre><p>父组件代码如下：</p><pre><code class="js">//父组件 index.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;插槽&lt;/h2&gt;    &lt;!-- 插槽 --&gt;    &lt;Layout&gt;      &lt;!-- 具名插槽 --&gt;      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;      &lt;!-- 匿名插槽 --&gt;      &lt;template&gt;content...&lt;/template&gt;      &lt;!-- 作用域插槽 --&gt;      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;    &lt;/Layout&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Layout from &#39;@/components/slots/Layout.vue&#39;    export default &#123;    components: &#123;      Layout    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件化实践之组件通信（一）</title>
      <link href="/2021/02/20/vue-component/"/>
      <url>/2021/02/20/vue-component/</url>
      
        <content type="html"><![CDATA[<p>vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护性，便于多人协同开发。</p><span id="more"></span><h3 id="一、组件通信常用方式"><a href="#一、组件通信常用方式" class="headerlink" title="一、组件通信常用方式"></a>一、组件通信常用方式</h3><p>1、props</p><blockquote><p>父组件传给子组件</p></blockquote><p>父子组件交互，props和$emit</p><pre><code class="js">// childprops:&#123;msg:String&#125;// parent&lt;HelloWorld msg=&quot;hello vue&quot; /&gt;</code></pre><p>2、自定义事件</p><blockquote><p>子传父</p></blockquote><pre><code class="js">//childthis.$emit(&#39;add&#39;,good)// parent&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;</code></pre><p>3、eventBus事件总线</p><blockquote><p>任意两个组件之间的传值常用事件总线或者vuex</p></blockquote><p>4、$parent和$root</p><blockquote><p>兄弟组件之间通信可通过共同父辈搭桥，$parent或$root</p></blockquote><pre><code class="js">// brother1this.$parent.$on(&#39;foo&#39;,handle)// brother2this.$parent.$emit(&#39;foo&#39;)</code></pre><p>5、$children</p><blockquote><p>父组件可通过$children访问子组件实现父子通信</p></blockquote><pre><code class="js">// parentthis.$children[0].xx=&#39;xxx&#39;</code></pre><p>6、$attrs、$listeners</p><blockquote><p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v- bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p></blockquote><pre><code class="js">// child:未在props中声明foo&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;// parent&lt;HelloWorld foo=&quot;foo&quot;&gt;</code></pre><p>7、refs</p><blockquote><p>获取子节点引用</p></blockquote><pre><code class="js">// parent&lt;HelloWorld ref=&quot;wrap&quot;&gt;mounted()&#123;    this.$refs.wrap.xx = &quot;xxx&quot;&#125;</code></pre><p>8、provide/inject</p><blockquote><p>能够实现祖先和后代之间的传值</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于v-for的key值为什么不能是index？</title>
      <link href="/2021/02/14/v-for-index/"/>
      <url>/2021/02/14/v-for-index/</url>
      
        <content type="html"><![CDATA[<p>从实际的案例发现到在使用 v-for 时，将 key 值写成了 index，出现的问题。</p><span id="more"></span><h3 id="一、案例-bug-复现"><a href="#一、案例-bug-复现" class="headerlink" title="一、案例 bug 复现"></a>一、案例 bug 复现</h3><p>父组件代码：</p><pre><code class="js">// 父组件&lt;Child    v-for=&quot;(item,index) in list&quot;    :key=&quot;index&quot;    :count=&quot;item.count&quot;    :name=&quot;item.name&quot;    @delete=&quot;handleDelete(index)&quot;/&gt;// datalist:[    &#123;        count:1,        name:&quot;1&quot;    &#125;,    &#123;        count:2,        name:&quot;2&quot;    &#125;,       &#123;        count:3,        name:&quot;3&quot;    &#125;,]// methodhandelDelete(index)&#123;    this.list.splice(index,1)&#125;</code></pre><p>子组件代码：</p><pre><code class="js">// 子组件&lt;div&gt;&lt;span&gt;    &#123;&#123;name&#125;&#125;&lt;/span&gt;count：&#123;&#123; innerCount &#125;&#125;&lt;button @click=&quot;$emit(&#39;delete)&quot;&gt;&lt;/button&gt;delete&lt;/button&gt;&lt;/div&gt;// propsprops:&#123;    count:&#123;        type:Number,        default:0    &#125;,    name:&#123;        type:String,        default:&#39;&#39;    &#125;&#125;// datadata()&#123;    retrun&#123;        // 子组件下面的这行代码定义了自己的状态，无法使用index作为key值        innerCount:this.count    &#125;&#125;</code></pre><p>当删除的时候，看上去是成功了，其实存在问题。加上排序也是存在问题。</p><p>将v-for里面的key换成item后，是正常的。</p><p>Vue官网的描述：</p><blockquote><p>当Vue正在更新使用v-for渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p></blockquote><blockquote><p>这个默认的模式是高效的，但是只适用于不依赖子组件装填或临时DOM状态的列表渲染输出。</p></blockquote><h3 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h3><p>写列表渲染时，依赖子组件状态或者临时DOM状态的情况，如果存在删除、增加、排序这样的功能，不能将index作为key值。</p><p>这里还包括diff算法…(待添加)</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用hls.js处理m3u8格式的视频</title>
      <link href="/2021/01/08/hls/"/>
      <url>/2021/01/08/hls/</url>
      
        <content type="html"><![CDATA[<p>m3u8 文件是指 UTF-8 编码格式的 m3u 文件。m3u 文件是记录了一个索引纯文本文件,打开它时播放软件并不是播放它,而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。</p><span id="more"></span><blockquote><p>HLS 与 M3U8 HLS(全称:Http Live Streaming)是由 Apple 公司定义的用于实时流传输的协议</p></blockquote><p>公司项目中使用了视频监控功能，需要在系统内显示 m3u8 格式的视频。</p><p>1、安装 hls.js 插件或者使用 CDN 引入</p><pre><code class="js">npm install hls.js --save// 或者&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;</code></pre><p>2、业务代码如下：</p><pre><code class="html">&lt;video  ref=&quot;video&quot;  id=&quot;myVideo2&quot;  class=&quot;video-js vjs-default-skin vjs-big-play-centered&quot;  autoplay=&quot;autoplay&quot;  controls  style=&quot;width: 100%; height: 280px; margin-top: 5px&quot;&gt;&lt;/video&gt;</code></pre><pre><code class="js">import Hls from &quot;hls.js&quot;;export default &#123;  data() &#123;    return &#123;      hls: null,    &#125;;  &#125;,  methods: &#123;    getStream(source) &#123;      if (Hls.isSupported()) &#123;        this.hls = new Hls();        this.hls.loadSource(source);        this.hls.attachMedia(this.$refs.video);        this.hls.on(Hls.Events.MANIFEST_PARSED, () =&gt; &#123;          this.$refs.video.play();        &#125;);        this.hls.on(Hls.Events.ERROR, (event, data) =&gt; &#123;          this.$message(&quot;视频加载失败&quot;);        &#125;);      &#125;else&#123;        this.$message(&quot;格式不支持&quot;)      &#125;    &#125;,  &#125;,  // 从接口获取的视频资源应当写在mounted里面，否则容易出现进入视频页面的时候，视频加载不出来的现象  mounted() &#123;    this.$service.get(&quot;demo/test&quot;).then((res) =&gt; &#123;      this.getStream(res.data[1].hls);    &#125;);  &#125;,&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3：linear-gradient线性渐变和radial-gradient径向渐变的使用</title>
      <link href="/2020/08/12/css3-linear-gradient/"/>
      <url>/2020/08/12/css3-linear-gradient/</url>
      
        <content type="html"><![CDATA[<p>linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。</p><p>创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。</p><span id="more"></span><p>radial-gradient()径向渐变由它的中心定义。</p><p>为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p><h3 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h3><pre><code class="html">// html&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box&#123;     width:100px;    height:100px;    /* 线性渐变 */    /* 从上到下 由黄色变为红色变为蓝色 */    background:linear-gradient(yellow,red,blue);    /* 渐变轴为45度，从蓝色渐变到红色 */    background:linear-gradient(45deg, blue, red);    /* 从右下到左上、从蓝色渐变到红色 */    background:linear-gradient(to left top, blue, red);    /* 从下到上，从蓝色开始渐变、到高度40%位置是绿色渐变开始、最后以红色结束 */    background:linear-gradient(0deg, blue, green 40%, red); &#125;    /* 径向渐变 */    /* 中心红色 红色周围为黄色 周边为绿色  */    background-image: radial-gradient(red, yellow, green)</code></pre><h3 id="二、不同浏览器的支持"><a href="#二、不同浏览器的支持" class="headerlink" title="二、不同浏览器的支持"></a>二、不同浏览器的支持</h3><pre><code class="html">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;// css.box&#123;     &lt;!-- chrome --&gt;    background: -webkit-linear-gradient(to right, red, green);     &lt;!-- Opera --&gt;    background:-o-linear-gradient(to right,to right, red, green);     &lt;!-- Firefox --&gt;    background:-moz-linear-gradient (to right, to right, red, green);     background:linear-gradient(to right, to right, red, green); &#125;</code></pre><h3 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h3><pre><code class="css">/* linear-gradient 线性渐变 */background-image: linear-gradient(direction, color-stop1, color-stop2, ...);/* radial-gradient 径向渐变*/background-image: radial-gradient(shape size at position, start-color, ..., last-color);</code></pre><h3 id="四、实际应用"><a href="#四、实际应用" class="headerlink" title="四、实际应用"></a>四、实际应用</h3><p>如dashboard首页有四个盒子，每个盒子的背景渐变色是不同的，使用scss css预处理器的写法。</p><h4 id="1、mixin-scss"><a href="#1、mixin-scss" class="headerlink" title="1、mixin.scss"></a>1、mixin.scss</h4><pre><code class="css">/*  */@mixin cardBg($leftColor, $rightColor) &#123;  background: -webkit-linear-gradient(to right, $leftColor, $rightColor);  background: -o-linear-gradient(to right, $leftColor, $rightColor);  background: -moz-linear-gradient (to right, $leftColor, $rightColor);  background: linear-gradient(to right, $leftColor, $rightColor);&#125;</code></pre><h4 id="2、页面引入mixin-scss"><a href="#2、页面引入mixin-scss" class="headerlink" title="2、页面引入mixin.scss"></a>2、页面引入mixin.scss</h4><blockquote><p>下面的@include 是调用mixin的cardBg变量</p></blockquote><pre><code class="css">@import &#39;&#39;./mixin.scss.cardList-wrapper&#123;    box-sizing:border-box;    heitht:150px;    padding:15px 15px 0;    border-radius:6px;    cursor:pointer;    margin-bottom:25px;    box-shadow:3px 5px 15px rgba(40,40,40,0.36);    /* 第一个盒子 */    &amp;.card-item-one&#123;        @include cardBg(#5171fd,#c97afd);        &amp;:hover&#123;            box-shadow:0 5px 10px #c97afd;        &#125;    &#125;    /* 第二个盒子 */    &amp;.card-item-two &#123;      @include cardBg(#3dadf6, #737bfc);       &amp;:hover &#123;        box-shadow: 0 5px 10px #737bfc;      &#125;    &#125;    /* 第三个盒子 */    &amp;.card-item-three &#123;      @include cardBg(#ea677c, #ef9b5f);       &amp;:hover &#123;        box-shadow: 0 5px 10px #ef9b5f;      &#125;    &#125;    /* 第四个盒子 */    &amp;.card-item-four &#123;      @include cardBg(#42d79b, #a6e25f);       &amp;:hover &#123;        box-shadow: 0 5px 10px #a6e25f;      &#125;    &#125;    /* 四个盒子在hover时都会变大一些 */    &amp;:hover &#123;      transform: scale(1.03);      transition: all 0.1s ease-out;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图LBS云检索</title>
      <link href="/2020/04/29/bmap/"/>
      <url>/2020/04/29/bmap/</url>
      
        <content type="html"><![CDATA[<p>百度地图自定义叠加层</p><span id="more"></span><blockquote><p>LBS 云服务提供海量位置数据的实时存储功能，JavaScript API 支持将用户上传到 LBS 云里的位置数据实时渲染成图层</p></blockquote><p>1、安装 vue-baidu-map</p><pre><code class="bash">npm install vue-baidu-map</code></pre><p>2、具体业务代码如下:</p><pre><code class="html">&lt;baidu-map  id=&quot;container&quot;  :scroll-wheel-zoom=&quot;true&quot;  :zoom=&quot;zoom&quot;  center=&quot;上海&quot;  :ak=&quot;selfKey&quot;  inertial-dragging  @ready=&quot;mapReady&quot;&gt;&lt;/baidu-map&gt;&lt;div class=&quot;menu-search&quot;&gt;  &lt;el-input placeholder=&quot;请输入站点名称&quot; v-model=&quot;site_name&quot; clearable&gt;    &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot; @click=&quot;search&quot;&gt;&lt;/el-button&gt;  &lt;/el-input&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">&lt;script&gt;// 在组件中引入vue-baidu-mapimport BaiduMap from &quot;vue-baidu-map/components/map/Map.vue&quot;;export default&#123;    components:&#123;BaiduMap&#125;,    data()&#123;        return&#123;            site_name:&#39;&#39;,            center:&#123;lng:121.532325,lat:31.232742&#125;,            selfKey:&#39;QloR7bQpWed3VDLbtcxi2NmgUcvXxcbx&#39;,            point:&#39;&#39;,            zoom:15        &#125;    &#125;,    mounted()&#123;        this.mapReady()    &#125;,    methods:&#123;        mapReady()&#123;            var map = new BMap.Map(&quot;container&quot;)            map.centerAndZoom(new BMap.Point(this.center.lng,ths.center.lat),10)            map.enableScrollWheelZoom()                  /**       *params   q:检索关键字       *params   tags：空格分割的多字符       *params   filter:过滤条件       */            var customLayer;            customLayer = new BMap.CustomLayer(&#123;                geotableId: 183323,                q: &quot;&quot;,                tags: &quot;&quot;,                filter: &quot;&quot;,            &#125;);            map.addTileLayer(customLayer);            // 热点图层            customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);            function callback(e) &#123;                var customPoi = e.customPoi;                var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                     customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                var BMapLib = window.BMapLib;                var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                        title: customPoi.title,                        width: 200,                        height: 100,                        panel: &quot;panel&quot;,                        enableAutoPan: true,                        enableSendToPhone: false,                        searchTypes: [],                &#125;);                var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                searchInfoWindow.open(point);            &#125;        &#125;,          search() &#123;                var map = new BMap.Map(&quot;container&quot;);                map.centerAndZoom(new BMap.Point(this.center.lng, this.center.lat), 10);                map.enableScrollWheelZoom();                var customLayer;                customLayer = new BMap.CustomLayer(&#123;                    geotableId: 183323,                    q: this.site_name || &quot;新西北物流园&quot;,                    tags: &quot;&quot;,                    filter: &quot;&quot;,                &#125;);                // 添加自定义图层                map.addTileLayer(customLayer);                // var mapDom = document.getElementById(&quot;container&quot;)                // mapDom.addEventListener(&quot;click&quot;, function () &#123;                //   window.location.href = &quot;./monitor/index&quot;;                // &#125;);                // 热点图层                customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);                function callback(e) &#123;                    var customPoi = e.customPoi;                    var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                    customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                    var BMapLib = window.BMapLib;                    // console.log(&quot;BMapLib&quot;, BMapLib);                    var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                    title: customPoi.title,                    width: 200,                    height: 100,                    panel: &quot;panel&quot;,                    enableAutoPan: true,                    enableSendToPhone: false,                    searchTypes: [],                    &#125;);                    var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                    searchInfoWindow.open(point);                &#125;    &#125;,    &#125;&#125;&lt;/script&gt;&lt;/details&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图动画（轨迹动画）</title>
      <link href="/2020/04/29/bmap-animate/"/>
      <url>/2020/04/29/bmap-animate/</url>
      
        <content type="html"><![CDATA[<p>百度地图动画及轨迹动画</p><span id="more"></span><h3 id="一、百度地图动画"><a href="#一、百度地图动画" class="headerlink" title="一、百度地图动画"></a>一、百度地图动画</h3><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.414, 39.915), 20); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放bmap.setTilt(20); // 设置地图初始倾斜角度var keyFrames = [  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: 0,    percentage: 0,  &#125;,  &#123;    center: new BMapGL.Point(116.307631, 40.055391),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.1,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.25,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.35,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.45,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.55,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.75,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -270,    percentage: 0.85,  &#125;,  &#123;    center: new BMapGL.Point(116.307779, 40.055754),    zoom: 21,    tilt: 70,    heading: -360,    percentage: 0.95,  &#125;,  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: -360,    percentage: 1,  &#125;,];var opts = &#123;  duration: 10000, // 设置每次迭代动画持续时间  delay: 3000, // 设置动画延迟开始时间  interation: &quot;INFINITE&quot;, // 设置动画迭代次数&#125;;var animation = new BMapGL.ViewAnimation(keyFrames, opts); // 初始化动画实例animation.addEventListener(&quot;animationstart&quot;, function (e) &#123;  // 监听动画开始事件  console.log(&quot;start&quot;);&#125;);animation.addEventListener(&quot;animationiterations&quot;, function (e) &#123;  // 监听动画迭代事件  console.log(&quot;onanimationiterations&quot;);&#125;);animation.addEventListener(&quot;animationend&quot;, function (e) &#123;  // 监听动画结束事件  console.log(&quot;end&quot;);&#125;);animation.addEventListener(&quot;animationcancel&quot;, function (e) &#123;  // 监听动画中途被终止事件  console.log(&quot;cancel&quot;);&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.startViewAnimation(animation); // 开始播放动画&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.cancelViewAnimation(animation); // 强制停止动画&#125;);</code></pre></details><h3 id="二、百度地图轨迹动画"><a href="#二、百度地图轨迹动画" class="headerlink" title="二、百度地图轨迹动画"></a>二、百度地图轨迹动画</h3><pre><code class="js">&lt;scrip  type=&quot;text/javascript&quot;  src=&quot;https://api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js&quot;&gt;&lt;/scrip&gt;</code></pre><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放var path = [  &#123;    lng: 116.297611,    lat: 40.047363,  &#125;,  &#123;    lng: 116.302839,    lat: 40.048219,  &#125;,  &#123;    lng: 116.308301,    lat: 40.050566,  &#125;,  &#123;    lng: 116.305732,    lat: 40.054957,  &#125;,  &#123;    lng: 116.304754,    lat: 40.057953,  &#125;,  &#123;    lng: 116.306487,    lat: 40.058312,  &#125;,  &#123;    lng: 116.307223,    lat: 40.056379,  &#125;,];var point = [];for (var i = 0; i &lt; path.length; i++) &#123;  point.push(new BMapGL.Point(path[i].lng, path[i].lat));&#125;var pl = new BMapGL.Polyline(point);var trackAni = new BMapGLLib.TrackAnimation(bmap, pl, &#123;  overallView: true, // 动画完成后自动调整视野到总览  tilt: 30, // 轨迹播放的角度，默认为55  duration: 20000, // 动画持续时长，默认为10000，单位ms  delay: 3000, // 动画开始的延迟，默认0，单位ms&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.start();&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.cancel(); // 强制停止动画&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-charts的options</title>
      <link href="/2020/04/28/v-charts/"/>
      <url>/2020/04/28/v-charts/</url>
      
        <content type="html"><![CDATA[<p>v-charts 的 options 使用 getOptions()而不是使用一个变量</p><span id="more"></span><blockquote><p>使用 getOptions()是为了获取数据之后才进行渲染数据，v-chart 的 options 可以直接绑定一个变量,在请求数据的时候，更新变量，图表需要进行重新渲染</p></blockquote><p>这里的 getOptions()也可以写在 computed 里面的。</p><pre><code class="html">&lt;template&gt;    &lt;v-charts :options=&quot;getOptions()&quot;&gt;&lt;/template&gt;</code></pre><details><summary>点我展示js代码</summary><pre><code class="js"> getOptions() &#123;        return &#123;          grid: &#123;            left: 0,            right: 0,            top: 0,            bottom: 0          &#125;,          xAxis: &#123;            type: &#39;value&#39;,            show: false          &#125;,          yAxis: &#123;            type: &#39;category&#39;,            show: false          &#125;,          series: [&#123;            name: &#39;上月平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            barWidth: 10,            itemStyle: &#123;              color: &#39;#45c946&#39;            &#125;          &#125;, &#123;            name: &#39;今日平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userTodayNumber],            itemStyle: &#123;              color: &#39;#eee&#39;            &#125;          &#125;, &#123;            type: &#39;custom&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            renderItem: (params, api) =&gt; &#123;              const value = api.value(0)              const endPoint = api.coord([value, 0])              return &#123;                type: &#39;group&#39;,                position: endPoint,                children: [&#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,                    x: -5,                    y: -20,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;, &#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,                    x: -5,                    y: 10,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;]              &#125;            &#125;          &#125;]        &#125;      &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> v-charts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间格式化</title>
      <link href="/2020/04/28/time/"/>
      <url>/2020/04/28/time/</url>
      
        <content type="html"><![CDATA[<p>获取时间格式的方式、封装的一些函数方法（待添加）</p><span id="more"></span><p>常用时间格式</p><pre><code class="js">    // 2021/3/10    let time = new Date().toLocaleDateString();    // 上午10:30:00    let times = new Date().toLocaleTimeString();    // 获取当前年份    2021年    let year = new Date().getFullYear();    // 获取当前月份  月份需要+1   3月份    let month = new Date().getMonth()+1;    // 获取当前月份日期   10号    let day = new Date().getDate();    // 获取当前星期几   三    let week = new Date().getDay();    // 获取当前季度   一季度    let season =  Math.floor((this.getMonth()+3)/3);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的封装</title>
      <link href="/2020/04/23/axios/"/>
      <url>/2020/04/23/axios/</url>
      
        <content type="html"><![CDATA[<blockquote><p>axios 基于promise的http库  特性：拦截请求和响应、取消请求、转换json、客户端防御XSRF</p></blockquote><span id="more"></span><p>当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。</p><p>所以记住：</p><blockquote><p>在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。</p></blockquote><pre><code class="js">service.interceptors.response.use(  (response) =&gt; &#123;    if (response.status === 200 &amp;&amp; response.data) &#123;      return response.data;    &#125; else &#123;      return Promise.reject(new Error(&quot;请求失败&quot;));    &#125;  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);</code></pre><h3 id="1、axios的安装"><a href="#1、axios的安装" class="headerlink" title="1、axios的安装"></a>1、axios的安装</h3><pre><code class="js">npm install axios</code></pre><h3 id="2、在request文件夹http-js"><a href="#2、在request文件夹http-js" class="headerlink" title="2、在request文件夹http.js"></a>2、在request文件夹http.js</h3><pre><code class="js">// http.jsimport axios from &quot;axios&quot;import QS from &quot;qs&quot;   // 序列化post类型的数据import &#123; Toast &#125; from &quot;vant&quot;  // 引入vant组件库的toast组件</code></pre><h3 id="3、环境的切换-请求超时-post请求头设置"><a href="#3、环境的切换-请求超时-post请求头设置" class="headerlink" title="3、环境的切换/请求超时/post请求头设置"></a>3、环境的切换/请求超时/post请求头设置</h3><pre><code class="js">// 环境的切换if (process.env.NODE_ENV == &#39;development&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.baidu.com&#39;;&#125; else if (process.env.NODE_ENV == &#39;debug&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.ceshi.com&#39;;&#125; else if (process.env.NODE_ENV == &#39;production&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.production.com&#39;;&#125;axios.defaults.timeout = 10000;axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;;</code></pre><h3 id="4、请求拦截-响应拦截"><a href="#4、请求拦截-响应拦截" class="headerlink" title="4、请求拦截 响应拦截"></a>4、请求拦截 响应拦截</h3><details><summary>点击展示代码</summary><pre><code class="js">// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from &#39;@/store/index&#39;;// 请求拦截器axios.interceptors.request.use(        config =&gt; &#123;                // 每次发送请求之前判断vuex中是否存在token                // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断         const token = store.state.token;                token &amp;&amp; (config.headers.Authorization = token);                return config;        &#125;,        error =&gt; &#123;                return Promise.error(error);        &#125;)// 响应拦截器axios.interceptors.response.use(        response =&gt; &#123;           // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据             // 否则的话抛出错误        if (response.status === 200) &#123;                        return Promise.resolve(response);                &#125; else &#123;                        return Promise.reject(response);                &#125;        &#125;,        // 服务器状态码不是2开头的的情况    // 这里可以跟你们的后台开发人员协商好统一的错误状态码        // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等    // 下面列举几个常见的操作，其他需求可自行扩展    error =&gt; &#123;                    if (error.response.status) &#123;                        switch (error.response.status) &#123;                                // 401: 未登录                // 未登录则跳转登录页面，并携带当前页面的路径                // 在登录成功后返回当前页面，这一步需要在登录页操作。                                case 401:                                        router.replace(&#123;                                                path: &#39;/login&#39;,                                                query: &#123;                             redirect: router.currentRoute.fullPath                         &#125;                    &#125;);                    break;                // 403 token过期                // 登录过期对用户进行提示                // 清除本地token和清空vuex中token对象                // 跳转登录页面                                case 403:                     Toast(&#123;                        message: &#39;登录过期，请重新登录&#39;,                        duration: 1000,                        forbidClick: true                    &#125;);                    // 清除token                    localStorage.removeItem(&#39;token&#39;);                    store.commit(&#39;loginSuccess&#39;, null);                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面                     setTimeout(() =&gt; &#123;                                                router.replace(&#123;                                                        path: &#39;/login&#39;,                                                        query: &#123;                                 redirect: router.currentRoute.fullPath                             &#125;                                                &#125;);                                        &#125;, 1000);                                        break;                 // 404请求不存在                case 404:                    Toast(&#123;                        message: &#39;网络请求不存在&#39;,                        duration: 1500,                        forbidClick: true                    &#125;);                    break;                // 其他错误，直接抛出错误提示                default:                    Toast(&#123;                        message: error.response.data.message,                        duration: 1500,                        forbidClick: true                    &#125;);            &#125;            return Promise.reject(error.response);        &#125;    &#125;    &#125;);</code></pre></details><h3 id="5、get、post请求的封装"><a href="#5、get、post请求的封装" class="headerlink" title="5、get、post请求的封装"></a>5、get、post请求的封装</h3><blockquote><p>get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123;        return new Promise((resolve, reject) =&gt;&#123;                axios.get(url, &#123;                        params: params                &#125;).then(res =&gt; &#123;            resolve(res.data);        &#125;).catch(err =&gt;&#123;            reject(err.data)            &#125;)    &#125;);&#125;</code></pre></details><blockquote><p>原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/**  * post方法，对应post请求  * @param &#123;String&#125; url [请求的url地址]  * @param &#123;Object&#125; params [请求时携带的参数]  */export function post(url, params) &#123;    return new Promise((resolve, reject) =&gt; &#123;         axios.post(url, QS.stringify(params))        .then(res =&gt; &#123;            resolve(res.data);        &#125;)        .catch(err =&gt;&#123;            reject(err.data)        &#125;)    &#125;);&#125;</code></pre></details><h3 id="6、axios完整封装代码"><a href="#6、axios完整封装代码" class="headerlink" title="6、axios完整封装代码:"></a>6、axios完整封装代码:</h3><details><summary>点击展示代码</summary><pre><code class="js">/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &#39;axios&#39;;import router from &#39;../router&#39;;import store from &#39;../store/index&#39;;import &#123; Toast &#125; from &#39;vant&#39;;/**  * 提示函数  * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; &#123;        Toast(&#123;                message: msg,                duration: 1000,                forbidClick: true        &#125;);&#125;/**  * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123;    router.replace(&#123;        path: &#39;/login&#39;,                query: &#123;            redirect: router.currentRoute.fullPath        &#125;    &#125;);&#125;/**  * 请求失败后的错误统一处理  * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123;    // 状态码判断    switch (status) &#123;        // 401: 未登录状态，跳转登录页        case 401:            toLogin();            break;        // 403 token过期        // 清除token并跳转登录页        case 403:            tip(&#39;登录过期，请重新登录&#39;);            localStorage.removeItem(&#39;token&#39;);            store.commit(&#39;loginSuccess&#39;, null);            setTimeout(() =&gt; &#123;                toLogin();            &#125;, 1000);            break;        // 404请求不存在        case 404:            tip(&#39;请求的资源不存在&#39;);             break;        default:            console.log(other);           &#125;&#125;// 创建axios实例var instance = axios.create(&#123;    timeout: 1000 * 12&#125;);// 设置post请求头instance.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;/**  * 请求拦截器  * 每次请求前，如果存在token则在请求头中携带token  */ instance.interceptors.request.use(        config =&gt; &#123;                // 登录流程控制中，根据本地是否存在token判断用户的登录情况                // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token                // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码                // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。                const token = store.state.token;                token &amp;&amp; (config.headers.Authorization = token);                return config;        &#125;,        error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use(        // 请求成功    res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res),        // 请求失败    error =&gt; &#123;        const &#123; response &#125; = error;        if (response) &#123;            // 请求已发出，但是不在2xx的范围             errorHandle(response.status, response.data.message);            return Promise.reject(response);        &#125; else &#123;            // 处理断网的情况            // eg:请求超时或断网时，更新state的network状态            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明            if (!window.navigator.onLine) &#123;               store.commit(&#39;changeNetwork&#39;, false);            &#125; else &#123;                return Promise.reject(error);            &#125;        &#125;    &#125;);export default instance;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于echarts官方的一个bug -- sublink跳转问题</title>
      <link href="/2020/04/20/echarts/"/>
      <url>/2020/04/20/echarts/</url>
      
        <content type="html"><![CDATA[<p>echarts 官方的一个 bug – sublink 跳转的问题。echarts版本号为4.8.0</p><span id="more"></span><p>开发百度地图 scatter 散点图时，副标题链接跳转出错（版本号为 4.8.0），在 GitHub 找到<a href="https://github.com/apache/incubator-echarts/issues/12841">issues</a>。<br>bug 介绍，点击副标题无法跳转到指定连接</p><pre><code class="js">this.options = &#123;  title: &#123;    text: &quot;我是主标题&quot;,    subtext: &quot;我是副标题，我可以跳转&quot;,    sublink: &quot;https://www.baidu.com&quot;,    left: &quot;center&quot;,  &#125;,&#125;;</code></pre><p>1、在 main.js 引入 echarts 和 vue-echarts，将 echarts 绑定到 Vue 原型，引入 vue-echarts 通过 vue.component()进行组件注册</p><blockquote><p>将 echarts 绑定到 Vue 原型上，可以减少代码量，开发过程中需要使用 echarts 里面提供的方法，如果没有全局引入的话，需要在每个使用 echarts 的页面都需要手动引入。将 vue-echarts 使用组件注册后，提供了属性绑定的方式渲染图表就不需要通过调用 echart 的方法了。</p></blockquote><h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><p>1、echarts 的绘图流程</p><pre><code class="js">// 1、引入echarts js库&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 2、DOM容器 设置宽高（注意）  --&gt;&lt;div id=&quot;charts&quot; style=&quot;width:800px;height:600px&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="js">// 3、获取渲染DOM对象const chartDom = document.getElementById(&quot;charts&quot;);// 4、初始化echarts对象const chart = echarts.init(chartDom);// 5、配置option参数  调用setOption完成渲染chart.setOption(&#123;  title: &#123;    text: &quot;Echarts 示例&quot;,  &#125;,  xAxis: &#123;    data: [&quot;食品&quot;, &quot;数码&quot;, &quot;服饰&quot;, &quot;箱包&quot;],  &#125;,  yAxis: &#123;&#125;,  // 系列： 包括图表的类型 包括：line bar pie等  series: &#123;    type: &quot;bar&quot;,    data: [&quot;100&quot;, &quot;120&quot;, &quot;40&quot;, &quot;160&quot;],  &#125;,&#125;);</code></pre><p>2、dataset: 数据集</p><blockquote><p>ECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">const chartDom = document.getElementById(&quot;chart&quot;);const chart = echarts.init(chartDom);const option = &#123;  xAxis: &#123;    type: &quot;category&quot;,  &#125;,  yAxis: &#123;&#125;,  dataset: &#123;    source: [      [&quot;1季度&quot;, 80, 100, &quot;分类1&quot;, 50],      [&quot;2季度&quot;, 81, 122, &quot;分类1&quot;, 60],      [&quot;3季度&quot;, 76, 90, &quot;分类1&quot;, 55],      [&quot;4季度&quot;, 65, 123, &quot;分类1&quot;, 70],    ],  &#125;,  // 系列  series: [    // 系列 0    &#123;      type: &quot;pie&quot;,      center: [&quot;65%&quot;, 60],      radius: 35,      encode: &#123;        itemName: 3,        value: 4,      &#125;,    &#125;,    // 系列 1    &#123;      type: &quot;line&quot;,      encode: &#123;        x: 0,        y: 2,      &#125;,    &#125;,    // 系列 2    &#123;      type: &quot;bar&quot;,      encode: &#123;        x: 0,        y: 1,      &#125;,    &#125;,  ],&#125;;chart.setOption(option);</code></pre></details><p>3、基本组件</p><blockquote><p>echarts 基本组件：title、坐标系的 X（xAxis）轴 Y(yAxis）轴、tooltip 提示框、toolbox 工具栏等</p></blockquote><p>4、定位</p><pre><code class="js">// 大多数组件都提供了定位属性，我们可以采用类似 CSS absolute 的定位属性来控制组件的位置 left right height bottom的值可以是数值或者百分比var option = &#123;  grid: &#123;    left: 120,    right: &quot;30%&quot;,    height: &quot;40%&quot;,    bottom: 100,  &#125;,&#125;;</code></pre><h2 id="echarts-常用属性"><a href="#echarts-常用属性" class="headerlink" title="echarts 常用属性"></a>echarts 常用属性</h2><p>（1）使用 ECharts 绘图后没有图像（这个问题会经常出现，一定要设置宽度高度！！！）</p><blockquote><p>ECharts 绘图后没有任何报错，但是没有图像。可以检查容器是否设置了宽高。因为 ECharts 不会设置默认宽高，如果容器没有设置宽高，则不会展示;如果使用的是 v-chart 则没有这个问题，因为 v-chart 默认了 600*400 的宽高。</p></blockquote><p>（2）使用 element-ui 的按需引入</p><blockquote><p>安装<code>vue add element</code>，后续会提示是全部引入或者按需引入，选择按需引入，在 App.vue 中会增加一些 element-ui 的示例代码，后续删除。项目目录会增加一个 plugin 文件夹</p></blockquote><blockquote><p>注意：按需引入组件后，再删除 App.vue 以及 view 文件夹内、component 文件夹内的不需要的内容。</p></blockquote><pre><code class="js">// main.jsimport &quot;./plugins/element.js&quot;;</code></pre><pre><code class="js">// element.jsimport Vue from &quot;vue&quot;;import &#123; Card, Col, Row &#125; from &quot;element-ui&quot;;Vue.use(Card);Vue.use(Col);Vue.use(Row);</code></pre><p>（3）vue 使用 echarts</p><pre><code class="js">// main.js 引入echarts 挂载到Vue实例import ECharts from &quot;echarts&quot;;Vue.prototype.$echarts = ECharts;</code></pre><p>（4）echarts 的常用属性</p><blockquote><p>1、隐藏线条 - listStyle</p></blockquote><pre><code class="js">listStyle: &#123;  width: 0;&#125;</code></pre><blockquote><p>2、隐藏数据点 - itemStyle</p></blockquote><pre><code class="js">itemStyle: &#123;  opacity: 0;&#125;</code></pre><blockquote><p>3、折线图填充面积区域颜色 - areaStyle</p></blockquote><pre><code class="js">areaStyle: &#123;  color: &quot;purple&quot;;&#125;</code></pre><blockquote><p>4、折线图平滑显示 - smooth</p></blockquote><pre><code class="js">smooth: true;</code></pre><blockquote><p>5、柱状图聚合 - stack</p></blockquote><pre><code class="js">series: [  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [100],  &#125;,  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [250],  &#125;,];</code></pre><blockquote><p>6、自定义绘图(重点)</p></blockquote><pre><code class="js">&#123;  type: &#39;custom&#39;,  stack: &#39;总量&#39;,  data: [100],  renderItem: (params, api) =&gt; &#123;    //  console.log(params,api);    const value = api.value(0)    const endPoint = api.coord([value, 0])    return &#123;      type: &#39;group&#39;,      position: endPoint,      children: [&#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,// 这里是svg里面的d          x: -5,          y: -20,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;, &#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,          x: -5,          y: 10,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;]    &#125;  &#125;&#125;</code></pre><blockquote><p>7、xAxis x 轴</p></blockquote><pre><code class="js">// 消除x轴两侧边距boundaryGap: false// 柱状图宽度barWidth: &#39;60%&#39;barWidth: 10// 条形图 type设置方法xAxis: &#123;  type: &#39;value&#39;&#125;,yAxis: &#123;  type: &#39;category&#39;&#125;</code></pre><blockquote><p>8、echarts 类目轴和非类目轴</p></blockquote><blockquote><p>类目轴的意思就是坐标轴上的展示信息是否是数据连贯，非类目轴就是除了标签类型为类目的其他坐标轴，有 时间（time），数值（value），对数（log）3 种。标签类型为类目是指 type:category</p></blockquote><p>坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样。类目轴中  boundaryGap  可以配置为  true  和  false。默认为  true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap 是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置  min  和  max  后无效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用canvas压缩图片？</title>
      <link href="/2020/04/10/canvas/"/>
      <url>/2020/04/10/canvas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>canvas 是 HTML5 的新特性，它允许我们使用 canvas 元素在网页上通过 JavaScript 绘制图像 （可以在 HTML 页面使用多个 canvas 元素）</p></blockquote><span id="more"></span><p><strong>1、绘图流程:</strong></p><pre><code class="js">// 1、编写canvas标签，指定宽高（注意）；&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;// 2、获取canvas DOM对象；const canvas = document.getElementById(&quot;canvas&quot;);// 3、获取Canvas对象；const ctx = canvas.getContext(&quot;2d&quot;); // 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法// 4、设置绘图属性；ctx.fillStyle = &quot;red&quot;; //设置填充色// 5、调用绘图API。ctx.fillRect(0, 0, 50, 50); // 绘制矩形</code></pre><p><strong>2、canvas 路径</strong></p><p>常用的方法：</p><p>（1）moveTo(x,y)–定义线条开始坐标</p><p>（2）lineTo(x,y)–定义线条结束坐标</p><p>示例 1、绘制线段</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath(); // 开始绘制路径ctx.lineWidth = 1; // 线条宽度ctx.strokeStyle = &quot;green&quot;; // 线条填充色ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); // 绘制线段</code></pre><p>示例 2、绘制圆形</p><p>arc(x,y,r,start,stop) x 轴 y 轴 r 半径</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath();ctx.lineWidth = 2;ctx.strokeStyle = &quot;green&quot;; // 圆形边框色ctx.fillStyle = &quot;red&quot;; // 圆形填充色ctx.arc(95, 50, 40, 0, 2 * Math.PI);ctx.stroke();</code></pre><p>示例 3、绘制矩形 （代码见绘图流程）</p><p><strong>3、使用 canvas 压缩图片</strong></p><pre><code class="html">&lt;!--编写input标签 指定type类型为file--&gt;&lt;input type=&quot;file&quot; id=&quot;upload&quot; /&gt;</code></pre><details><summary>压缩图片js代码(点击展开)</summary><pre><code class="js">// 设置上传图片类型  上传图片的容量大小const ACCEPT = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;]; // 限定图片文件类型const MAXSIZE = 1024 * 1024 * 3; // 限定图片最大容量const MAXSIZE_STR = &quot;3MB&quot;;function convertImageToBase64(file, cb) &#123;  let reader = new FileReader();  reader.addEventListener(&quot;load&quot;, function (e) &#123;    const base64Image = e.target.result; // 获取文件内容，等同于 reader.result    cb(base64Image);    reader = null;  &#125;);  reader.readAsDataURL(file); // 读取 file 对象中的内容&#125;// 图片是否压缩的判断function compress(base64Image, cb) &#123;  let maxW = 1024;  let maxH = 1024;  const image = new Image();  image.addEventListener(&quot;load&quot;, function () &#123;    let ratio; // 压缩比    let needCompress = false; // 是否需要压缩    if (maxW &lt; image.naturalWidth) &#123;      needCompress = true;      ratio = image.naturalWidth / maxW;      maxH = image.naturalHeight / ratio;    &#125;    if (maxH &lt; image.naturalHeight) &#123;      needCompress = true;      ratio = image.naturalHeight / maxH;      maxW = image.naturalWidth / ratio;    &#125;    if (!needCompress) &#123;      maxW = image.naturalWidth;      maxH = image.naturalHeight;    &#125;    const canvas = document.createElement(&quot;canvas&quot;);    canvas.setAttribute(&quot;id&quot;, &quot;__compress__&quot;);    canvas.width = maxW;    canvas.height = maxH;    canvas.style.visibility = &quot;hidden&quot;;    document.body.append(canvas);    // canvas画布    const ctx = canvas.getContext(&quot;2d&quot;);    ctx.clearRect(0, 0, maxW, maxH);    ctx.drawImage(image, 0, 0, maxW, maxH); // 渲染图片    const compressImage = canvas.toDataURL(&quot;image/jpeg&quot;, 0.9); // 压缩图片    cb(compressImage);    const _image = new Image();    _image.src = compressImage;    document.body.appendChild(_image);    canvas.remove(); // 移除 canvas  &#125;);  image.src = base64Image; // 将图片设置到 image 的 src 属性中  document.body.appendChild(image);&#125;// 上传给服务端function uploadImage(compressImage) &#123;  console.log(&quot;upload image to server...&quot;, compressImage);&#125;const upload = document.getElementById(&quot;upload&quot;);upload.addEventListener(&quot;change&quot;, function (e) &#123;  const file = e.target.files[0];  console.log(file);  if (!file) &#123;    return;  &#125;  const &#123; type: fileType, size: fileSize &#125; = file;  // 图片类型检查  if (!ACCEPT.includes(fileType)) &#123;    alert(&quot;不支持上传该格式文件！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 图片大小检查  if (fileSize &gt; MAXSIZE) &#123;    alert(&quot;文件超出&quot; + MAXSIZE_STR + &quot;！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 压缩文件  convertImageToBase64(file, (base64Image) =&gt;    compress(base64Image, uploadImage)  );&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端300ms延迟在IOS11中的bug</title>
      <link href="/2020/02/20/mobile/"/>
      <url>/2020/02/20/mobile/</url>
      
        <content type="html"><![CDATA[<p>在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click</p><span id="more"></span><h2 id="移动端300ms延迟在IOS11中的bug"><a href="#移动端300ms延迟在IOS11中的bug" class="headerlink" title="移动端300ms延迟在IOS11中的bug"></a>移动端300ms延迟在IOS11中的bug</h2><blockquote><p>解决方案</p></blockquote><p>1、禁用缩放 更改默认视口宽度</p><pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1&quot;&gt;</code></pre><p>2、fastclick解决300ms延迟问题<br>        首先，需要安装fastclick插件</p><pre><code class="js">npm install fastclick</code></pre><p>3、在main.js文件中引入fastclick，绑定到body上</p><pre><code class="js">import FastClick from &quot;fastclick&quot;FastClick.attach(document.body);</code></pre><p>这就是常用来解决移动端300ms延迟的方法。但是这种方法在iOS11的系统中存在bug。</p><p>4、iOS11系统中出现的bug<br>    在iOS11系统下，点击input输入框的时候会出现不灵敏的现象。</p><blockquote><p>解决方案:</p></blockquote><details><summary>点我展示代码</summary><pre><code class="js">&lt;script&gt;FastClick.prototype.focus = function (targetElement) &#123;  var length;  var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;  var deviceIsIos = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;  //兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError  //这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法  if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#39;date&#39;) !== 0 &amp;&amp; targetElement.type !== &#39;time&#39; &amp;&amp; targetElement.type !== &#39;month&#39;) &#123;    length = targetElement.value.length;    // 修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘    targetElement.setSelectionRange(length, length);  &#125; else &#123;    targetElement.focus();  &#125;&#125;&lt;/script&gt;</code></pre></details><blockquote><p>注意：<br>setSelectionRange是HTMLInputElement的一个方法,用来设定input textare的当前文本的起始位置和结束位置。<br>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement/setSelectionRange">MDN文档</a>）<br>对setSelectionRange方法只能用于类型为文本、搜索、连接、电话号码、密码的输入，以及在Chrome33开始访问其余类型的属性和方法抛出异常。<br>输入类型为数字时会抛出：“不能从’HTMLInputElement’中读取’selectionStart’属性：输入元素的类型(‘number’)不支持选择（Failed to read the ‘selectionStart’ property from ‘HTMLInputElement’: The input element’s type (‘number’) does not support selection）”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-cloak解决页面闪烁问题</title>
      <link href="/2020/02/12/v-cloak/"/>
      <url>/2020/02/12/v-cloak/</url>
      
        <content type="html"><![CDATA[<p>这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{ display: none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p><span id="more"></span><p>很多时候，我们页面模板中的数据是异步获取的，在网络不好的情况下，渲染页面的时候会出现页面闪烁的效果，影响用户体验，v-cloak 指令保持在元素上直到关联实例结束编译，利用它的特性，结合 CSS 的规则 [v-cloak] { display: none } 一起使用就可以隐藏掉未编译好的 Mustache 标签，直到实例准备完毕。</p><pre><code class="html">&lt;div class=&quot;#app&quot; v-cloak&gt;    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">[v-cloak] &#123;    display: none;&#125;</code></pre><blockquote><p>需要注意，虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个loading动画或者骨架屏的效果，提升用户体验。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决oh-my-zsh启动时出现多行提示</title>
      <link href="/2020/02/09/oh-my-zsh/"/>
      <url>/2020/02/09/oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<p>oh-my-zsh在启动时，出现很多行提示，仔细阅读发现是2个文件夹权限的问题，修改文件夹权限，添加命令即可解决。</p><span id="more"></span><h3 id="一、修改文件夹权限"><a href="#一、修改文件夹权限" class="headerlink" title="一、修改文件夹权限"></a>一、修改文件夹权限</h3><pre><code class="js">cd /usr/local/sharesudo chmod 755 zshcd /usr/local/share/zshsudo chmod 755 site-functions</code></pre><h3 id="二、-zshrc添加命令"><a href="#二、-zshrc添加命令" class="headerlink" title="二、.zshrc添加命令"></a>二、.zshrc添加命令</h3><pre><code class="js">// 根目录下添加下面的命令cd ~sudo vi .zshrc#写在  # User configuration  之后ZSH_DISABLE_COMPFIX=&quot;true&quot; #保存并退出esc -&gt; :wq </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理javascript知识(二)</title>
      <link href="/2020/01/15/javascript-simple2/"/>
      <url>/2020/01/15/javascript-simple2/</url>
      
        <content type="html"><![CDATA[<p>JavaScript的闭包、作用域、原型链</p><span id="more"></span><h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><h5 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h5><blockquote><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，<u>闭包让你可以在一个内层函数中访问到其外层函数的作用域</u>。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。— from MDN</p></blockquote><p>javascript闭包的本质源自2点：词法作用域和函数当做值传递。</p><h5 id="2、词法作用域"><a href="#2、词法作用域" class="headerlink" title="2、词法作用域"></a>2、词法作用域</h5><blockquote><p>按照代码的书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这个变量就登记在相应的数据结构中。</p></blockquote><pre><code class="js">function init()&#123;    // 局部变量    var name = &#39;jude&#39;      // 内部函数，一个闭包    function displayName()&#123;        // 父函数中声明的变量        console.log(name)    &#125;    displayName()&#125;init()</code></pre><p>name、displayName()是init()函数的一个局部变量和一个内部函数，displayName()函数没有自己的局部变量，但是它可以访问到外部函数的变量，所以displayName()可以使用父函数init()中声明的变量name。</p><h5 id="3、函数当做值传递"><a href="#3、函数当做值传递" class="headerlink" title="3、函数当做值传递"></a>3、函数当做值传递</h5><blockquote><p>即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。</p></blockquote><p>闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。</p><h3 id="4、闭包的缺点：造成内存泄漏"><a href="#4、闭包的缺点：造成内存泄漏" class="headerlink" title="4、闭包的缺点：造成内存泄漏"></a>4、闭包的缺点：造成内存泄漏</h3><blockquote><p>如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。</p></blockquote><h4 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h4><h4 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h4><blockquote><p>作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。</p></blockquote><p>JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。</p><p>每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。</p><h4 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h4><blockquote><p>在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。</p></blockquote><h4 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h4>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理javascript知识(一)</title>
      <link href="/2020/01/12/javascript-simple/"/>
      <url>/2020/01/12/javascript-simple/</url>
      
        <content type="html"><![CDATA[<p>javascript 数据类型、类型检测、类型检测函数的封装（包括纯粹对象、空对象、window 对象）。</p><span id="more"></span><h3 id="一、基础类型及类型检测"><a href="#一、基础类型及类型检测" class="headerlink" title="一、基础类型及类型检测"></a>一、基础类型及类型检测</h3><h4 id="1、基础类型"><a href="#1、基础类型" class="headerlink" title="1、基础类型"></a>1、基础类型</h4><blockquote><p>JavaScript 数据类型包括：Null、Undefined、Boolean、Number、String、Symbol、Bigint(7 种原始类型)、Object(引用类型，包括 Object/Array/Date/Function/RegExp 等)</p></blockquote><h4 id="2、类型检测"><a href="#2、类型检测" class="headerlink" title="2、类型检测"></a>2、类型检测</h4><h5 id="1-、typeof"><a href="#1-、typeof" class="headerlink" title="(1)、typeof"></a>(1)、typeof</h5><blockquote><p>7 种原始类型可以使用 typeof 操作符检查数据类型（其中，typeof null === ‘object’）</p></blockquote><p>检查 Object 派生出来的结构类型，使用 typeof 是不行的， 会一直 === ‘object’,通常使用 instanceof 检查 Object 种类（这样还是存在误差）。</p><h5 id="（2-、instanceof"><a href="#（2-、instanceof" class="headerlink" title="（2)、instanceof"></a>（2)、instanceof</h5><blockquote><p>instanceof 运算符是用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p></blockquote><p>Tips: 检测对象不是某个构造函数的实例</p><pre><code class="js">if (!(mycar instanceof Car)) &#123;  // do something&#125;// 上面代码和下面代码完全不同，下面的代码!mycar会在instanceof之前被验证if (!mycar instanceof Car) &#123;&#125;</code></pre><h5 id="（3-、Object-prototype-toString-call"><a href="#（3-、Object-prototype-toString-call" class="headerlink" title="（3)、Object.prototype.toString().call()"></a>（3)、Object.prototype.toString().call()</h5><blockquote><p>每个对象都有一个 toString()方法，可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。</p></blockquote><p>调用 Object.prototype.toString 会返回一个由 “[object “ 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。</p><p>(看了别人翻译的es5规范，讲解这个toString（）函数，如下：)<br>当toString方法被调用的时候，执行步骤为：</p><blockquote><p>1、如果 this 值是 undefined，就返回 [object Undefined]<br>2、如果 this 的值是 null，就返回 [object Null]<br>3、让 O 成为 ToObject(this) 的结果<br>4、让 class 成为 O 的内部属性 [[Class]] 的值<br>5、最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串</p></blockquote><pre><code class="js">// 以下是11种：var number = 1; // [object Number]var string = &quot;123&quot;; // [object String]var boolean = true; // [object Boolean]var und = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123; a: 1 &#125;; // [object Object]var array = [1, 2, 3]; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a() &#123;&#125;; // [object Function]function checkType() &#123;  for (var i = 0; i &lt; arguments.length; i++) &#123;    console.log(Object.prototype.toString.call(arguments[i]));  &#125;&#125;checkType(  number,  string,  boolean,  und,  nul,  obj,  array,  date,  error,  reg,  func);// 除了以上11种，还包括console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]// 还可以这样function a() &#123;  console.log(Object.prototype.toString.call(arguments)); // [object Arguments]&#125;a();</code></pre><h5 id="（4-、封装一个-type-函数"><a href="#（4-、封装一个-type-函数" class="headerlink" title="（4)、封装一个 type 函数"></a>（4)、封装一个 type 函数</h5><p>写一个 type 函数检测各种类型的值,考虑到兼容性（IE6，null 和 undefined 会被 Obejct.prototype.toString 识别为[object Obejct]）</p><pre><code class="js">var class2type = &#123;&#125;;// 生成class2type映射&quot;Boolean Number String Function Array Date RegExp Object Error&quot;  .split(&quot; &quot;)  .map(function (item, index) &#123;    class2type[&quot;[object &quot; + item + &quot;]&quot;] = item.toLowerCase();  &#125;);function type(obj) &#123;  // 一箭双雕  if (obj == null) &#123;    return obj + &quot;&quot;;  &#125;  return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;    ? class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;    : typeof obj;&#125;</code></pre><h5 id="（5-、函数类型的检测"><a href="#（5-、函数类型的检测" class="headerlink" title="（5)、函数类型的检测"></a>（5)、函数类型的检测</h5><pre><code class="js">// type函数function isFunction(obj) &#123;  return type(obj) === &quot;function&quot;;&#125;</code></pre><h5 id="（6-、纯粹对象的检测"><a href="#（6-、纯粹对象的检测" class="headerlink" title="（6)、纯粹对象的检测"></a>（6)、纯粹对象的检测</h5><p>什么是纯粹对象？</p><blockquote><p>该对象是通过 “{}” 或 “new Object” 创建的，该对象含有零个或者多个键值对。</p></blockquote><pre><code class="js">// 上面写 type 函数时，用来存放 toString 映射结果的对象var class2type = &#123;&#125;;// 相当于 Object.prototype.toStringvar toString = class2type.toString;// 相当于 Object.prototype.hasOwnPropertyvar hasOwn = class2type.hasOwnProperty;function isPlainObject(obj) &#123;  var proto, Ctor;  // 排除掉明显不是obj的以及一些宿主对象如Window  if (!obj || toString.call(obj) !== &quot;[object Object]&quot;) &#123;    return false;  &#125;  /**   * getPrototypeOf es5 方法，获取 obj 的原型   * 以 new Object 创建的对象为例的话   * obj.__proto__ === Object.prototype   */  proto = Object.getPrototypeOf(obj);  // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true  if (!proto) &#123;    return true;  &#125;  /**   * 以下判断通过 new Object 方式创建的对象   * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor   * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数   */  Ctor = hasOwn.call(proto, &quot;constructor&quot;) &amp;&amp; proto.constructor;  // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数  return (    typeof Ctor === &quot;function&quot; &amp;&amp;    hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object)  );&#125;</code></pre><h5 id="（7-、空对象的判断"><a href="#（7-、空对象的判断" class="headerlink" title="（7)、空对象的判断"></a>（7)、空对象的判断</h5><pre><code class="js">function isEmptyObject(obj) &#123;  var name;  for (name in obj) &#123;    return false;  &#125;  return true;&#125;</code></pre><h5 id="（8-、window-对象的判断"><a href="#（8-、window-对象的判断" class="headerlink" title="（8)、window 对象的判断"></a>（8)、window 对象的判断</h5><pre><code class="js">function isWindow(obj) &#123;  return obj != null &amp;&amp; obj === obj.window;&#125;</code></pre><h5 id="（9-、数组类型的检测"><a href="#（9-、数组类型的检测" class="headerlink" title="（9)、数组类型的检测"></a>（9)、数组类型的检测</h5><pre><code class="js">// 判断Array.isArray()方法是否存在，如果存在就使用该方法，不存在就使用type函数var isArray =  Array.isArray ||  function (obj) &#123;    return type(obj) === &quot;array&quot;;  &#125;;</code></pre><h5 id="（10-、类数组的判断"><a href="#（10-、类数组的判断" class="headerlink" title="（10)、类数组的判断"></a>（10)、类数组的判断</h5><p>满足的三个条件：</p><blockquote><p>1、是数组<br>2、长度为 0<br>3、lengths 属性是大于 0 的数字类型，并且 obj[length - 1]必须存在</p></blockquote><pre><code class="js">function isArrayLike(obj) &#123;  // obj 必须有 length属性  var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length;  var typeRes = type(obj);  // 排除掉函数和 Window 对象  if (typeRes === &quot;function&quot; || isWindow(obj)) &#123;    return false;  &#125;  return (    typeRes === &quot;array&quot; ||    length === 0 ||    (typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; length - 1 in obj)  );&#125;</code></pre><p>函数库的实现，如：underscore</p><pre><code class="js">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;var isArrayLike = function (collection) &#123;  var length = getLength(collection);  return typeof length == &quot;number&quot; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;&#125;;</code></pre><h5 id="11-、判断是不是-DOM-元素"><a href="#11-、判断是不是-DOM-元素" class="headerlink" title="(11)、判断是不是 DOM 元素"></a>(11)、判断是不是 DOM 元素</h5><pre><code class="js">var isElement = function (obj) &#123;  return !!(obj &amp;&amp; obj.nodeType === 1);&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下拉框select的option</title>
      <link href="/2019/12/29/select/"/>
      <url>/2019/12/29/select/</url>
      
        <content type="html"><![CDATA[<p>下拉的选项是从后台获取的数据,如何获取选定项的值?</p><span id="more"></span><p>以选择银行卡为例：</p><pre><code class="js">    &lt;select v-model=&quot;selected&quot; class=&quot;selected&quot;&gt;        &lt;option disabled value v-show=&quot;showBankCard&quot;&gt;请选择提现到账的银行卡&lt;/option&gt;        &lt;option            v-for=&quot;item in BankCardList&quot;            :key=&quot;item.id&quot;            v-bind:value=&quot;item.id&quot;        &gt;            &#123;&#123; item.card_no &#125;&#125;        &lt;/option&gt;    &lt;/select&gt;</code></pre><pre><code class="js">item.card_no ? item.card_no.replace(/^(\d&#123;4&#125;)\d+(\d&#123;4&#125;)$/,&quot;$1****$2&quot;):&quot;&quot;// 银行卡号显示为 6217 **** 0000 的格式。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码的生成</title>
      <link href="/2019/12/28/qrcode/"/>
      <url>/2019/12/28/qrcode/</url>
      
        <content type="html"><![CDATA[<p>使用 qrcode 生成二维码</p><span id="more"></span><p>一、下载插件 qrcode 插件</p><pre><code class="js">    npm install qrcode --save</code></pre><p>二、在 main.js 中引用</p><pre><code class="js">import QRCode from &quot;qrcode&quot;;Vue.use(QRCode);</code></pre><p>三、组件中引入 QRCode</p> <details> <summary>点我展示代码</summary> <pre><code class="html">    &lt;template&gt;        &lt;div&gt;            &lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;</code></pre><pre><code class="js">    &lt;script&gt;      import QRCode from &#39;qrcode&#39;;      mounted()&#123;          this.CreateQrcode();      &#125;,      method:&#123;          setTimeout(() =&gt; &#123;              // 获取DOM节点              let dom = document.getElementById(&#39;qrcode);              // 路由传参              const res = this.$route.params;              const lbsid = res.id;              // 二维码包含的URL 需要将URL和id做一下字符串的拼接              let url = &#39;http://*********&#39;;              let URL = url.concat(lbsid);              let qrCode = new QRCode(dom,&#123;                  width:260, // 图像宽度                  height:260,  // 图像高度                  colorDark:&quot;#000000&quot;,  // 前景色                  colorLight:&quot;#ffffff&quot;, // 背景色                  correctLevel: QRCode.CorrectLevel.H  // 容错等级              &#125;);              qrCode.clear();              qrCode.makeCode(URL);          &#125;,100)      &#125;    &lt;/script&gt;    &lt;style lang=&quot;less&quot; scoped&gt;        #qrcode &#123;            display: inline-block;            margin-top: 6rem;            img &#123;                width: 60%;                height: 60%;                background-color: #fff; //设置白色背景色                padding: 6px; // 利用padding的特性，挤出白边  &#125;&#125;    &lt;/style&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号网页使用popstate事件</title>
      <link href="/2019/12/23/popstate/"/>
      <url>/2019/12/23/popstate/</url>
      
        <content type="html"><![CDATA[<p>如何在h5移动端禁止某一些页面使用虚拟返回键。</p><span id="more"></span><h3 id="1、popstate事件"><a href="#1、popstate事件" class="headerlink" title="1、popstate事件"></a>1、popstate事件</h3><p>MDN上是这样介绍popstate的：<br>    当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。<br>    需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）<br>    不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会。<br>    我负责的一个项目中，在微信公众号网页的某一个页面需要禁止使用微信浏览器的返回键。</p><h3 id="2、解决方式："><a href="#2、解决方式：" class="headerlink" title="2、解决方式："></a>2、解决方式：</h3><details><summary>点我展示代码</summary><pre><code class="js">// 在禁止返回的组件的methods中写一个方法forbidBackforbidBack()&#123;    window.history.pushState(&quot;forward&quot;,null,&quot;#&quot;);    window.history.forward(1);&#125;// 监听返回键，禁止返回之前的路由if(window.history &amp;&amp; window.history.pushState)&#123;    window.addEventListener(&quot;popstate&quot;,this.forbidBack,false);    this.forbidBack();&#125;//离开页面需要销毁监听window.removeEventListener(&quot;popstate&quot;,this.forbidBack,fasle);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5扫码功能</title>
      <link href="/2019/12/20/h5-scan/"/>
      <url>/2019/12/20/h5-scan/</url>
      
        <content type="html"><![CDATA[<p>使用H5 API barcode实现扫码。</p><span id="more"></span><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;div @click=&quot;handleCloseScan&quot;&gt;X&lt;/div&gt;        &lt;div class=&quot;scan&quot;&gt;            &lt;div id=&quot;bcid&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;button @click=&quot;handleStartScan&quot;&gt;扫 码&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><details><summary>点击展示js代码</summary><pre><code class="js">    &lt;script&gt;        // 扫描对象        var scan = null;        methods:&#123;            // 开始扫描            handleStartScan()&#123;                const that = this;                if(!window.plus) return;                scan = new plus.barcode.Barcode(&#39;bcid&#39;);                // 开始扫描                scan.start();                // 扫码成功之后的回调函数 type是类型 result 结果                scan.onmarked = function(type,result)&#123;                    const text = &#39;&#39;;                    switch(type)&#123;                        case plus.barcode.QR:                            type = &#39;QR&#39;;                            break;                        case plus.barcode.EAN13:                            type = &quot;EAN13&quot;;                            break;                        case plus.barcode.EAN8:                            type = &quot;EAN8&quot;;                            break;                        default:                            type = &quot;其它&quot; + type;                            break;                    &#125;                    result = result.replace(/\n/g,&quot;&quot;);                    const id = result.match(/\d+/)[0];                    that.$router.push(&#123;                        name:&#39;ComponentName&#39;,                        params: &#123;                            id:id                        &#125;                    &#125;);                    scan.close();                &#125;            &#125;,            // 关闭扫描控件            handleCloseScan()&#123;                 if(!window.plus) return;                 scan.close();                 this.$router.push(&#39;/&#39;);            &#125;        &#125;&#125;    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Vue项目热更新打包时间过长</title>
      <link href="/2019/12/11/hot/"/>
      <url>/2019/12/11/hot/</url>
      
        <content type="html"><![CDATA[<p>维护公司一个项目的时候，发现在项目启动、热更新和打包项目的时候，时间长的“感人”。</p><span id="more"></span><p>当你改动项目的一些地方想要立即看到效果的时候，却发现热更新的编译过程却花了你很长时间，“心态崩了。。。”。</p><h3 id="1、解决Vue项目热更新打包时间过长"><a href="#1、解决Vue项目热更新打包时间过长" class="headerlink" title="1、解决Vue项目热更新打包时间过长"></a>1、解决Vue项目热更新打包时间过长</h3><p>解决方法：</p><p>1、使用html-webpack-plugin-for-multihtml插件</p><p>2、在build-webpack.dev.conf.js文件中</p><pre><code class="js">    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    // 替换成    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin-for-multihtml&#39;);</code></pre><p>3、multihtmlCache:true  解决多页热部署的关键</p><pre><code class="js">for (var pathname in pages) &#123;  // 配置生成的html文件，定义路径等  var conf = &#123;    filename: pathname + &#39;.html&#39;,    template: pages[pathname],   // 模板路径    inject: true,              // js插入位置    multihtmlCache: true,    // 解决多页热部署的关键 这里这里这里这里这里很重要！！！    // necessary to consistently work with multiple chunks via CommonsChunkPlugin    chunksSortMode: &#39;dependency&#39;  &#125;;  if (pathname in devWebpackConfig.entry) &#123;    conf.chunks = [&#39;manifest&#39;,&#39;vendor&#39;, pathname];    conf.hash = false;  &#125;  devWebpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;</code></pre><p>4、router.js中使用路由懒加载</p><p>这时候再启动项目，热更新、编译和打包的速度会大大提升。</p><h3 id="2、项目打包由4M变为1M"><a href="#2、项目打包由4M变为1M" class="headerlink" title="2、项目打包由4M变为1M"></a>2、项目打包由4M变为1M</h3><p>公司有一个H5微信公众号网页的项目，项目打包之后文件有4M；</p><p>修改webpack.prod.conf.js里的UglifyJsPlugin，这里的意思是打包后不产生后缀名为.map的文件。</p><pre><code class="javascript">webpack.prod.conf.js    new UglifyJsPlugin(&#123;      uglifyOptions: &#123;        compress: &#123;          warnings: false        &#125;      &#125;,      // sourceMap: config.build.productionSourceMap, 将这行代码注释掉。      parallel: true    &#125;)</code></pre><p>处理后打包的文件的大小为1M</p>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/12/05/markdown/"/>
      <url>/2019/12/05/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown语法整理</p><span id="more"></span><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue实现模糊搜索</title>
      <link href="/2019/11/13/mohu-search/"/>
      <url>/2019/11/13/mohu-search/</url>
      
        <content type="html"><![CDATA[<p>利用computed计算属性实现模糊搜索</p><span id="more"></span><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;搜索&quot; v-model=&quot;sousuo&quot;&gt;    &lt;table border=&quot;1&quot;&gt;      &lt;th&gt;编号&lt;/th&gt;      &lt;th&gt;英雄&lt;/th&gt;      &lt;th&gt;技能&lt;/th&gt;      &lt;tr v-for=&quot;(item,index) in sousuo1()&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.jn&#125;&#125;&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;  &lt;/div&gt;</code></pre><p>利用computed计算属性</p><details><summary>点我展示代码</summary><pre><code class="javascript">var app = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    sousuo: &#39;&#39;,    list: [&#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;艾希&quot;,        &quot;jn&quot;: &quot;射箭&quot;      &#125;, &#123;        &quot;id&quot;: 2,        &quot;name&quot;: &quot;狐狸&quot;,        &quot;jn&quot;: &quot;魅惑&quot;      &#125;, &#123;        &quot;id&quot;: 3,        &quot;name&quot;: &quot;猴子&quot;,        &quot;jn&quot;: &quot;棍子&quot;      &#125;, &#123;        &quot;id&quot;: 4,        &quot;name&quot;: &quot;盖伦&quot;,        &quot;jn&quot;: &quot;大宝剑&quot;      &#125;, &#123;        &quot;id&quot;: 5,        &quot;name&quot;: &quot;德邦&quot;,        &quot;jn&quot;: &quot;尖枪&quot;      &#125;, &#123;        &quot;id&quot;: 6,        &quot;name&quot;: &quot;皇子&quot;,        &quot;jn&quot;: &quot;旗子&quot;      &#125;,    ]  &#125;,  computed: &#123; //设置计算属性    Search() &#123;      if (this.sousuo) &#123;        return this.list.filter((value) =&gt; &#123; //过滤数组元素  this.list就是上面的那个死数据          return value.name.includes(this.sousuo); // 查看value.name里面包含不包含输入的字体          &#125;); //this.sousuo跟上面的输入框是双重绑定      &#125;    &#125;  &#125;,  methods: &#123;    sousuo1() &#123;      if (!this.sousuo) &#123;        return this.list;      &#125;      return this.Search    &#125;  &#125;,&#125;)</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基础知识</title>
      <link href="/2019/09/26/vue-simple/"/>
      <url>/2019/09/26/vue-simple/</url>
      
        <content type="html"><![CDATA[<p>Vue基础知识点，包括常用指令、计算属性、侦听属性等。</p><span id="more"></span><h2 id="Vuejs响应式原理"><a href="#Vuejs响应式原理" class="headerlink" title="Vuejs响应式原理"></a>Vuejs响应式原理</h2><pre><code>编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。</code></pre><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快: 相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。</p><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h2 id="vue组件中data必须是一个函数？"><a href="#vue组件中data必须是一个函数？" class="headerlink" title="vue组件中data必须是一个函数？"></a>vue组件中data必须是一个函数？</h2><p>官网上是这样写的：</p><blockquote><p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，可能会影响到其它所有实例。</p></blockquote><p>当创建Vue实例时，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p><h2 id="v-if和v-show有什么区别？"><a href="#v-if和v-show有什么区别？" class="headerlink" title="v-if和v-show有什么区别？"></a>v-if和v-show有什么区别？</h2><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>计算属性computed：</p><p>支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><p>侦听属性watch：</p><p>不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：<br>immediate：组件加载立即触发回调函数执行</p><pre><code class="js">watch: &#123;  firstName: &#123;    handler(newName, oldName) &#123;      this.fullName = newName + &#39; &#39; + this.lastName;    &#125;,    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法    immediate: true  &#125;&#125;</code></pre><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p><pre><code class="js">watch: &#123;  obj: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    deep: true  &#125;&#125;</code></pre><p>优化：我们可以使用字符串的形式监听</p><pre><code class="js">watch: &#123;  &#39;obj.a&#39;: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    // deep: true  &#125;&#125;</code></pre><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h2 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h2><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。<br>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p><h2 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h2><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><blockquote><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p></blockquote><p>v-for提升性能的原因:</p><p>key相同时，两个VNode会相同，可以避免不必要的DOM更新；而且在diff内部，也会根据key来跟踪VNode。</p><h2 id="双向数据绑定原理是什么？"><a href="#双向数据绑定原理是什么？" class="headerlink" title="双向数据绑定原理是什么？"></a>双向数据绑定原理是什么？</h2><blockquote><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><p>主要分为以下几个步骤：</p><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>①在自身实例化时往属性订阅器(dep)里面添加自己<br>②自身必须有一个update()方法<br>③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h2 id="vue-router路由页面管理"><a href="#vue-router路由页面管理" class="headerlink" title="vue-router路由页面管理"></a>vue-router路由页面管理</h2><blockquote><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote><p>包含的功能有：</p><p>1、嵌套的路由/视图表</p><p>2、模块化的、基于组件的路由配置</p><p>3、路由参数、查询、通配符</p><p>4、基于 Vue.js 过渡系统的视图过渡效果</p><p>5、细粒度的导航控制</p><p>6、带有自动激活的 CSS class 的链接</p><p>7、HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p><p>8、自定义的滚动条行为</p><blockquote><p>1、动态路由匹配</p></blockquote><p>例如：对不同ID的用户，使用同一个组件来渲染。</p><pre><code class="js">const User = &#123;  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;&#125;const router = new VueRouter(&#123;  routes: [    // 动态路径参数 以冒号开头    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)</code></pre><p>这样/user/foo 和 /user/bar 都将映射到相同的路由User。</p><p>一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;</code></pre><blockquote><p>2、编程式的导航<br>router.push({name:””,params:{}})</p></blockquote><pre><code class="js">  （1）this.$router.push  // 带参数  this.$router.push(&#123;    name:&quot;User&quot;,    params:&#123;      userId:&quot;123&quot;    &#125;  &#125;)</code></pre><p>router.push({path:””,query:””})</p><pre><code class="js">  (2) this.$router.push(&#123;    path:&quot;/user&quot;,    query:&#123;      plan:&quot;private&quot;    &#125;  &#125;)</code></pre><p>router.replace()使用方法跟router.push()很像，不会向history添加新纪录，替换掉当前的history记录。<br>router.go()在history记录中向前或者向后多少步。正数为向前多少步，负数为向后多少步</p><blockquote><p>3、滚动行为</p></blockquote><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><blockquote><p>注意：这个功能只在支持 history.pushState 的浏览器中可用。</p></blockquote><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;  if (savedPosition) &#123;    return savedPosition  &#125; else &#123;    return &#123; x: 0, y: 0 &#125;  &#125;&#125;</code></pre><blockquote><p>4、路由懒加载</p></blockquote><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名chunk，一个特殊的注释语法来提供chunk name(需要 Webpack &gt; 2.4)。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><h2 id="表单输入控制"><a href="#表单输入控制" class="headerlink" title="表单输入控制"></a>表单输入控制</h2><blockquote><p>表单修饰符：如果是简单的控制输入一定是数字或者去掉用户输入的收尾空白符，可以直接使用 Vue 提供的表单修饰符 .number 和 .trim</p></blockquote><p>1、如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><pre><code class="vue">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre><p>2、如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><pre><code class="vue">&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre><blockquote><p>change事件:给表单绑定事件，在事件处理中进行表单输入控制</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value2&quot; type=&quot;text&quot; @change=&quot;inputChange(value2)&quot; /&gt;</code></pre><pre><code class="js">methods: &#123;  inputChange: function(val) &#123;    if (!val) return &#39;&#39;    val = val.toString()    this.value2 = val.charAt(0).toUpperCase() + val.slice(1)  &#125;&#125;</code></pre><blockquote><p>filter过滤器</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value1&quot;  type=&quot;text&quot; /&gt;</code></pre><pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;  if (!value) return &#39;&#39;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)</code></pre><pre><code class="js">watch: &#123;  value1(val) &#123;     this.value1 = this.$options.filters.capitalize(val);  &#125;&#125;</code></pre><blockquote><p>指令:声明一个全局指令</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// 只能输入正整数,0-9的数字Vue.directive(&#39;enterIntNumber&#39;, &#123;  inserted: function (el) &#123;    let trigger = (el, type) =&gt; &#123;      const e = document.createEvent(&#39;HTMLEvents&#39;)      e.initEvent(type, true, true)      el.dispatchEvent(e)    &#125;    el.addEventListener(&quot;keyup&quot;, function (e) &#123;      let input = e.target;      let reg = new RegExp(&#39;^\\d&#123;1&#125;\\d*$&#39;);  //正则验证是否是数字      let correctReg = new RegExp(&#39;\\d&#123;1&#125;\\d*&#39;);  //正则获取是数字的部分      let matchRes = input.value.match(reg);      if (matchRes === null) &#123;        // 若不是纯数字 把纯数字部分用正则获取出来替换掉        let correctMatchRes = input.value.match(correctReg);        if (correctMatchRes) &#123;          input.value = correctMatchRes[0];        &#125; else &#123;          input.value = &quot;&quot;;        &#125;      &#125;      trigger(input, &#39;input&#39;)    &#125;);  &#125;&#125;);</code></pre></details><pre><code class="html">&lt;!--限制输入正整数--&gt;&lt;input v-enterIntNumber placeholder=&quot;0&quot; type=&quot;number&quot;&gt;</code></pre><h1 id="Vue渲染目标元素的6种方法"><a href="#Vue渲染目标元素的6种方法" class="headerlink" title="Vue渲染目标元素的6种方法"></a>Vue渲染目标元素的6种方法</h1><p>1、直接创建Vue实例</p><details><summary>点击展示代码</summary><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- 这里直接引入cdn源码 --&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    template: &quot;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&quot;,    data()&#123;      return&#123;        message:&#39;Hello Vue.js!&#39;      &#125;    &#125;  &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></details><p>2、Vue.extend</p><blockquote><p>Vue.extend(options) 方式是使用Vue构造器的一个“子类”，其参数同Vue(options)一模一样，唯一的不同是没有 el 属性来指定挂载的DOM元素，所以这里需要通过 $mount() 方法，来手动实现挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  var app = Vue.extend(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello extend&#39;      &#125;    &#125;  &#125;)  // 注意这里 Vue.extend 方式是生成了一个 Vue 子类，所以需要 new关键字来重新创建，然后手动挂载。  new app().$mount(&#39;#app&#39;);  &lt;/script&gt;</code></pre></details><p>3.Vue.component</p><blockquote><p>Vue.component(id, [definition])方式是注册一个名称为id的全局组件，然后我们可以通过使用该组件来，实现目标元素渲染。其中definition 参数同 Vue.extend 中的参数一模一样，方法一样，需要使用$mount()方法手动挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  // var app = Vue.component(&#39;hello&#39;, &#123;  //     template:&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,  //   data() &#123;  //     return &#123;  //       msg: &#39;hello component&#39;  //     &#125;  //   &#125;  // &#125;)  // new app().$mount(&#39;#app&#39;)  //1、 注册组件  Vue.component(&#39;hello&#39;, &#123;    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello component&#39;      &#125;    &#125;  &#125;)  // 2、创建Vue实例  new Vue(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;hello /&gt;&#39;  &#125;)  &lt;/script&gt;</code></pre><blockquote><p>仅仅注册组件式不够的，我们还要通过创建一个Vue实例，才能使用该组件。</p></blockquote></details><p>4、Vue.directive自定义指令</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;div v-hello=&quot;msg&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;  Vue.directive(&#39;hello&#39;, &#123;    bind: function(el, binding) &#123;      el.innerHTML = &quot;&lt;h1&gt;&quot; + binding.value + &quot;&lt;/h1&gt;&quot;    &#125;  &#125;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello directive 自定义指令&quot;      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>5、Vue.compile</p><blockquote><p>Vue.compile(template) 参数也就是 template 模板字符串属性，然后通过替换 Vue实例的 render 函数，来实现渲染。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;      // 参数就是template模板字符串  然后通过替换Vue实例的render函数来实现渲染  var tpl = Vue.compile(&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;&#39;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello,compile&quot;      &#125;    &#125;,    render: tpl.render  &#125;)  &lt;/script&gt;</code></pre></details><p>6、render</p><blockquote><p>Vue实例在创建的过程中也会调用 render 函数，render 函数默认会传递一个参数,我们可以通过 createElement 来动态创建一个 VNode，以此来渲染目标元素</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &#39;hello,render&#39;      &#125;    &#125;,    render: function(createElement) &#123;      return createElement(&#39;h1&#39;, this.msg)    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><h1 id="data-computed-watch"><a href="#data-computed-watch" class="headerlink" title="data/computed/watch"></a>data/computed/watch</h1><p>1、data</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;        &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        list: [&#123;          name: &#39;vue js&#39;,          url: &#39;https://cn.vuejs.org&#39;        &#125;, &#123;          name: &#39;github&#39;,          url: &#39;https://github.com&#39;        &#125;, &#123;          name: &#39;blog&#39;,          url: &#39;issummer.cn&#39;        &#125;]      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.list.push(&#123;          name: &#39;baidu&#39; + this.count,          url: &#39;https://www.baidu.com&#39;        &#125;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>2、computed</p><blockquote><p>computed 中的属性是需要先进行计算，然后再返回想要的数据的。当我们输出某个属性，必须依赖另外一个 data 中的属性来动态计算获得的，此时使用 computed 就非常简单了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;      &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;      &lt;ul&gt;          &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;              &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;          &lt;/li&gt;      &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        // 这里是后台数据        requestList: [          &#39;vuejs https://cn.vuejs.org&#39;,          &#39;github https://github.com&#39;,          &#39;blog https://issummer.cn&#39;        ]      &#125;    &#125;,    computed: &#123;      list: function() &#123;        var list = []        this.requestList.map(function(item, index) &#123;          var tempArr = item.split(&#39;-&#39;)          list.push(&#123;            name: tempArr[0],            url: tempArr[1]          &#125;)        &#125;)        return list      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.requestList.push(&#39;blog&#39; + this.count + &#39;issummer.cn&#39;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><blockquote><p>计算是可以修改的,计算属性不仅可以定义为一个函数，也可以定义为一个含有 get/set 属性的对象。当我们定义为一个函数是，Vue 内部会默认将这个函数赋值给 get 属性，一般 set 是未定义的。当我们定义 set 属性后，就可以对它进行修改了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;    &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        firstName: &#39;Jude&#39;,        lastName: &#39;Summer&#39;      &#125;    &#125;,    computed: &#123;      username: &#123;        get: function() &#123;          return this.firstName + &#39; &#39; + this.lastName        &#125;,        set: function(newVal) &#123;          var names = newVal.split(&#39; &#39;);          this.firstName = names[0];          this.lastName = names[1];        &#125;      &#125;    &#125;,    methods:&#123;        changeName()&#123;            if(this.username === &#39;Jude Summer&#39;)&#123;                this.username = &quot;YQ&quot;            &#125;else&#123;                this.username = &#39;Jude Summer&#39;            &#125;        &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>3、watch侦听器</p><blockquote><p>创建 Vue 应用时，我们还提到过 watch 这个属性，它其实是个对象，键是需要观察的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。和上面的计算属性类似，他可以监听 值/表达式 的变化来执行回调函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;        &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    firstName: &#39;Jude&#39;,                    lastName: &#39;Summer&#39;,                    username: &#39;Jude Summer&#39;                &#125;            &#125;,            watch: &#123;                firstName: function (val, oldVal) &#123;                    this.username = val + &#39; &#39; + this.lastName;                &#125;,                lastName: function (val, oldVal) &#123;                    this.username = this.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                changeName() &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.firstName = &quot;Y&quot;;                        this.lastName = &quot;Q&quot;;                    &#125; else &#123;                        this.firstName = &quot;Jude&quot;;                        this.lastName = &quot;Summer&quot;;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 监听对象属性    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 此时无论我们如何点击按钮，都无法改变 username 的值，因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听                userinfo: function (val, oldVal) &#123;                    this.username = val.firstName + &#39; &#39; + val.lastName;                &#125;            &#125;,            methods: &#123;                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 上面的方法是无法修改username的值 因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听。实际上对于侦听的值是可以为一个对象的，它还有个 deep 属性，用来设置是否侦听内部属性的变化，而回调函数是通过 handler 来设置的     &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // depp属性用来侦听内部属性变化，回调函数是通过hander来设置                // 适用于非整体赋值  也就是适用于局部修改属性，这个时候通过设置deep属性为true，来达到侦听目的。                userinfo: &#123;                    deep: true,                    handler: function (val, oldVal) &#123;                        this.username = val.firstName + &quot; &quot; + val.lastName;                    &#125;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 写成对象属性访问表达式的    当侦听对象包含很多属性，而我们只是需要监听其中的一个或某几个属性，这时如果我们通过这种方式侦听所有内部属性的变化，自然就会造成内存的浪费。那么我们可以只侦听单一内部属性的变化    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 侦听对象的某个属性                &#39;userinfo.lastName&#39;:function(val,oldVal)&#123;                    this.username = this.userinfo.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        // this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        // this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;</code></pre></details><h1 id="v-on对象语法"><a href="#v-on对象语法" class="headerlink" title="v-on对象语法"></a>v-on对象语法</h1><blockquote><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p></blockquote><p>通常的写法：</p><pre><code class="html">&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</code></pre><p>对象语法: </p><pre><code class="html">&lt;div v-on=&quot;&#123; mouseenter: ShowInfo, mouseleave: HideInfo &#125;&quot;&gt;  &lt;div&gt;我是title&lt;/div&gt;  &lt;div v-show=&quot;ShowWrapper&quot;&gt;我是显示的内容！&lt;/div&gt;&lt;/div&gt;</code></pre><h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><blockquote><p>有时候，我们需要将router-link渲染成某种标签，例如<code>&lt;li&gt;&lt;/li&gt;</code>使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航</p></blockquote><p>示例:</p><pre><code class="html">&lt;ul class=&quot;nav-list&quot;&gt;  &lt;router-link tag=&quot;li&quot; to=&quot;home&quot;&gt;home&lt;/router-link&gt;&lt;/ul&gt;&lt;!-- 渲染的结果为 --&gt;&lt;li&gt;home&lt;/li&gt;</code></pre><h1 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h1><blockquote><p>可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。提供具名插槽或需要接收 prop 的插槽。</p></blockquote><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div class=&quot;common-card&quot;&gt;    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;value&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;chart&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;total&quot;&gt;      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="html">&lt;!-- 子组件 --&gt;  &lt;common-card title=&quot;今日交易用户数&quot; :value=&quot;1234567890&quot;&gt;    &lt;template&gt;      &lt;v-chart :options=&quot;getOptions()&quot; /&gt;    &lt;/template&gt;    &lt;template v-slot:footer&gt;      &lt;span&gt;退货率&lt;/span&gt;      &lt;span class=&quot;emphasis&quot;&gt;12%&lt;/span&gt;    &lt;/template&gt;  &lt;/common-card&gt;</code></pre><h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote><p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p></blockquote><blockquote><p>常用于父组件与子组件的通信<br>对象语法选项包括:</p></blockquote><p>1、type：原生构造函数的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。</p><p>2、default: any 默认值</p><p>3、required:Boolean 该prop是否是必填项</p><p>4、validator: Function 校验函数</p><pre><code class="js">  props: &#123;    // 检测类型    title: String,    // 检测类型 + 其他验证    age: &#123;      type: Number, //类型      default: 0,// 默认值      required: true,// 是否是必填项      // 校验函数      validator: function (value) &#123;        return value &gt;= 0      &#125;    &#125;  &#125;</code></pre><h1 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h1><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote><p>1、实现原理</p><blockquote><p>将用户传入的对象与 Vue 自身的options属性合并，合并后的对象将会覆盖原来的Vue.options。因为 mixin 方法修改了Vue.options属性，之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。</p></blockquote><p>注意：如果用户传入的对象与组件有相同的数据对象，将会发生合并，并且遵循组件数据优先的原则。对于钩子函数来说，如果相同，将会合并为一个数组，所以都会被调用，只是混入对象的钩子会被先调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><pre><code class="js">// vue源码 vue/src/core/global-api/mixin.jsimport &#123; mergeOptions &#125; from &#39;../util/index&#39;export function initMixin (Vue: GlobalAPI) &#123;  Vue.mixin = function (mixin: Object) &#123;    this.options = mergeOptions(this.options, mixin)    return this  &#125;&#125;</code></pre><p>2、如何理解mixin?</p><p>可以将mixin理解为数组，数组中有单个或者多个mixin，mixin的本质就是js对象，拥有Vue实例的所有属性，例如：data,created,methods等，还可以在mixin中再次嵌套mixin</p><p>注意：在组件中引入的方式为 <code>mixins:[myMixin]</code></p><p>3、mixin的实现</p><blockquote><p>当Vue在实例的时候，会调用mergeOptions函数进行options的合并</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// vue源码 core/util/options.jsexport function mergeOptions(  parent: Object,  child: Object,  vm?: Component): Object &#123;  ...  // 如果有 child.extends 递归调用 mergeOptions 实现属性拷贝  const extendsFrom = child.extends  if (extendsFrom) &#123;    parent = mergeOptions(parent, extendsFrom, vm)  &#125;  // 如果有 child.mixins 递归调用 mergeOptions 实现属性拷贝  if (child.mixins) &#123;    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;      parent = mergeOptions(parent, child.mixins[i], vm)    &#125;  &#125;  // 申明 options 空对象，用来保存属性拷贝结果  const options = &#123;&#125;  let key  // 遍历 parent 对象，调用 mergeField 进行属性拷贝  for (key in parent) &#123;    mergeField(key)  &#125;  // 遍历 child 对象，调用 mergeField 进行属性拷贝  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123;      mergeField(key)    &#125;  &#125;  // 属性拷贝实现方法 mergeField 函数接收一个 key，首先会申明 strat 变量，如果 strats[key] 为真，就将 strats[key] 赋值给 strat。  function mergeField(key) &#123;    // 穿透赋值，默认为 defaultStrat    const strat = strats[key] || defaultStrat    options[key] = strat(parent[key], child[key], vm, key)  &#125;  return options&#125;</code></pre></details><blockquote><p>vue 中 mixins 的优先级，component &gt; mixins &gt; extends。</p></blockquote><h1 id="边界处理：inject-provide"><a href="#边界处理：inject-provide" class="headerlink" title="边界处理：inject/provide"></a>边界处理：inject/provide</h1><p>类型：</p><blockquote><p>provide：Object | () =&gt; Object</p></blockquote><blockquote><p>inject：Array<string> | { [key: string]: string | Symbol | Object }</p></blockquote><p>provide和inject需要一起使用，可以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件的层次有多深，并在其上下游关系成立的时间里始终生效。</p><p>同react的上下文特性相似</p><details><summary>点击展示代码</summary><pre><code class="js">// 父级组件提供 &#39;foo&#39;var Provider = &#123;  provide: &#123;    foo: &#39;bar&#39;  &#125;,  // ...&#125;// 子组件注入 &#39;foo&#39;var Child = &#123;  inject: [&#39;foo&#39;],  created () &#123;    console.log(this.foo) // =&gt; &quot;bar&quot;  &#125;  // ...&#125;</code></pre></details><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单的说，vuex就是一个状态管理器。</p></blockquote><p>开发过程，通常会遇到多个视图依赖同一个状态，不同视图的行为需要变更为同一状态（例如：后台管理系统的侧边栏的收缩功能。）</p><p>Vuex的核心就是store，它就是一个仓库容器，包含了驱动应用的数据源（state），不同于单纯的全局对象，vuex的状态存储是响应式的，当 Vue组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOMContentLoaded</title>
      <link href="/2019/08/18/DOMContentLoaded/"/>
      <url>/2019/08/18/DOMContentLoaded/</url>
      
        <content type="html"><![CDATA[<p>DOMContentLoaded顾名思义就是DOM内容加载完毕。</p><span id="more"></span><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 这里有一个常见的错误，就是在本应使用 DOMContentLoaded 会更加合适的情况下，却选择使用 load，所以要谨慎。<br>注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。</p><p>在Vue项目的App.vue中，我们可以这样设置字体。</p><p>1、获取HTML元素；</p><p>2、根据屏幕宽度动态计算fontSize</p><p>3、当fontSize大于50时，设置最大值为50</p><p>4、设置HTML的fontSize属性，使rem生效，1rem = fontSize + “px”</p><pre><code class="js">&lt;script&gt;// DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。  document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;    // 获取html元素    const html = document.querySelector(&#39;html&#39;)    // 根据屏幕宽度动态计算fontSize    let fontSize = window.innerWidth / 10    // 当fontSize大于50时，设置最大值为50    fontSize = fontSize &gt; 50 ? 50 : fontSize    // 设置html的fontSize属性，使rem生效，1rem = fontSize + &#39;px&#39;    html.style.fontSize = fontSize + &#39;px&#39;  &#125;)&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用CSS画三角形?</title>
      <link href="/2019/06/20/css/"/>
      <url>/2019/06/20/css/</url>
      
        <content type="html"><![CDATA[<p>三角形的画法,一般经常使用三角形作为提示框、下拉菜单等功能。</p><span id="more"></span><p>实现方式：</p><p>1、HTML结构</p><pre><code class="html">&lt;div class=&quot;item0&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item3&quot;&gt;&lt;/div&gt;</code></pre><p>2、将类名为item的块级元素的width、height设置为0</p><pre><code class="css">.item0&#123;    width:0;    height:0;&#125;</code></pre><p>3、将类名为item的元素的3个border的颜色设置为transparent，箭头指向的对面border设置颜色；</p><pre><code class="css">.item0&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 50px solid transparent;    border-top: 50px solid transparent;    border-bottom: 80px solid blue;    background: white;&#125;</code></pre><p>上面的为方向向上的三角形<br>4、依次类推可以画出方向向左、右、下的三角形</p><pre><code class="css">.item1&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 50px solid transparent;    border-top: 80px solid green;    border-bottom: 50px solid transparent;    background: white;&#125;.item2&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 80px solid violet;    border-top: 50px solid transparent;    border-bottom: 50px solid transparent;    background: white;&#125;.item3&#123;    width: 0px;    height: 0px;    border-left: 80px solid purple;    border-right: 50px solid transparent;    border-top: 50px solid transparent;    border-bottom: 50px solid transparent;    background: white;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和栈、变量复制、深拷贝与浅拷贝</title>
      <link href="/2019/05/25/stack-heap/"/>
      <url>/2019/05/25/stack-heap/</url>
      
        <content type="html"><![CDATA[<p>栈（stack）：主要存放的是基本类型的变量和对象的应用，其优势是存储速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。   </p><p>堆（heap）：用于引用类型（复杂数据类型：如数组对象、object对象）分配空间，运行时动态分配内存，存储速度较慢。</p><span id="more"></span><p>JavaScript中，内存分为三种类型：代码空间、栈空间、堆空间，其中代码空间用于存放可执行代码。</p><h2 id="一、堆栈内存空间"><a href="#一、堆栈内存空间" class="headerlink" title="一、堆栈内存空间"></a>一、堆栈内存空间</h2><h3 id="1、栈内存空间"><a href="#1、栈内存空间" class="headerlink" title="1、栈内存空间"></a>1、栈内存空间</h3><blockquote><p>用栈作为数据结构在内存中所申请的空间。</p></blockquote><h3 id="2、栈的特点："><a href="#2、栈的特点：" class="headerlink" title="2、栈的特点："></a>2、栈的特点：</h3><p>1、后进先出，最后添加进栈的元素最先出</p><p>2、访问栈底元素，必须拿掉它上面的元素</p><p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5631876df7b34b1cbe19f10ff5fe7b1a~tplv-k3u1fbpfcp-watermark.awebp"></image></p><p>js7种基本数据类型变量保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。</p><h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><blockquote><p>闭包中的基本数据类型变量是保存在堆内存里的，当函数执行完弹出调用栈后，返回内部函数的一个应用，这时候函数的变量就会转移到堆上，因此内部函数依然能访问到上一层函数的变量。</p></blockquote><h2 id="二、堆内存空间"><a href="#二、堆内存空间" class="headerlink" title="二、堆内存空间"></a>二、堆内存空间</h2><blockquote><p>用堆作为数据结构在内存中所申请的空间。<br>通常情况下，我们所说的堆数据结构指的就是二叉堆。</p></blockquote><h3 id="1、二叉堆的特点："><a href="#1、二叉堆的特点：" class="headerlink" title="1、二叉堆的特点："></a>1、二叉堆的特点：</h3><p>1、它是一颗完全二叉树</p><p>2、二叉堆不是最小堆就是最大堆</p><h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><blockquote><p>引用数据类型存储在堆内存中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。<br>引用数据类型会在栈中存储一个指针，这个指针指向堆内存空间中该实体的起始地址。<br>当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后，从堆中获得实体。</p></blockquote><pre><code class="js">// 基本数据类型-栈内存let name = &quot;大白&quot;;// 基本数据类型-栈内存let age = 20;// 基本数据类型-栈内存let info = null;// 对象指针存放在栈内存中，指针指向的对象放在堆内存中let msgObj = &#123;msg: &quot;测试&quot;, id: 5&#125;;// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中let ages = [19, 22, 57]</code></pre><p>上面代码中：</p><pre><code>1、创建了两个变量msgObj、ages，它们的值都是引用类型(object、array)2、堆内存空间采用二叉堆作为数据结构，msgObj与ages的具体值会存在堆内存空间中3、存储完成后，堆内存空间会返回这两个值的引用地址(指针)4、拿到引用地址后，这个引用地址会和它的变量名对应起来，存放在栈内存空间中5、在查找变量msgObj与ages的具体值时，会先从栈内存空间中获取它的引用地址6、获取到引用地址后，通过引用地址在堆内存空间的二叉堆中查找到对应的值。</code></pre><p>堆内存空间中的object，表示的是存储在空间中的其他对象的引用值</p><p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18fbd5bf395a42e5b6757c84a4768be7~tplv-k3u1fbpfcp-watermark.awebp"></image></p><h3 id="3、栈内存空间与堆内存的区别"><a href="#3、栈内存空间与堆内存的区别" class="headerlink" title="3、栈内存空间与堆内存的区别"></a>3、栈内存空间与堆内存的区别</h3><blockquote><p>堆内存空间：相当于一个采用二叉堆作为数据结构的容器。<br>堆内存：指的是一个引用类型的具体值<br>堆内存存在于堆内存空间中</p></blockquote><h2 id="三、变量复制"><a href="#三、变量复制" class="headerlink" title="三、变量复制"></a>三、变量复制</h2><h3 id="1、基本数据类型的复制"><a href="#1、基本数据类型的复制" class="headerlink" title="1、基本数据类型的复制"></a>1、基本数据类型的复制</h3><p>下面代码中，name、alias都是基本类型，值存储在栈内存，分别有各自独立的栈空间，因此修改了alias的值，name是不受影响的。</p><pre><code class="js">let name =&#39;jude&#39;let alias = namealias = &#39;summer&#39;console.log(name) // judeconsole.log(alias) // summer</code></pre><p>相当于复制前是这样的：</p><blockquote><p>name | jude</p></blockquote><p>复制后：</p><blockquote><p>alias | jude<br>name  | jude</p></blockquote><p>修改后:</p><blockquote><p>alias | summer<br>name  | jude</p></blockquote><h3 id="2、引用类型的复制"><a href="#2、引用类型的复制" class="headerlink" title="2、引用类型的复制"></a>2、引用类型的复制</h3><p>下面代码中，info、book都是引用类型，它们引用存在栈内存，值存在堆内存，它们的值指向同一块堆内存，栈内存中会复制一份相同的引用。</p><pre><code class="js">let book = &#123;title:&#39;book&#39;,id:1&#125;let info = bookinfo.title = &#39;javascript&#39;console.log(book.title) // javascript</code></pre><h2 id="四、深拷贝与浅拷贝"><a href="#四、深拷贝与浅拷贝" class="headerlink" title="四、深拷贝与浅拷贝"></a>四、深拷贝与浅拷贝</h2><h3 id="1、浅拷贝："><a href="#1、浅拷贝：" class="headerlink" title="1、浅拷贝："></a>1、浅拷贝：</h3><blockquote><p>引用数据类型在复制时，改了其中一个数据的值，另一个数据的值也会跟着改变，这种拷贝方式我们称为浅拷贝。</p></blockquote><h4 id="1-1-Object-asign"><a href="#1-1-Object-asign" class="headerlink" title="1.1 Object.asign()"></a>1.1 Object.asign()</h4><blockquote><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p></blockquote><pre><code class="js">let obj1 = &#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;,sports:&#39;basketball&#39; &#125;;let obj2 = Object.assign(&#123;&#125;, obj1);obj2.person.name = &quot;wade&quot;;obj2.sports = &#39;football&#39;console.log(obj1); // &#123; person: &#123; name: &#39;wade&#39;, age: 41 &#125;, sports: &#39;basketball&#39; &#125;</code></pre><h4 id="1-2-扩展运算符"><a href="#1-2-扩展运算符" class="headerlink" title="1.2 扩展运算符"></a>1.2 扩展运算符</h4><pre><code class="js">let obj1 = &#123; name: &#39;Kobe&#39;, address:&#123;x:100,y:100&#125;&#125;let obj2= &#123;... obj1&#125;obj1.address.x = 200;obj1.name = &#39;wade&#39;console.log(&#39;obj2&#39;,obj2) // obj2 &#123; name: &#39;Kobe&#39;, address: &#123; x: 200, y: 100 &#125; &#125;</code></pre><h4 id="1-3-Array-prototype-concat-Array-ptototype-slice"><a href="#1-3-Array-prototype-concat-Array-ptototype-slice" class="headerlink" title="1.3 Array.prototype.concat()/Array.ptototype.slice()"></a>1.3 Array.prototype.concat()/Array.ptototype.slice()</h4><pre><code class="js">let arr = [1, 3, &#123;    username: &#39;kobe&#39;&#125;];let arr2 = arr.concat();    arr2[2].username = &#39;wade&#39;;console.log(arr); //[ 1, 3, &#123; username: &#39;wade&#39; &#125; ]let arr = [1, 3, &#123;    username: &#39; kobe&#39;&#125;];let arr3 = arr.slice();arr3[2].username = &#39;wade&#39;console.log(arr); // [ 1, 3, &#123; username: &#39;wade&#39; &#125; ]</code></pre><h3 id="2、深拷贝："><a href="#2、深拷贝：" class="headerlink" title="2、深拷贝："></a>2、深拷贝：</h3><blockquote><p>引用类型复制到新的变量后，二者是独立的，不会因为一个的改变而影响到另一个<br>实际上就是重新在堆内存中开辟一块新的空间，把原对象的数据拷贝到这个新地址空间里来</p></blockquote><h4 id="2-1-深拷贝方法1："><a href="#2-1-深拷贝方法1：" class="headerlink" title="2.1 深拷贝方法1："></a>2.1 深拷贝方法1：</h4><blockquote><p>将对象转一遍JSON，缺点是只能转化一般常见的数据，function、undefined、正则等类型无法通过这种方法变回来。</p></blockquote><pre><code class="js">const data = &#123; name: &quot;jude&quot; &#125;;const obj = JSON.parse(JSON.stringify(data));obj.age = 20;console.log(&quot;data = &quot;, data);// data = &#123; name:&quot;jude&quot;&#125;console.log(&quot;obj = &quot;, obj);// obj = &#123;name:&#39;jude&#39;,age:20&#125;</code></pre><h4 id="2-2-深拷贝方法2："><a href="#2-2-深拷贝方法2：" class="headerlink" title="2.2 深拷贝方法2："></a>2.2 深拷贝方法2：</h4><blockquote><p>手动去写循环遍历</p></blockquote><pre><code class="js">const data = [&#123; name: &quot;jude&quot; &#125;];let obj = data.map(item =&gt; item);obj.push(&#123; name: &quot;summer&quot; &#125;);console.log(&quot;data = &quot;, data);// data = [&#123;name:&#39;jude&#39;&#125;]console.log(&quot;obj = &quot;, obj);// obj = [&#123;name:&#39;jude&#39;,name:&#39;summer&#39;&#125;]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序checkbox-group</title>
      <link href="/2019/01/20/check-group/"/>
      <url>/2019/01/20/check-group/</url>
      
        <content type="html"><![CDATA[<p>checkbox-group多项选择器，内部由多个checkbox组成；<br>主要的属性bindchange   说明checkbox-group中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]};</p><span id="more"></span><pre><code class="html">&lt;checkbox-group  class=&quot;checkbox_group&quot; bindchange=&quot;checkboxChange&quot;&gt;    &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;item&quot;&gt;        &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot;  checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot; /&gt;        &#123;&#123;item.value&#125;&#125;    &lt;/label&gt;&lt;/checkbox-group&gt;</code></pre><p>每一次修改选中项，都需要一个空数组去存放选中项。</p><details><summary>点我展示代码</summary><pre><code class="js">  checkboxChange(e) &#123;    const items = this.data.items;     const values = e.detail.value;    // 设置选中的数组为空  选中的id push到数组里面    this.data.vehicle_arr = [];    for (let i = 0, lenI = items.length; i &lt; lenI; ++i) &#123;      items[i].checked = false // 遍历items，让所有的选中状态都为false      for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123;        if (items[i].value === values[j]) &#123;          items[i].checked = true;          const List = items[i].name.toString().split();          for (let k in List) &#123;            this.data.vehicle_arr.push(List[k]);          &#125;        &#125;      &#125;    &#125;    // 选中的id    this.data.unique = [...new Set(this.data.vehicle_arr)];    this.setData(&#123;      driverarr: e.detail.value.join(&quot;,&quot;), // 多选的数组      items,    &#125;);  &#125;,</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2019/01/02/hello-world/"/>
      <url>/2019/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>hexo常用命令</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><pre><code class="js">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><pre><code class="js">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成本地静态文件"><a href="#生成本地静态文件" class="headerlink" title="生成本地静态文件"></a>生成本地静态文件</h3><pre><code class="js">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!-- 打包上传发布命令 --><p>打包发布的命令行可以直接这样写：</p><pre><code class="bash">hexo g &amp;&amp; hexo d</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

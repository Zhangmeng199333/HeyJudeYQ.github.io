<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webp格式的图片</title>
      <link href="/2022/01/24/image-host/"/>
      <url>/2022/01/24/image-host/</url>
      
        <content type="html"><![CDATA[<p>将本地图片上传到个人GitHub image-host 转换成webp格式。</p><span id="more"></span><h3 id="1、什么是webp？"><a href="#1、什么是webp？" class="headerlink" title="1、什么是webp？"></a>1、什么是webp？</h3><blockquote><p>WebP is  是由 Google 公司开发的一种可提供有损和无损压缩的图片格式，支持透明度，目前已支持动图。</p></blockquote><h3 id="2、PicX图床的使用"><a href="#2、PicX图床的使用" class="headerlink" title="2、PicX图床的使用"></a>2、PicX图床的使用</h3><p>PicX 是一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了。</p><p>配置链接：<a href="https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE">https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE</a></p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.1fp31abnh9sw.webp"></image></p><p>将本地图片上传至图床，上床成功后的图片会生成一个GitHub外链和cdn外链。</p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.27ywn4r0zskk.webp"></image></p>]]></content>
      
      
      
        <tags>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用装饰器descriptor</title>
      <link href="/2022/01/20/decorator/"/>
      <url>/2022/01/20/decorator/</url>
      
        <content type="html"><![CDATA[<p>decorator装饰器通过对类、对象、方法、属性进行修饰，对其添加一些其他行为，即对一段代码进行二次包装。</p><span id="more"></span><p>使用方法：</p><pre><code class="js">const decorator = (target,name,descriptor) =&gt; &#123;  var oldValue = descriptor.value  descriptor.value = function()&#123;    return oldValue.apply(this,arguments)  &#125;  return descriptor&#125;</code></pre><p>然后直接@descriptor到函数、类或者对象上即可。使用装饰器可以不需要关注代码内部的实现，增强了代码的可读性。</p><p>vue中使用装饰器：</p><p>项目中使用eslint，需要开启装饰器相关语法的检测。</p><pre><code class="js">// .eslintrc.js  parserOptions: &#123;    parser: &#39;babel-eslint&#39;,    ecmaFeatures:&#123;      legacyDecorators: true    &#125;  &#125;,</code></pre><p>Vue项目二次弹窗进行取消操作：</p><p>1、工具函数decorator.js</p><pre><code class="js">// 需安装element-uiimport &#123; MessageBox, Message &#125; from &#39;element-ui&#39;export function confirm (title, content, confirmButtonText = &#39;确定&#39;) &#123;  return function(target, name, descriptor) &#123;    const originValue = descriptor.value    descriptor.value = function(...args) &#123;      MessageBox.confirm(content, title, &#123;        dangerouslyUseHTMLString: true,        distinguishCancelAndClose: true,        confirmButtonText: confirmButtonText      &#125;).then(originValue.bind(this, ...args)).catch(error =&gt; &#123;        if (error === &#39;close&#39; || error === &#39;cancel&#39;) &#123;          Message.info(&#39;用户取消操作&#39;)        &#125; else &#123;          Message.info(error)        &#125;      &#125;)    &#125;    return descriptor  &#125;&#125;</code></pre><p>2、页面引入装饰器函数</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;about&quot;&gt;    &lt;h1&gt;This is an about page&lt;/h1&gt;    &lt;p&gt;装饰器&lt;/p&gt;    &lt;button @click=&#39;test&#39;&gt;confirm&lt;/button&gt;&lt;button&gt;cancel&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">import &#123; confirm &#125; from &#39;./decorator.js&#39;export default &#123;  name: &#39;about&#39;,  methods: &#123;    @confirm(&#39;删除&#39;, &#39;确认删除?&#39;)    test () &#123;      this.$message.success(&#39;success!!&#39;)    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountTo:数字动态滚动</title>
      <link href="/2022/01/13/count-to/"/>
      <url>/2022/01/13/count-to/</url>
      
        <content type="html"><![CDATA[<p>vue使用vue-count-to实现数字的动态滚动功能。</p><span id="more"></span><pre><code class="js">npm isntall vue-count-to// 2、组件内引入、注册 startVal endVal 类型为Number</code></pre><pre><code class="html">&lt;template&gt;  &lt;countTo :startVal=&#39;startVal&#39; :endVal=&#39;number&#39; :duration=&#39;3000&#39; :decimals=&#39;0&#39;  :autoplay=true&gt;&lt;/countTo&gt;&lt;/template&gt;&lt;script&gt;import countTo from &#39;vue-count-to&#39;;  export default&#123;    components:&#123;countTo&#125;,    props:&#123;      number: [Number, String],      startVal:&#123;        type:Number,        default:0      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用hls.js处理m3u8格式的视频</title>
      <link href="/2022/01/08/hls/"/>
      <url>/2022/01/08/hls/</url>
      
        <content type="html"><![CDATA[<p>m3u8文件是指UTF-8编码格式的m3u文件。m3u文件是记录了一个索引纯文本文件,打开它时播放软件并不是播放它,而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。</p><span id="more"></span><blockquote><p>HLS 与 M3U8 HLS(全称:Http Live Streaming)是由Apple公司定义的用于实时流传输的协议</p></blockquote><p>1、安装hls.js插件或者使用CDN引入</p><pre><code class="bash">npm install hls.js --save</code></pre><pre><code class="js">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;2、业务代码```html        &lt;video          ref=&quot;video&quot;          id=&quot;myVideo2&quot;          class=&quot;video-js vjs-default-skin vjs-big-play-centered&quot;          autoplay=&quot;autoplay&quot;          controls          style=&quot;width: 100%; height: 280px; margin-top: 5px&quot;        &gt;&lt;/video&gt;</code></pre><pre><code class="js">import Hls from &quot;hls.js&quot;export default&#123;  data()&#123;    return&#123;      hls:null    &#125;  &#125;,  methods:&#123;    getStream(source)&#123;      if(Hls.isSupported())&#123;        this.hls = new Hls()        this.hls.loadSource(source);        this.hls.attachMedia(this.$refs.video);        this.hls.on(Hls.Events.MANIFEST_PARSED, () =&gt; &#123;          this.$refs.video.play();        &#125;);        this.hls.on(Hls.Events.ERROR, (event, data) =&gt; &#123;          this.$message(&quot;视频加载失败&quot;);        &#125;);      &#125;    &#125;  &#125;,  // 从接口获取的视频资源应当写在mounted里面，否则容易出现进入视频页面的时候，视频加载不出来的现象  mounted()&#123;    this.$service.get(&quot;demo/test&quot;).then(res =&gt;&#123;      this.getStream(res.data[1].hls);    &#125;)  &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用hook处理组件内定时器</title>
      <link href="/2022/01/01/hook/"/>
      <url>/2022/01/01/hook/</url>
      
        <content type="html"><![CDATA[<p>vue 项目使用 hook 处理组件内定时器的方式。</p><span id="more"></span><blockquote><p>通常处理组件内定时器的步骤是：</p></blockquote><pre><code class="js">export default&#123;    mounted()&#123;        this.timer = setInterval（() =&gt;&#123;            // do something        &#125;,1000）    &#125;,    beforeDestory()&#123;        clearInterval(this.timer);    &#125;&#125;</code></pre><blockquote><p>使用 hook 可以更好的处理</p></blockquote><pre><code class="js">export default&#123;    mounted()&#123;        const timer = setInterval(() =&gt; &#123;            // do something        &#125;,1000);        this.$once(&#39;hook:beforeDestory&#39;,()=&gt; clearInterval(timer);)    &#125;&#125;</code></pre><blockquote><p>适用场景:</p></blockquote><p>处理可视化图表的时候，我们需要在数据渲染到页面之前让页面有 loading 动画，mounted 挂载之后停止 loading，beforeUpdate 时开始 loading，updated 之后停止 loading。</p><p>使用 hook 处理:</p><pre><code class="js">&lt;v-chart&gt;  @hook:mounted=&quot;loading = false&quot; @hook:beforeUpdated=&quot;loading = true&quot;  @hook:updated=&quot;loading = false&quot; :data=&quot;data&quot;&lt;/v-chart&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交规范</title>
      <link href="/2021/12/22/git/"/>
      <url>/2021/12/22/git/</url>
      
        <content type="html"><![CDATA[<p>使用commitizen和cz-customizable规范代码提交</p><span id="more"></span><h3 id="1-安装commitizen和cz-customizable"><a href="#1-安装commitizen和cz-customizable" class="headerlink" title="1.安装commitizen和cz-customizable"></a>1.安装commitizen和cz-customizable</h3><pre><code class="js">npm install -g commitizen@4.2.4npm i cz-customizable@6.3.0 --save-dev</code></pre><h3 id="2-在package-json中进行新增"><a href="#2-在package-json中进行新增" class="headerlink" title="2.在package.json中进行新增"></a>2.在package.json中进行新增</h3><pre><code class="js">&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;  &#125;&#125;</code></pre><h3 id="3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit"><a href="#3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit" class="headerlink" title="3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit"></a>3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit</h3><h3 id="4-使用husky进行强制git代码提交规范"><a href="#4-使用husky进行强制git代码提交规范" class="headerlink" title="4.使用husky进行强制git代码提交规范"></a>4.使用husky进行强制git代码提交规范</h3><pre><code class="js">npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4npm install husky@7.0.1 --save-devnpx husky install</code></pre><h3 id="5-在package-json中新增指令"><a href="#5-在package-json中新增指令" class="headerlink" title="5.在package.json中新增指令"></a>5.在package.json中新增指令</h3><pre><code class="js">&quot;prepare&quot;: &quot;husky install&quot;</code></pre><h3 id="6-并执行"><a href="#6-并执行" class="headerlink" title="6.并执行"></a>6.并执行</h3><pre><code class="js">npm run prepare</code></pre><h3 id="7-新增husky配置文件-并往里面写入"><a href="#7-新增husky配置文件-并往里面写入" class="headerlink" title="7.新增husky配置文件 并往里面写入"></a>7.新增husky配置文件 并往里面写入</h3><pre><code class="js">npx husky add .husky/commit-msgnpx --no-install commitlint --edit</code></pre><h3 id="8、husky规范"><a href="#8、husky规范" class="headerlink" title="8、husky规范"></a>8、husky规范</h3><pre><code class="js">// commitlint.config.jsmodule.exports = &#123;  // 继承的规则  extends: [&#39;@commitlint/config-conventional&#39;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;, // 新功能 feature        &#39;fix&#39;, // 修复 bug        &#39;docs&#39;, // 文档注释        &#39;style&#39;, // 代码格式(不影响代码运行的变动)        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)        &#39;perf&#39;, // 性能优化        &#39;test&#39;, // 增加测试        &#39;chore&#39;, // 构建过程或辅助工具的变动        &#39;revert&#39;, // 回退        &#39;build&#39; // 打包      ]    ],    // subject 大小写不做校验    &#39;subject-case&#39;: [0]  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义input唤起键盘</title>
      <link href="/2021/10/20/input/"/>
      <url>/2021/10/20/input/</url>
      
        <content type="html"><![CDATA[<p>自定义 input 唤起键盘。移动端页面自定义 input 唤起键盘 return，有时需要将换行键改为搜索，为了达到更好的用户体验。<br>在 html5 中，我们可以将 input 的 type 修改为 search，这样修改之后，我们的安卓手机会变成搜索或者搜索符号、IOS 则会变成换行。</p><span id="more"></span><p>1、安卓手机</p><pre><code class="html">&lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot; /&gt;</code></pre><p>2、苹果 IOS 手机</p><p>与安卓手机不同的是，我们需要在外层包裹一个 form</p><pre><code class="html">    &lt;from action=&quot;javascript:return true&quot;&gt;        &lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot;&gt;    &lt;/form&gt;</code></pre><p>3、修改 search 的默认样式</p><pre><code class="css">input[type=&quot;search&quot;] &#123;  -webkit-appearance: none;&#125;input::-webkit-search-cancel-button &#123;  display: none; // 关闭按钮&#125;</code></pre><p>4、禁止输入法弹出的方法</p><blockquote><p>readonly 属性的使用</p></blockquote><p>点击输入框触发 focus 事件弹出时间 picker，将选择的开始时间、结束时间都显示在输入框里，这里加入只读 readonly 属性可以避免输入法的弹出。</p><pre><code class="html">&lt;input v-model=&quot;startDate&quot; readonly @focus=&quot;openStartPicker&quot; /&gt;&lt;input v-model=&quot;endDate&quot; readonly @focus=&quot;openEndPicker&quot; /&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>websocket实现客户端和服务端的通信</title>
      <link href="/2021/09/20/websocket/"/>
      <url>/2021/09/20/websocket/</url>
      
        <content type="html"><![CDATA[<p>传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。</p><span id="more"></span><p>初始化websocket<br>1、创建websocket实例，参数为url<br>2、连接 websocket.onopen<br>3、server响应数据触发 websocket.onmessage<br>4、关闭websocket，websocket.onclose</p><pre><code class="js">// 构造函数 参数为urlconst wsurl = &quot;ws://localhost:8080&quot;;var ws = new Websocket(wsurl);// 连接状态readState 1  准备好发送和接受数据了ws.onopen = function()&#123;  ws.send(&#39;hello server! websocket is open now!&#39;)&#125;// 通过客户端的事件   发送信息给服务端ws.send(&#39;hello websocket&#39;);// 发生错误ws.onerror = function(event)&#123;  console.log(&quot;websocket error observed&quot;,event)&#125;// readState CLOSED  关闭websocketws.onclose = function(event)&#123;  let status_code = event.status;  let msg = event.msg;  console.log(&quot;websocket is closed now&quot;)&#125;// 响应数据的接收ws.onmessage = function(event)&#123;  let data = event.data;&#125;</code></pre><ul><li>路由改变，需要断开websocket连接，节省服务器开支。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识egg.js</title>
      <link href="/2021/06/20/egg/"/>
      <url>/2021/06/20/egg/</url>
      
        <content type="html"><![CDATA[<p>egg.js的使用</p><span id="more"></span><h3 id="1、创建-启动项目"><a href="#1、创建-启动项目" class="headerlink" title="1、创建/启动项目"></a>1、创建/启动项目</h3><p>直接使用下面的方式，无法创建项目</p><pre><code class="js">// 无法创建项目npm init egg --type=simple// 需要在后面指定淘宝源npm init egg --type=simple -r=https://registry.npm.taobao.orgnpm run dev</code></pre><h3 id="2、内置的ctx对象"><a href="#2、内置的ctx对象" class="headerlink" title="2、内置的ctx对象"></a>2、内置的ctx对象</h3><blockquote><p>ctx这个对象非常重要，请求来的参数，返回去的消息都需要通过ctx这个对象获取或者设置</p></blockquote><blockquote><p>ctx是继承koa的context对象通过设置ctx.body， 可以改变返回信息</p></blockquote><pre><code class="js">ctx &#123; request:    &#123; method: &#39;GET&#39;,     url: &#39;/&#39;,     header:       &#123; host: &#39;127.0.0.1:7001&#39;,        connection: &#39;keep-alive&#39;,        pragma: &#39;no-cache&#39;,        &#39;cache-control&#39;: &#39;no-cache&#39;,        &#39;sec-ch-ua&#39;: &#39;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#39;,        &#39;sec-ch-ua-mobile&#39;: &#39;?0&#39;,        &#39;sec-ch-ua-platform&#39;: &#39;&quot;macOS&quot;&#39;,        &#39;upgrade-insecure-requests&#39;: &#39;1&#39;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&#39;,        accept: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,        &#39;sec-fetch-site&#39;: &#39;none&#39;,        &#39;sec-fetch-mode&#39;: &#39;navigate&#39;,        &#39;sec-fetch-user&#39;: &#39;?1&#39;,        &#39;sec-fetch-dest&#39;: &#39;document&#39;,        &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,        &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,        cookie: &#39;csrfToken=DpyybUjAh9JRzrCgx3itQifi&#39; &#125; &#125;,  response: &#123; status: 404, message: &#39;Not Found&#39;, header: &#123;&#125; &#125;,  app:    &#123; env: &#39;local&#39;,     name: &#39;eggjs&#39;,     baseDir: &#39;/Users/yq/Desktop/express&#39;,     subdomainOffset: 2,     config: &#39;&lt;egg config&gt;&#39;,     controller: &#39;&lt;egg controller&gt;&#39;,     httpclient: &#39;&lt;egg httpclient&gt;&#39;,     loggers: &#39;&lt;egg loggers&gt;&#39;,     middlewares: &#39;&lt;egg middlewares&gt;&#39;,     router: &#39;&lt;egg router&gt;&#39;,     serviceClasses: &#39;&lt;egg serviceClasses&gt;&#39; &#125;,  originalUrl: &#39;/&#39;,  req: &#39;&lt;original node req&gt;&#39;,  res: &#39;&lt;original node res&gt;&#39;,  socket: &#39;&lt;original node socket&gt;&#39; &#125;</code></pre><h3 id="3、路由"><a href="#3、路由" class="headerlink" title="3、路由"></a>3、路由</h3><p>在controller的home.js中写一个新的路由,</p><pre><code class="js">    async list()&#123;        const &#123; ctx &#125; = this        ctx.body = &#123;            code:200,            data:[                &#123;                    id:&#39;1&#39;,                    name:&#39;jude&#39;                &#125;,                &#123;                    id:&#39;2&#39;,                    name:&#39;summer&#39;                &#125;            ],            msg:&#39;success&#39;        &#125;    &#125;</code></pre><p>在router.js中匹配新写的路由</p><pre><code class="js">    router.get(&#39;/list&#39;,controller.home.list)</code></pre><p>打开127.0.0.1:7001/list即可看到效果</p><h3 id="4、Controller控制层"><a href="#4、Controller控制层" class="headerlink" title="4、Controller控制层"></a>4、Controller控制层</h3><p>在controller新建一个user.js</p><pre><code class="js">&#39;use strict&#39;const Controller = require(&#39;egg&#39;).Controllerclass UserController extends Controller &#123;    async info()&#123;        const &#123;ctx&#125; = this        ctx.body = &#123;            code:200,            data:&#123;                id:&#39;1&#39;,                name:&quot;jude&quot;                age:29,                gender:&quot;man&quot;            &#125;            msg::&quot;success&quot;        &#125;    &#125;&#125;module.exports = UserController</code></pre><p>配置新的路由</p><pre><code class="js">router.get(&#39;/user/info&#39;,controller.user.info)</code></pre><p>打开127.0.0.1:7001/user/info 即可看到效果</p><h3 id="5、post请求及配置CSRF跨域"><a href="#5、post请求及配置CSRF跨域" class="headerlink" title="5、post请求及配置CSRF跨域"></a>5、post请求及配置CSRF跨域</h3><p>安装跨域插件</p><pre><code class="js">npm install egg-cors --save</code></pre><p>配置config下的plugin.js和config.default.js</p><pre><code>// plugin.jsmoduel.exports = &#123;    cors:&#123;        enable:true,        package:&#39;egg-cors&#39;    &#125;&#125;// config.default.jsconfig.security = &#123;    csrf:&#123;        enable:true    &#125;,    domainWhiteList:[]&#125;config.cors = &#123;    origin:&quot;*&quot;,    allowMethods:&#39;GET,PUT,POST,DELETE.PATCH&#39;&#125;</code></pre><h3 id="6、创建post请求"><a href="#6、创建post请求" class="headerlink" title="6、创建post请求"></a>6、创建post请求</h3><pre><code class="js">// user.jsasync createUser()&#123;    const &#123;ctx &#125; = this    const result = &#123;        username:ctx.request.body.username,        age:ctx.request.body.age    &#125;    ctx.body = &#123;        code:200,        data:result,        msg:&#39;success&#39;    &#125;&#125;</code></pre><p>此时，打开ApiPost工具，选择post请求，输入请求地址+参数信息，即可看到响应信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/2021/05/15/typescript/"/>
      <url>/2021/05/15/typescript/</url>
      
        <content type="html"><![CDATA[<p>typescript基础知识</p><span id="more"></span><h3 id="1、typescript的安装"><a href="#1、typescript的安装" class="headerlink" title="1、typescript的安装"></a>1、typescript的安装</h3><blockquote><p>1、安装node</p></blockquote><blockquote><p>2、安装typescript</p></blockquote><pre><code class="shell">sudo npm install typescript -g  //(mac 则需要添加sudo window则不需要)tsc -v // 查看版本号</code></pre><blockquote><p>3、hello world</p></blockquote><pre><code class="shell"># 初始化项目npm init -y# typescript配置文件tsc --init# 安装@type/node(解决模块声明问题)npm install @types/node --save-dev# 创建helloworld.ts文件touch helloworld.ts</code></pre><pre><code class="js">var a:String = &#39;hello world&#39;console.log(a)</code></pre><blockquote><p>4、将helloworld.ts转换成helloworld.js</p></blockquote><pre><code class="shell">tsc helloworld.ts  //将ts文件转换成js文件# 运行helloworld.jsnode helloworld.js  // 打印结果hello world</code></pre><h3 id="2、typescript函数的定义方式"><a href="#2、typescript函数的定义方式" class="headerlink" title="2、typescript函数的定义方式"></a>2、typescript函数的定义方式</h3><p>1、函数声明<br>    使用function和函数名来定义一个函数</p><pre><code class="ts">    function search(time:number) : string &#123;        return &#39;终于找到了丢失&#39; + time + &#39;天的dog--小七&#39;    &#125;    var time = 1    var result : string = search(time)    console.log(result)  // 终于找到了丢失一天的dog--小七</code></pre><p>2、函数表达式<br>    将函数赋值给一个变量，变量名就是函数名。通过变量名来调用函数</p><pre><code class="ts">    var Adc = function(n1:number,n2:number) : number &#123;        return n1++ + ++n2    &#125;    console.log(Adc(2,3))  // 6</code></pre><p>3、箭头函数<br>    typescript是支持ES6的。</p><pre><code class="ts">    var Jungle = (n1:number,n2:number) : number =&gt; &#123;        return n1 * n2    &#125;    console.log(Jungle(12,2) // 24</code></pre><pre><code>将ts文件转换为js文件：tsc function.ts  =&gt;  生成function.js  =&gt; 运行function.js,node function.js</code></pre><h3 id="3、typescript函数作用域"><a href="#3、typescript函数作用域" class="headerlink" title="3、typescript函数作用域"></a>3、typescript函数作用域</h3><blockquote><p>typescript也是有全局变量和局部变量的</p></blockquote><pre><code class="ts">    function star():void&#123;    var Jay = &#39;周杰伦&#39;        console.log(Jay)  // 周杰伦    &#125;    star()    console.log(star) // [Function:star]    var JayChou = &#39;周杰伦&#39;  // 此时JayChou是全局变量    function superstar():void&#123;    console.log(&#39;青花瓷是&#39; + JayChou + &#39;演唱的！&#39;) // 青花瓷是周杰伦演唱的！    &#125;    superstar()    console.log(JayChou) // 周杰伦</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119154050226-530021968.png"></p><h3 id="4、typescript数组"><a href="#4、typescript数组" class="headerlink" title="4、typescript数组"></a>4、typescript数组</h3><blockquote><p>ts中数据分为值类型和引用类型。</p></blockquote><p>1、什么是引用类型？</p><blockquote><p>引用类型是一种复合类型，引用类型中封装了很多属性，可以通过变量名和属性名来获取属性值或者调用属性的方法。</p></blockquote><pre><code class="ts">    let Jude = &#123;        name: &#39;Jude&#39;,        age: 28,        saySomething: function () &#123;            console.log(&#39;行到水穷处，坐看云起时！&#39;);        &#125;    &#125;    console.log(Jude.name) // Jude</code></pre><p>2、元祖– 一种特殊的数组</p><p>数组中允许含有多种类型的元素</p><pre><code class="ts">    let arr : [number,string]    arr = [123,&#39;123&#39;]    // console.log(arr) // [123,&#39;123]</code></pre><p>当我们写成这个样子，是会报错的</p><pre><code class="ts">    let arr : [number,sting]    arr = [&#39;123&#39;,123]</code></pre><pre><code>error1: Type &#39;string&#39; is not assignable to type &#39;number&#39;. error2: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119172755771-1404695424.png"></p><h3 id="5、typescript字符串"><a href="#5、typescript字符串" class="headerlink" title="5、typescript字符串"></a>5、typescript字符串</h3><p>1、Typescript中字符串的两种类型：</p><blockquote><p>基本类型字符串：由单引号或者双引号’包裹的’一串字符;</p></blockquote><blockquote><p>引用类型字符串：由new实例化的String类型。</p></blockquote><p>2、基本类型的字符串可以直接使用引用类型的属性和方法</p><pre><code class="ts">    let Jude: string = &#39;YQ&#39;    let JudeYQ: String = new String(&#39;JudeYQ&#39;)    console.log(Jude) // YQ    console.log(JudeYQ) // [String:&#39;JudeYQ&#39;]    // 基本类型的字符串可以直接使用引用类型的属性和方法    console.log(Jude.length) // 2    console.log(JudeYQ.length)  // 6</code></pre><p>3、字符串常用的方法</p><blockquote><p>字符串查找 indexOf()和lastIndexOf()，二者返回的都是字符串的下标。</p></blockquote><pre><code class="ts">    let word:string = &#39;西虹人瘦，燃烧我的卡路里&#39;    let Calorie: string = &#39;卡路里&#39;    console.log(word.indexOf(Calorie)) // 9    let ST:string = &#39;沈腾&#39;    console.log(word.indexOf(ST)) // -1 没有查找到返回-1    console.log(word.lastIndexOf(Calorie)) // 9 从字符串尾部开始查找字符串的位置 和indexOf（）返回的都是字符串下标</code></pre><blockquote><p>字符串的截取， substring()</p></blockquote><pre><code class="ts">    // 字符串的截取    console.log(word.substring(9)) // 卡路里    console.log(word.substring(9,12)) // 卡路里</code></pre><p>3、字符串的替换,replace()</p><pre><code class="ts">    console.log(word.replace(Calorie,&#39;腹肌&#39;))  // 西虹人瘦，燃烧我的腹肌</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组方法</title>
      <link href="/2021/05/02/array/"/>
      <url>/2021/05/02/array/</url>
      
        <content type="html"><![CDATA[<p>js常用数组方法整理</p><span id="more"></span><h3 id="1、常用数组方法"><a href="#1、常用数组方法" class="headerlink" title="1、常用数组方法"></a>1、常用数组方法</h3><details><summary>点击展示代码</summary><pre><code class="js">// 1、删除数组的最后一项  pop()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop();console.log(fruits);// &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;var x = fruits.pop();// Mango// 2、数组结尾添加一个新元素  push()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;);//&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;,&quot;Kiwi&quot;var x = fruits.push(&quot;Kiwi&quot;); // 5// 3、删除数组第一个元素    shift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift();// &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 4、数组开头返回一个新元素   返回新数组长度   unshift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;);//&quot;Lemon&quot; &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 5、删除元素 delete  会留下数组未定义的空洞  可以使用pop shift替代 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // empty,&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 6、拼接数组  splice()  第一个参数 2 定义了应添加新元素的位置   第二个参数 定义应删除多少元素  其余参数  定义要添加的新元素  返回一个包含已删除项的数组var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;, &quot;Apple&quot;, &quot;Mango&quot;fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;,// 7、删除元素 splice()  在数组中不留“空洞”的情况下移除元素var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); //&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 8、合并数组 concat()var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var myChildren = myGirls.concat(myBoys);// 9、裁剪数组 slice()   源数组不会删除任何元素   第一个参数  开始选取的元素  第二个参数  结束参数为止（不包含）var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1);// &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3);// &quot;Orange&quot;, &quot;Lemon&quot;   第2个元素 到 第4个元素  截取结果为第2个和第3个元素// 10、数组元素结合成字符串 join() 和 toString()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];fruits.join(&#39;,&#39;);// Banana,Orange,Apple,Mangofruits.toString();// Banana,Orange,Apple,Mango</code></pre></details><h3 id="2、高阶函数"><a href="#2、高阶函数" class="headerlink" title="2、高阶函数"></a>2、高阶函数</h3><p>1、forEach</p><blockquote><p>forEach()方法对数组的每个元素执行一次给定的函数。</p></blockquote><p>for example：</p><pre><code class="js">var array = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]array.forEach(e =&gt; &#123;    console.log(e)  // &#39;a&#39; &#39;b&#39; &#39;c&#39;&#125;)</code></pre><p>语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</p><p>参数介绍：</p><pre><code>callback：为数组中的每个元素执行的函数，该函数接收1~3个参数        currentValue：数组中正在处理的当前元素    index: 数组中正在处理的当前元素的索引    array: forEach()正在操作的数组   数组对象本身thisArg：可选参数。当执行回调函数callback时，用作this的值。</code></pre><p>常见用法：</p><p>（1）、稀疏数组：不对未初始化的值进行任何操作</p><pre><code class="js">const arratSpace = [1,3,,7]let numCallbackRuns = 0arratSpace.forEach(function(e)&#123;    console.log(e)    numCallbackRuns++&#125;)console.log(&quot;numCallbackRuns:&quot;,numCallbackRuns)</code></pre><p>(2)for循环转换成forEach</p><pre><code class="js">const items = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]const copy = []//for循环for(let i=0;i&lt;items.length;i++)&#123;    copey.push(itmes[i])&#125;// foeEachitems.forEach(function(itme)&#123;    copy.push(item)&#125;)</code></pre><p>(3)thisArg   使用箭头函数thisArg参数会被忽略，因为箭头函数绑定了this值</p><p>(4)对象复制器函数</p><pre><code class="js">function copy(obj)&#123;    const copy = Object.create(Object.getPrototypeOf(obj))    const propNames = Object.getOwnPropertyNames(obj)    propNames.forEach(function(name)&#123;        const desc = Object.getOwnPropertyDescriptor(obj,name)        Object.defineProperty(copy,name,desc)    &#125;)    return copy&#125;const obj1 = &#123;a:1,b:2&#125;const obj2 = copy(obj1)  // obj2看起来和obj1一模一样</code></pre><p>(5)数组在迭代时被修改了，则其他元素会被跳过</p><pre><code class="js">var words = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;];words.forEach(function(word) &#123;  console.log(word);  if (word === &#39;two&#39;) &#123;    words.shift();  &#125;&#125;);</code></pre><p>(6)promise 或 async 函数的使用</p><pre><code class="js">let ratings = [5, 4, 5];let sum = 0;let sumFunction = async function (a, b) &#123;    return a + b;&#125;ratings.forEach(async function(rating) &#123;    sum = await sumFunction(sum, rating);&#125;)console.log(sum)  // 0</code></pre><p>2、filter</p><blockquote><p>filter()创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回满足条件的新数组，不满足则返回空数组。</p></blockquote><p>for example</p><pre><code class="js">const words = [&#39;111&#39;,&#39;222&#39;,&#39;333333&#39;,&#39;4444444&#39;,&#39;55555555&#39;]const result = words.filter(word =&gt;&#123;    word.length &gt; 5&#125;)console.log(result) // 333333  4444444    55555555</code></pre><p>语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p><p>参数：<br>    callback:用来测试数组的每个元素的函数。返回true表示该元素通过测试，保留该元素，false则不保留。</p><pre><code>    element:数组中当前正在处理的元素    index:正在处理的元素在数组中的索引    array:调用filter的数组本身thisArg:执行callback时，用于this的值</code></pre><p>返回值：</p><pre><code>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</code></pre><p>用法：</p><p>（1）筛选排除所有较小的值</p><pre><code class="js">function isBig(e)&#123;    return e &gt;= 10&#125;var filterd = [3,6,9,14,32].filter(isBig)// [14,32]</code></pre><p>(2)过滤JSON中的无效条目</p><pre><code class="js">var arr = [    &#123;id:12&#125;,    &#123;id:-1&#125;,    &#123;id:0&#125;,    &#123;id:3&#125;,    &#123;id:14.4&#125;,    &#123;&#125;,    &#123;id:null&#125;,    &#123;id:NaN&#125;,    &#123;id:&#39;undefined&#39;&#125;]var entries = 0function isNumber(obj)&#123;    return obj !== undefined &amp;&amp; typeof(obj) === &#39;number&#39; &amp;&amp; !isNaN(obj)&#125;function filterID(item)&#123;    if(isNumber(item.id) &amp;&amp; item.id !== 0)&#123;        return true    &#125;    entries++    return false&#125;var arrId = arr.filter(filterID)console.log(arrId)// [&#123;id:12&#125;,&#123;id:-1&#125;,&#123;id:3&#125;,&#123;id:14.4&#125;]console.log(entries)// 5</code></pre><p>(3)在数组中搜索：根据搜索条件来过滤数组内容</p><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]function filterItems(query)&#123;    return fruits.filter(function(e)&#123;        return e.toLowerCase().indexOf(query.toLowerCase()) &gt; -1    &#125;)&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><p>上面是es5的写法，下面是es6的写法</p><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]const filterItems = (query) =&gt;&#123;    return fruits.filter((e) =&gt;        e.toLowerCase().indexOf(query,toLowerCase()) &gt; -1    )&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><p>3、map</p><blockquote><p>map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。  原数组不会改变</p></blockquote><pre><code class="js">const array = [1,2,3,4]const maps = array.map(x=&gt;x*2)console.log(maps)// 2 4 6 8</code></pre><p>用法：</p><p>(1)格式化数组中的对象</p><pre><code class="js">var array = [    &#123;key:1,value:10&#125;,    &#123;key:2,value:20&#125;,    &#123;key:3,value:30&#125;]var formatterArray = array.map(function(obj)&#123;    var o = &#123;&#125;    o[obj.key]=obj.value    return o&#125;)console.log(formatterArray) // [&#123;1:10&#125;,&#123;2:20&#125;,&#123;3:30&#125;]</code></pre><p>(2)使用包含一个参数的函数来构建一个数字数组</p><p>```js<br>var numbers = [1,4,9]<br>var double = numbers.map(function(item){<br>    return item*2<br>})<br>console.log(double) // [2,8,18]</p>]]></content>
      
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerms、Node版本管理工具、nrm等的使用方法</title>
      <link href="/2021/05/02/tool/"/>
      <url>/2021/05/02/tool/</url>
      
        <content type="html"><![CDATA[<p>一些开发过程中需要使用的工具整理</p><span id="more"></span><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>快捷键</p><pre><code>    commond + t              // 新建标签页    commond + w              // 关闭标签    commond + enter          // 切换全屏(第一次切换至全屏，再commond + enter恢复到之前窗口)     commond + 左右方向键       // 切换标签    commond + +              // 窗口和字体变大    commond + -              // 窗口和字体变小</code></pre><h2 id="Node版本管理工具"><a href="#Node版本管理工具" class="headerlink" title="Node版本管理工具"></a>Node版本管理工具</h2><p>在开发的工程中，我们可能需要经常切换node版本来应对不同的开发环境，所以需要经常使用不同版本的node。</p><p>一、安装npm插件n ,通过n模块来管理node版本</p><p>1、全局安装n模块</p><pre><code>    npm instlal -g n </code></pre><p>2、安装当前稳定版本</p><pre><code>    n stable或者sudo n stable</code></pre><p>3、安装最新版本的</p><pre><code>    n latest或者sudo n latest</code></pre><p>4、安装指定版本的node</p><pre><code>    n v8.16.0</code></pre><p>5、卸载指定的node版本</p><pre><code>    n rm v8.16.0</code></pre><p>二、使用nvm管理node版本<br>1、安装nvm </p><pre><code>    brew install nvm</code></pre><p>2、使用nvm安装node版本</p><pre><code>    // 安装最新版本    nvm isntall node    // 安装指定版本    nvm install 8.16.0</code></pre><p>3、查看所有版本</p><pre><code>    nvm ls</code></pre><p>4、切换node版本</p><pre><code>    // 使用最新版本    nvm use node           // 使用指定版本    nvm use 8.16.0</code></pre><p>通常我会使用第二种方式<br>例如：</p><p>我在一个项目中使用的是<code>node@6.13.2</code>,</p><p>新项目使用的是<code>node@8.16.0</code>,</p><p>先要安装<code>node@8.16.0   nvm install 8.16.0</code></p><p>然后<code>nvm use 8.16.0</code></p><p>5、卸载指定版本的node</p><pre><code>    nvm uninstall  v6.13.2</code></pre><p>6、设置系统默认的node版本</p><pre><code>    nvm alias default v8.16.0</code></pre><p>这样使用的node的默认版本为8.16.0</p><h2 id="nrm切换npm源"><a href="#nrm切换npm源" class="headerlink" title="nrm切换npm源"></a>nrm切换npm源</h2><p>因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。</p><p>一、切换成淘宝源</p><p>1、config命令的使用</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><p>2、命令行指定</p><pre><code>npm i node --registry https://registry.npm.taobao.org info underscore </code></pre><p>3、编辑~/.npmrc，加入以下内容：</p><pre><code>registry = https://registry.npm.taobao.org</code></pre><p>二、nrm的使用</p><blockquote><p>nrm是一个可以切换、添加/删除/测试源的工具</p></blockquote><p>1、全局安装nrm</p><pre><code>npm install -g nrm  // mac如果出现权限问题，加上sudo</code></pre><p>2、安装完成，查看所有的可用源</p><pre><code>nrm ls</code></pre><p>3、添加源</p><pre><code>nrm add 源的名称  https:// 地址</code></pre><p>4、删除原</p><pre><code>nrm del 源的名字</code></pre><p>5、切换到某个源</p><pre><code>nrm use 源的名字</code></pre><p>6、测试源速度</p><pre><code>nrm test</code></pre><p>例如，我需要使用淘宝源，只需nrm use taobao就可以了，cnpm不要使用，容易出现莫名其妙的错误。</p><h2 id="前端常用的linux命令"><a href="#前端常用的linux命令" class="headerlink" title="前端常用的linux命令"></a>前端常用的linux命令</h2><p>常用的Linux命令</p><pre><code>1、vim test.html   创建新的文件    vim + 文件名.后缀2、ls     查看当前文件夹下的文件    ls -a  列出所有文件，包括隐藏文件    ls -1  每行列出一个文件，以单列形式列出3、cat test.html  将该文件内容打印显示出来   cat test1.html   cat test2.html   cat test1.html     test2.html&gt;test3.html   cat test3.html   将多个文件合并到目标文件中。   cat test1.html   cat test2.html   cat test1.html test2.html&gt;&gt;test4.html  将几个文件附加到目录文件中4、mv   移动或重命名文件和目录mv file1.txt file2.txt   将file1文件命名为file2用法： cat 1.txt mv 1.txt 2.txt mv file1.txt file2  将file1文本移动到file2目录  5、touch  file   命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。 touch newfile6、mkdir file    创建文件夹7、cd ../  返回当前文件夹的上一层 cd /    返回到根目录下8、rm -rf folder  删除文件夹</code></pre><h2 id="eslint的配置"><a href="#eslint的配置" class="headerlink" title="eslint的配置"></a>eslint的配置</h2><p>常用的配置</p><pre><code>module.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  &#39;extends&#39;: [    &#39;plugin:vue/essential&#39;,    &#39;@vue/standard&#39;  ],  rules: &#123;    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无console.log    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无debugger    &#39;indent&#39;: &#39;off&#39;,    // 函数定义时括号前面要不要有空格    &#39;space-before-function-paren&#39;: &#39;off&#39;  &#125;,  parserOptions: &#123;    parser: &#39;babel-eslint&#39;  &#125;&#125;</code></pre><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><p>一、初始化本地仓库，提交代码，提交到远程git仓库</p><p>1、初始化代码仓库</p><pre><code>    git init</code></pre><p>2、将当前目录下的所有文件放到暂存区</p><pre><code>    git add .</code></pre><p>3、查看文件状态</p><pre><code>    git status</code></pre><p>4、添加提交的描述信息</p><pre><code>    git commit -m &quot;提交的描述信息&quot;</code></pre><p>5、远程仓库地址</p><pre><code>    git remote add origin &quot;远程仓库地址&quot;</code></pre><p>6、推送到远程仓库</p><pre><code>    git push -u origin master</code></pre><p>二、创建分支，提交代码到分支</p><p>1、创建切换分支</p><pre><code>    git checkout -b dev  dev为分支名称    git add .    git commit -m &#39;描述&#39;    git push --set-upstream origin dev1   将分支推送到远程仓库    切换到主分支    git checkout master    git merge dev  将dev合并到主分支    git push origin master  推送到远程仓库</code></pre><p>三、克隆指定分支</p><pre><code>    git clone -b master git@gitee.com:username/projectname.git    git clone -b admin git@gitee.com:username/projectname.git</code></pre><p>四、git reflog</p><pre><code>查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。</code></pre><h2 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键"></a>vscode快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>commond + B</td><td>显示/隐藏侧边栏</td></tr><tr><td>commond + shift + p</td><td>显示命令窗口</td></tr><tr><td>commond +</td><td>创建多个编辑器</td></tr><tr><td>commond + 1、2</td><td>聚焦到第1、第2个编辑器</td></tr><tr><td>commond + J 或者 Ctrl + `</td><td>显示隐藏控制台</td></tr><tr><td>commond + W</td><td>关闭当前文件</td></tr><tr><td>option + 左右方向键</td><td>单词之间移动光标</td></tr><tr><td>commond + 左右方向键</td><td>移动光标至最前、最后</td></tr><tr><td>commond + shift + \</td><td>代码块之间移动光标</td></tr></tbody></table><blockquote><p>fileheader插件的使用</p></blockquote><pre><code>commond+shift+p -&gt; fileheader -&gt; enter/* * @Author: Jude  * @Date: 2020-07-24 16:39:41  * @Last Modified by: Jude * @Last Modified time: 2020-07-24 16:40:34 */</code></pre><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><h2 id="HBuilder真机调试"><a href="#HBuilder真机调试" class="headerlink" title="HBuilder真机调试"></a>HBuilder真机调试</h2><p>1、小米手机开发者模式如何打开（MIUI 11.0.4）</p><p>步骤：设置–我的设备–全部参数–（点击）MINI版本;</p><p>2、手机连接Mac：</p><p>Mac的关于本机–系统报告–USB–你所连接的device–厂商ID</p><p>3、打开Mac终端：</p><p>在终端执行如下命令：</p><pre><code class="shell">    echo xxxxxx &gt;&gt; ~/.android/adb_usb.ini （“xxxxxx”为厂商ID);</code></pre><p>4、重启HBuilderX;</p><p>这里如果出现了问题需要切换到HBuilderX自带的adb目录；</p><p>路径为：/Applications/HBuilderX-Alpha.app/Contents/HBuilderX/plugins/launcher/tools/adbs</p><p>在adbs目录下运行Terminal，输入：</p><pre><code class="shell">    ./adb kill-server</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决点击手机虚拟返回键退出应用</title>
      <link href="/2021/03/23/back/"/>
      <url>/2021/03/23/back/</url>
      
        <content type="html"><![CDATA[<p>如何解决安卓手机点击虚拟返回键退出当前应用。</p><span id="more"></span><p>一、问题描述：</p><p>最近的项目是使用Vue全家桶+HBuilder打包开发一个移动端APP。<br>在测试的时候发现，当安卓手机使用虚拟按钮的时候，点击虚拟按钮的返回键，APP会直接退出。<br>这是因为安卓手机自带back虚拟按键，如果不修改其默认事件，点一下app就退出了，<br>所以需要修改这个按键默认事件事件的代码。</p><p>二、解决办法：</p><p>在index.html中加入一个script，加上如下代码：</p><details><summary>点我展示代码</summary><pre><code class="javascript">&lt;script&gt;    document.addEventListener(&#39;plusready&#39;, function () &#123;        var first = null;        var webview = plus.webview.currentWebview();        plus.key.addEventListener(&#39;backbutton&#39;, function () &#123;            webview.canBack(function (e) &#123;                if (e.canBack) &#123;                    webview.back(); //这里不建议修改自己跳转的路径                  &#125; else &#123;                    //首次按键，提示‘再按一次退出应用’                      if (!first) &#123;                      first = new Date().getTime(); //获取第一次点击的时间戳                        plus.nativeUI.toast(&quot;再按一次退出应用&quot;, &#123;                        duration: &#39;short&#39;                      &#125;); //通过H5+ API 调用Android 上的toast 提示框                        setTimeout(function () &#123;                        first = null;                      &#125;, 1000);                    &#125; else &#123;                        // 获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次,                       if (new Date().getTime() - first &lt; 1000) &#123;                          plus.runtime.quit(); //退出应用                &#125;            &#125;          &#125;        &#125;)      &#125;);    &#125;);    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图LBS云检索</title>
      <link href="/2020/04/29/bmap/"/>
      <url>/2020/04/29/bmap/</url>
      
        <content type="html"><![CDATA[<p>百度地图自定义叠加层</p><span id="more"></span><blockquote><p>LBS 云服务提供海量位置数据的实时存储功能，JavaScript API 支持将用户上传到 LBS 云里的位置数据实时渲染成图层</p></blockquote><p>1、安装 vue-baidu-map</p><pre><code class="bash">npm install vue-baidu-map</code></pre><p>2、具体业务代码如下:</p><pre><code class="html">&lt;baidu-map  id=&quot;container&quot;  :scroll-wheel-zoom=&quot;true&quot;  :zoom=&quot;zoom&quot;  center=&quot;上海&quot;  :ak=&quot;selfKey&quot;  inertial-dragging  @ready=&quot;mapReady&quot;&gt;&lt;/baidu-map&gt;&lt;div class=&quot;menu-search&quot;&gt;  &lt;el-input placeholder=&quot;请输入站点名称&quot; v-model=&quot;site_name&quot; clearable&gt;    &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot; @click=&quot;search&quot;&gt;&lt;/el-button&gt;  &lt;/el-input&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">&lt;script&gt;// 在组件中引入vue-baidu-mapimport BaiduMap from &quot;vue-baidu-map/components/map/Map.vue&quot;;export default&#123;    components:&#123;BaiduMap&#125;,    data()&#123;        return&#123;            site_name:&#39;&#39;,            center:&#123;lng:121.532325,lat:31.232742&#125;,            selfKey:&#39;QloR7bQpWed3VDLbtcxi2NmgUcvXxcbx&#39;,            point:&#39;&#39;,            zoom:15        &#125;    &#125;,    mounted()&#123;        this.mapReady()    &#125;,    methods:&#123;        mapReady()&#123;            var map = new BMap.Map(&quot;container&quot;)            map.centerAndZoom(new BMap.Point(this.center.lng,ths.center.lat),10)            map.enableScrollWheelZoom()                  /**       *params   q:检索关键字       *params   tags：空格分割的多字符       *params   filter:过滤条件       */            var customLayer;            customLayer = new BMap.CustomLayer(&#123;                geotableId: 183323,                q: &quot;&quot;,                tags: &quot;&quot;,                filter: &quot;&quot;,            &#125;);            map.addTileLayer(customLayer);            // 热点图层            customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);            function callback(e) &#123;                var customPoi = e.customPoi;                var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                     customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                var BMapLib = window.BMapLib;                var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                        title: customPoi.title,                        width: 200,                        height: 100,                        panel: &quot;panel&quot;,                        enableAutoPan: true,                        enableSendToPhone: false,                        searchTypes: [],                &#125;);                var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                searchInfoWindow.open(point);            &#125;        &#125;,          search() &#123;                var map = new BMap.Map(&quot;container&quot;);                map.centerAndZoom(new BMap.Point(this.center.lng, this.center.lat), 10);                map.enableScrollWheelZoom();                var customLayer;                customLayer = new BMap.CustomLayer(&#123;                    geotableId: 183323,                    q: this.site_name || &quot;新西北物流园&quot;,                    tags: &quot;&quot;,                    filter: &quot;&quot;,                &#125;);                // 添加自定义图层                map.addTileLayer(customLayer);                // var mapDom = document.getElementById(&quot;container&quot;)                // mapDom.addEventListener(&quot;click&quot;, function () &#123;                //   window.location.href = &quot;./monitor/index&quot;;                // &#125;);                // 热点图层                customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);                function callback(e) &#123;                    var customPoi = e.customPoi;                    var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                    customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                    var BMapLib = window.BMapLib;                    // console.log(&quot;BMapLib&quot;, BMapLib);                    var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                    title: customPoi.title,                    width: 200,                    height: 100,                    panel: &quot;panel&quot;,                    enableAutoPan: true,                    enableSendToPhone: false,                    searchTypes: [],                    &#125;);                    var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                    searchInfoWindow.open(point);                &#125;    &#125;,    &#125;&#125;&lt;/script&gt;&lt;/details&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图动画（轨迹动画）</title>
      <link href="/2020/04/29/bmap-animate/"/>
      <url>/2020/04/29/bmap-animate/</url>
      
        <content type="html"><![CDATA[<p>百度地图动画及轨迹动画</p><span id="more"></span><h3 id="一、百度地图动画"><a href="#一、百度地图动画" class="headerlink" title="一、百度地图动画"></a>一、百度地图动画</h3><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.414, 39.915), 20); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放bmap.setTilt(20); // 设置地图初始倾斜角度var keyFrames = [  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: 0,    percentage: 0,  &#125;,  &#123;    center: new BMapGL.Point(116.307631, 40.055391),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.1,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.25,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.35,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.45,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.55,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.75,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -270,    percentage: 0.85,  &#125;,  &#123;    center: new BMapGL.Point(116.307779, 40.055754),    zoom: 21,    tilt: 70,    heading: -360,    percentage: 0.95,  &#125;,  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: -360,    percentage: 1,  &#125;,];var opts = &#123;  duration: 10000, // 设置每次迭代动画持续时间  delay: 3000, // 设置动画延迟开始时间  interation: &quot;INFINITE&quot;, // 设置动画迭代次数&#125;;var animation = new BMapGL.ViewAnimation(keyFrames, opts); // 初始化动画实例animation.addEventListener(&quot;animationstart&quot;, function (e) &#123;  // 监听动画开始事件  console.log(&quot;start&quot;);&#125;);animation.addEventListener(&quot;animationiterations&quot;, function (e) &#123;  // 监听动画迭代事件  console.log(&quot;onanimationiterations&quot;);&#125;);animation.addEventListener(&quot;animationend&quot;, function (e) &#123;  // 监听动画结束事件  console.log(&quot;end&quot;);&#125;);animation.addEventListener(&quot;animationcancel&quot;, function (e) &#123;  // 监听动画中途被终止事件  console.log(&quot;cancel&quot;);&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.startViewAnimation(animation); // 开始播放动画&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.cancelViewAnimation(animation); // 强制停止动画&#125;);</code></pre></details><h3 id="二、百度地图轨迹动画"><a href="#二、百度地图轨迹动画" class="headerlink" title="二、百度地图轨迹动画"></a>二、百度地图轨迹动画</h3><pre><code class="js">&lt;scrip  type=&quot;text/javascript&quot;  src=&quot;https://api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js&quot;&gt;&lt;/scrip&gt;</code></pre><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放var path = [  &#123;    lng: 116.297611,    lat: 40.047363,  &#125;,  &#123;    lng: 116.302839,    lat: 40.048219,  &#125;,  &#123;    lng: 116.308301,    lat: 40.050566,  &#125;,  &#123;    lng: 116.305732,    lat: 40.054957,  &#125;,  &#123;    lng: 116.304754,    lat: 40.057953,  &#125;,  &#123;    lng: 116.306487,    lat: 40.058312,  &#125;,  &#123;    lng: 116.307223,    lat: 40.056379,  &#125;,];var point = [];for (var i = 0; i &lt; path.length; i++) &#123;  point.push(new BMapGL.Point(path[i].lng, path[i].lat));&#125;var pl = new BMapGL.Polyline(point);var trackAni = new BMapGLLib.TrackAnimation(bmap, pl, &#123;  overallView: true, // 动画完成后自动调整视野到总览  tilt: 30, // 轨迹播放的角度，默认为55  duration: 20000, // 动画持续时长，默认为10000，单位ms  delay: 3000, // 动画开始的延迟，默认0，单位ms&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.start();&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.cancel(); // 强制停止动画&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-charts的options</title>
      <link href="/2020/04/28/v-charts/"/>
      <url>/2020/04/28/v-charts/</url>
      
        <content type="html"><![CDATA[<p>v-charts 的 options 使用 getOptions()而不是使用一个变量</p><span id="more"></span><blockquote><p>使用 getOptions()是为了获取数据之后才进行渲染数据，v-chart 的 options 可以直接绑定一个变量,在请求数据的时候，更新变量，图表需要进行重新渲染</p></blockquote><p>这里的 getOptions()也可以写在 computed 里面的。</p><pre><code class="html">&lt;template&gt;    &lt;v-charts :options=&quot;getOptions()&quot;&gt;&lt;/template&gt;</code></pre><details><summary>点我展示js代码</summary><pre><code class="js"> getOptions() &#123;        return &#123;          grid: &#123;            left: 0,            right: 0,            top: 0,            bottom: 0          &#125;,          xAxis: &#123;            type: &#39;value&#39;,            show: false          &#125;,          yAxis: &#123;            type: &#39;category&#39;,            show: false          &#125;,          series: [&#123;            name: &#39;上月平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            barWidth: 10,            itemStyle: &#123;              color: &#39;#45c946&#39;            &#125;          &#125;, &#123;            name: &#39;今日平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userTodayNumber],            itemStyle: &#123;              color: &#39;#eee&#39;            &#125;          &#125;, &#123;            type: &#39;custom&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            renderItem: (params, api) =&gt; &#123;              const value = api.value(0)              const endPoint = api.coord([value, 0])              return &#123;                type: &#39;group&#39;,                position: endPoint,                children: [&#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,                    x: -5,                    y: -20,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;, &#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,                    x: -5,                    y: 10,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;]              &#125;            &#125;          &#125;]        &#125;      &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> v-charts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间格式化</title>
      <link href="/2020/04/28/time/"/>
      <url>/2020/04/28/time/</url>
      
        <content type="html"><![CDATA[<p>获取时间格式的方式、封装的一些函数方法（待添加）</p><span id="more"></span><p>常用时间格式</p><pre><code class="js">    // 2021/3/10    let time = new Date().toLocaleDateString();    // 上午10:30:00    let times = new Date().toLocaleTimeString();    // 获取当前年份    2021年    let year = new Date().getFullYear();    // 获取当前月份  月份需要+1   3月份    let month = new Date().getMonth()+1;    // 获取当前月份日期   10号    let day = new Date().getDate();    // 获取当前星期几   三    let week = new Date().getDay();    // 获取当前季度   一季度    let season =  Math.floor((this.getMonth()+3)/3);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的封装</title>
      <link href="/2020/04/23/axios/"/>
      <url>/2020/04/23/axios/</url>
      
        <content type="html"><![CDATA[<blockquote><p>axios 基于promise的http库  特性：拦截请求和响应、取消请求、转换json、客户端防御XSRF</p></blockquote><span id="more"></span><p>当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。</p><p>所以记住：</p><blockquote><p>在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。</p></blockquote><pre><code class="js">service.interceptors.response.use(  (response) =&gt; &#123;    if (response.status === 200 &amp;&amp; response.data) &#123;      return response.data;    &#125; else &#123;      return Promise.reject(new Error(&quot;请求失败&quot;));    &#125;  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);</code></pre><h3 id="1、axios的安装"><a href="#1、axios的安装" class="headerlink" title="1、axios的安装"></a>1、axios的安装</h3><pre><code class="js">npm install axios</code></pre><h3 id="2、在request文件夹http-js"><a href="#2、在request文件夹http-js" class="headerlink" title="2、在request文件夹http.js"></a>2、在request文件夹http.js</h3><pre><code class="js">// http.jsimport axios from &quot;axios&quot;import QS from &quot;qs&quot;   // 序列化post类型的数据import &#123; Toast &#125; from &quot;vant&quot;  // 引入vant组件库的toast组件</code></pre><h3 id="3、环境的切换-请求超时-post请求头设置"><a href="#3、环境的切换-请求超时-post请求头设置" class="headerlink" title="3、环境的切换/请求超时/post请求头设置"></a>3、环境的切换/请求超时/post请求头设置</h3><pre><code class="js">// 环境的切换if (process.env.NODE_ENV == &#39;development&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.baidu.com&#39;;&#125; else if (process.env.NODE_ENV == &#39;debug&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.ceshi.com&#39;;&#125; else if (process.env.NODE_ENV == &#39;production&#39;) &#123;        axios.defaults.baseURL = &#39;https://www.production.com&#39;;&#125;axios.defaults.timeout = 10000;axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;;</code></pre><h3 id="4、请求拦截-响应拦截"><a href="#4、请求拦截-响应拦截" class="headerlink" title="4、请求拦截 响应拦截"></a>4、请求拦截 响应拦截</h3><details><summary>点击展示代码</summary><pre><code class="js">// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from &#39;@/store/index&#39;;// 请求拦截器axios.interceptors.request.use(        config =&gt; &#123;                // 每次发送请求之前判断vuex中是否存在token                // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断         const token = store.state.token;                token &amp;&amp; (config.headers.Authorization = token);                return config;        &#125;,        error =&gt; &#123;                return Promise.error(error);        &#125;)// 响应拦截器axios.interceptors.response.use(        response =&gt; &#123;           // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据             // 否则的话抛出错误        if (response.status === 200) &#123;                        return Promise.resolve(response);                &#125; else &#123;                        return Promise.reject(response);                &#125;        &#125;,        // 服务器状态码不是2开头的的情况    // 这里可以跟你们的后台开发人员协商好统一的错误状态码        // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等    // 下面列举几个常见的操作，其他需求可自行扩展    error =&gt; &#123;                    if (error.response.status) &#123;                        switch (error.response.status) &#123;                                // 401: 未登录                // 未登录则跳转登录页面，并携带当前页面的路径                // 在登录成功后返回当前页面，这一步需要在登录页操作。                                case 401:                                        router.replace(&#123;                                                path: &#39;/login&#39;,                                                query: &#123;                             redirect: router.currentRoute.fullPath                         &#125;                    &#125;);                    break;                // 403 token过期                // 登录过期对用户进行提示                // 清除本地token和清空vuex中token对象                // 跳转登录页面                                case 403:                     Toast(&#123;                        message: &#39;登录过期，请重新登录&#39;,                        duration: 1000,                        forbidClick: true                    &#125;);                    // 清除token                    localStorage.removeItem(&#39;token&#39;);                    store.commit(&#39;loginSuccess&#39;, null);                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面                     setTimeout(() =&gt; &#123;                                                router.replace(&#123;                                                        path: &#39;/login&#39;,                                                        query: &#123;                                 redirect: router.currentRoute.fullPath                             &#125;                                                &#125;);                                        &#125;, 1000);                                        break;                 // 404请求不存在                case 404:                    Toast(&#123;                        message: &#39;网络请求不存在&#39;,                        duration: 1500,                        forbidClick: true                    &#125;);                    break;                // 其他错误，直接抛出错误提示                default:                    Toast(&#123;                        message: error.response.data.message,                        duration: 1500,                        forbidClick: true                    &#125;);            &#125;            return Promise.reject(error.response);        &#125;    &#125;    &#125;);</code></pre></details><h3 id="5、get、post请求的封装"><a href="#5、get、post请求的封装" class="headerlink" title="5、get、post请求的封装"></a>5、get、post请求的封装</h3><blockquote><p>get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123;        return new Promise((resolve, reject) =&gt;&#123;                axios.get(url, &#123;                        params: params                &#125;).then(res =&gt; &#123;            resolve(res.data);        &#125;).catch(err =&gt;&#123;            reject(err.data)            &#125;)    &#125;);&#125;</code></pre></details><blockquote><p>原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/**  * post方法，对应post请求  * @param &#123;String&#125; url [请求的url地址]  * @param &#123;Object&#125; params [请求时携带的参数]  */export function post(url, params) &#123;    return new Promise((resolve, reject) =&gt; &#123;         axios.post(url, QS.stringify(params))        .then(res =&gt; &#123;            resolve(res.data);        &#125;)        .catch(err =&gt;&#123;            reject(err.data)        &#125;)    &#125;);&#125;</code></pre></details><h3 id="6、axios完整封装代码"><a href="#6、axios完整封装代码" class="headerlink" title="6、axios完整封装代码:"></a>6、axios完整封装代码:</h3><details><summary>点击展示代码</summary><pre><code class="js">/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &#39;axios&#39;;import router from &#39;../router&#39;;import store from &#39;../store/index&#39;;import &#123; Toast &#125; from &#39;vant&#39;;/**  * 提示函数  * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; &#123;        Toast(&#123;                message: msg,                duration: 1000,                forbidClick: true        &#125;);&#125;/**  * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123;    router.replace(&#123;        path: &#39;/login&#39;,                query: &#123;            redirect: router.currentRoute.fullPath        &#125;    &#125;);&#125;/**  * 请求失败后的错误统一处理  * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123;    // 状态码判断    switch (status) &#123;        // 401: 未登录状态，跳转登录页        case 401:            toLogin();            break;        // 403 token过期        // 清除token并跳转登录页        case 403:            tip(&#39;登录过期，请重新登录&#39;);            localStorage.removeItem(&#39;token&#39;);            store.commit(&#39;loginSuccess&#39;, null);            setTimeout(() =&gt; &#123;                toLogin();            &#125;, 1000);            break;        // 404请求不存在        case 404:            tip(&#39;请求的资源不存在&#39;);             break;        default:            console.log(other);           &#125;&#125;// 创建axios实例var instance = axios.create(&#123;    timeout: 1000 * 12&#125;);// 设置post请求头instance.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;/**  * 请求拦截器  * 每次请求前，如果存在token则在请求头中携带token  */ instance.interceptors.request.use(        config =&gt; &#123;                // 登录流程控制中，根据本地是否存在token判断用户的登录情况                // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token                // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码                // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。                const token = store.state.token;                token &amp;&amp; (config.headers.Authorization = token);                return config;        &#125;,        error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use(        // 请求成功    res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res),        // 请求失败    error =&gt; &#123;        const &#123; response &#125; = error;        if (response) &#123;            // 请求已发出，但是不在2xx的范围             errorHandle(response.status, response.data.message);            return Promise.reject(response);        &#125; else &#123;            // 处理断网的情况            // eg:请求超时或断网时，更新state的network状态            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明            if (!window.navigator.onLine) &#123;               store.commit(&#39;changeNetwork&#39;, false);            &#125; else &#123;                return Promise.reject(error);            &#125;        &#125;    &#125;);export default instance;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于echarts官方的一个bug -- sublink跳转问题</title>
      <link href="/2020/04/20/echarts/"/>
      <url>/2020/04/20/echarts/</url>
      
        <content type="html"><![CDATA[<p>echarts 官方的一个 bug – sublink 跳转的问题。echarts版本号为4.8.0</p><span id="more"></span><p>开发百度地图 scatter 散点图时，副标题链接跳转出错（版本号为 4.8.0），在 GitHub 找到<a href="https://github.com/apache/incubator-echarts/issues/12841">issues</a>。<br>bug 介绍，点击副标题无法跳转到指定连接</p><pre><code class="js">this.options = &#123;  title: &#123;    text: &quot;我是主标题&quot;,    subtext: &quot;我是副标题，我可以跳转&quot;,    sublink: &quot;https://www.baidu.com&quot;,    left: &quot;center&quot;,  &#125;,&#125;;</code></pre><p>1、在 main.js 引入 echarts 和 vue-echarts，将 echarts 绑定到 Vue 原型，引入 vue-echarts 通过 vue.component()进行组件注册</p><blockquote><p>将 echarts 绑定到 Vue 原型上，可以减少代码量，开发过程中需要使用 echarts 里面提供的方法，如果没有全局引入的话，需要在每个使用 echarts 的页面都需要手动引入。将 vue-echarts 使用组件注册后，提供了属性绑定的方式渲染图表就不需要通过调用 echart 的方法了。</p></blockquote><h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><p>1、echarts 的绘图流程</p><pre><code class="js">// 1、引入echarts js库&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 2、DOM容器 设置宽高（注意）  --&gt;&lt;div id=&quot;charts&quot; style=&quot;width:800px;height:600px&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="js">// 3、获取渲染DOM对象const chartDom = document.getElementById(&quot;charts&quot;);// 4、初始化echarts对象const chart = echarts.init(chartDom);// 5、配置option参数  调用setOption完成渲染chart.setOption(&#123;  title: &#123;    text: &quot;Echarts 示例&quot;,  &#125;,  xAxis: &#123;    data: [&quot;食品&quot;, &quot;数码&quot;, &quot;服饰&quot;, &quot;箱包&quot;],  &#125;,  yAxis: &#123;&#125;,  // 系列： 包括图表的类型 包括：line bar pie等  series: &#123;    type: &quot;bar&quot;,    data: [&quot;100&quot;, &quot;120&quot;, &quot;40&quot;, &quot;160&quot;],  &#125;,&#125;);</code></pre><p>2、dataset: 数据集</p><blockquote><p>ECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">const chartDom = document.getElementById(&quot;chart&quot;);const chart = echarts.init(chartDom);const option = &#123;  xAxis: &#123;    type: &quot;category&quot;,  &#125;,  yAxis: &#123;&#125;,  dataset: &#123;    source: [      [&quot;1季度&quot;, 80, 100, &quot;分类1&quot;, 50],      [&quot;2季度&quot;, 81, 122, &quot;分类1&quot;, 60],      [&quot;3季度&quot;, 76, 90, &quot;分类1&quot;, 55],      [&quot;4季度&quot;, 65, 123, &quot;分类1&quot;, 70],    ],  &#125;,  // 系列  series: [    // 系列 0    &#123;      type: &quot;pie&quot;,      center: [&quot;65%&quot;, 60],      radius: 35,      encode: &#123;        itemName: 3,        value: 4,      &#125;,    &#125;,    // 系列 1    &#123;      type: &quot;line&quot;,      encode: &#123;        x: 0,        y: 2,      &#125;,    &#125;,    // 系列 2    &#123;      type: &quot;bar&quot;,      encode: &#123;        x: 0,        y: 1,      &#125;,    &#125;,  ],&#125;;chart.setOption(option);</code></pre></details><p>3、基本组件</p><blockquote><p>echarts 基本组件：title、坐标系的 X（xAxis）轴 Y(yAxis）轴、tooltip 提示框、toolbox 工具栏等</p></blockquote><p>4、定位</p><pre><code class="js">// 大多数组件都提供了定位属性，我们可以采用类似 CSS absolute 的定位属性来控制组件的位置 left right height bottom的值可以是数值或者百分比var option = &#123;  grid: &#123;    left: 120,    right: &quot;30%&quot;,    height: &quot;40%&quot;,    bottom: 100,  &#125;,&#125;;</code></pre><h2 id="echarts-常用属性"><a href="#echarts-常用属性" class="headerlink" title="echarts 常用属性"></a>echarts 常用属性</h2><p>（1）使用 ECharts 绘图后没有图像（这个问题会经常出现，一定要设置宽度高度！！！）</p><blockquote><p>ECharts 绘图后没有任何报错，但是没有图像。可以检查容器是否设置了宽高。因为 ECharts 不会设置默认宽高，如果容器没有设置宽高，则不会展示;如果使用的是 v-chart 则没有这个问题，因为 v-chart 默认了 600*400 的宽高。</p></blockquote><p>（2）使用 element-ui 的按需引入</p><blockquote><p>安装<code>vue add element</code>，后续会提示是全部引入或者按需引入，选择按需引入，在 App.vue 中会增加一些 element-ui 的示例代码，后续删除。项目目录会增加一个 plugin 文件夹</p></blockquote><blockquote><p>注意：按需引入组件后，再删除 App.vue 以及 view 文件夹内、component 文件夹内的不需要的内容。</p></blockquote><pre><code class="js">// main.jsimport &quot;./plugins/element.js&quot;;</code></pre><pre><code class="js">// element.jsimport Vue from &quot;vue&quot;;import &#123; Card, Col, Row &#125; from &quot;element-ui&quot;;Vue.use(Card);Vue.use(Col);Vue.use(Row);</code></pre><p>（3）vue 使用 echarts</p><pre><code class="js">// main.js 引入echarts 挂载到Vue实例import ECharts from &quot;echarts&quot;;Vue.prototype.$echarts = ECharts;</code></pre><p>（4）echarts 的常用属性</p><blockquote><p>1、隐藏线条 - listStyle</p></blockquote><pre><code class="js">listStyle: &#123;  width: 0;&#125;</code></pre><blockquote><p>2、隐藏数据点 - itemStyle</p></blockquote><pre><code class="js">itemStyle: &#123;  opacity: 0;&#125;</code></pre><blockquote><p>3、折线图填充面积区域颜色 - areaStyle</p></blockquote><pre><code class="js">areaStyle: &#123;  color: &quot;purple&quot;;&#125;</code></pre><blockquote><p>4、折线图平滑显示 - smooth</p></blockquote><pre><code class="js">smooth: true;</code></pre><blockquote><p>5、柱状图聚合 - stack</p></blockquote><pre><code class="js">series: [  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [100],  &#125;,  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [250],  &#125;,];</code></pre><blockquote><p>6、自定义绘图(重点)</p></blockquote><pre><code class="js">&#123;  type: &#39;custom&#39;,  stack: &#39;总量&#39;,  data: [100],  renderItem: (params, api) =&gt; &#123;    //  console.log(params,api);    const value = api.value(0)    const endPoint = api.coord([value, 0])    return &#123;      type: &#39;group&#39;,      position: endPoint,      children: [&#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,// 这里是svg里面的d          x: -5,          y: -20,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;, &#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,          x: -5,          y: 10,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;]    &#125;  &#125;&#125;</code></pre><blockquote><p>7、xAxis x 轴</p></blockquote><pre><code class="js">// 消除x轴两侧边距boundaryGap: false// 柱状图宽度barWidth: &#39;60%&#39;barWidth: 10// 条形图 type设置方法xAxis: &#123;  type: &#39;value&#39;&#125;,yAxis: &#123;  type: &#39;category&#39;&#125;</code></pre><blockquote><p>8、echarts 类目轴和非类目轴</p></blockquote><blockquote><p>类目轴的意思就是坐标轴上的展示信息是否是数据连贯，非类目轴就是除了标签类型为类目的其他坐标轴，有 时间（time），数值（value），对数（log）3 种。标签类型为类目是指 type:category</p></blockquote><p>坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样。类目轴中  boundaryGap  可以配置为  true  和  false。默认为  true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap 是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置  min  和  max  后无效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用canvas压缩图片？</title>
      <link href="/2020/04/10/canvas/"/>
      <url>/2020/04/10/canvas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>canvas 是 HTML5 的新特性，它允许我们使用 canvas 元素在网页上通过 JavaScript 绘制图像 （可以在 HTML 页面使用多个 canvas 元素）</p></blockquote><span id="more"></span><p><strong>1、绘图流程:</strong></p><pre><code class="js">// 1、编写canvas标签，指定宽高（注意）；&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;// 2、获取canvas DOM对象；const canvas = document.getElementById(&quot;canvas&quot;);// 3、获取Canvas对象；const ctx = canvas.getContext(&quot;2d&quot;); // 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法// 4、设置绘图属性；ctx.fillStyle = &quot;red&quot;; //设置填充色// 5、调用绘图API。ctx.fillRect(0, 0, 50, 50); // 绘制矩形</code></pre><p><strong>2、canvas 路径</strong></p><p>常用的方法：</p><p>（1）moveTo(x,y)–定义线条开始坐标</p><p>（2）lineTo(x,y)–定义线条结束坐标</p><p>示例 1、绘制线段</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath(); // 开始绘制路径ctx.lineWidth = 1; // 线条宽度ctx.strokeStyle = &quot;green&quot;; // 线条填充色ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); // 绘制线段</code></pre><p>示例 2、绘制圆形</p><p>arc(x,y,r,start,stop) x 轴 y 轴 r 半径</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath();ctx.lineWidth = 2;ctx.strokeStyle = &quot;green&quot;; // 圆形边框色ctx.fillStyle = &quot;red&quot;; // 圆形填充色ctx.arc(95, 50, 40, 0, 2 * Math.PI);ctx.stroke();</code></pre><p>示例 3、绘制矩形 （代码见绘图流程）</p><p><strong>3、使用 canvas 压缩图片</strong></p><pre><code class="html">&lt;!--编写input标签 指定type类型为file--&gt;&lt;input type=&quot;file&quot; id=&quot;upload&quot; /&gt;</code></pre><details><summary>压缩图片js代码(点击展开)</summary><pre><code class="js">// 设置上传图片类型  上传图片的容量大小const ACCEPT = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;]; // 限定图片文件类型const MAXSIZE = 1024 * 1024 * 3; // 限定图片最大容量const MAXSIZE_STR = &quot;3MB&quot;;function convertImageToBase64(file, cb) &#123;  let reader = new FileReader();  reader.addEventListener(&quot;load&quot;, function (e) &#123;    const base64Image = e.target.result; // 获取文件内容，等同于 reader.result    cb(base64Image);    reader = null;  &#125;);  reader.readAsDataURL(file); // 读取 file 对象中的内容&#125;// 图片是否压缩的判断function compress(base64Image, cb) &#123;  let maxW = 1024;  let maxH = 1024;  const image = new Image();  image.addEventListener(&quot;load&quot;, function () &#123;    let ratio; // 压缩比    let needCompress = false; // 是否需要压缩    if (maxW &lt; image.naturalWidth) &#123;      needCompress = true;      ratio = image.naturalWidth / maxW;      maxH = image.naturalHeight / ratio;    &#125;    if (maxH &lt; image.naturalHeight) &#123;      needCompress = true;      ratio = image.naturalHeight / maxH;      maxW = image.naturalWidth / ratio;    &#125;    if (!needCompress) &#123;      maxW = image.naturalWidth;      maxH = image.naturalHeight;    &#125;    const canvas = document.createElement(&quot;canvas&quot;);    canvas.setAttribute(&quot;id&quot;, &quot;__compress__&quot;);    canvas.width = maxW;    canvas.height = maxH;    canvas.style.visibility = &quot;hidden&quot;;    document.body.append(canvas);    // canvas画布    const ctx = canvas.getContext(&quot;2d&quot;);    ctx.clearRect(0, 0, maxW, maxH);    ctx.drawImage(image, 0, 0, maxW, maxH); // 渲染图片    const compressImage = canvas.toDataURL(&quot;image/jpeg&quot;, 0.9); // 压缩图片    cb(compressImage);    const _image = new Image();    _image.src = compressImage;    document.body.appendChild(_image);    canvas.remove(); // 移除 canvas  &#125;);  image.src = base64Image; // 将图片设置到 image 的 src 属性中  document.body.appendChild(image);&#125;// 上传给服务端function uploadImage(compressImage) &#123;  console.log(&quot;upload image to server...&quot;, compressImage);&#125;const upload = document.getElementById(&quot;upload&quot;);upload.addEventListener(&quot;change&quot;, function (e) &#123;  const file = e.target.files[0];  console.log(file);  if (!file) &#123;    return;  &#125;  const &#123; type: fileType, size: fileSize &#125; = file;  // 图片类型检查  if (!ACCEPT.includes(fileType)) &#123;    alert(&quot;不支持上传该格式文件！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 图片大小检查  if (fileSize &gt; MAXSIZE) &#123;    alert(&quot;文件超出&quot; + MAXSIZE_STR + &quot;！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 压缩文件  convertImageToBase64(file, (base64Image) =&gt;    compress(base64Image, uploadImage)  );&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端300ms延迟在IOS11中的bug</title>
      <link href="/2020/02/20/mobile/"/>
      <url>/2020/02/20/mobile/</url>
      
        <content type="html"><![CDATA[<p>在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click</p><span id="more"></span><h2 id="移动端300ms延迟在IOS11中的bug"><a href="#移动端300ms延迟在IOS11中的bug" class="headerlink" title="移动端300ms延迟在IOS11中的bug"></a>移动端300ms延迟在IOS11中的bug</h2><blockquote><p>解决方案</p></blockquote><p>1、禁用缩放 更改默认视口宽度</p><pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1&quot;&gt;</code></pre><p>2、fastclick解决300ms延迟问题<br>        首先，需要安装fastclick插件</p><pre><code class="js">npm install fastclick</code></pre><p>3、在main.js文件中引入fastclick，绑定到body上</p><pre><code class="js">import FastClick from &quot;fastclick&quot;FastClick.attach(document.body);</code></pre><p>这就是常用来解决移动端300ms延迟的方法。但是这种方法在iOS11的系统中存在bug。</p><p>4、iOS11系统中出现的bug<br>    在iOS11系统下，点击input输入框的时候会出现不灵敏的现象。</p><blockquote><p>解决方案:</p></blockquote><details><summary>点我展示代码</summary><pre><code class="js">&lt;script&gt;FastClick.prototype.focus = function (targetElement) &#123;  var length;  var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;  var deviceIsIos = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;  //兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError  //这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法  if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#39;date&#39;) !== 0 &amp;&amp; targetElement.type !== &#39;time&#39; &amp;&amp; targetElement.type !== &#39;month&#39;) &#123;    length = targetElement.value.length;    // 修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘    targetElement.setSelectionRange(length, length);  &#125; else &#123;    targetElement.focus();  &#125;&#125;&lt;/script&gt;</code></pre></details><blockquote><p>注意：<br>setSelectionRange是HTMLInputElement的一个方法,用来设定input textare的当前文本的起始位置和结束位置。<br>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement/setSelectionRange">MDN文档</a>）<br>对setSelectionRange方法只能用于类型为文本、搜索、连接、电话号码、密码的输入，以及在Chrome33开始访问其余类型的属性和方法抛出异常。<br>输入类型为数字时会抛出：“不能从’HTMLInputElement’中读取’selectionStart’属性：输入元素的类型(‘number’)不支持选择（Failed to read the ‘selectionStart’ property from ‘HTMLInputElement’: The input element’s type (‘number’) does not support selection）”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-cloak解决页面闪烁问题</title>
      <link href="/2020/02/12/v-cloak/"/>
      <url>/2020/02/12/v-cloak/</url>
      
        <content type="html"><![CDATA[<p>这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{ display: none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p><span id="more"></span><p>很多时候，我们页面模板中的数据是异步获取的，在网络不好的情况下，渲染页面的时候会出现页面闪烁的效果，影响用户体验，v-cloak 指令保持在元素上直到关联实例结束编译，利用它的特性，结合 CSS 的规则 [v-cloak] { display: none } 一起使用就可以隐藏掉未编译好的 Mustache 标签，直到实例准备完毕。</p><pre><code class="html">&lt;div class=&quot;#app&quot; v-cloak&gt;    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">[v-cloak] &#123;    display: none;&#125;</code></pre><blockquote><p>需要注意，虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个loading动画或者骨架屏的效果，提升用户体验。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下拉框select的option</title>
      <link href="/2019/12/29/select/"/>
      <url>/2019/12/29/select/</url>
      
        <content type="html"><![CDATA[<p>下拉的选项是从后台获取的数据,如何获取选定项的值?</p><span id="more"></span><p>以选择银行卡为例：</p><pre><code class="js">    &lt;select v-model=&quot;selected&quot; class=&quot;selected&quot;&gt;        &lt;option disabled value v-show=&quot;showBankCard&quot;&gt;请选择提现到账的银行卡&lt;/option&gt;        &lt;option            v-for=&quot;item in BankCardList&quot;            :key=&quot;item.id&quot;            v-bind:value=&quot;item.id&quot;        &gt;            &#123;&#123; item.card_no &#125;&#125;        &lt;/option&gt;    &lt;/select&gt;</code></pre><pre><code class="js">item.card_no ? item.card_no.replace(/^(\d&#123;4&#125;)\d+(\d&#123;4&#125;)$/,&quot;$1****$2&quot;):&quot;&quot;// 银行卡号显示为 6217 **** 0000 的格式。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码的生成</title>
      <link href="/2019/12/28/qrcode/"/>
      <url>/2019/12/28/qrcode/</url>
      
        <content type="html"><![CDATA[<p>使用 qrcode 生成二维码</p><span id="more"></span><p>一、下载插件 qrcode 插件</p><pre><code class="js">    npm install qrcode --save</code></pre><p>二、在 main.js 中引用</p><pre><code class="js">import QRCode from &quot;qrcode&quot;;Vue.use(QRCode);</code></pre><p>三、组件中引入 QRCode</p> <details> <summary>点我展示代码</summary> <pre><code class="html">    &lt;template&gt;        &lt;div&gt;            &lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;</code></pre><pre><code class="js">    &lt;script&gt;      import QRCode from &#39;qrcode&#39;;      mounted()&#123;          this.CreateQrcode();      &#125;,      method:&#123;          setTimeout(() =&gt; &#123;              // 获取DOM节点              let dom = document.getElementById(&#39;qrcode);              // 路由传参              const res = this.$route.params;              const lbsid = res.id;              // 二维码包含的URL 需要将URL和id做一下字符串的拼接              let url = &#39;http://*********&#39;;              let URL = url.concat(lbsid);              let qrCode = new QRCode(dom,&#123;                  width:260, // 图像宽度                  height:260,  // 图像高度                  colorDark:&quot;#000000&quot;,  // 前景色                  colorLight:&quot;#ffffff&quot;, // 背景色                  correctLevel: QRCode.CorrectLevel.H  // 容错等级              &#125;);              qrCode.clear();              qrCode.makeCode(URL);          &#125;,100)      &#125;    &lt;/script&gt;    &lt;style lang=&quot;less&quot; scoped&gt;        #qrcode &#123;            display: inline-block;            margin-top: 6rem;            img &#123;                width: 60%;                height: 60%;                background-color: #fff; //设置白色背景色                padding: 6px; // 利用padding的特性，挤出白边  &#125;&#125;    &lt;/style&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号网页使用popstate事件</title>
      <link href="/2019/12/23/popstate/"/>
      <url>/2019/12/23/popstate/</url>
      
        <content type="html"><![CDATA[<p>如何在h5移动端禁止某一些页面使用虚拟返回键。</p><span id="more"></span><h3 id="1、popstate事件"><a href="#1、popstate事件" class="headerlink" title="1、popstate事件"></a>1、popstate事件</h3><p>MDN上是这样介绍popstate的：<br>    当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。<br>    需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）<br>    不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会。<br>    我负责的一个项目中，在微信公众号网页的某一个页面需要禁止使用微信浏览器的返回键。</p><h3 id="2、解决方式："><a href="#2、解决方式：" class="headerlink" title="2、解决方式："></a>2、解决方式：</h3><details><summary>点我展示代码</summary><pre><code class="js">// 在禁止返回的组件的methods中写一个方法forbidBackforbidBack()&#123;    window.history.pushState(&quot;forward&quot;,null,&quot;#&quot;);    window.history.forward(1);&#125;// 监听返回键，禁止返回之前的路由if(window.history &amp;&amp; window.history.pushState)&#123;    window.addEventListener(&quot;popstate&quot;,this.forbidBack,false);    this.forbidBack();&#125;//离开页面需要销毁监听window.removeEventListener(&quot;popstate&quot;,this.forbidBack,fasle);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5扫码功能</title>
      <link href="/2019/12/20/h5-scan/"/>
      <url>/2019/12/20/h5-scan/</url>
      
        <content type="html"><![CDATA[<p>使用H5 API barcode实现扫码。</p><span id="more"></span><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;div @click=&quot;handleCloseScan&quot;&gt;X&lt;/div&gt;        &lt;div class=&quot;scan&quot;&gt;            &lt;div id=&quot;bcid&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;button @click=&quot;handleStartScan&quot;&gt;扫 码&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><details><summary>点击展示js代码</summary><pre><code class="js">    &lt;script&gt;        // 扫描对象        var scan = null;        methods:&#123;            // 开始扫描            handleStartScan()&#123;                const that = this;                if(!window.plus) return;                scan = new plus.barcode.Barcode(&#39;bcid&#39;);                // 开始扫描                scan.start();                // 扫码成功之后的回调函数 type是类型 result 结果                scan.onmarked = function(type,result)&#123;                    const text = &#39;&#39;;                    switch(type)&#123;                        case plus.barcode.QR:                            type = &#39;QR&#39;;                            break;                        case plus.barcode.EAN13:                            type = &quot;EAN13&quot;;                            break;                        case plus.barcode.EAN8:                            type = &quot;EAN8&quot;;                            break;                        default:                            type = &quot;其它&quot; + type;                            break;                    &#125;                    result = result.replace(/\n/g,&quot;&quot;);                    const id = result.match(/\d+/)[0];                    that.$router.push(&#123;                        name:&#39;ComponentName&#39;,                        params: &#123;                            id:id                        &#125;                    &#125;);                    scan.close();                &#125;            &#125;,            // 关闭扫描控件            handleCloseScan()&#123;                 if(!window.plus) return;                 scan.close();                 this.$router.push(&#39;/&#39;);            &#125;        &#125;&#125;    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Vue项目热更新打包时间过长</title>
      <link href="/2019/12/11/hot/"/>
      <url>/2019/12/11/hot/</url>
      
        <content type="html"><![CDATA[<p>维护公司一个项目的时候，发现在项目启动、热更新和打包项目的时候，时间长的“感人”。</p><span id="more"></span><p>当你改动项目的一些地方想要立即看到效果的时候，却发现热更新的编译过程却花了你很长时间，“心态崩了。。。”。</p><h3 id="1、解决Vue项目热更新打包时间过长"><a href="#1、解决Vue项目热更新打包时间过长" class="headerlink" title="1、解决Vue项目热更新打包时间过长"></a>1、解决Vue项目热更新打包时间过长</h3><p>解决方法：</p><p>1、使用html-webpack-plugin-for-multihtml插件</p><p>2、在build-webpack.dev.conf.js文件中</p><pre><code class="js">    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    // 替换成    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin-for-multihtml&#39;);</code></pre><p>3、multihtmlCache:true  解决多页热部署的关键</p><pre><code class="js">for (var pathname in pages) &#123;  // 配置生成的html文件，定义路径等  var conf = &#123;    filename: pathname + &#39;.html&#39;,    template: pages[pathname],   // 模板路径    inject: true,              // js插入位置    multihtmlCache: true,    // 解决多页热部署的关键 这里这里这里这里这里很重要！！！    // necessary to consistently work with multiple chunks via CommonsChunkPlugin    chunksSortMode: &#39;dependency&#39;  &#125;;  if (pathname in devWebpackConfig.entry) &#123;    conf.chunks = [&#39;manifest&#39;,&#39;vendor&#39;, pathname];    conf.hash = false;  &#125;  devWebpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;</code></pre><p>4、router.js中使用路由懒加载</p><p>这时候再启动项目，热更新、编译和打包的速度会大大提升。</p><h3 id="2、项目打包由4M变为1M"><a href="#2、项目打包由4M变为1M" class="headerlink" title="2、项目打包由4M变为1M"></a>2、项目打包由4M变为1M</h3><p>公司有一个H5微信公众号网页的项目，项目打包之后文件有4M；</p><p>修改webpack.prod.conf.js里的UglifyJsPlugin，这里的意思是打包后不产生后缀名为.map的文件。</p><pre><code class="javascript">webpack.prod.conf.js    new UglifyJsPlugin(&#123;      uglifyOptions: &#123;        compress: &#123;          warnings: false        &#125;      &#125;,      // sourceMap: config.build.productionSourceMap, 将这行代码注释掉。      parallel: true    &#125;)</code></pre><p>处理后打包的文件的大小为1M</p>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/12/05/markdown/"/>
      <url>/2019/12/05/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown语法整理</p><span id="more"></span><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue实现模糊搜索</title>
      <link href="/2019/11/13/mohu-search/"/>
      <url>/2019/11/13/mohu-search/</url>
      
        <content type="html"><![CDATA[<p>利用computed计算属性实现模糊搜索</p><span id="more"></span><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;搜索&quot; v-model=&quot;sousuo&quot;&gt;    &lt;table border=&quot;1&quot;&gt;      &lt;th&gt;编号&lt;/th&gt;      &lt;th&gt;英雄&lt;/th&gt;      &lt;th&gt;技能&lt;/th&gt;      &lt;tr v-for=&quot;(item,index) in sousuo1()&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.jn&#125;&#125;&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;  &lt;/div&gt;</code></pre><p>利用computed计算属性</p><details><summary>点我展示代码</summary><pre><code class="javascript">var app = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    sousuo: &#39;&#39;,    list: [&#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;艾希&quot;,        &quot;jn&quot;: &quot;射箭&quot;      &#125;, &#123;        &quot;id&quot;: 2,        &quot;name&quot;: &quot;狐狸&quot;,        &quot;jn&quot;: &quot;魅惑&quot;      &#125;, &#123;        &quot;id&quot;: 3,        &quot;name&quot;: &quot;猴子&quot;,        &quot;jn&quot;: &quot;棍子&quot;      &#125;, &#123;        &quot;id&quot;: 4,        &quot;name&quot;: &quot;盖伦&quot;,        &quot;jn&quot;: &quot;大宝剑&quot;      &#125;, &#123;        &quot;id&quot;: 5,        &quot;name&quot;: &quot;德邦&quot;,        &quot;jn&quot;: &quot;尖枪&quot;      &#125;, &#123;        &quot;id&quot;: 6,        &quot;name&quot;: &quot;皇子&quot;,        &quot;jn&quot;: &quot;旗子&quot;      &#125;,    ]  &#125;,  computed: &#123; //设置计算属性    Search() &#123;      if (this.sousuo) &#123;        return this.list.filter((value) =&gt; &#123; //过滤数组元素  this.list就是上面的那个死数据          return value.name.includes(this.sousuo); // 查看value.name里面包含不包含输入的字体          &#125;); //this.sousuo跟上面的输入框是双重绑定      &#125;    &#125;  &#125;,  methods: &#123;    sousuo1() &#123;      if (!this.sousuo) &#123;        return this.list;      &#125;      return this.Search    &#125;  &#125;,&#125;)</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基础知识</title>
      <link href="/2019/09/26/vue-simple/"/>
      <url>/2019/09/26/vue-simple/</url>
      
        <content type="html"><![CDATA[<p>Vue基础知识点，包括常用指令、计算属性、侦听属性等。</p><span id="more"></span><h2 id="Vuejs响应式原理"><a href="#Vuejs响应式原理" class="headerlink" title="Vuejs响应式原理"></a>Vuejs响应式原理</h2><pre><code>编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。</code></pre><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快: 相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。</p><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h2 id="vue组件中data必须是一个函数？"><a href="#vue组件中data必须是一个函数？" class="headerlink" title="vue组件中data必须是一个函数？"></a>vue组件中data必须是一个函数？</h2><p>官网上是这样写的：</p><blockquote><p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，可能会影响到其它所有实例。</p></blockquote><p>当创建Vue实例时，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p><h2 id="v-if和v-show有什么区别？"><a href="#v-if和v-show有什么区别？" class="headerlink" title="v-if和v-show有什么区别？"></a>v-if和v-show有什么区别？</h2><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>计算属性computed：</p><p>支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><p>侦听属性watch：</p><p>不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：<br>immediate：组件加载立即触发回调函数执行</p><pre><code class="js">watch: &#123;  firstName: &#123;    handler(newName, oldName) &#123;      this.fullName = newName + &#39; &#39; + this.lastName;    &#125;,    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法    immediate: true  &#125;&#125;</code></pre><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p><pre><code class="js">watch: &#123;  obj: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    deep: true  &#125;&#125;</code></pre><p>优化：我们可以使用字符串的形式监听</p><pre><code class="js">watch: &#123;  &#39;obj.a&#39;: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    // deep: true  &#125;&#125;</code></pre><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h2 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h2><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。<br>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p><h2 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h2><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><blockquote><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p></blockquote><p>v-for提升性能的原因:</p><p>key相同时，两个VNode会相同，可以避免不必要的DOM更新；而且在diff内部，也会根据key来跟踪VNode。</p><h2 id="双向数据绑定原理是什么？"><a href="#双向数据绑定原理是什么？" class="headerlink" title="双向数据绑定原理是什么？"></a>双向数据绑定原理是什么？</h2><blockquote><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><p>主要分为以下几个步骤：</p><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>①在自身实例化时往属性订阅器(dep)里面添加自己<br>②自身必须有一个update()方法<br>③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h2 id="vue-router路由页面管理"><a href="#vue-router路由页面管理" class="headerlink" title="vue-router路由页面管理"></a>vue-router路由页面管理</h2><blockquote><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote><p>包含的功能有：</p><p>1、嵌套的路由/视图表</p><p>2、模块化的、基于组件的路由配置</p><p>3、路由参数、查询、通配符</p><p>4、基于 Vue.js 过渡系统的视图过渡效果</p><p>5、细粒度的导航控制</p><p>6、带有自动激活的 CSS class 的链接</p><p>7、HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p><p>8、自定义的滚动条行为</p><blockquote><p>1、动态路由匹配</p></blockquote><p>例如：对不同ID的用户，使用同一个组件来渲染。</p><pre><code class="js">const User = &#123;  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;&#125;const router = new VueRouter(&#123;  routes: [    // 动态路径参数 以冒号开头    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)</code></pre><p>这样/user/foo 和 /user/bar 都将映射到相同的路由User。</p><p>一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;</code></pre><blockquote><p>2、编程式的导航<br>router.push({name:””,params:{}})</p></blockquote><pre><code class="js">  （1）this.$router.push  // 带参数  this.$router.push(&#123;    name:&quot;User&quot;,    params:&#123;      userId:&quot;123&quot;    &#125;  &#125;)</code></pre><p>router.push({path:””,query:””})</p><pre><code class="js">  (2) this.$router.push(&#123;    path:&quot;/user&quot;,    query:&#123;      plan:&quot;private&quot;    &#125;  &#125;)</code></pre><p>router.replace()使用方法跟router.push()很像，不会向history添加新纪录，替换掉当前的history记录。<br>router.go()在history记录中向前或者向后多少步。正数为向前多少步，负数为向后多少步</p><blockquote><p>3、滚动行为</p></blockquote><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><blockquote><p>注意：这个功能只在支持 history.pushState 的浏览器中可用。</p></blockquote><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;  if (savedPosition) &#123;    return savedPosition  &#125; else &#123;    return &#123; x: 0, y: 0 &#125;  &#125;&#125;</code></pre><blockquote><p>4、路由懒加载</p></blockquote><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名chunk，一个特殊的注释语法来提供chunk name(需要 Webpack &gt; 2.4)。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><h2 id="表单输入控制"><a href="#表单输入控制" class="headerlink" title="表单输入控制"></a>表单输入控制</h2><blockquote><p>表单修饰符：如果是简单的控制输入一定是数字或者去掉用户输入的收尾空白符，可以直接使用 Vue 提供的表单修饰符 .number 和 .trim</p></blockquote><p>1、如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><pre><code class="vue">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre><p>2、如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><pre><code class="vue">&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre><blockquote><p>change事件:给表单绑定事件，在事件处理中进行表单输入控制</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value2&quot; type=&quot;text&quot; @change=&quot;inputChange(value2)&quot; /&gt;</code></pre><pre><code class="js">methods: &#123;  inputChange: function(val) &#123;    if (!val) return &#39;&#39;    val = val.toString()    this.value2 = val.charAt(0).toUpperCase() + val.slice(1)  &#125;&#125;</code></pre><blockquote><p>filter过滤器</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value1&quot;  type=&quot;text&quot; /&gt;</code></pre><pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;  if (!value) return &#39;&#39;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)</code></pre><pre><code class="js">watch: &#123;  value1(val) &#123;     this.value1 = this.$options.filters.capitalize(val);  &#125;&#125;</code></pre><blockquote><p>指令:声明一个全局指令</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// 只能输入正整数,0-9的数字Vue.directive(&#39;enterIntNumber&#39;, &#123;  inserted: function (el) &#123;    let trigger = (el, type) =&gt; &#123;      const e = document.createEvent(&#39;HTMLEvents&#39;)      e.initEvent(type, true, true)      el.dispatchEvent(e)    &#125;    el.addEventListener(&quot;keyup&quot;, function (e) &#123;      let input = e.target;      let reg = new RegExp(&#39;^\\d&#123;1&#125;\\d*$&#39;);  //正则验证是否是数字      let correctReg = new RegExp(&#39;\\d&#123;1&#125;\\d*&#39;);  //正则获取是数字的部分      let matchRes = input.value.match(reg);      if (matchRes === null) &#123;        // 若不是纯数字 把纯数字部分用正则获取出来替换掉        let correctMatchRes = input.value.match(correctReg);        if (correctMatchRes) &#123;          input.value = correctMatchRes[0];        &#125; else &#123;          input.value = &quot;&quot;;        &#125;      &#125;      trigger(input, &#39;input&#39;)    &#125;);  &#125;&#125;);</code></pre></details><pre><code class="html">&lt;!--限制输入正整数--&gt;&lt;input v-enterIntNumber placeholder=&quot;0&quot; type=&quot;number&quot;&gt;</code></pre><h1 id="Vue渲染目标元素的6种方法"><a href="#Vue渲染目标元素的6种方法" class="headerlink" title="Vue渲染目标元素的6种方法"></a>Vue渲染目标元素的6种方法</h1><p>1、直接创建Vue实例</p><details><summary>点击展示代码</summary><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- 这里直接引入cdn源码 --&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    template: &quot;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&quot;,    data()&#123;      return&#123;        message:&#39;Hello Vue.js!&#39;      &#125;    &#125;  &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></details><p>2、Vue.extend</p><blockquote><p>Vue.extend(options) 方式是使用Vue构造器的一个“子类”，其参数同Vue(options)一模一样，唯一的不同是没有 el 属性来指定挂载的DOM元素，所以这里需要通过 $mount() 方法，来手动实现挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  var app = Vue.extend(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello extend&#39;      &#125;    &#125;  &#125;)  // 注意这里 Vue.extend 方式是生成了一个 Vue 子类，所以需要 new关键字来重新创建，然后手动挂载。  new app().$mount(&#39;#app&#39;);  &lt;/script&gt;</code></pre></details><p>3.Vue.component</p><blockquote><p>Vue.component(id, [definition])方式是注册一个名称为id的全局组件，然后我们可以通过使用该组件来，实现目标元素渲染。其中definition 参数同 Vue.extend 中的参数一模一样，方法一样，需要使用$mount()方法手动挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  // var app = Vue.component(&#39;hello&#39;, &#123;  //     template:&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,  //   data() &#123;  //     return &#123;  //       msg: &#39;hello component&#39;  //     &#125;  //   &#125;  // &#125;)  // new app().$mount(&#39;#app&#39;)  //1、 注册组件  Vue.component(&#39;hello&#39;, &#123;    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello component&#39;      &#125;    &#125;  &#125;)  // 2、创建Vue实例  new Vue(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;hello /&gt;&#39;  &#125;)  &lt;/script&gt;</code></pre><blockquote><p>仅仅注册组件式不够的，我们还要通过创建一个Vue实例，才能使用该组件。</p></blockquote></details><p>4、Vue.directive自定义指令</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;div v-hello=&quot;msg&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;  Vue.directive(&#39;hello&#39;, &#123;    bind: function(el, binding) &#123;      el.innerHTML = &quot;&lt;h1&gt;&quot; + binding.value + &quot;&lt;/h1&gt;&quot;    &#125;  &#125;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello directive 自定义指令&quot;      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>5、Vue.compile</p><blockquote><p>Vue.compile(template) 参数也就是 template 模板字符串属性，然后通过替换 Vue实例的 render 函数，来实现渲染。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;      // 参数就是template模板字符串  然后通过替换Vue实例的render函数来实现渲染  var tpl = Vue.compile(&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;&#39;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello,compile&quot;      &#125;    &#125;,    render: tpl.render  &#125;)  &lt;/script&gt;</code></pre></details><p>6、render</p><blockquote><p>Vue实例在创建的过程中也会调用 render 函数，render 函数默认会传递一个参数,我们可以通过 createElement 来动态创建一个 VNode，以此来渲染目标元素</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &#39;hello,render&#39;      &#125;    &#125;,    render: function(createElement) &#123;      return createElement(&#39;h1&#39;, this.msg)    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><h1 id="data-computed-watch"><a href="#data-computed-watch" class="headerlink" title="data/computed/watch"></a>data/computed/watch</h1><p>1、data</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;        &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        list: [&#123;          name: &#39;vue js&#39;,          url: &#39;https://cn.vuejs.org&#39;        &#125;, &#123;          name: &#39;github&#39;,          url: &#39;https://github.com&#39;        &#125;, &#123;          name: &#39;blog&#39;,          url: &#39;issummer.cn&#39;        &#125;]      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.list.push(&#123;          name: &#39;baidu&#39; + this.count,          url: &#39;https://www.baidu.com&#39;        &#125;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>2、computed</p><blockquote><p>computed 中的属性是需要先进行计算，然后再返回想要的数据的。当我们输出某个属性，必须依赖另外一个 data 中的属性来动态计算获得的，此时使用 computed 就非常简单了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;      &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;      &lt;ul&gt;          &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;              &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;          &lt;/li&gt;      &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        // 这里是后台数据        requestList: [          &#39;vuejs https://cn.vuejs.org&#39;,          &#39;github https://github.com&#39;,          &#39;blog https://issummer.cn&#39;        ]      &#125;    &#125;,    computed: &#123;      list: function() &#123;        var list = []        this.requestList.map(function(item, index) &#123;          var tempArr = item.split(&#39;-&#39;)          list.push(&#123;            name: tempArr[0],            url: tempArr[1]          &#125;)        &#125;)        return list      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.requestList.push(&#39;blog&#39; + this.count + &#39;issummer.cn&#39;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><blockquote><p>计算是可以修改的,计算属性不仅可以定义为一个函数，也可以定义为一个含有 get/set 属性的对象。当我们定义为一个函数是，Vue 内部会默认将这个函数赋值给 get 属性，一般 set 是未定义的。当我们定义 set 属性后，就可以对它进行修改了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;    &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        firstName: &#39;Jude&#39;,        lastName: &#39;Summer&#39;      &#125;    &#125;,    computed: &#123;      username: &#123;        get: function() &#123;          return this.firstName + &#39; &#39; + this.lastName        &#125;,        set: function(newVal) &#123;          var names = newVal.split(&#39; &#39;);          this.firstName = names[0];          this.lastName = names[1];        &#125;      &#125;    &#125;,    methods:&#123;        changeName()&#123;            if(this.username === &#39;Jude Summer&#39;)&#123;                this.username = &quot;YQ&quot;            &#125;else&#123;                this.username = &#39;Jude Summer&#39;            &#125;        &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>3、watch侦听器</p><blockquote><p>创建 Vue 应用时，我们还提到过 watch 这个属性，它其实是个对象，键是需要观察的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。和上面的计算属性类似，他可以监听 值/表达式 的变化来执行回调函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;        &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    firstName: &#39;Jude&#39;,                    lastName: &#39;Summer&#39;,                    username: &#39;Jude Summer&#39;                &#125;            &#125;,            watch: &#123;                firstName: function (val, oldVal) &#123;                    this.username = val + &#39; &#39; + this.lastName;                &#125;,                lastName: function (val, oldVal) &#123;                    this.username = this.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                changeName() &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.firstName = &quot;Y&quot;;                        this.lastName = &quot;Q&quot;;                    &#125; else &#123;                        this.firstName = &quot;Jude&quot;;                        this.lastName = &quot;Summer&quot;;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 监听对象属性    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 此时无论我们如何点击按钮，都无法改变 username 的值，因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听                userinfo: function (val, oldVal) &#123;                    this.username = val.firstName + &#39; &#39; + val.lastName;                &#125;            &#125;,            methods: &#123;                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 上面的方法是无法修改username的值 因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听。实际上对于侦听的值是可以为一个对象的，它还有个 deep 属性，用来设置是否侦听内部属性的变化，而回调函数是通过 handler 来设置的     &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // depp属性用来侦听内部属性变化，回调函数是通过hander来设置                // 适用于非整体赋值  也就是适用于局部修改属性，这个时候通过设置deep属性为true，来达到侦听目的。                userinfo: &#123;                    deep: true,                    handler: function (val, oldVal) &#123;                        this.username = val.firstName + &quot; &quot; + val.lastName;                    &#125;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 写成对象属性访问表达式的    当侦听对象包含很多属性，而我们只是需要监听其中的一个或某几个属性，这时如果我们通过这种方式侦听所有内部属性的变化，自然就会造成内存的浪费。那么我们可以只侦听单一内部属性的变化    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 侦听对象的某个属性                &#39;userinfo.lastName&#39;:function(val,oldVal)&#123;                    this.username = this.userinfo.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        // this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        // this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;</code></pre></details><h1 id="v-on对象语法"><a href="#v-on对象语法" class="headerlink" title="v-on对象语法"></a>v-on对象语法</h1><blockquote><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p></blockquote><p>通常的写法：</p><pre><code class="html">&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</code></pre><p>对象语法: </p><pre><code class="html">&lt;div v-on=&quot;&#123; mouseenter: ShowInfo, mouseleave: HideInfo &#125;&quot;&gt;  &lt;div&gt;我是title&lt;/div&gt;  &lt;div v-show=&quot;ShowWrapper&quot;&gt;我是显示的内容！&lt;/div&gt;&lt;/div&gt;</code></pre><h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><blockquote><p>有时候，我们需要将router-link渲染成某种标签，例如<code>&lt;li&gt;&lt;/li&gt;</code>使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航</p></blockquote><p>示例:</p><pre><code class="html">&lt;ul class=&quot;nav-list&quot;&gt;  &lt;router-link tag=&quot;li&quot; to=&quot;home&quot;&gt;home&lt;/router-link&gt;&lt;/ul&gt;&lt;!-- 渲染的结果为 --&gt;&lt;li&gt;home&lt;/li&gt;</code></pre><h1 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h1><blockquote><p>可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。提供具名插槽或需要接收 prop 的插槽。</p></blockquote><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div class=&quot;common-card&quot;&gt;    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;value&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;chart&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;total&quot;&gt;      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="html">&lt;!-- 子组件 --&gt;  &lt;common-card title=&quot;今日交易用户数&quot; :value=&quot;1234567890&quot;&gt;    &lt;template&gt;      &lt;v-chart :options=&quot;getOptions()&quot; /&gt;    &lt;/template&gt;    &lt;template v-slot:footer&gt;      &lt;span&gt;退货率&lt;/span&gt;      &lt;span class=&quot;emphasis&quot;&gt;12%&lt;/span&gt;    &lt;/template&gt;  &lt;/common-card&gt;</code></pre><h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote><p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p></blockquote><blockquote><p>常用于父组件与子组件的通信<br>对象语法选项包括:</p></blockquote><p>1、type：原生构造函数的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。</p><p>2、default: any 默认值</p><p>3、required:Boolean 该prop是否是必填项</p><p>4、validator: Function 校验函数</p><pre><code class="js">  props: &#123;    // 检测类型    title: String,    // 检测类型 + 其他验证    age: &#123;      type: Number, //类型      default: 0,// 默认值      required: true,// 是否是必填项      // 校验函数      validator: function (value) &#123;        return value &gt;= 0      &#125;    &#125;  &#125;</code></pre><h1 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h1><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote><p>1、实现原理</p><blockquote><p>将用户传入的对象与 Vue 自身的options属性合并，合并后的对象将会覆盖原来的Vue.options。因为 mixin 方法修改了Vue.options属性，之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。</p></blockquote><p>注意：如果用户传入的对象与组件有相同的数据对象，将会发生合并，并且遵循组件数据优先的原则。对于钩子函数来说，如果相同，将会合并为一个数组，所以都会被调用，只是混入对象的钩子会被先调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><pre><code class="js">// vue源码 vue/src/core/global-api/mixin.jsimport &#123; mergeOptions &#125; from &#39;../util/index&#39;export function initMixin (Vue: GlobalAPI) &#123;  Vue.mixin = function (mixin: Object) &#123;    this.options = mergeOptions(this.options, mixin)    return this  &#125;&#125;</code></pre><p>2、如何理解mixin?</p><p>可以将mixin理解为数组，数组中有单个或者多个mixin，mixin的本质就是js对象，拥有Vue实例的所有属性，例如：data,created,methods等，还可以在mixin中再次嵌套mixin</p><p>注意：在组件中引入的方式为 <code>mixins:[myMixin]</code></p><p>3、mixin的实现</p><blockquote><p>当Vue在实例的时候，会调用mergeOptions函数进行options的合并</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// vue源码 core/util/options.jsexport function mergeOptions(  parent: Object,  child: Object,  vm?: Component): Object &#123;  ...  // 如果有 child.extends 递归调用 mergeOptions 实现属性拷贝  const extendsFrom = child.extends  if (extendsFrom) &#123;    parent = mergeOptions(parent, extendsFrom, vm)  &#125;  // 如果有 child.mixins 递归调用 mergeOptions 实现属性拷贝  if (child.mixins) &#123;    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;      parent = mergeOptions(parent, child.mixins[i], vm)    &#125;  &#125;  // 申明 options 空对象，用来保存属性拷贝结果  const options = &#123;&#125;  let key  // 遍历 parent 对象，调用 mergeField 进行属性拷贝  for (key in parent) &#123;    mergeField(key)  &#125;  // 遍历 child 对象，调用 mergeField 进行属性拷贝  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123;      mergeField(key)    &#125;  &#125;  // 属性拷贝实现方法 mergeField 函数接收一个 key，首先会申明 strat 变量，如果 strats[key] 为真，就将 strats[key] 赋值给 strat。  function mergeField(key) &#123;    // 穿透赋值，默认为 defaultStrat    const strat = strats[key] || defaultStrat    options[key] = strat(parent[key], child[key], vm, key)  &#125;  return options&#125;</code></pre></details><blockquote><p>vue 中 mixins 的优先级，component &gt; mixins &gt; extends。</p></blockquote><h1 id="边界处理：inject-provide"><a href="#边界处理：inject-provide" class="headerlink" title="边界处理：inject/provide"></a>边界处理：inject/provide</h1><p>类型：</p><blockquote><p>provide：Object | () =&gt; Object</p></blockquote><blockquote><p>inject：Array<string> | { [key: string]: string | Symbol | Object }</p></blockquote><p>provide和inject需要一起使用，可以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件的层次有多深，并在其上下游关系成立的时间里始终生效。</p><p>同react的上下文特性相似</p><details><summary>点击展示代码</summary><pre><code class="js">// 父级组件提供 &#39;foo&#39;var Provider = &#123;  provide: &#123;    foo: &#39;bar&#39;  &#125;,  // ...&#125;// 子组件注入 &#39;foo&#39;var Child = &#123;  inject: [&#39;foo&#39;],  created () &#123;    console.log(this.foo) // =&gt; &quot;bar&quot;  &#125;  // ...&#125;</code></pre></details><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单的说，vuex就是一个状态管理器。</p></blockquote><p>开发过程，通常会遇到多个视图依赖同一个状态，不同视图的行为需要变更为同一状态（例如：后台管理系统的侧边栏的收缩功能。）</p><p>Vuex的核心就是store，它就是一个仓库容器，包含了驱动应用的数据源（state），不同于单纯的全局对象，vuex的状态存储是响应式的，当 Vue组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2019/08/22/hello-world/"/>
      <url>/2019/08/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>hexo常用命令</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="js">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="js">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="js">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DOMContentLoaded</title>
      <link href="/2019/08/18/DOMContentLoaded/"/>
      <url>/2019/08/18/DOMContentLoaded/</url>
      
        <content type="html"><![CDATA[<p>DOMContentLoaded顾名思义就是DOM内容加载完毕。</p><span id="more"></span><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 这里有一个常见的错误，就是在本应使用 DOMContentLoaded 会更加合适的情况下，却选择使用 load，所以要谨慎。<br>注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。</p><p>在Vue项目的App.vue中，我们可以这样设置字体。</p><p>1、获取HTML元素；</p><p>2、根据屏幕宽度动态计算fontSize</p><p>3、当fontSize大于50时，设置最大值为50</p><p>4、设置HTML的fontSize属性，使rem生效，1rem = fontSize + “px”</p><pre><code class="js">&lt;script&gt;// DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。  document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;    // 获取html元素    const html = document.querySelector(&#39;html&#39;)    // 根据屏幕宽度动态计算fontSize    let fontSize = window.innerWidth / 10    // 当fontSize大于50时，设置最大值为50    fontSize = fontSize &gt; 50 ? 50 : fontSize    // 设置html的fontSize属性，使rem生效，1rem = fontSize + &#39;px&#39;    html.style.fontSize = fontSize + &#39;px&#39;  &#125;)&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用CSS画三角形?</title>
      <link href="/2019/06/20/css/"/>
      <url>/2019/06/20/css/</url>
      
        <content type="html"><![CDATA[<p>三角形的画法,一般经常使用三角形作为提示框、下拉菜单等功能。</p><span id="more"></span><p>实现方式：</p><p>1、HTML结构</p><pre><code class="html">&lt;div class=&quot;item0&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item3&quot;&gt;&lt;/div&gt;</code></pre><p>2、将类名为item的块级元素的width、height设置为0</p><pre><code class="css">.item0&#123;    width:0;    height:0;&#125;</code></pre><p>3、将类名为item的元素的3个border的颜色设置为transparent，箭头指向的对面border设置颜色；</p><pre><code class="css">.item0&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 50px solid transparent;    border-top: 50px solid transparent;    border-bottom: 80px solid blue;    background: white;&#125;</code></pre><p>上面的为方向向上的三角形<br>4、依次类推可以画出方向向左、右、下的三角形</p><pre><code class="css">.item1&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 50px solid transparent;    border-top: 80px solid green;    border-bottom: 50px solid transparent;    background: white;&#125;.item2&#123;    width: 0px;    height: 0px;    border-left: 50px solid transparent;    border-right: 80px solid violet;    border-top: 50px solid transparent;    border-bottom: 50px solid transparent;    background: white;&#125;.item3&#123;    width: 0px;    height: 0px;    border-left: 80px solid purple;    border-right: 50px solid transparent;    border-top: 50px solid transparent;    border-bottom: 50px solid transparent;    background: white;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序checkbox-group</title>
      <link href="/2019/01/20/check-group/"/>
      <url>/2019/01/20/check-group/</url>
      
        <content type="html"><![CDATA[<p>checkbox-group多项选择器，内部由多个checkbox组成；<br>主要的属性bindchange   说明checkbox-group中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]};</p><span id="more"></span><pre><code class="html">&lt;checkbox-group  class=&quot;checkbox_group&quot; bindchange=&quot;checkboxChange&quot;&gt;    &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;item&quot;&gt;        &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot;  checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot; /&gt;        &#123;&#123;item.value&#125;&#125;    &lt;/label&gt;&lt;/checkbox-group&gt;</code></pre><p>每一次修改选中项，都需要一个空数组去存放选中项。</p><details><summary>点我展示代码</summary><pre><code class="js">  checkboxChange(e) &#123;    const items = this.data.items;     const values = e.detail.value;    // 设置选中的数组为空  选中的id push到数组里面    this.data.vehicle_arr = [];    for (let i = 0, lenI = items.length; i &lt; lenI; ++i) &#123;      items[i].checked = false // 遍历items，让所有的选中状态都为false      for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123;        if (items[i].value === values[j]) &#123;          items[i].checked = true;          const List = items[i].name.toString().split();          for (let k in List) &#123;            this.data.vehicle_arr.push(List[k]);          &#125;        &#125;      &#125;    &#125;    // 选中的id    this.data.unique = [...new Set(this.data.vehicle_arr)];    this.setData(&#123;      driverarr: e.detail.value.join(&quot;,&quot;), // 多选的数组      items,    &#125;);  &#125;,</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>119、稀土掘金小册-记账本（十） 个人中心 （完结）</title>
      <link href="/2023/01/31/119-react/"/>
      <url>/2023/01/31/119-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>行文至此，万里长征已经快要走到头了。本章节带同学们来编写最后一个模块 —— 个人中心。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7faa8d9d5851499ba78625108b2ddea1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>个人中心模块分几个功能点，首先是头部的用户信息展示，包括头像、用户昵称、个人签名。其次是一些账号相关的操作，如用户信息修改、密码重置等。最后是退出登录，将其放置于页面底部，并且设置二次确认弹窗，避免误触。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>图片资源上传格式处理。</li><li>原生表单插件 <code>rc-form</code> 的使用。</li><li>底部导航栏定位。</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="头部信息展示"><a href="#头部信息展示" class="headerlink" title="头部信息展示"></a>头部信息展示</h4><p>修改 <code>container/User/index.jsx</code> 代码如下：</p><pre><code class="js">import React from &quot;react&quot;;import s from &quot;./style.module.less&quot;;const User = () =&gt; &#123;  return (    &lt;div className=&#123;s.user&#125;&gt;      &lt;div className=&#123;s.head&#125;&gt;        &lt;div className=&#123;s.info&#125;&gt;          &lt;span&gt;昵称：测试&lt;/span&gt;          &lt;span&gt;            &lt;img              style=&#123;&#123; width: 30, height: 30, verticalAlign: "-10px" &#125;&#125;              src=&quot;//s.yezgea02.com/1615973630132/geqian.png&quot;              alt=&quot;&quot;            /&gt;            &lt;b&gt;个性签名&lt;/b&gt;          &lt;/span&gt;        &lt;/div&gt;        &lt;img          className=&#123;s.avatar&#125;          style=&#123;&#123; width: 60, height: 60, borderRadius: 8 &#125;&#125;          src=&#123;&quot;//s.yezgea02.com/1624959897466/avatar.jpeg&quot;&#125;          alt=&quot;&quot;        /&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default User;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>这里给 <code>.head</code> 一个背景图片，介绍一下顶部的布局思路，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7140a83118464d419c020dd84616954f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在 <code>.head</code> 内通过 <code>flex</code> 实现左右布局，在 <code>.info</code> 内通过 <code>flex</code> 的 <code>flex-direction</code> 设置为 <code>column</code> 实现上下布局。</p><p><code>.head</code> 底部留出的位置，用于放置后续的操作。</p><p>完成布局之后，将数据填上，通过 <code>/api/user/get_userinfo</code> 接口，获取用户信息，添加代码如下：</p><pre><code class="js">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;import &#123; get &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;const User = () =&gt; &#123;  const [user, setUser] = useState(&#123;&#125;);  useEffect(() =&gt; &#123;    getUserInfo();  &#125;, []);  // 获取用户信息  const getUserInfo = async () =&gt; &#123;    const &#123; data &#125; = await get(&quot;/api/user/get_userinfo&quot;);    setUser(data);    setAvatar(data.avatar);  &#125;;  return (    &lt;div className=&#123;s.user&#125;&gt;      &lt;div className=&#123;s.head&#125;&gt;        &lt;div className=&#123;s.info&#125;&gt;          &lt;span&gt;昵称：&#123;user.username || &quot;--&quot;&#125;&lt;/span&gt;          &lt;span&gt;            &lt;img              style=&#123;&#123; width: 30, height: 30, verticalAlign: "-10px" &#125;&#125;              src=&quot;//s.yezgea02.com/1615973630132/geqian.png&quot;              alt=&quot;&quot;            /&gt;            &lt;b&gt;&#123;user.signature || &quot;暂无个签&quot;&#125;&lt;/b&gt;          &lt;/span&gt;        &lt;/div&gt;        &lt;img          className=&#123;s.avatar&#125;          style=&#123;&#123; width: 60, height: 60, borderRadius: 8 &#125;&#125;          src=&#123;user.avatar || &quot;&quot;&#125;          alt=&quot;&quot;        /&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default User;</code></pre><p><code>/api/user/get_userinfo</code> 接口返回字段分析：</p><ul><li>avatar：头像地址，这里要注意，我目前采用的线上接口，如果是本地开发的情况，需要修改你的 <code>host</code>。</li><li>signature：个性签名。</li><li>username：用户登录名称。</li></ul><p>浏览器展示如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38d7bc9820bb40af9b3c0a587ea44c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="用户信息相关操作"><a href="#用户信息相关操作" class="headerlink" title="用户信息相关操作"></a>用户信息相关操作</h4><p>紧接着，我们需要布局用户相关操作的内容，在上述基础上添加如下代码：</p><pre><code class="js">...import &#123; useNavigate &#125; from &#39;react-router-dom&#39;;import &#123; Cell,  &#125; from &#39;zarm&#39;;const User = () =&gt; &#123;  ...  const navigateTo = useNavigate();  return &lt;div className=&#123;s.user&#125;&gt;    ...    &lt;div className=&#123;s.content&#125;&gt;      &lt;Cell        hasArrow        title=&quot;用户信息修改&quot;        onClick=&#123;() =&gt; navigateTo(&#39;/userinfo&#39;)&#125;        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615974766264/gxqm.png&quot; alt=&quot;&quot; /&gt;&#125;      /&gt;      &lt;Cell        hasArrow        title=&quot;重制密码&quot;        onClick=&#123;() =&gt; navigateTo(&#39;/account&#39;)&#125;        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615974766264/zhaq.png&quot; alt=&quot;&quot; /&gt;&#125;      /&gt;      &lt;Cell        hasArrow        title=&quot;关于我们&quot;        onClick=&#123;() =&gt; navigateTo(&#39;/about&#39;)&#125;        icon=&#123;&lt;img style=&#123;&#123; width: 20, verticalAlign: '-7px' &#125;&#125; src=&quot;//s.yezgea02.com/1615975178434/lianxi.png&quot; alt=&quot;&quot; /&gt;&#125;      /&gt;    &lt;/div&gt;  &lt;/div&gt;&#125;;</code></pre><p>添加样式：</p><pre><code class="css">... .content &#123;  width: 90%;  position: absolute;  top: 120px;  left: 50%;  transform: translateX(-50%);  box-shadow: 3px 2px 20px 10px rgba(0, 0, 0, 0.1);  border-radius: 10px;  overflow: hidden;&#125;</code></pre><p>代码部分，直接采用 <code>Zarm</code> 组件库提供的 <code>Cell</code> 组件，它适用于列表布局，<a href="https://link.juejin.cn/?target=https://zarm.gitee.io/%23/components/cell">官方文档</a>提供了很多列表布局的例子，可以直接在内部拷贝代码进行二次加工。能不用自己写样式，尽量就不要写。用组件库的目的，就是减少工作量，提高布局的效率。</p><p>浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efc9a9ee5b794140b0da572a651b67f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这里有三个列表跳转项，分别是 <code>userinfo</code>、<code>account</code>、<code>about</code>。我们逐一击破。</p><p>首先我们在 <code>container</code> 目录下新建一个 <code>UserInfo</code> 目录，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508f67feaa5745689513b1c3a4037bbb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>添加 <code>index.js</code> 和 <code>style.module.less</code>，并且在 <code>router/index.js</code> 内添加相对应的路由配置项。</p><p>于是我们尝试点击「修改用户信息」，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be3e4fe43b5f48afa0e627a53efcdada~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>成功之后，我们便可在 <code>UserInfo</code> 中编写编辑用户相关信息的操作，在编写正式代码之前，我们先对 <code>Zarm</code> 的上传组件进行分析，我们尝试编写如下代码：</p><pre><code class="js">import React from &quot;react&quot;;import &#123; FilePicker, Button &#125; from &quot;zarm&quot;;import s from &quot;./style.module.less&quot;;const UserInfo = () =&gt; &#123;  const handleSelect = (file) =&gt; &#123;    console.log(&quot;file&quot;, file);  &#125;;  return (    &lt;div className=&#123;s.userinfo&#125;&gt;      &lt;FilePicker onChange=&#123;handleSelect&#125; accept=&quot;image/*&quot;&gt;        &lt;Button theme=&quot;primary&quot; size=&quot;xs&quot;&gt;          点击上传        &lt;/Button&gt;      &lt;/FilePicker&gt;    &lt;/div&gt;  );&#125;;export default UserInfo;</code></pre><p>点击按钮，上传一张图片，我们查看回调函数 <code>handleSelect</code> 的执行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5668a3d8c3ac48fc9c793060570ddf8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时，我们需要的是上传资源的原始文件，在上述返回对象中，<code>file</code> 属性为 <code>File</code> 文件类型，它是浏览器返回的原生对象，我们需要通过下列代码，将其改造成一个 <code>form-data</code> 对象：</p><pre><code class="js">const handleSelect = (file) =&gt; &#123;  console.log(&quot;file&quot;, file);  let formData = new FormData();  formData.append(&quot;file&quot;, file.file);&#125;;</code></pre><p>再将 <code>formData</code> 通过 <code>axios</code> 上传到服务器，服务端通过 <code>ctx.request.files[0]</code> 获取到前端上传的 文件原始对象，并将其读取，存入服务器内部。这样就完成了一套前端上传资源，服务端存储并返回路径的一个过程。</p><p>接下来进行完整代码的编写，如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; Button, FilePicker, Input, Toast &#125; from &quot;zarm&quot;;import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;import Header from &quot;@/components/Header&quot;; // 由于是内页，使用到公用头部import axios from &quot;axios&quot;; // // 由于采用 form-data 传递参数，所以直接只用 axios 进行请求import &#123; get, post &#125; from &quot;@/utils&quot;;import &#123; baseUrl &#125; from &quot;config&quot;; // 由于直接使用 axios 进行请求，统一封装了请求 baseUrlimport s from &quot;./style.module.less&quot;;const UserInfo = () =&gt; &#123;  const navigateTo = useNavigate(); // 路由实例  const [user, setUser] = useState(&#123;&#125;); // 用户  const [avatar, setAvatar] = useState(&quot;&quot;); // 头像  const [signature, setSignature] = useState(&quot;&quot;); // 个签  const token = localStorage.getItem(&quot;token&quot;); // 登录令牌  useEffect(() =&gt; &#123;    getUserInfo(); // 初始化请求  &#125;, []);  // 获取用户信息  const getUserInfo = async () =&gt; &#123;    const &#123; data &#125; = await get(&quot;/api/user/get_userinfo&quot;);    setUser(data);    setAvatar(data.avatar);    setSignature(data.signature);  &#125;;  // 获取图片回调  const handleSelect = (file) =&gt; &#123;    console.log(&quot;file.file&quot;, file.file);    if (file &amp;&amp; file.file.size &gt; 200 * 1024) &#123;      Toast.show(&quot;上传头像不得超过 200 KB！！&quot;);      return;    &#125;    let formData = new FormData();    // 生成 form-data 数据类型    formData.append(&quot;file&quot;, file.file);    // 通过 axios 设置  &#39;Content-Type&#39;: &#39;multipart/form-data&#39;, 进行文件上传    axios(&#123;      method: &quot;post&quot;,      url: `$&#123;baseUrl&#125;/upload`,      data: formData,      headers: &#123;        &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,        Authorization: token,      &#125;,    &#125;).then((res) =&gt; &#123;      // 返回图片地址      setAvatar(res.data);    &#125;);  &#125;;  // 编辑用户信息方法  const save = async () =&gt; &#123;    const &#123; data &#125; = await post(&quot;/api/user/edit_userinfo&quot;, &#123;      signature,      avatar,    &#125;);    Toast.show(&quot;修改成功&quot;);    // 成功后回到个人中心页面    navigateTo(-1);  &#125;;  return (    &lt;&gt;      &lt;Header title=&quot;用户信息&quot; /&gt;      &lt;div className=&#123;s.userinfo&#125;&gt;        &lt;h1&gt;个人资料&lt;/h1&gt;        &lt;div className=&#123;s.item&#125;&gt;          &lt;div className=&#123;s.title&#125;&gt;头像&lt;/div&gt;          &lt;div className=&#123;s.avatar&#125;&gt;            &lt;img className=&#123;s.avatarUrl&#125; src=&#123;avatar&#125; alt=&quot;&quot; /&gt;            &lt;div className=&#123;s.desc&#125;&gt;              &lt;span&gt;支持 jpg、png、jpeg 格式大小 200KB 以内的图片&lt;/span&gt;              &lt;FilePicker                className=&#123;s.filePicker&#125;                onChange=&#123;handleSelect&#125;                accept=&quot;image/*&quot;              &gt;                &lt;Button className=&#123;s.upload&#125; theme=&quot;primary&quot; size=&quot;xs&quot;&gt;                  点击上传                &lt;/Button&gt;              &lt;/FilePicker&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div className=&#123;s.item&#125;&gt;          &lt;div className=&#123;s.title&#125;&gt;个性签名&lt;/div&gt;          &lt;div className=&#123;s.signature&#125;&gt;            &lt;Input              clearable              type=&quot;text&quot;              value=&#123;signature&#125;              placeholder=&quot;请输入个性签名&quot;              onChange=&#123;(value) =&gt; setSignature(value)&#125;            /&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;Button onClick=&#123;save&#125; style=&#123;&#123; marginTop: 50 &#125;&#125; block theme=&quot;primary&quot;&gt;          保存        &lt;/Button&gt;      &lt;/div&gt;    &lt;/&gt;  );&#125;;export default UserInfo;</code></pre><p>详细的注释信息，已经在上述代码中表明，需要注意的是，本次请求直接使用了 <code>axios</code> 方法，所以我们需要将 <code>baseUrl</code> 单独封装到一个配置文件中，便于后续使用，在 <code>src</code> 目录下新建 <code>config/index.js</code>，添加如下代码：</p><pre><code class="js">const MODE = import.meta.env.MODE; // 环境变量export const baseUrl =  MODE == &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;</code></pre><p><code>MODE</code> 作为 <code>vite</code> 运行时的环境变量，可以通过它来配置开发环境和生成环境的一些变量差异。</p><p>然后需要在 <code>vite.config.js</code> 中修改如下：</p><pre><code class="js">resolve: &#123;    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;), // src 路径      &#39;utils&#39;: path.resolve(__dirname, &#39;src/utils&#39;), // src 路径      &#39;config&#39;: path.resolve(__dirname, &#39;src/config&#39;) // src 路径    &#125;  &#125;,</code></pre><p>配置好 <code>config</code> ，便可以直接在代码中通过：</p><pre><code class="js">import &#123; baseUrl &#125; from &quot;config&quot;;</code></pre><p>上述形式来获取 <code>config</code> 中的变量信息。</p><p>重启项目，浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8155a0c93fbe47d1a5c061ffb57d91fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>通过请求，得到的路径是这样的，因为我们在服务端返回的地址就是一个相对路径，所以我们需要给路径加上 <code>host</code>，要注意如果你是本地启动的服务端代码，这里的 <code>host</code> 就是你的服务端代码启动的 <code>host</code>，如 <code>locahost:7001</code>，而我目前使用的是在线接口，所以我们在 <code>utils/index.js</code> 下新增一个图片地址转换的方法，如下所示：</p><pre><code class="js">// utils/index.jsimport &#123; baseUrl &#125; from &#39;config&#39;const MODE = import.meta.env.MODE // 环境变量...export const imgUrlTrans = (url) =&gt; &#123;  if (url &amp;&amp; url.startsWith(&#39;http&#39;)) &#123;    return url  &#125; else &#123;    url = `$&#123;MODE == &#39;development&#39; ? &#39;http://api.chennick.wang&#39; : baseUrl&#125;$&#123;url&#125;`    return url  &#125;&#125;</code></pre><p>然后在 <code>UserInfo/index.jsx</code> 中引入 <code>imgUrlTrans</code> 并如下使用：</p><pre><code class="js">// 获取用户信息const getUserInfo = async () =&gt; &#123;  const &#123; data &#125; = await get(&#39;/api/user/get_userinfo&#39;);  setUser(data);  setAvatar(imgUrlTrans(data.avatar))  setSignature(data.signature)&#125;;...// 返回图片地址setAvatar(imgUrlTrans(res.data))</code></pre><p>再次打开浏览器，点击选择图片如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/806c25af2a8c4622a7286a1b68f0bcf9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>保存后，数据成功修改，我们如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3260506bed5945fa94fb872358850ad8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h4><p>完成用户信息编辑之后，接下来实现重置密码部分，我们在 <code>container</code> 目录下新建 <code>Account</code> 目录，在内部分别新建 <code>index.jsx</code> 和 <code>style.module.less</code>。</p><p>首先我们需要安装 <code>rc-form</code> 作为本次页面的表单组件，因为 <code>Zarm</code> 没有提供表单组件，包括 <code>Antd Mobile</code> 这样的组件，也没有提供表单相关的组件，所以这里我们需要使用 <code>rc-form</code> 自己编写表单相关验证方法，它也是 <code>antd</code> 官方使用的表单组件。</p><pre><code class="bash">npm i rc-form -S</code></pre><p>我们为 <code>Account/index.jsx</code> 添加如下代码：</p><pre><code class="js">// Account/index.jsximport React from &quot;react&quot;;import &#123; Cell, Input, Button, Toast &#125; from &quot;zarm&quot;;import &#123; createForm &#125; from &quot;rc-form&quot;;import Header from &quot;@/components/Header&quot;;import &#123; post &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;const Account = (props) =&gt; &#123;  // Account 通过 createForm 高阶组件包裹之后，可以在 props 中获取到 form 属性  const &#123; getFieldProps, getFieldError &#125; = props.form;  // 提交修改方法  const submit = () =&gt; &#123;    // validateFields 获取表单属性元素    props.form.validateFields(async (error, value) =&gt; &#123;      // error 表单验证全部通过，为 false，否则为 true      if (!error) &#123;        console.log(value);        if (value.newpass != value.newpass2) &#123;          Toast.show(&quot;新密码输入不一致&quot;);          return;        &#125;        await post(&quot;/api/user/modify_pass&quot;, &#123;          old_pass: value.oldpass,          new_pass: value.newpass,          new_pass2: value.newpass2,        &#125;);        Toast.show(&quot;修改成功&quot;);      &#125;    &#125;);  &#125;;  return (    &lt;&gt;      &lt;Header title=&quot;重制密码&quot; /&gt;      &lt;div className=&#123;s.account&#125;&gt;        &lt;div className=&#123;s.form&#125;&gt;          &lt;Cell title=&quot;原密码&quot;&gt;            &lt;Input              clearable              type=&quot;text&quot;              placeholder=&quot;请输入原密码&quot;              &#123;...getFieldProps(&quot;oldpass&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;            /&gt;          &lt;/Cell&gt;          &lt;Cell title=&quot;新密码&quot;&gt;            &lt;Input              clearable              type=&quot;text&quot;              placeholder=&quot;请输入新密码&quot;              &#123;...getFieldProps(&quot;newpass&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;            /&gt;          &lt;/Cell&gt;          &lt;Cell title=&quot;确认密码&quot;&gt;            &lt;Input              clearable              type=&quot;text&quot;              placeholder=&quot;请再此输入新密码确认&quot;              &#123;...getFieldProps(&quot;newpass2&quot;, &#123; rules: [&#123; required: true &#125;] &#125;)&#125;            /&gt;          &lt;/Cell&gt;        &lt;/div&gt;        &lt;Button className=&#123;s.btn&#125; block theme=&quot;primary&quot; onClick=&#123;submit&#125;&gt;          提交        &lt;/Button&gt;      &lt;/div&gt;    &lt;/&gt;  );&#125;;export default createForm()(Account);</code></pre><p>样式代码：</p><pre><code class="css">.account &#123;  padding: 0 12px;  .form &#123;    :global &#123;      .za-cell:after &#123;        left: unset;        border-top: unset;        border-bottom: 1px solid #e9e9e9;      &#125;    &#125;  &#125;  .btn &#123;    margin-top: 50px;  &#125;&#125;</code></pre><p>这里要注意，<code>Account</code> 在抛出去的时候，需要用 <code>createForm()</code> 高阶组件进行包裹，这样在 <code>Account</code> 的内部能接收到 <code>form</code> 属性，它的内部提供了 <code>getFieldProps</code> 方法，对 <code>Input</code> 组件进行表单设置，<code>Input</code> 的 <code>onChange</code> 方法会被代理，最终可以通过 <code>form.validateFields</code> 以回到函数的形式拿到 <code>Input</code> 内的值，并且可以加以验证。</p><p>别忘记在路由配置项中添加相应的路由：</p><pre><code class="js">// router/index.js...import Account from &#39;@/container/Account&#39;...&#123;  path: &quot;/account&quot;,  component: Account&#125;</code></pre><p>页面展示如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219b6798b5bc4e6ca78b6db0165af6b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这里为了方便查看效果，输入框就不以密码的形式隐藏输入了，点击「提交」按钮之后，接口调用成功，但是我为 <code>admin</code> 账户在服务端设置了不能修改密码的权限，这里方便大家测试页面方便，不能随意修改密码。</p><blockquote><p>测试账号：admin，密码：111111</p></blockquote><h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><p>退出登录操作，我的处理方式是将本地的 <code>token</code> 清除，并且回到登录页面，简单粗暴了一些，但也不失为一个解决方案。</p><p>在 <code>User/index.jsx</code> 下添加代码如下：</p><pre><code class="js">const User = () =&gt; &#123;  // 退出登录  const logout = async () =&gt; &#123;    localStorage.removeItem(&quot;token&quot;);    navigateTo(&quot;/login&quot;);  &#125;;  return (    &lt;div className=&#123;s.user&#125;&gt;      ...      &lt;Button className=&#123;s.logout&#125; block theme=&quot;danger&quot; onClick=&#123;logout&#125;&gt;        退出登录      &lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p>样式如下：</p><pre><code class="css">.logout &#123;  width: 90%;  position: absolute;  bottom: 70px;  left: 50%;  transform: translateX(-50%);&#125;</code></pre><p>通过绝对定位将按钮定位在底部，我们尝试点击它，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/502235db11294dad90861694845e5241~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>再次点击登录，发现没有自动前往首页，我们这里对登录页面进行修改，打开 <code>Login/index.jsx</code>，做如下修改：</p><pre><code class="js">const &#123; data &#125; = await post(&quot;/api/user/login&quot;, &#123;  username,  password,&#125;);console.log(&quot;data&quot;, data);localStorage.setItem(&quot;token&quot;, data.token);window.location.href = &quot;/&quot;;</code></pre><p>这里之所以用 <code>window.location.href</code> 的原因是，<code>utils/axios.js</code> 内部需要再次被执行，才能通过 <code>localStorage.getItem</code> 拿到最新的 <code>token</code>。如果只是用 <code>navigateTo</code> 跳转页面的话，页面是不会被刷新，那么 <code>axios.js</code> 的 <code>token</code> 就无法设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>118、稀土掘金小册-记账本（九） 账单可视化</title>
      <link href="/2023/01/28/118-react/"/>
      <url>/2023/01/28/118-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>账单的操作部分在之前的章节已经结束了，本章节我们学习如何将账单列表，以可视化数据的新形势展示，本章节我们会通过 <code>Echart</code> 插件，对数据进行可视化展示。</p><p>页面布局和分析如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af9e832e388940eeade66dcf304a4eeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>Echart 引入和使用。</li><li>进度条组件 <code>Progress</code> 的使用。</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="头部筛选和数据实现"><a href="#头部筛选和数据实现" class="headerlink" title="头部筛选和数据实现"></a>头部筛选和数据实现</h4><p>当你看到顶部的时间筛选项的时候，你会再一次体会到当初把时间筛选功能封装成公用组件的好处，于是我们打开 <code>Data/index.jsx</code>，添加如下代码：</p><pre><code class="js">import React, &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;import &#123; Icon, Progress &#125; from &quot;zarm&quot;;import cx from &quot;classnames&quot;;import dayjs from &quot;dayjs&quot;;import &#123; get, typeMap &#125; from &quot;@/utils&quot;;import CustomIcon from &quot;@/components/CustomIcon&quot;;import PopupDate from &quot;@/components/PopupDate&quot;;import s from &quot;./style.module.less&quot;;const Data = () =&gt; &#123;  return (    &lt;div className=&#123;s.data&#125;&gt;      &lt;div className=&#123;s.total&#125;&gt;        &lt;div className=&#123;s.time&#125;&gt;          &lt;span&gt;2021-06&lt;/span&gt;          &lt;Icon className=&#123;s.date&#125; type=&quot;date&quot; /&gt;        &lt;/div&gt;        &lt;div className=&#123;s.title&#125;&gt;共支出&lt;/div&gt;        &lt;div className=&#123;s.expense&#125;&gt;¥1000&lt;/div&gt;        &lt;div className=&#123;s.income&#125;&gt;共收入¥200&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default Data;</code></pre><p>头部的一些引入是为后面的代码所用，在这里事先引入，避免后面重复出现。</p><p>上述代码为头部统计的页面布局，同样采用的 <code>flex</code> 布局，样式部分如下：</p><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>样式部分有一个小技巧需要注意，日期后面的小竖线，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c98a98ee5aee44af8f5361ce8f144eda~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在业务中，类似这样的需求非常多，这里我们可以使用伪类 <code>::before</code> 或 <code>::after</code> 去实现，减少在页面中再添加一些多余的标签。上述代码实现的逻辑是在日期的 <code>span</code> 上加上 <code>::after</code>，如下所示：</p><pre><code class="css">span:nth-of-type(1)::after &#123;  content: &quot;&quot;;  position: absolute;  top: 9px;  bottom: 8px;  right: 28px;  width: 1px;  background-color: rgba(0, 0, 0, 0.5);&#125;</code></pre><p>给一个空的 <code>content</code>，再给上 <code>1px</code> 的宽度，颜色和上下距离可以根据需求调整。</p><p>苦口婆心的我再次强调，<code>flex</code> 布局的重要性，一定要把它吃透，至少在布局的时候，你可以灵活的运用横竖布局。</p><p>点击如期按钮，弹出底部弹窗，这里使用到了之前写好的 <code>PopupDate</code> 组件，代码如下：</p><pre><code class="js">const Data = () =&gt; &#123;  const monthRef = useRef();  const [currentMonth, setCurrentMonth] = useState(dayjs().format(&quot;YYYY-MM&quot;));  // 月份弹窗开关  const monthShow = () =&gt; &#123;    monthRef.current &amp;&amp; monthRef.current.show();  &#125;;  const selectMonth = (item) =&gt; &#123;    setCurrentMonth(item);  &#125;;  return (    &lt;div className=&#123;s.data&#125;&gt;      &lt;div className=&#123;s.total&#125;&gt;        &lt;div className=&#123;s.time&#125; onClick=&#123;monthShow&#125;&gt;          &lt;span&gt;&#123;currentMonth&#125;&lt;/span&gt;          &lt;Icon className=&#123;s.date&#125; type=&quot;date&quot; /&gt;        &lt;/div&gt;        &lt;div className=&#123;s.title&#125;&gt;共支出&lt;/div&gt;        &lt;div className=&#123;s.expense&#125;&gt;¥1000&lt;/div&gt;        &lt;div className=&#123;s.income&#125;&gt;共收入¥200&lt;/div&gt;      &lt;/div&gt;      &lt;PopupDate ref=&#123;monthRef&#125; mode=&quot;month&quot; onSelect=&#123;selectMonth&#125; /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p>给日期按钮添加 <code>monthShow</code> 点击事件，调出 <code>PopupDate</code> 弹窗。并且，通过 <code>selectMonth</code> 方法，设置好选择的月份，展示于页面之上。效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34f85185a5934aaba55e13a58d3bdfdd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="账单单项排名制作"><a href="#账单单项排名制作" class="headerlink" title="账单单项排名制作"></a>账单单项排名制作</h4><p>我们将账单排名部分的结构搭建出来，通过请求数据接口，将数据展示在页面上，代码如下：</p><pre><code class="js">const Data = () =&gt; &#123;  ...  const [totalType, setTotalType] = useState(&#39;expense&#39;); // 收入或支出类型  const [totalExpense, setTotalExpense] = useState(0); // 总支出  const [totalIncome, setTotalIncome] = useState(0); // 总收入  const [expenseData, setExpenseData] = useState([]); // 支出数据  const [incomeData, setIncomeData] = useState([]); // 收入数据  useEffect(() =&gt; &#123;    getData()  &#125;, [currentMonth]);  // 获取数据详情  const getData = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/data?date=$&#123;currentMonth&#125;`);    // 总收支    setTotalExpense(data.total_expense);    setTotalIncome(data.total_income);    // 过滤支出和收入    const expense_data = data.total_data.filter(item =&gt; item.pay_type == 1).sort((a, b) =&gt; b.number - a.number); // 过滤出账单类型为支出的项    const income_data = data.total_data.filter(item =&gt; item.pay_type == 2).sort((a, b) =&gt; b.number - a.number); // 过滤出账单类型为收入的项    setExpenseData(expense_data);    setIncomeData(income_data);  &#125;;  return &lt;div className=&#123;s.data&#125;&gt;    ...    &lt;div className=&#123;s.structure&#125;&gt;      &lt;div className=&#123;s.head&#125;&gt;        &lt;span className=&#123;s.title&#125;&gt;收支构成&lt;/span&gt;        &lt;div className=&#123;s.tab&#125;&gt;          &lt;span onClick=&#123;() =&gt; changeTotalType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: totalType == &#39;expense&#39; &#125;)&#125;&gt;支出&lt;/span&gt;          &lt;span onClick=&#123;() =&gt; changeTotalType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: totalType == &#39;income&#39; &#125;)&#125;&gt;收入&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div className=&#123;s.content&#125;&gt;        &#123;          (totalType == &#39;expense&#39; ? expenseData : incomeData).map(item =&gt; &lt;div key=&#123;item.type_id&#125; className=&#123;s.item&#125;&gt;            &lt;div className=&#123;s.left&#125;&gt;              &lt;div className=&#123;s.type&#125;&gt;                &lt;span className=&#123;cx(&#123; [s.expense]: totalType == &#39;expense&#39;, [s.income]: totalType == &#39;income&#39; &#125;)&#125;&gt;                  &lt;CustomIcon                    type=&#123;item.type_id ? typeMap[item.type_id].icon : 1&#125;                  /&gt;                &lt;/span&gt;                &lt;span className=&#123;s.name&#125;&gt;&#123; item.type_name &#125;&lt;/span&gt;              &lt;/div&gt;              &lt;div className=&#123;s.progress&#125;&gt;¥&#123; Number(item.number).toFixed(2) || 0 &#125;&lt;/div&gt;            &lt;/div&gt;            &lt;div className=&#123;s.right&#125;&gt;              &lt;div className=&#123;s.percent&#125;&gt;                &lt;Progress                  shape=&quot;line&quot;                  percent=&#123;Number((item.number / Number(totalType == &#39;expense&#39; ? totalExpense : totalIncome)) * 100).toFixed(2)&#125;                  theme=&#39;primary&#39;                /&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;)        &#125;      &lt;/div&gt;    &lt;/div&gt;    ...  &lt;/div&gt;&#125;</code></pre><p>上述是账单排名部分的代码部分，通过 <code>getData</code> 方法获取账单数据，接口字段分析：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/139ab1e147bb4fd2a30d543b7e445b82~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>首先我们需要传递日期参数 <code>date</code>，才能正常获取该月份的数据。</p><ul><li>number: 账单金额。</li><li>pay_type：账单类型，1 为支出，2 为收入。</li><li>type_id：账单种类 id。</li><li>type_name：账单种类名称，如购物、交通、医疗等。</li></ul><p>并将数据进行二次处理，将「收入」和「支出」分成两个数组保存。</p><p>通过 <code>changeTotalType</code> 方法，切换展示「收入」或「支出」。</p><p>通过对 <code>Progress</code> 组件的样式二次修改，样式代码如下：</p><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>将组件展示效果改成如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d660fe020efb419394c6951253775124~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="饼图制作"><a href="#饼图制作" class="headerlink" title="饼图制作"></a>饼图制作</h4><p>接下来我们尝试引入 <code>Echart</code>，我们不通过 <code>npm</code> 引入它，我们尝试引入它的静态资源，找到根目录下的 <code>index.html</code>，添加如下代码：</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/favicons/v2/favicon-32x32.png~tplv-t2oaga2asx-image.image&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;掘掘手札&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;//s.yezgea02.com/1609305532675/echarts.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;module&quot; src=&quot;/src/main.jsx&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>这种引入方式，不会将 <code>echart</code> 打包到最终的入口脚本里。有同学会说可以按需引入，但是就算是按需引入，脚本也会变得很大，本身 <code>echart</code> 这类可视化工具库就非常大，因为内部使用了大量绘制图形的代码。</p><p>完成上述操作之后，我们尝试在 <code>/Data/index.jsx</code> 添加如下代码：</p><pre><code class="js">let proportionChart = null; // 用于存放 echart 初始化返回的实例const Data = () =&gt; &#123;  ...  const [pieType, setPieType] = useState(&#39;expense&#39;); // 饼图的「收入」和「支出」控制  useEffect(() =&gt; &#123;    getData();    return () =&gt; &#123;      // 每次组件卸载的时候，需要释放图表实例。clear 只是将其清空不会释放。      proportionChart.dispose();    &#125;;  &#125;, [currentMonth]);  // 绘制饼图方法  const setPieChart = (data) =&gt; &#123;    if (window.echarts) &#123;      // 初始化饼图，返回实例。      proportionChart = echarts.init(document.getElementById(&#39;proportion&#39;));      proportionChart.setOption(&#123;          tooltip: &#123;            trigger: &#39;item&#39;,            formatter: &#39;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#39;          &#125;,          // 图例          legend: &#123;              data: data.map(item =&gt; item.type_name)          &#125;,          series: [            &#123;              name: &#39;支出&#39;,              type: &#39;pie&#39;,              radius: &#39;55%&#39;,              data: data.map(item =&gt; &#123;                return &#123;                  value: item.number,                  name: item.type_name                &#125;              &#125;),              emphasis: &#123;                itemStyle: &#123;                  shadowBlur: 10,                  shadowOffsetX: 0,                  shadowColor: &#39;rgba(0, 0, 0, 0.5)&#39;                &#125;              &#125;            &#125;          ]      &#125;)    &#125;;  &#125;;  // 获取数据详情  const getData = async () =&gt; &#123;    // ...    // 绘制饼图    setPieChart(pieType == &#39;expense&#39; ? expense_data : income_data);  &#125;;  // 切换饼图收支类型  const changePieType = (type) =&gt; &#123;    setPieType(type);    // 重绘饼图    setPieChart(type == &#39;expense&#39; ? expenseData : incomeData);  &#125;  return &lt;div className=&#123;s.data&#125;&gt;    ...    &lt;div className=&#123;s.structure&#125;&gt;      &lt;div className=&#123;s.proportion&#125;&gt;        &lt;div className=&#123;s.head&#125;&gt;          &lt;span className=&#123;s.title&#125;&gt;收支构成&lt;/span&gt;          &lt;div className=&#123;s.tab&#125;&gt;            &lt;span onClick=&#123;() =&gt; changePieType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: pieType == &#39;expense&#39;  &#125;)&#125;&gt;支出&lt;/span&gt;            &lt;span onClick=&#123;() =&gt; changePieType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: pieType == &#39;income&#39;  &#125;)&#125;&gt;收入&lt;/span&gt;          &lt;/div&gt;        &lt;/div&gt;        &#123;/* 这是用于放置饼图的 DOM 节点 */&#125;        &lt;div id=&quot;proportion&quot;&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&#125;</code></pre><p>切换饼图「收入」和「支出」这里，我使用了一个小技巧，每次调用 <code>setPieChart</code> 的时候，会将数据重新传入，此时的数据是经过 <code>changePieType</code> 接收的参数进行筛选的，如果形参 <code>type</code> 的值为 <code>expense</code>，那么给 <code>setPieChart</code> 传的参数为 <code>expenseData</code>，反之则为 <code>incomeData</code>。</p><p>注意，在页面销毁前，需要将实例清除。在 <code>useEffect</code> 内 <code>return</code> 一个函数，该函数就是在组件销毁时执行，在函数内部执行 <code>proportionChart.dispose();</code> 对实例进行销毁操作。</p><p>最后，我们将头部的数据补上，如下所示：</p><pre><code class="html">&lt;div className=&quot;&#123;s.expense&#125;&quot;&gt;¥&#123; totalExpense &#125;&lt;/div&gt;&lt;div className=&quot;&#123;s.income&#125;&quot;&gt;共收入¥&#123; totalIncome &#125;&lt;/div&gt;</code></pre><p>浏览器展示如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1509f4c80c0429ebcd09d5c91144631~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可视化的形式还有很多，相关的可视化库有 three.js、d3.js、highchart.js 等等，这些内容都值得你去深入，但是在此之前，希望同学们能明确自己希望深入那一方面的知识，进行深度学习。比如张鑫旭大神，对 <code>CSS</code> 的研究，入骨三分，我相信业务无人出其右。所以找准方向，往前冲。</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_67.9ceed33.png" alt="[嘿哈]"></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>117、稀土掘金小册-记账本（八） 账单详情</title>
      <link href="/2023/01/21/117-react/"/>
      <url>/2023/01/21/117-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>账单模块还剩最后一个小节，账单详情。账单详情页要做的事情有两个，一个是编辑当前账单操作，另一个是删除当前账单操作，我们先来观察完成后页面结构，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd8a2c4723fb4bbdbde0695d55e6bd92~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这里是第一次涉及内页，所以我们需要制作一个公用的头部 <code>Header</code>，支持传参接收 <code>title</code> 信息。我们在上一章节提取的「添加账单弹窗组件」，在这里派上了用场，新增和编辑是一家，唯一的差别就是编辑的时候，需要传入当前账单的 <code>id</code> 给「添加账单组件」，组件内通过账单详情接口，获取账单详情，并将获取的参数用于各个字段初始化值，这就实现了组件的复用。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>封装公用头部组件</li><li>复用添加账单弹窗组件</li></ul><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><h4 id="公用头部"><a href="#公用头部" class="headerlink" title="公用头部"></a>公用头部</h4><p>在 <code>components</code> 目录下新建 <code>Header</code> 目录，老规矩，添加两个文件 <code>index.jsx</code> 和 <code>style.module.less</code>。</p><p>为 <code>Header/index.jsx</code> 添加代码如下：</p><pre><code class="js">import React from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;import &#123; NavBar, Icon &#125; from &quot;zarm&quot;;import s from &quot;./style.module.less&quot;;const Header = (&#123; title = &quot;&quot; &#125;) =&gt; &#123;  const navigateTo = useNavigate();  return (    &lt;div className=&#123;s.headerWarp&#125;&gt;      &lt;div className=&#123;s.block&#125;&gt;        &lt;NavBar          className=&#123;s.header&#125;          left=&#123;            &lt;Icon              type=&quot;arrow-left&quot;              theme=&quot;primary&quot;              onClick=&#123;() =&gt; navigateTo(-1)&#125;            /&gt;          &#125;          title=&#123;title&#125;        /&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;Header.propTypes = &#123;  title: PropTypes.string, // 标题&#125;;export default Header;</code></pre><p>我们采用 <code>Zarm</code> 组件库为我们提供的 <code>NavBar</code> 组件，实现头部的组件布局。为左边的返回箭头添加一个事件，<code>navigateTo(-1)</code> 的作用是路由返回事件，它不会触发浏览器的刷新，而是改变浏览器的地址栏，让组件匹配地址栏对应的地址组件。</p><p>还有一点要提醒大家，写公用组件一定要写 <code>PropTypes</code>，这是让其他使用该组件的同事知道，你这个组件接受的参数有哪些，以及每个参数的作用是什么，都要注释清楚，这才是一个好的公用组件。我见过很多同事写公用组件都不写 <code>PropTypes</code>，这让使用者非常头大。</p><p><strong>CSS 样式代码</strong></p><pre><code class="css">.header-warp &#123;  border-bottom: 1px solid #e9e9e9;  .block &#123;    width: 100%;    height: 46px;    :global &#123;      .za-nav-bar__title &#123;        font-size: 14px;        color: rgba(0, 0, 0, 0.9);      &#125;      .za-icon--arrow-left &#123;        font-size: 20px;      &#125;    &#125;  &#125;  .header &#123;    position: fixed;    top: 0;    left: 0;    width: 100%;    .more &#123;      font-size: 20px;    &#125;  &#125;&#125;</code></pre><p>完成上述代码之后，我们需要在 <code>container/Detail/index.jsx</code> 下引入这个公用头部，代码如下：</p><pre><code class="js">import React from &quot;react&quot;;import Header from &quot;@/components/Header&quot;;import s from &quot;./style.module.less&quot;;const Detail = () =&gt; &#123;  return (    &lt;div className=&#123;s.detail&#125;&gt;      &lt;Header title=&quot;账单详情&quot; /&gt;    &lt;/div&gt;  );&#125;;export default Detail;</code></pre><p>效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4711827eba5141a2822bbde2237032d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="账单明细"><a href="#账单明细" class="headerlink" title="账单明细"></a>账单明细</h4><p>接下来，我们通过列表页传入的浏览器查询字符串，通俗的将就是浏览器地址栏上的参数，来获取该笔账单的详情，如下所示：</p><pre><code class="js">// container/Detail/index.jsximport React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useLocation &#125; from &quot;react-router-dom&quot;;import qs from &quot;query-string&quot;;import Header from &quot;@/components/Header&quot;;import &#123; get &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;const Detail = () =&gt; &#123;  const location = useLocation(); // 获取 locaton 实例，我们可以通过打印查看内部都有些什么内容。  const &#123; id &#125; = qs.parse(location.search);  const [detail, setDetail] = useState(&#123;&#125;);  console.log(&quot;location&quot;, location);  useEffect(() =&gt; &#123;    getDetail();  &#125;, []);  const getDetail = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/detail?id=$&#123;id&#125;`);    setDetail(data);  &#125;;  return (    &lt;div className=&#123;s.detail&#125;&gt;      &lt;Header title=&quot;账单详情&quot; /&gt;    &lt;/div&gt;  );&#125;;export default Detail;</code></pre><p>我们先来看看，浏览器控制台打印出的 <code>location</code> 如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec916d9afd2477680bd98f0ac24a052~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到，我们想要的参数在 <code>search</code> 属性中，我想把 <code>?id=917</code> 转换成 <code>json</code> 键值对的形式，如：</p><pre><code class="json">&#123;  &quot;id&quot;: 917&#125;</code></pre><p>所以我通过 <code>npm install query-string</code> 引入了查询字符串解析的一个插件，通过如下方式：</p><pre><code class="js">qs.parse(location.search);</code></pre><p>可以将浏览器查询参数变成一个对象形式，所以我们在代码中可以通过 <code>const</code> 的解构，将 <code>id</code> 取出。最后通过 <code>get</code> 方法请求详情接口：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5910c717994f729e744328c2cf2517~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来，我们给账单明细部分布局，并且将数据接入，代码如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useLocation &#125; from &quot;react-router-dom&quot;;import qs from &quot;query-string&quot;;import dayjs from &quot;dayjs&quot;;import cx from &quot;classnames&quot;;import Header from &quot;@/components/Header&quot;;import CustomIcon from &quot;@/components/CustomIcon&quot;;import &#123; get, typeMap &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;const Detail = () =&gt; &#123;  const location = useLocation(); // 路由 location 实例  const &#123; id &#125; = qs.parse(location.search); // 查询字符串反序列化  const [detail, setDetail] = useState(&#123;&#125;); // 订单详情数据  useEffect(() =&gt; &#123;    getDetail();  &#125;, []);  const getDetail = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/detail?id=$&#123;id&#125;`);    setDetail(data);  &#125;;  return (    &lt;div className=&#123;s.detail&#125;&gt;      &lt;Header title=&quot;账单详情&quot; /&gt;      &lt;div className=&#123;s.card&#125;&gt;        &lt;div className=&#123;s.type&#125;&gt;          &#123;/* 通过 pay_type 属性，判断是收入或指出，给出不同的颜色*/&#125;          &lt;span            className=&#123;cx(&#123;              [s.expense]: detail.pay_type == 1,              [s.income]: detail.pay_type == 2,            &#125;)&#125;          &gt;            &#123;/* typeMap 是我们事先约定好的 icon 列表 */&#125;            &lt;CustomIcon              className=&#123;s.iconfont&#125;              type=&#123;detail.type_id ? typeMap[detail.type_id].icon : 1&#125;            /&gt;          &lt;/span&gt;          &lt;span&gt;&#123;detail.type_name || &quot;&quot;&#125;&lt;/span&gt;        &lt;/div&gt;        &#123;detail.pay_type == 1 ? (          &lt;div className=&#123;cx(s.amount, s.expense)&#125;&gt;-&#123;detail.amount&#125;&lt;/div&gt;        ) : (          &lt;div className=&#123;cx(s.amount, s.incom)&#125;&gt;+&#123;detail.amount&#125;&lt;/div&gt;        )&#125;        &lt;div className=&#123;s.info&#125;&gt;          &lt;div className=&#123;s.time&#125;&gt;            &lt;span&gt;记录时间&lt;/span&gt;            &lt;span&gt;&#123;dayjs(Number(detail.date)).format(&quot;YYYY-MM-DD HH:mm&quot;)&#125;&lt;/span&gt;          &lt;/div&gt;          &lt;div className=&#123;s.remark&#125;&gt;            &lt;span&gt;备注&lt;/span&gt;            &lt;span&gt;&#123;detail.remark || &quot;-&quot;&#125;&lt;/span&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div className=&#123;s.operation&#125;&gt;          &lt;span&gt;            &lt;CustomIcon type=&quot;shanchu&quot; /&gt;            删除          &lt;/span&gt;          &lt;span&gt;            &lt;CustomIcon type=&quot;tianjia&quot; /&gt;            编辑          &lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default Detail;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>布局部分我都已经在代码中给了注释，还有不明白的同学可以在群里提问，再次强调一点，<code>flex</code> 布局请务必要掌握熟练，在日后的开发过程中，无论是小册还是公司的项目，都会大量的运用到它。甚至 <code>Flutter</code> 的布局也借鉴了 <code>flex</code> 的原理。</p><p>浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ccc8d4d2fb343878c22bb37f3949673~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们还需为底部的两个按钮添加事件。首先，为删除按钮添加删除事件：</p><pre><code class="js">import &#123; useLocation, useNavigate &#125; from &#39;react-router-dom&#39;;import &#123; get, post, typeMap &#125; from &#39;@/utils&#39;;import &#123; Modal, Toast &#125; from &#39;zarm&#39;;...const navigateTo = useNavigate();// 删除方法const deleteDetail = () =&gt; &#123;  Modal.confirm(&#123;    title: &#39;删除&#39;,    content: &#39;确认删除账单？&#39;,    onOk: async () =&gt; &#123;      const &#123; data &#125; = await post(&#39;/api/bill/delete&#39;, &#123; id &#125;)      Toast.show(&#39;删除成功&#39;)      navigateTo(-1)    &#125;,  &#125;);&#125;</code></pre><p>这里我们利用 <code>Zarm</code> 组件提供的 <code>Modal</code> 组件，该组件提供了调用方法的形式唤起弹窗，我们利用这个属性 为「删除」加一个二次确认的形式，避免误触按钮。</p><p>效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f1edbbe9d147e39ffd28d9b0a0ab1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>最麻烦的编辑事件处理，我们先来明确一下思路。在点击「编辑」按钮之后，我们会唤起之前写好的「添加账单天窗」，然后将账单 <code>detail</code> 参数通过 <code>props</code> 传递给弹窗组件，组件在接收到 <code>detail</code> 时，将信息初始化给弹窗给的相应参数。</p><p>我们来看代码的实现，首先在 <code>Detail/index.jsx</code> 内添加代码：</p><pre><code class="js">import React, &#123; useEffect, useState, useRef &#125; from &#39;react&#39;;import PopupAddBill from &#39;@/components/PopupAddBill&#39;;...const editRef = useRef();...&lt;div className=&#123;s.operation&#125;&gt;  &lt;span onClick=&#123;deleteDetail&#125;&gt;&lt;CustomIcon type=&#39;shanchu&#39; /&gt;删除&lt;/span&gt;  &lt;span onClick=&#123;() =&gt; editRef.current &amp;&amp; editRef.current.show()&#125;&gt;&lt;CustomIcon type=&#39;tianjia&#39; /&gt;编辑&lt;/span&gt;&lt;/div&gt;...&lt;PopupAddBill ref=&#123;editRef&#125; detail=&#123;detail&#125; onReload=&#123;getDetail&#125; /&gt;</code></pre><p>尝试点击编辑按钮：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e946a44ae224128ae356abc36d990eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>紧接着，我们修改 <code>PopupAddBill</code> 组件，如下所示：</p><pre><code class="js">const PopupAddBill = forwardRef((&#123; detail = &#123;&#125;, onReload &#125;, ref) =&gt; &#123;  ...  const id = detail &amp;&amp; detail.id // 外部传进来的账单详情 id  useEffect(() =&gt; &#123;    if (detail.id) &#123;      setPayType(detail.pay_type == 1 ? &#39;expense&#39; : &#39;income&#39;)      setCurrentType(&#123;        id: detail.type_id,        name: detail.type_name      &#125;)      setRemark(detail.remark)      setAmount(detail.amount)      setDate(dayjs(Number(detail.date)).$d)    &#125;  &#125;, [detail])  ...  useEffect(async () =&gt; &#123;    const &#123; data: &#123; list &#125; &#125; = await get(&#39;/api/type/list&#39;);    const _expense = list.filter(i =&gt; i.type == 1); // 支出类型    const _income = list.filter(i =&gt; i.type == 2); // 收入类型    setExpense(_expense);    setIncome(_income);      // 没有 id 的情况下，说明是新建账单。    if (!id) &#123;      setCurrentType(_expense[0]);    &#125;;  &#125;, []);  ...  // 添加账单  const addBill = async () =&gt; &#123;    if (!amount) &#123;      Toast.show(&#39;请输入具体金额&#39;)      return    &#125;    const params = &#123;      amount: Number(amount).toFixed(2),      type_id: currentType.id,      type_name: currentType.name,      date: dayjs(date).unix() * 1000,      pay_type: payType == &#39;expense&#39; ? 1 : 2,      remark: remark || &#39;&#39;    &#125;    if (id) &#123;      params.id = id;      // 如果有 id 需要调用详情更新接口      const result = await post(&#39;/api/bill/update&#39;, params);      Toast.show(&#39;修改成功&#39;);    &#125; else &#123;      const result = await post(&#39;/api/bill/add&#39;, params);      setAmount(&#39;&#39;);      setPayType(&#39;expense&#39;);      setCurrentType(expense[0]);      setDate(new Date());      setRemark(&#39;&#39;);      Toast.show(&#39;添加成功&#39;);    &#125;    setShow(false);    if (onReload) onReload();  &#125;&#125;)</code></pre><p>首先，通过 <code>setXXX</code> 将 <code>detail</code> 的数据依次设置初始值；其次，账单种类需要判断是否是编辑或是新建；最后，修改添加账单按钮，如果是「编辑」操作，给 <code>params</code> 参数添加一个 <code>id</code>，并且调用的接口变成 <code>/api/bill/update</code>。</p><p>完成上述操作之后，我们查看浏览器操作情况如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97d70e0092747cb8c78da25cf17c576~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本小节我们学习了如何封装内页的头部组件，以及如何将之前的「新增」复用给「编辑」操作，可以以这个为一个思考点，用发散的思维去复制这样的模式，是否其他的新增和编辑操作，也可以这么实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116、稀土掘金小册-记账本（七）新增账单弹窗封装</title>
      <link href="/2023/01/18/116-react/"/>
      <url>/2023/01/18/116-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回顾一下上一章节学习的内容。无限滚动列表、弹窗组件的内部控制显隐、工具方法以及常量的提取。若是你开发项目时，在潜意识里，有对这些内容进行封装的思想，那么你已经有模块化、组件化的开发理念了。在大量的工程中得出的实践，将会根深蒂固在你的开发理念里。</p><p>之前，我们是对一个小组件，如时间筛选、类型筛选等小组件进行封装。本章节，我们对一个添加模块进行封装，好处就是你在任何地方，都能使用这个添加组件，对账单进行增加操作。</p><p>我们先来看看本章节要绘制的页面和逻辑：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349d2f897ff84498a7016596b2e11882~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>如上图所示，本章节要实现的需求逻辑，基本上已经绘制在图中。所有的努力，都是为了凑出这几个参数：</p><ul><li>账单类型</li><li>账单金额</li><li>账单日期</li><li>账单种类</li><li>备注</li></ul><p>然后将这些数据，提交给服务端进行处理，然后存储到数据库，完事。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上述需求整理清楚之后，我们开始本章节的制作环节。</p><h4 id="弹窗组件实现"><a href="#弹窗组件实现" class="headerlink" title="弹窗组件实现"></a>弹窗组件实现</h4><p>先实现点击新增按钮，调出弹窗的功能。首先，在 <code>Home/index.jsx</code> 文件中添加 「新增按钮」，如下所示：</p><pre><code class="js">import CustomIcon from &#39;@/components/CustomIcon&#39;...const Home = () =&gt; &#123;  ...  const addToggle = () =&gt; &#123;    // do something  &#125;  ...  return &lt;div className=&#123;s.home&#125;&gt;    ...    &lt;div className=&#123;s.add&#125; onClick=&#123;addToggle&#125;&gt;&lt;CustomIcon type=&#39;tianjia&#39; /&gt;&lt;/div&gt;  &lt;/div&gt;&#125;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>样式中，注意我给 <code>border</code> 设置的是 <code>1PX</code>，大写的单位，因为这样写的话，<code>postcss-pxtorem</code> 插件就不会将其转化为 <code>rem</code> 单位。</p><p>重启项目之后，刷新浏览器，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf8cf59aeed4061b36a5b7359fb42b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>根据之前实现的弹窗组件，我们再实现一套类似的，在弹窗内控制弹窗组件的显示隐藏，在 <code>components</code> 下新建 <code>PopupAddBill</code> 文件夹，再新建 <code>index.jsx</code> 和 <code>style.module.less</code>，代码如下：</p><pre><code class="js">// PopupAddBill/index.jsximport React, &#123; forwardRef, useEffect, useRef, useState &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; Popup &#125; from &quot;zarm&quot;;const PopupAddBill = forwardRef((props, ref) =&gt; &#123;  const [show, setShow] = useState(false); // 内部控制弹窗显示隐藏。  // 通过 forwardRef 拿到外部传入的 ref，并添加属性，使得父组件可以通过 ref 控制子组件。  if (ref) &#123;    ref.current = &#123;      show: () =&gt; &#123;        setShow(true);      &#125;,      close: () =&gt; &#123;        setShow(false);      &#125;,    &#125;;  &#125;  return (    &lt;Popup      visible=&#123;show&#125;      direction=&quot;bottom&quot;      onMaskClick=&#123;() =&gt; setShow(false)&#125;      destroy=&#123;false&#125;      mountContainer=&#123;() =&gt; document.body&#125;    &gt;      &lt;div style=&#123;&#123; height: 200, background: "#fff" &#125;&#125;&gt;弹窗&lt;/div&gt;    &lt;/Popup&gt;  );&#125;);export default PopupAddBill;</code></pre><p>写完弹窗组件，当然就得去 <code>Home/index.jsx</code> 中调用：</p><pre><code class="js">// Home/index.jsximport PopupAddBill from &#39;@/components/PopupAddBill&#39;const Home = () =&gt; &#123;  ...  const addRef = useRef(); // 添加账单 ref  ...  // 添加账单弹窗  const addToggle = () =&gt; &#123;    addRef.current &amp;&amp; addRef.current.show()  &#125;  return &lt;div className=&#123;s.home&#125;&gt;    ...    &lt;PopupAddBill ref=&#123;addRef&#125; /&gt;  &lt;/div&gt;&#125;</code></pre><p>重启浏览器，效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7025a89978114333bdf7cbdb20139482~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时我们的“地基”已经打好了，接下来我们要在这个基础上给新增账单弹窗“添砖加瓦”。</p><h4 id="账单类型和账单时间"><a href="#账单类型和账单时间" class="headerlink" title="账单类型和账单时间"></a>账单类型和账单时间</h4><p>我们先实现弹窗头部左侧的「支出」和「收入」账单类型切换功能，添加代码如下：</p><pre><code class="js">// components/PopupAddBill/index.jsx...import cx from &#39;classnames&#39;;import &#123; Popup, Icon  &#125; from &#39;zarm&#39;;import s from &#39;./style.module.less&#39;;const PopupAddBill = forwardRef((props, ref) =&gt; &#123;  ...  const [payType, setPayType] = useState(&#39;expense&#39;); // 支出或收入类型  ...  // 切换收入还是支出  const changeType = (type) =&gt; &#123;    setPayType(type);  &#125;;  return &lt;Popup    visible=&#123;show&#125;    direction=&quot;bottom&quot;    onMaskClick=&#123;() =&gt; setShow(false)&#125;    destroy=&#123;false&#125;    mountContainer=&#123;() =&gt; document.body&#125;  &gt;    &lt;div className=&#123;s.addWrap&#125;&gt;      &#123;/* 右上角关闭弹窗 */&#125;      &lt;header className=&#123;s.header&#125;&gt;        &lt;span className=&#123;s.close&#125; onClick=&#123;() =&gt; setShow(false)&#125;&gt;&lt;Icon type=&quot;wrong&quot; /&gt;&lt;/span&gt;      &lt;/header&gt;       &#123;/* 「收入」和「支出」类型切换 */&#125;      &lt;div className=&#123;s.filter&#125;&gt;        &lt;div className=&#123;s.type&#125;&gt;          &lt;span onClick=&#123;() =&gt; changeType(&#39;expense&#39;)&#125; className=&#123;cx(&#123; [s.expense]: true, [s.active]: payType == &#39;expense&#39; &#125;)&#125;&gt;支出&lt;/span&gt;          &lt;span onClick=&#123;() =&gt; changeType(&#39;income&#39;)&#125; className=&#123;cx(&#123; [s.income]: true, [s.active]: payType == &#39;income&#39; &#125;)&#125;&gt;收入&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/Popup&gt;&#125;)export default PopupAddBill</code></pre><p>为了减少代码的重复，上述代码只展示了需要添加的部分，尽量不让大家混淆视听。</p><p>我们定义 <code>expense</code> 为支出，<code>income</code> 为收入，代码中通过 <code>payType</code> 变量，来控制「收入」和「支出」按钮的切换。上述代码视图效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd1f72d07dff4f69af0848e8d2f0696f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来在类型边上添加时间筛选弹窗，此时你将体会到之前提取时间筛选组件是多么的明智。我们继续添加代码：</p><pre><code class="js">import React, &#123; forwardRef, useEffect, useRef, useState &#125; from &#39;react&#39;;...import dayjs from &#39;dayjs&#39;;import PopupDate from &#39;../PopupDate&#39;...const PopupAddBill = forwardRef((props, ref) =&gt; &#123;  ...  const dateRef = useRef();  const [date, setDate] = useState(new Date()); // 日期  ...  // 日期选择回调  const selectDate = (val) =&gt; &#123;    setDate(val);  &#125;  return &lt;Popup    visible=&#123;show&#125;    direction=&quot;bottom&quot;    onMaskClick=&#123;() =&gt; setShow(false)&#125;    destroy=&#123;false&#125;    mountContainer=&#123;() =&gt; document.body&#125;  &gt;    &lt;div className=&#123;s.addWrap&#125;&gt;       &#123;/* 「收入」和「支出」类型切换 */&#125;      &lt;div className=&#123;s.filter&#125;&gt;        ...        &lt;div          className=&#123;s.time&#125;          onClick=&#123;() =&gt; dateRef.current &amp;&amp; dateRef.current.show()&#125;        &gt;&#123;dayjs(date).format(&#39;MM-DD&#39;)&#125; &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/div&gt;      &lt;/div&gt;      &lt;PopupDate ref=&#123;dateRef&#125; onSelect=&#123;selectDate&#125; /&gt;    &lt;/div&gt;  &lt;/Popup&gt;&#125;)export default PopupAddBill</code></pre><p>我们引入了公共组件 <code>PopupDate</code>，传入 <code>ref</code> 控制弹窗的显示隐藏，传入 <code>onSelect</code> 获取日期组件选择后回调的值，并通过 <code>setDate</code> 重制 <code>date</code>，触发视图的更新，我们来看浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3fa326b74f41ddb0d211e886ca5ccb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们通过上述代码，已经创造出了两个值，分别是「账单类型」和「账单日期」，还差「账单金额」 「账单种类」、「备注」。</p><h4 id="账单金额"><a href="#账单金额" class="headerlink" title="账单金额"></a>账单金额</h4><p>本章开头大家也应该看到了，金额输入框是模拟的，也就是说当下面模拟数字键盘点击的时候，我们将返回的数据渲染到进入输入框的位置，下面我们先将金额输入框搭建出来，添加代码如下：</p><pre><code class="js">&lt;div className=&#123;s.money&#125;&gt;  &lt;span className=&#123;s.sufix&#125;&gt;¥&lt;/span&gt;  &lt;span className=&#123;cx(s.amount, s.animation)&#125;&gt;10&lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15dc48f98c4f42eb9310619510603506~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们将金额动态化，引入 <code>Zarm</code> 为我们提供的模拟数字键盘组件 <code>Keyboard</code>，代码如下：</p><pre><code class="js">...// 监听输入框改变值  const handleMoney = (value) =&gt; &#123;    value = String(value)    // 点击是删除按钮时    if (value == &#39;delete&#39;) &#123;      let _amount = amount.slice(0, amount.length - 1)      setAmount(_amount)      return    &#125;    // 点击确认按钮时    if (value == &#39;ok&#39;) &#123;      // 这里后续将处理添加账单逻辑      return    &#125;    // 当输入的值为 &#39;.&#39; 且 已经存在 &#39;.&#39;，则不让其继续字符串相加。    if (value == &#39;.&#39; &amp;&amp; amount.includes(&#39;.&#39;)) return    // 小数点后保留两位，当超过两位时，不让其字符串继续相加。    if (value != &#39;.&#39; &amp;&amp; amount.includes(&#39;.&#39;) &amp;&amp; amount &amp;&amp; amount.split(&#39;.&#39;)[1].length &gt;= 2) return    // amount += value    setAmount(amount + value)  &#125;...&lt;div className=&#123;s.money&#125;&gt;  &lt;span className=&#123;s.sufix&#125;&gt;¥&lt;/span&gt;  &lt;span className=&#123;cx(s.amount, s.animation)&#125;&gt;&#123;amount&#125;&lt;/span&gt;&lt;/div&gt;&lt;Keyboard type=&quot;price&quot; onKeyClick=&#123;(value) =&gt; handleMoney(value)&#125; /&gt;</code></pre><p>重启项目，浏览器展示如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc90561f73d4b2c921864ebefc2cd2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><blockquote><p>这里一个小提示，我在制作项目的过程中，发现一个 Zarm 2.9.0 版本的 bug，Keyboard 组件在点击删除按钮的时候，onKeyClick 方法会反复被执行，于是我降级为 2.8.2 版本，并且去他们的官网提了 issue。</p></blockquote><p>此时「账单金额」也被安排上了。</p><h4 id="账单种类"><a href="#账单种类" class="headerlink" title="账单种类"></a>账单种类</h4><p>账单种类的作用是表示该笔账单的大致用途，我们通过接口从数据库回去账单种类列表，以横向滚动的形式，展示在金额的下面，接下来我们看具体的代码实现：</p><pre><code class="js">...import CustomIcon from &#39;../CustomIcon&#39;;import &#123; get, typeMap &#125; from &#39;@/utils&#39;;...const [currentType, setCurrentType] = useState(&#123;&#125;); // 当前选中账单类型const [expense, setExpense] = useState([]); // 支出类型数组const [income, setIncome] = useState([]); // 收入类型数组useEffect(async () =&gt; &#123;  const &#123; data: &#123; list &#125; &#125; = await get(&#39;/api/type/list&#39;);  const _expense = list.filter(i =&gt; i.type == 1); // 支出类型  const _income = list.filter(i =&gt; i.type == 2); // 收入类型  setExpense(_expense);  setIncome(_income);  setCurrentType(_expense[0]); // 新建账单，类型默认是支出类型数组的第一项&#125;, [])...&lt;div className=&#123;s.typeWarp&#125;&gt;  &lt;div className=&#123;s.typeBody&#125;&gt;    &#123;/* 通过 payType 判断，是展示收入账单类型，还是支出账单类型 */&#125;    &#123;      (payType == &#39;expense&#39; ? expense : income).map(item =&gt; &lt;div onClick=&#123;() =&gt; setCurrentType(item)&#125; key=&#123;item.id&#125; className=&#123;s.typeItem&#125;&gt;        &#123;/* 收入和支出的字体颜色，以及背景颜色通过 payType 区分，并且设置高亮 */&#125;        &lt;span className=&#123;cx(&#123;[s.iconfontWrap]: true, [s.expense]: payType == &#39;expense&#39;, [s.income]: payType == &#39;income&#39;, [s.active]: currentType.id == item.id&#125;)&#125;&gt;          &lt;CustomIcon className=&#123;s.iconfont&#125; type=&#123;typeMap[item.id].icon&#125; /&gt;        &lt;/span&gt;        &lt;span&gt;&#123;item.name&#125;&lt;/span&gt;      &lt;/div&gt;)    &#125;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>注意，在 <code>h5</code> 界面实现横向滚动，和在网页端相比，多了如下属性：</p><pre><code class="css">* &#123;  touch-action: pan-x;&#125;</code></pre><blockquote><p>CSS 属性 touch-action 用于设置触摸屏用户如何操纵元素的区域(例如，浏览器内置的缩放功能)。</p></blockquote><p>如果不设置它，只是通过 <code>overflow-x: auto</code>，无法实现 <code>h5</code> 端的横向滚动的，并且你要在一个 <code>div</code> 容器内设置全局 <code>*</code> 为 <code>touch-action: pan-x;</code>，如果后续遇到类似的问题，大家可以参考我上述做法，这是经过实践验证过的方法。</p><p>我们来看看浏览器的展示效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9047dbf8d2d44f09ab66fce10dc1ee89~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="备注弹窗"><a href="#备注弹窗" class="headerlink" title="备注弹窗"></a>备注弹窗</h4><p>备注虽然不起眼，但是别小看它，它可以在账单类型不足以概括账单时，加以一定的文字描述。</p><p>我们直接将其放置于「账单种类」的下面，代码如下：</p><pre><code class="js">...import &#123;  Input  &#125; from &#39;zarm&#39;;...const [remark, setRemark] = useState(&#39;&#39;); // 备注const [showRemark, setShowRemark] = useState(false); // 备注输入框展示控制...&lt;div className=&#123;s.remark&#125;&gt;  &#123;    showRemark ? &lt;Input      autoHeight      showLength      maxLength=&#123;50&#125;      type=&quot;text&quot;      rows=&#123;3&#125;      value=&#123;remark&#125;      placeholder=&quot;请输入备注信息&quot;      onChange=&#123;(val) =&gt; setRemark(val)&#125;      onBlur=&#123;() =&gt; setShowRemark(false)&#125;    /&gt; : &lt;span onClick=&#123;() =&gt; setShowRemark(true)&#125;&gt;&#123;remark || &#39;添加备注&#39;&#125;&lt;/span&gt;  &#125;&lt;/div&gt;</code></pre><p><strong>CSS 样式部分</strong></p><pre><code class="css">.remark &#123;  padding: 0 24px;  padding-bottom: 12px;  color: #4b67e2;  :global &#123;    .za-input--textarea &#123;      border: 1px solid #e9e9e9;      padding: 10px;    &#125;  &#125;&#125;</code></pre><p><code>:global</code> 的使用之前已经有描述过，这里再提醒大家一句，目前项目使用的是 <code>css module</code> 的形式，所以样式名都会被打上 <code>hash</code> 值，我们需要修改没有打 <code>hash</code> 值的 <code>zarm</code> 内部样式，需要通过 <code>:global</code> 方法。</p><p>浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28bec13e3c9444cb8a4fd3779290193f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="调用上传账单接口"><a href="#调用上传账单接口" class="headerlink" title="调用上传账单接口"></a>调用上传账单接口</h4><p>此时我们集齐了五大参数：</p><ul><li>账单类型：payType</li><li>账单金额：amount</li><li>账单日期：date</li><li>账单种类：currentType</li><li>备注：remark</li></ul><p>我们给 <code>Keyboard</code> 的「确定」按钮回调添加方法：</p><pre><code class="js">import &#123; Toast &#125; from &quot;zarm&quot;;import &#123; post &#125; from &quot;@/utils&quot;;// 监听输入框改变值const handleMoney = (value) =&gt; &#123;  value = String(value);  // 点击是删除按钮时  if (value == &quot;delete&quot;) &#123;    let _amount = amount.slice(0, amount.length - 1);    setAmount(_amount);    return;  &#125;  // 点击确认按钮时  if (value == &quot;ok&quot;) &#123;    addBill();    return;  &#125;  // 当输入的值为 &#39;.&#39; 且 已经存在 &#39;.&#39;，则不让其继续字符串相加。  if (value == &quot;.&quot; &amp;&amp; amount.includes(&quot;.&quot;)) return;  // 小数点后保留两位，当超过两位时，不让其字符串继续相加。  if (    value != &quot;.&quot; &amp;&amp;    amount.includes(&quot;.&quot;) &amp;&amp;    amount &amp;&amp;    amount.split(&quot;.&quot;)[1].length &gt;= 2  )    return;  // amount += value  setAmount(amount + value);&#125;;// 添加账单const addBill = async () =&gt; &#123;  if (!amount) &#123;    Toast.show(&quot;请输入具体金额&quot;);    return;  &#125;  const params = &#123;    amount: Number(amount).toFixed(2), // 账单金额小数点后保留两位    type_id: currentType.id, // 账单种类id    type_name: currentType.name, // 账单种类名称    date: dayjs(date).unix() * 1000, // 日期传时间戳    pay_type: payType == &quot;expense&quot; ? 1 : 2, // 账单类型传 1 或 2    remark: remark || &quot;&quot;, // 备注  &#125;;  const result = await post(&quot;/api/bill/add&quot;, params);  // 重制数据  setAmount(&quot;&quot;);  setPayType(&quot;expense&quot;);  setCurrentType(expense[0]);  setDate(new Date());  setRemark(&quot;&quot;);  Toast.show(&quot;添加成功&quot;);  setShow(false);  if (props.onReload) props.onReload();&#125;;</code></pre><p><code>onReload</code> 方法为首页账单列表传进来的函数，当添加完账单的时候，执行 <code>onReload</code> 重新获取首页列表数据。</p><pre><code class="js">&lt;PopupAddBill ref=&#123;addRef&#125; onReload=&#123;refreshData&#125; /&gt;</code></pre><p>浏览器展示如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c3fd021a8f8497d8b14ff0c81a53367~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>如果如上图所示，恭喜你，你已经成功完成了添加账单的 工作，此时再回头甚至之前写的代码，马上改正一些变量及一些方法的命名，规范化一下代码。</p><p>千万别在后面再去完善，因为很大程度上，到后面你会懒得翻前面写的代码，除非实在是逻辑问题导致的 bug。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节的内容也是非常丰富，我们的所有的努力，就是为了集齐「添加账单」所需要的五大参数。这是很多需求的一个索引，试问前端在调用接口的过程中，不都是做各种努力为了凑齐那几个参数呢？过程很重要，只要流程做得完善，结果自然水到渠成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115、稀土掘金小册-记账本（六）账单列表</title>
      <link href="/2023/01/11/115-react/"/>
      <url>/2023/01/11/115-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章节介绍的登录注册是整个项目的根基，没有拿到 <code>token</code>，将无法进行后续的各种操作，如账单的增删改查。所以务必将上一章节好好地阅读与揣摩，为后面的学习做好铺垫。我们直接进入本次前端实战项目的主题，账单的增删改查之列表页。</p><blockquote><p>本教程已有线上地址<a href="https://link.juejin.cn/?target=http://cost.chennick.wang">在线地址</a>，同学们可以在实战部分，对照着线上页面进行学习。</p></blockquote><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>单项组件抽离</li><li>列表页无限滚动</li><li>下拉刷新列表</li><li>弹窗组件封装</li></ul><p>我们先来欣赏一下最终的页面效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fc0196a649c41cb8fe73dafe50233b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="列表页编写（静态部分）"><a href="#列表页编写（静态部分）" class="headerlink" title="列表页编写（静态部分）"></a>列表页编写（静态部分）</h2><p>按照正常的开发流程，我们先将静态页面切出来，再填入数据使其动态化。在此之前，我们已经新建好了 <code>Home</code> 目录，该目录便是用于放置账单列表，所以我们直接在 <code>Home/index.jsx</code> 新增代码。</p><h4 id="头部统计实现"><a href="#头部统计实现" class="headerlink" title="头部统计实现"></a>头部统计实现</h4><p>列表的头部展示的内容为当月的收入和支出汇总，并且有两个列表条件过滤项，分别是类型过滤和时间过滤。</p><p>我们新增代码如下：</p><pre><code class="js">import React from &quot;react&quot;;import &#123; Icon &#125; from &quot;zarm&quot;;import s from &quot;./style.module.less&quot;;const Home = () =&gt; &#123;  return (    &lt;div className=&#123;s.home&#125;&gt;      &lt;div className=&#123;s.header&#125;&gt;        &lt;div className=&#123;s.dataWrap&#125;&gt;          &lt;span className=&#123;s.expense&#125;&gt;            总支出：&lt;b&gt;¥ 200&lt;/b&gt;          &lt;/span&gt;          &lt;span className=&#123;s.income&#125;&gt;            总收入：&lt;b&gt;¥ 500&lt;/b&gt;          &lt;/span&gt;        &lt;/div&gt;        &lt;div className=&#123;s.typeWrap&#125;&gt;          &lt;div className=&#123;s.left&#125;&gt;            &lt;span className=&#123;s.title&#125;&gt;              类型 &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;            &lt;/span&gt;          &lt;/div&gt;          &lt;div className=&#123;s.right&#125;&gt;            &lt;span className=&#123;s.time&#125;&gt;              2022-06              &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;            &lt;/span&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default Home;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>代码分析：</p><p><code>header</code> 采用 <code>fixed</code> 固定定位，将整个汇总信息固定在页面的顶部位置，这样后续列表滚动的时候，你可以方便查看当月的收入汇总，以及筛选当月消费类型和时间段的筛选。每个列表展示的是当月的收入与支出明细，比如 <code>2021-06</code> 的收入明细。</p><p>本次项目全程采用的是 <code>Flex</code> 弹性布局，这种布局形式在当下的开发生产环境已经非常成熟，同学们如果还有不熟悉的，请实现对 <code>Flex</code> 布局做一个简单的学习，这边推荐一个学习网站：</p><blockquote><p><a href="https://link.juejin.cn/?target=http://flexboxfroggy.com/%23zh-cn">flexboxfroggy.com/#zh-cn</a></p></blockquote><p>笔者当初也是通过这个网站的学习，入门的 <code>Flex</code>。</p><p>完成上述布局之后，页面如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b4da908ba7d412ea25d6b925006f163~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="列表页面实现"><a href="#列表页面实现" class="headerlink" title="列表页面实现"></a>列表页面实现</h4><p>列表页面会用到 <code>Zarm</code> 组件库为我们提供的 <a href="https://link.juejin.cn/?target=https://zarm.gitee.io/%23/components/pull">Pull</a> 组件，来实现下拉刷新以及无限滚动，我们先来将基础布局实现，如下所示：</p><pre><code class="js">// Home/index.jsxconst Home = () =&gt; &#123;  const [list, setList] = useState([    &#123;      bills: [        &#123;          amount: &quot;25.00&quot;,          date: &quot;1623390740000&quot;,          id: 911,          pay_type: 1,          remark: &quot;&quot;,          type_id: 1,          type_name: &quot;餐饮&quot;,        &#125;,      ],      date: &quot;2021-06-11&quot;,    &#125;,  ]); // 账单列表  return (    &lt;div className=&#123;s.home&#125;&gt;      &lt;div className=&#123;s.header&#125;&gt;...&lt;/div&gt;      &lt;div className=&#123;s.contentWrap&#125;&gt;        &#123;list.map((item, index) =&gt; (          &lt;BillItem /&gt;        ))&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;</code></pre><p>上述我们添加 <code>list</code> 为列表假数据，<code>BillItem</code> 组件为账单单项组件，我们将其抽离到 <code>components</code> 组件库，如下：</p><pre><code class="js">// components/BillItem/index.jsximport React, &#123; useEffect, useState &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import dayjs from &quot;dayjs&quot;;import &#123; Cell &#125; from &quot;zarm&quot;;import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;import CustomIcon from &quot;../CustomIcon&quot;;import &#123; typeMap &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;const BillItem = (&#123; bill &#125;) =&gt; &#123;  const [income, setIncome] = useState(0); // 收入  const [expense, setExpense] = useState(0); // 支出  const navigateTo = useNavigate(); // 路由实例  // 当添加账单是，bill.bills 长度变化，触发当日收支总和计算。  useEffect(() =&gt; &#123;    // 初始化将传入的 bill 内的 bills 数组内数据项，过滤出支出和收入。    // pay_type：1 为支出；2 为收入    // 通过 reduce 累加    const _income = bill.bills      .filter((i) =&gt; i.pay_type == 2)      .reduce((curr, item) =&gt; &#123;        curr += Number(item.amount);        return curr;      &#125;, 0);    setIncome(_income);    const _expense = bill.bills      .filter((i) =&gt; i.pay_type == 1)      .reduce((curr, item) =&gt; &#123;        curr += Number(item.amount);        return curr;      &#125;, 0);    setExpense(_expense);  &#125;, [bill.bills]);  // 前往账单详情  const goToDetail = (item) =&gt; &#123;    navigateTo(`/detail?id=$&#123;item.id&#125;`);  &#125;;  return (    &lt;div className=&#123;s.item&#125;&gt;      &lt;div className=&#123;s.headerDate&#125;&gt;        &lt;div className=&#123;s.date&#125;&gt;&#123;bill.date&#125;&lt;/div&gt;        &lt;div className=&#123;s.money&#125;&gt;          &lt;span&gt;            &lt;img src=&quot;//s.yezgea02.com/1615953405599/zhi%402x.png&quot; alt=&quot;支&quot; /&gt;            &lt;span&gt;¥&#123;expense.toFixed(2)&#125;&lt;/span&gt;          &lt;/span&gt;          &lt;span&gt;            &lt;img src=&quot;//s.yezgea02.com/1615953405599/shou%402x.png&quot; alt=&quot;收&quot; /&gt;            &lt;span&gt;¥&#123;income.toFixed(2)&#125;&lt;/span&gt;          &lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;      &#123;bill &amp;&amp;        bill.bills.map((item) =&gt; (          &lt;Cell            className=&#123;s.bill&#125;            key=&#123;item.id&#125;            onClick=&#123;() =&gt; goToDetail(item)&#125;            title=&#123;              &lt;&gt;                &lt;CustomIcon                  className=&#123;s.itemIcon&#125;                  type=&#123;item.type_id ? typeMap[item.type_id].icon : 1&#125;                /&gt;                &lt;span&gt;&#123;item.type_name&#125;&lt;/span&gt;              &lt;/&gt;            &#125;            description=&#123;              &lt;span                style=&#123;&#123; color: item.pay_type == 2 ? "red" : "#39be77" &#125;&#125;              &gt;&#123;`$&#123;item.pay_type == 1 ? &quot;-&quot; : &quot;+&quot;&#125;$&#123;item.amount&#125;`&#125;&lt;/span&gt;            &#125;            help=&#123;              &lt;div&gt;                &#123;dayjs(Number(item.date)).format(&quot;HH:mm&quot;)&#125;&#123;&quot; &quot;&#125;                &#123;item.remark ? `| $&#123;item.remark&#125;` : &quot;&quot;&#125;              &lt;/div&gt;            &#125;          &gt;&lt;/Cell&gt;        ))&#125;    &lt;/div&gt;  );&#125;;BillItem.propTypes = &#123;  bill: PropTypes.object,&#125;;export default BillItem;</code></pre><p>通过 <code>npm i dayjs -S</code> 添加日期操作工具，移动端建议使用 <code>dayjs</code>，因为它相比 <code>moment</code>，体积小很多。</p><p>上述代码中，<code>typeMap</code> 为我们自定义的属性，它是一个简直对，<code>key</code> 为消费类型 <code>icon</code> 的 <code>id</code>，<code>value</code> 为消费类型的 <code>iconfont</code> 的值，如下所示：</p><pre><code class="js">// utils/index.js...export const typeMap = &#123;  1: &#123;    icon: &#39;canyin&#39;  &#125;,  2: &#123;    icon: &#39;fushi&#39;  &#125;,  3: &#123;    icon: &#39;jiaotong&#39;  &#125;,  4: &#123;    icon: &#39;riyong&#39;  &#125;,  5: &#123;    icon: &#39;gouwu&#39;  &#125;,  6: &#123;    icon: &#39;xuexi&#39;  &#125;,  7: &#123;    icon: &#39;yiliao&#39;  &#125;,  8: &#123;    icon: &#39;lvxing&#39;  &#125;,  9: &#123;    icon: &#39;renqing&#39;  &#125;,  10: &#123;    icon: &#39;qita&#39;  &#125;,  11: &#123;    icon: &#39;gongzi&#39;  &#125;,  12: &#123;    icon: &#39;jiangjin&#39;  &#125;,  13: &#123;    icon: &#39;zhuanzhang&#39;  &#125;,  14: &#123;    icon: &#39;licai&#39;  &#125;,  15: &#123;    icon: &#39;tuikuang&#39;  &#125;,  16: &#123;    icon: &#39;qita&#39;  &#125;&#125;</code></pre><p>完成上述操作之后，我们重启浏览器，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2eb308feee24749a7ce4cd0d00a9645~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>样式部分大家可以根据自己的喜好进行微调，不一定要一模一样，仁者见仁。</p><h4 id="下拉刷新、上滑无限加载"><a href="#下拉刷新、上滑无限加载" class="headerlink" title="下拉刷新、上滑无限加载"></a>下拉刷新、上滑无限加载</h4><p>我们修改 <code>Home/index.jsx</code> 如下所示：</p><pre><code class="js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;import &#123; Icon, Pull &#125; from &#39;zarm&#39;import dayjs from &#39;dayjs&#39;import BillItem from &#39;@/components/BillItem&#39;import &#123; get, REFRESH_STATE, LOAD_STATE &#125; from &#39;@/utils&#39; // Pull 组件需要的一些常量import s from &#39;./style.module.less&#39;const Home = () =&gt; &#123;  const [currentTime, setCurrentTime] = useState(dayjs().format(&#39;YYYY-MM&#39;)); // 当前筛选时间  const [page, setPage] = useState(1); // 分页  const [list, setList] = useState([]); // 账单列表  const [totalPage, setTotalPage] = useState(0); // 分页总数  const [refreshing, setRefreshing] = useState(REFRESH_STATE.normal); // 下拉刷新状态  const [loading, setLoading] = useState(LOAD_STATE.normal); // 上拉加载状态  useEffect(() =&gt; &#123;    getBillList() // 初始化  &#125;, [page])  // 获取账单方法  const getBillList = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;`);    // 下拉刷新，重制数据    if (page == 1) &#123;      setList(data.list);    &#125; else &#123;      setList(list.concat(data.list));    &#125;    setTotalPage(data.totalPage);    // 上滑加载状态    setLoading(LOAD_STATE.success);    setRefreshing(REFRESH_STATE.success);  &#125;  // 请求列表数据  const refreshData = () =&gt; &#123;    setRefreshing(REFRESH_STATE.loading);    if (page != 1) &#123;      setPage(1);    &#125; else &#123;      getBillList();    &#125;;  &#125;;  const loadData = () =&gt; &#123;    if (page &lt; totalPage) &#123;      setLoading(LOAD_STATE.loading);      setPage(page + 1);    &#125;  &#125;  return &lt;div className=&#123;s.home&#125;&gt;    &lt;div className=&#123;s.header&#125;&gt;      &lt;div className=&#123;s.dataWrap&#125;&gt;        &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ 200&lt;/b&gt;&lt;/span&gt;        &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ 500&lt;/b&gt;&lt;/span&gt;      &lt;/div&gt;      &lt;div className=&#123;s.typeWrap&#125;&gt;        &lt;div className=&#123;s.left&#125;&gt;          &lt;span className=&#123;s.title&#125;&gt;类型 &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div className=&#123;s.right&#125;&gt;          &lt;span className=&#123;s.time&#125;&gt;2022-06&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div className=&#123;s.contentWrap&#125;&gt;      &#123;        list.length ? &lt;Pull          animationDuration=&#123;200&#125;          stayTime=&#123;400&#125;          refresh=&#123;&#123;            state: refreshing,            handler: refreshData          &#125;&#125;          load=&#123;&#123;            state: loading,            distance: 200,            handler: loadData          &#125;&#125;        &gt;          &#123;            list.map((item, index) =&gt; &lt;BillItem              bill=&#123;item&#125;              key=&#123;index&#125;            /&gt;)          &#125;        &lt;/Pull&gt; : null      &#125;    &lt;/div&gt;  &lt;/div&gt;&#125;export default Home&#125;</code></pre><p>在 <code>utils/index.js</code> 中添加一些 <code>Pull</code> 组件需要用到的常量，如下：</p><pre><code class="js">// utils/index.jsexport const REFRESH_STATE = &#123;  normal: 0, // 普通  pull: 1, // 下拉刷新（未满足刷新条件）  drop: 2, // 释放立即刷新（满足刷新条件）  loading: 3, // 加载中  success: 4, // 加载成功  failure: 5, // 加载失败&#125;;export const LOAD_STATE = &#123;  normal: 0, // 普通  abort: 1, // 中止  loading: 2, // 加载中  success: 3, // 加载成功  failure: 4, // 加载失败  complete: 5, // 加载完成（无新数据）&#125;;</code></pre><p>代码中，已经为大家整理了详细的注释。无限滚动在移动端的应用随处可见，所以这块内容大家尽量能做到烂熟于心。如果有可能的话，希望你也能将其二次封装，便于多个地方的复用。我们打开浏览器查看效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b1408791dbd457f9a68abd898f6bb74~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>同学们注意一下上述动图中的细节，滑到底部的时候，有一部分内容被遮挡住了，此时我们需要添加下列样式，进行修复：</p><pre><code class="css">.home &#123;  ... .content-wrap &#123;    height: calc(~&quot;(100% - 50px)&quot;);    overflow: hidden;    overflow-y: scroll;    background-color: #f5f5f5;    padding: 10px;    :global &#123;      .za-pull &#123;        overflow: unset;      &#125;    &#125;  &#125;&#125;</code></pre><p>给 <code>content-wrap</code> 对应的标签一个高度，并且减去 <code>50px</code> 的高度，这样就不会被遮挡住下面一点的部分。</p><p>还有一个很关键的步骤，给 <code>src</code> 目录下的的 <code>index.css</code> 添加初始化高度和样式：</p><pre><code class="css">body &#123;  margin: 0;  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Roboto&quot;,    &quot;Oxygen&quot;, &quot;Ubuntu&quot;, &quot;Cantarell&quot;, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;,    &quot;Helvetica Neue&quot;, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;body,html,p &#123;  height: 100%;  margin: 0;  padding: 0;&#125;* &#123;  box-sizing: border-box;&#125;#root &#123;  height: 100%;&#125;.text-deep &#123;  color: rgba(0, 0, 0, 0.9);&#125;.text-light &#123;  color: rgba(0, 0, 0, 0.6);&#125;</code></pre><p>至此，滚动加载基本上就完成了。</p><h4 id="添加筛选条件"><a href="#添加筛选条件" class="headerlink" title="添加筛选条件"></a>添加筛选条件</h4><p>最后我们需要添加两个筛选条件，类型选择和日期选择。</p><p>我们先来实现类型选择弹窗，我们采用的形式如下，底部弹出的弹窗形式，大致如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a334aa0eee1451fbb268f3b2e70a67c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>想要实现上述形式，我们需要借助 <code>Zarm</code> 组件库为我们提供的 <a href="https://link.juejin.cn/?target=https://zarm.gitee.io/%23/components/popup">Popup</a> 组件，它的作用就是从不同方向弹出一个脱离文档流的弹出层。同样，我们使用组件的形式将其放置于 <code>components</code> 文件夹内实现，这样便于后续其他地方的使用。</p><p>新建 <code>components/PopupType</code>，在其内部新建 <code>index.jsx</code> 和 <code>style.module.less</code> 内容如下：</p><pre><code class="js">// PopupType/index.jsximport React, &#123; forwardRef, useEffect, useState &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; Popup, Icon &#125; from &quot;zarm&quot;;import cx from &quot;classnames&quot;;import &#123; get &#125; from &quot;@/utils&quot;;import s from &quot;./style.module.less&quot;;// forwardRef 用于拿到父组件传入的 ref 属性，这样在父组件便能通过 ref 控制子组件。const PopupType = forwardRef((&#123; onSelect &#125;, ref) =&gt; &#123;  const [show, setShow] = useState(false); // 组件的显示和隐藏  const [active, setActive] = useState(&quot;all&quot;); // 激活的 type  const [expense, setExpense] = useState([]); // 支出类型标签  const [income, setIncome] = useState([]); // 收入类型标签  useEffect(async () =&gt; &#123;    // 请求标签接口放在弹窗内，这个弹窗可能会被复用，所以请求如果放在外面，会造成代码冗余。    const &#123;      data: &#123; list &#125;,    &#125; = await get(&quot;/api/type/list&quot;);    setExpense(list.filter((i) =&gt; i.type == 1));    setIncome(list.filter((i) =&gt; i.type == 2));  &#125;, []);  if (ref) &#123;    ref.current = &#123;      // 外部可以通过 ref.current.show 来控制组件的显示      show: () =&gt; &#123;        setShow(true);      &#125;,      // 外部可以通过 ref.current.close 来控制组件的显示      close: () =&gt; &#123;        setShow(false);      &#125;,    &#125;;  &#125;  // 选择类型回调  const choseType = (item) =&gt; &#123;    setActive(item.id);    setShow(false);    // 父组件传入的 onSelect，为了获取类型    onSelect(item);  &#125;;  return (    &lt;Popup      visible=&#123;show&#125;      direction=&quot;bottom&quot;      onMaskClick=&#123;() =&gt; setShow(false)&#125;      destroy=&#123;false&#125;      mountContainer=&#123;() =&gt; document.body&#125;    &gt;      &lt;div className=&#123;s.popupType&#125;&gt;        &lt;div className=&#123;s.header&#125;&gt;          请选择类型          &lt;Icon            type=&quot;wrong&quot;            className=&#123;s.cross&#125;            onClick=&#123;() =&gt; setShow(false)&#125;          /&gt;        &lt;/div&gt;        &lt;div className=&#123;s.content&#125;&gt;          &lt;div            onClick=&#123;() =&gt; choseType(&#123; id: &quot;all&quot; &#125;)&#125;            className=&#123;cx(&#123; [s.all]: true, [s.active]: active == &quot;all&quot; &#125;)&#125;          &gt;            全部类型          &lt;/div&gt;          &lt;div className=&#123;s.title&#125;&gt;支出&lt;/div&gt;          &lt;div className=&#123;s.expenseWrap&#125;&gt;            &#123;expense.map((item, index) =&gt; (              &lt;p                key=&#123;index&#125;                onClick=&#123;() =&gt; choseType(item)&#125;                className=&#123;cx(&#123; [s.active]: active == item.id &#125;)&#125;              &gt;                &#123;item.name&#125;              &lt;/p&gt;            ))&#125;          &lt;/div&gt;          &lt;div className=&#123;s.title&#125;&gt;收入&lt;/div&gt;          &lt;div className=&#123;s.incomeWrap&#125;&gt;            &#123;income.map((item, index) =&gt; (              &lt;p                key=&#123;index&#125;                onClick=&#123;() =&gt; choseType(item)&#125;                className=&#123;cx(&#123; [s.active]: active == item.id &#125;)&#125;              &gt;                &#123;item.name&#125;              &lt;/p&gt;            ))&#125;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/Popup&gt;  );&#125;);PopupType.propTypes = &#123;  onSelect: PropTypes.func,&#125;;export default PopupType;</code></pre><p>老规矩，代码逻辑注释我都写在代码中，我坚持不把注释和逻辑分开，是因为我自己在看其他教程的时候，遇到代码中没写逻辑的文章，来回看下边的注释和上边的代码，有点乱，如果同学们有疑问，可以进群截图咨询，我在群里看到的话，随时进行解答。</p><p>类型弹窗组件写完之后，我们在 <code>Home/index.jsx</code> 内尝试调用它，如下所示：</p><pre><code class="js">...import PopupType from &#39;@/components/PopupType&#39;const Home = () =&gt; &#123;  const typeRef = useRef(); // 账单类型 ref  const [currentSelect, setCurrentSelect] = useState(&#123;&#125;); // 当前筛选类型  ...  useEffect(() =&gt; &#123;    getBillList() // 初始化  &#125;, [page, currentSelect])  const getBillList = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;&amp;type_id=$&#123;currentSelect.id || &#39;all&#39;&#125;`);    // 下拉刷新，重制数据    if (page == 1) &#123;      setList(data.list);    &#125; else &#123;      setList(list.concat(data.list));    &#125;    setTotalPage(data.totalPage);    // 上滑加载状态    setLoading(LOAD_STATE.success);    setRefreshing(REFRESH_STATE.success);  &#125;  ...  // 添加账单弹窗  const toggle = () =&gt; &#123;    typeRef.current &amp;&amp; typeRef.current.show()  &#125;;  // 筛选类型  const select = (item) =&gt; &#123;    setRefreshing(REFRESH_STATE.loading);    // 触发刷新列表，将分页重制为 1    setPage(1);    setCurrentSelect(item)  &#125;  return &lt;div className=&#123;s.home&#125;&gt;    &lt;div className=&#123;s.header&#125;&gt;      &lt;div className=&#123;s.dataWrap&#125;&gt;        &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ 200&lt;/b&gt;&lt;/span&gt;        &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ 500&lt;/b&gt;&lt;/span&gt;      &lt;/div&gt;      &lt;div className=&#123;s.typeWrap&#125;&gt;        &lt;div className=&#123;s.left&#125; onClick=&#123;toggle&#125;&gt;          &lt;span className=&#123;s.title&#125;&gt;&#123; currentSelect.name || &#39;全部类型&#39; &#125; &lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div className=&#123;s.right&#125;&gt;          &lt;span className=&#123;s.time&#125;&gt;2022-06&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div className=&#123;s.contentWrap&#125;&gt;      &#123;        list.length ? &lt;Pull          animationDuration=&#123;200&#125;          stayTime=&#123;400&#125;          refresh=&#123;&#123;            state: refreshing,            handler: refreshData          &#125;&#125;          load=&#123;&#123;            state: loading,            distance: 200,            handler: loadData          &#125;&#125;        &gt;          &#123;            list.map((item, index) =&gt; &lt;BillItem              bill=&#123;item&#125;              key=&#123;index&#125;            /&gt;)          &#125;        &lt;/Pull&gt; : null      &#125;    &lt;/div&gt;    &lt;PopupType ref=&#123;typeRef&#125; onSelect=&#123;select&#125; /&gt;  &lt;/div&gt;&#125;</code></pre><p>添加类型选择弹窗注意几个点：</p><p>1、使用 <code>useState</code> 声明好类型字段。 2、通过 <code>useRef</code> 声明的 ref 给到 <code>PopupType</code> 组件，便于控制内部的方法。 3、传递 <code>onSelect</code> 方法，获取到弹窗内部选择的类型。 4、<code>useEffect</code> 第二个参数，添加一个 <code>currentSelect</code> 以来，便于修改的时候，触发列表的重新渲染。</p><p>有一个有趣的知识点，这里和大家分享一下，你尝试去打印 <code>typeRef</code> 变量，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c7b0f79094c436d8ee0d089b35acc46~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到，在 <code>PopupType</code> 组件内挂载的方法，可以在父组件内获取到，那么我们便可以直接把弹窗的显示隐藏参数放在子组件内维护，而不用每次都去在父组件声明 <code>show</code> 或 <code>hide</code>。</p><p>加完类型筛选之后，我们再将时间筛选加上，同样将时间筛选添加至 <code>components</code> 目录下，便于后续数据页面的时间筛选。</p><pre><code class="js">// PopupDate/index.jsximport React, &#123; forwardRef, useState &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; Popup, DatePicker &#125; from &quot;zarm&quot;;import dayjs from &quot;dayjs&quot;;const PopupDate = forwardRef((&#123; onSelect, mode = &quot;date&quot; &#125;, ref) =&gt; &#123;  const [show, setShow] = useState(false);  const [now, setNow] = useState(new Date());  const choseMonth = (item) =&gt; &#123;    setNow(item);    setShow(false);    if (mode == &quot;month&quot;) &#123;      onSelect(dayjs(item).format(&quot;YYYY-MM&quot;));    &#125; else if (mode == &quot;date&quot;) &#123;      onSelect(dayjs(item).format(&quot;YYYY-MM-DD&quot;));    &#125;  &#125;;  if (ref) &#123;    ref.current = &#123;      show: () =&gt; &#123;        setShow(true);      &#125;,      close: () =&gt; &#123;        setShow(false);      &#125;,    &#125;;  &#125;  return (    &lt;Popup      visible=&#123;show&#125;      direction=&quot;bottom&quot;      onMaskClick=&#123;() =&gt; setShow(false)&#125;      destroy=&#123;false&#125;      mountContainer=&#123;() =&gt; document.body&#125;    &gt;      &lt;div&gt;        &lt;DatePicker          visible=&#123;show&#125;          value=&#123;now&#125;          mode=&#123;mode&#125;          onOk=&#123;choseMonth&#125;          onCancel=&#123;() =&gt; setShow(false)&#125;        /&gt;      &lt;/div&gt;    &lt;/Popup&gt;  );&#125;);PopupDate.propTypes = &#123;  mode: PropTypes.string, // 日期模式  onSelect: PropTypes.func, // 选择后的回调&#125;;export default PopupDate;</code></pre><p>底部时间弹窗逻辑和类型选择的逻辑相似，这里不做赘述，直接在 <code>Home/index.jsx</code> 中引入时间筛选框：</p><pre><code class="js">// Home/index.jsx...import PopupDate from &#39;@/components/PopupDate&#39;const Home = () =&gt; &#123;  ...  const monthRef = useRef(); // 月份筛选 ref  useEffect(() =&gt; &#123;    getBillList() // 初始化  &#125;, [page, currentSelect, currentTime])  ...  // 选择月份弹窗  const monthToggle = () =&gt; &#123;    monthRef.current &amp;&amp; monthRef.current.show()  &#125;;  // 筛选月份  const selectMonth = (item) =&gt; &#123;    setRefreshing(REFRESH_STATE.loading);    setPage(1);    setCurrentTime(item)  &#125;  return &lt;div className=&#123;s.home&#125;&gt;    ...    &lt;div className=&#123;s.right&#125;&gt;      &lt;span className=&#123;s.time&#125; onClick=&#123;monthToggle&#125;&gt;&#123; currentTime &#125;&lt;Icon className=&#123;s.arrow&#125; type=&quot;arrow-bottom&quot; /&gt;&lt;/span&gt;    &lt;/div&gt;    ...    &lt;PopupDate ref=&#123;monthRef&#125; mode=&quot;month&quot; onSelect=&#123;selectMonth&#125; /&gt;  &lt;/div&gt;&#125;</code></pre><p>刷新浏览器如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847ab58538134cdcb8d819d61823a5a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>最后不要忘记计算当前月份的收入和支出汇总数据，放置于头部，修改 <code>Home/index.jsx</code> 内的代码如下：</p><pre><code class="js">...const Home = () =&gt; &#123;  ...  const [totalExpense, setTotalExpense] = useState(0); // 总支出  const [totalIncome, setTotalIncome] = useState(0); // 总收入  const getBillList = async () =&gt; &#123;    const &#123; data &#125; = await get(`/api/bill/list?page=$&#123;page&#125;&amp;page_size=5&amp;date=$&#123;currentTime&#125;&amp;type_id=$&#123;currentSelect.id || &#39;all&#39;&#125;`);    // 下拉刷新，重制数据    if (page == 1) &#123;      setList(data.list);    &#125; else &#123;      setList(list.concat(data.list));    &#125;    setTotalExpense(data.totalExpense.toFixed(2));    setTotalIncome(data.totalIncome.toFixed(2));    setTotalPage(data.totalPage);    // 上滑加载状态    setLoading(LOAD_STATE.success);    setRefreshing(REFRESH_STATE.success);  &#125;  return &lt;div className=&#123;s.home&#125;&gt;    ...    &lt;div className=&#123;s.dataWrap&#125;&gt;      &lt;span className=&#123;s.expense&#125;&gt;总支出：&lt;b&gt;¥ &#123; totalExpense &#125;&lt;/b&gt;&lt;/span&gt;      &lt;span className=&#123;s.income&#125;&gt;总收入：&lt;b&gt;¥ &#123; totalIncome &#125;&lt;/b&gt;&lt;/span&gt;    &lt;/div&gt;    ...  &lt;div&gt;&#125;</code></pre><p>最终展示效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17747f5d0d7b41eabcbe47e8dc633de7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节的内容，偏向实战，而实战部分代码在文章的重复率不可避免，这里大家把握好本章节两个重要知识点：</p><p>1、无限加载、下拉刷新。</p><p>2、公用组件提取，如弹窗组件、账单组件。</p><p>这两个知识点在实战中，用到的非常多，希望同学们能重视。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>114、稀土掘金小册-记账本（五）登录注册</title>
      <link href="/2023/01/08/114-react/"/>
      <url>/2023/01/08/114-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章节我们实现了底部导航栏，并且创建了三个主页面，这三个页面是需要展示底部导航栏，而我们本章节要制作的「登录注册页面」便是不需要底部导航栏的单独页面。</p><blockquote><p>本教程已有线上地址<a href="https://link.juejin.cn/?target=http://cost.chennick.wang">在线地址</a>，同学们可以在实战部分，对照着线上页面进行学习。</p></blockquote><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>组件：<code>Cell</code>、<code>Input</code>、<code>Button</code>、<code>CheckBox</code>。</p><h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff7150ab666463faf49a280bded1d9b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们的系统是面向多用户的，换句话说也就是一个纯正的 C 端项目，任何人都可以通过网站，注册一个新的账号。接下来开始注册页面的编写。</p><p>首先新建 <code>Login</code> 文件夹，在文件夹内添加两个文件 <code>index.jsx</code> 和 <code>style.module.less</code>，我们先把注册页面的静态页面切出来，首先给 <code>index.jsx</code> 添加如下代码：</p><pre><code class="js">import React from &quot;react&quot;;import s from &quot;./style.module.less&quot;;const Login = () =&gt; &#123;  return &lt;div className=&#123;s.auth&#125;&gt;注册&lt;/div&gt;;&#125;;export default Login;</code></pre><p>为它添加一个路由配置，打开 <code>router/index.js</code> 添加如下：</p><pre><code class="js">import Login from &#39;@/container/Login&#39;...&#123;  path: &quot;/login&quot;,  component: Login&#125;</code></pre><p>重启项目，如下所示代表登录注册页面创建成功了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70072a5101314b52a83e7675deb6a205~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来为 <code>Login/index.jsx</code> 添加静态页面代码：</p><pre><code class="js">import React from &quot;react&quot;;import &#123; Cell, Input, Button, Checkbox &#125; from &quot;zarm&quot;;import CustomIcon from &quot;@/components/CustomIcon&quot;;import s from &quot;./style.module.less&quot;;const Login = () =&gt; &#123;  return (    &lt;div className=&#123;s.auth&#125;&gt;      &lt;div className=&#123;s.head&#125; /&gt;      &lt;div className=&#123;s.tab&#125;&gt;        &lt;span&gt;注册&lt;/span&gt;      &lt;/div&gt;      &lt;div className=&#123;s.form&#125;&gt;        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;zhanghao&quot; /&gt;&#125;&gt;          &lt;Input clearable type=&quot;text&quot; placeholder=&quot;请输入账号&quot; /&gt;        &lt;/Cell&gt;        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;          &lt;Input clearable type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;        &lt;/Cell&gt;        &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;          &lt;Input clearable type=&quot;text&quot; placeholder=&quot;请输入验证码&quot; /&gt;        &lt;/Cell&gt;      &lt;/div&gt;      &lt;div className=&#123;s.operation&#125;&gt;        &lt;div className=&#123;s.agree&#125;&gt;          &lt;Checkbox /&gt;          &lt;label className=&quot;text-light&quot;&gt;            阅读并同意&lt;a&gt;《掘掘手札条款》&lt;/a&gt;          &lt;/label&gt;        &lt;/div&gt;        &lt;Button block theme=&quot;primary&quot;&gt;          注册        &lt;/Button&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default Login;</code></pre><blockquote><p>文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。</p></blockquote><p>上述代码中，关键部分是账号输入、密码输入、验证码输入，这三个输入框是需要获取数据作为接口的参数提交上去的。</p><p>很多时候，服务端没有开发好接口的时候，我们前端要做的任务就是先还原 <code>UI</code> 稿，把该切的页面都切出来，并且预留好需要给接口提交的数据交互，比如上述三个输入框。</p><p>样式编写部分，要注意的一点是 <code>:global</code> 这个关键词。由于我们采用的是 <code>CSS Module</code> 的形式进行开发，也就是你在页面中声明的类名都会根据当前页面，打一个唯一的 <code>hash</code> 值，比如我们页面中声明的 <code>className=&#123;s.form&#125;</code>，最终在浏览器中显示的是这样的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bab558e802d84ccd8c0b4273fe1e6174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>_form_kpur3_30</code> 是已经被编译过的样式，这样做的目的是避免和别的页面的样式重名，这是目前样式管理的一个诟病，当多人参与项目开发的时候，很难做到不污染全局样式名称，除非很小心的命名样式名称。</p><p>所以经过编译之后，想要修改 <code>.form</code> 下的 <code>.za-cell</code>，如下写法，将无法修改成功：</p><pre><code class="css">.form &#123;  .za-cell &#123;    color: red;  &#125;&#125;</code></pre><p>原因是，上述写法，<code>.za-cell</code> 会被编译加上 <code>hash</code>，组件库 <code>Zarm</code> 内的 <code>dom</code> 类名还是叫 <code>za-cell</code>，如上图所示。所以为了不加 <code>hash</code>，就需要这样操作：</p><pre><code class="css">.form &#123;  :global &#123;    .za-cell &#123;      color: red;    &#125;  &#125;&#125;</code></pre><p>这样 <code>.za-cell</code> 就不会被加上 <code>hash</code>，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580f03ce2daf4f4488edd73c9a1efae6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>完成上述页面布局之后，你会看到这样一个效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2933714025354b66ac111139397aa2d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>少了一个验证码，我们使用插件 <code>react-captcha-code</code>，我们通过 <code>npm</code> 下载它：</p><pre><code class="bash">npm i react-captcha-code -S</code></pre><p>在代码中引入：</p><pre><code class="js">...import Captcha from &quot;react-captcha-code&quot;...&lt;Input  clearable  type=&quot;text&quot;  placeholder=&quot;请输入验证码&quot;  onChange=&#123;(value) =&gt; setVerify(value)&#125;/&gt;&lt;Captcha charNum=&#123;4&#125; /&gt;</code></pre><p>浏览器展示如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa07ed8b505a421bb3d9120ba8741cac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时我们已经切完注册页面需要的内容。</p><p>我们给页面加上相应的逻辑，首先是账号、密码、验证码：</p><pre><code class="js">...const [username, setUsername] = useState(&#39;&#39;); // 账号const [password, setPassword] = useState(&#39;&#39;); // 密码const [verify, setVerify] = useState(&#39;&#39;); // 验证码...&lt;Input  clearable  type=&quot;text&quot;  placeholder=&quot;请输入账号&quot;  onChange=&#123;(value) =&gt; setUsername(value)&#125;/&gt;...&lt;Input  clearable  type=&quot;password&quot;  placeholder=&quot;请输入密码&quot;  onChange=&#123;(value) =&gt; setPassword(value)&#125;/&gt;...&lt;Input  clearable  type=&quot;text&quot;  placeholder=&quot;请输入验证码&quot;  onChange=&#123;(value) =&gt; setVerify(value)&#125;/&gt;</code></pre><p>当输入框内容修改的时候，<code>onChange</code> 会被触发，接受的回调函数参数，便是变化的输入值，此时我们将其保存在声明的变量中。</p><p>我们输入的验证码是需要和验证码图片里的验证码匹配的，所以我们还需要拿到图片里的验证码，我们作如下操作：</p><pre><code class="js">import React, &#123; useCallback &#125; from &#39;react&#39;...const [captcha, setCaptcha] = useState(&#39;&#39;); // 验证码变化后存储值//  验证码变化，回调方法const handleChange = useCallback((captcha) =&gt; &#123;  console.log(&#39;captcha&#39;, captcha)  setCaptcha(captcha)&#125;, []);...&lt;Captcha charNum=&#123;4&#125; onChange=&#123;handleChange&#125; /&gt;</code></pre><p>当验证码变化的时候，便能获取到相应的值。修改完上述代码，我们不妨测试一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68459ab851c941ee92f3fcdaf6f758a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>到此，注册需要的参数都有了，我们开始编写注册方法：</p><pre><code class="js">import &#123; Cell, Input, Button, Checkbox, Toast &#125; from &#39;zarm&#39;import &#123; post &#125; from &#39;@/utils&#39;...const onSubmit = async () =&gt; &#123;  if (!username) &#123;    Toast.show(&#39;请输入账号&#39;)    return  &#125;  if (!password) &#123;    Toast.show(&#39;请输入密码&#39;)    return  &#125;  if (!verify) &#123;    Toast.show(&#39;请输入验证码&#39;)    return  &#125;;  if (verify != captcha) &#123;    Toast.show(&#39;验证码错误&#39;)    return  &#125;;  try &#123;    const &#123; data &#125; = await post(&#39;/api/user/register&#39;, &#123;      username,      password    &#125;);    Toast.show(&#39;注册成功&#39;);  &#125; catch (error) &#123;    Toast.show(&#39;系统错误&#39;);  &#125;&#125;;...&lt;Button onClick=&#123;onSubmit&#125; block theme=&quot;primary&quot;&gt;注册&lt;/Button&gt;</code></pre><p>上述代码中，因为我们使用的是 <code>async await</code> 做异步处理，所以需要通过 <code>try catch</code> 来捕获异步处理过程中出现的错误，如果使用 <code>Promise</code> 的回调函数，则无需使用 <code>try catch</code>，改动如下：</p><pre><code class="js">post(&quot;/api/user/register&quot;, &#123;  username,  password,&#125;).then((res) =&gt; &#123;  // do something&#125;);</code></pre><p>尝试使用之前注册过的用户名，注册一个账号：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e36ba2f6724445a821b444dda9643f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>服务端给出正确的报错，我们再用一个未注册过的用户名：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb9d6a0ade945589835a6add7c87e99~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时我们大致将注册功能实现了。这里我不再展开讲样式部分，因为这样会使得文章中出现过多的重复代码，不以阅读，大家尽量根据标签的类名去查找 <code>css</code> 样式部分。</p><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><p>登录页面的逻辑我们直接做到同一个页面中，通过一个 <code>type</code> 参数作为判断条件，判断当前状态是登录页面或是注册页面。</p><p>话不多说我们添加代码如下：</p><pre><code class="js">...import cx from &#39;classnames&#39;...const Login = () =&gt; &#123;  ...  const [type, setType] = useState(&#39;login&#39;); // 登录注册类型  return &lt;div className=&#123;s.auth&#125;&gt;    ...    &lt;div className=&#123;s.tab&#125;&gt;      &lt;span className=&#123;cx(&#123; [s.avtive]: type == &#39;login&#39; &#125;)&#125; onClick=&#123;() =&gt; setType(&#39;login&#39;)&#125;&gt;登录&lt;/span&gt;      &lt;span className=&#123;cx(&#123; [s.avtive]: type == &#39;register&#39; &#125;)&#125; onClick=&#123;() =&gt; setType(&#39;register&#39;)&#125;&gt;注册&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div className=&#123;s.form&#125;&gt;    ...    &#123;      type == &#39;register&#39; ? &lt;Cell icon=&#123;&lt;CustomIcon type=&quot;mima&quot; /&gt;&#125;&gt;        &lt;Input          clearable          type=&quot;text&quot;          placeholder=&quot;请输入验证码&quot;          onChange=&#123;(value) =&gt; setVerify(value)&#125;        /&gt;        &lt;Captcha ref=&#123;captchaRef&#125; charNum=&#123;4&#125; onChange=&#123;handleChange&#125; /&gt;      &lt;/Cell&gt; : null    &#125;  &lt;/div&gt;  &lt;div className=&#123;s.operation&#125;&gt;    &#123;      type == &#39;register&#39; ? &lt;div className=&#123;s.agree&#125;&gt;        &lt;Checkbox /&gt;        &lt;label className=&quot;text-light&quot;&gt;阅读并同意&lt;a&gt;《掘掘手札条款》&lt;/a&gt;&lt;/label&gt;      &lt;/div&gt; : null    &#125;    &lt;Button onClick=&#123;onSubmit&#125; block theme=&quot;primary&quot;&gt;&#123;type == &#39;login&#39; ? &#39;登录&#39; : &#39;注册&#39;&#125;&lt;/Button&gt;  &lt;/div&gt;&#125;</code></pre><blockquote><p>注意，如果引入了新的工具包，请自行安装，如上述代码就需要安装 classnames。可以通过 npm i classnames -S 指令</p></blockquote><p>代码分析：</p><p>上述代码中，通过 <code>type</code> 属性区分注册和登录。</p><p>首先是 <code>tab</code> 切换，通过 <code>classname</code> 来判断是否是当前高亮，用于样式控制。</p><p>其次，当 <code>type == &#39;register&#39;</code> 的时候，才把验证码展示出来，因为登录这边咱们就不设置验证码，只在注册的时候显示。</p><p>最后是事件的判断，如果 <code>type == &#39;login&#39;</code>，则按钮文案显示为 <code>登录</code>，否则为 <code>注册</code>。</p><p>此时点击触发的 <code>onSubmit</code> 事件也很关键，同样需要通过 <code>type</code> 判断是登录还是注册，修改代码如下：</p><pre><code class="js">const onSubmit = async () =&gt; &#123;  if (!username) &#123;    Toast.show(&quot;请输入账号&quot;);    return;  &#125;  if (!password) &#123;    Toast.show(&quot;请输入密码&quot;);    return;  &#125;  try &#123;    // 判断是否是登录状态    if (type == &quot;login&quot;) &#123;      // 执行登录接口，获取 token      const &#123; data &#125; = await post(&quot;/api/user/login&quot;, &#123;        username,        password,      &#125;);      // 将 token 写入 localStorage      localStorage.setItem(&quot;token&quot;, data.token);    &#125; else &#123;      if (!verify) &#123;        Toast.show(&quot;请输入验证码&quot;);        return;      &#125;      if (verify != captcha) &#123;        Toast.show(&quot;验证码错误&quot;);        return;      &#125;      const &#123; data &#125; = await post(&quot;/api/user/register&quot;, &#123;        username,        password,      &#125;);      Toast.show(&quot;注册成功&quot;);      // 注册成功，自动将 tab 切换到 login 状态      setType(&quot;login&quot;);    &#125;  &#125; catch (error) &#123;    Toast.show(&quot;系统错误&quot;);  &#125;&#125;;</code></pre><p>由于登录注册的账号和密码是同一参数，我们这边就直接复用了逻辑，并通过 <code>type</code> 判断调用哪一个接口。</p><p>重启项目，验证登录接口是否成功，如果成功则会返回 <code>token</code> 信息，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79260001863b4fcc9f9d52522a7732fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时，我们本地的 <code>localStorage</code> 里，已经存下了 <code>token</code>，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cac2dd5459b4fab8ccb7bb476719944~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>保存 <code>token</code> 的形式有很多，你可以引入状态管理插件来对这些数据进行存储，但是这里我们对其进行简单处理，减少项目多余的负担，保证课程的完成度。有时候，成功的将课程完成，也是一种成就感。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我们的登录注册页面算是完成了，我们拿到的 <code>token</code> 是有时效性的，我在后台设置的是 24 小时的时效，如果过期了，请求其他接口时，就会报错，从而通过逻辑判断重新回到登录页面。下一章节，我会详细分析这块内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>113、稀土掘金小册-记账本（四）底部导航栏</title>
      <link href="/2023/01/05/113-react/"/>
      <url>/2023/01/05/113-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章节，我们从 0 开始搭建出一套以 <code>React</code> 技术栈为基础的前端开发环境，过程中肯定会遇到各种奇奇怪怪的问题，比如 <code>Node</code> 版本问题，工具包的版本问题，插件下载完之后，无法得到自己想要的效果等等，为了大家能顺畅地进行开发，请大家尽量将项目中用到的 <code>node_module</code> 包版本和我提供给大家的项目中的版本，保持一致。</p><p>倘若你学会了这一套搭建流程，我希望你能举一反三，根据项目需求，灵活的切换组件库、PC 版、甚至是主框架。这对提升自己的知识广度很有帮助，因为相比每次都看教程，自己手动实现一遍，印象会更深刻，遇到问题也能通过自己的认知，去解决它。</p><p>扯得有点远了，本章节我们将正式进入前端实战环节。</p><blockquote><p>本教程已有线上地址<a href="https://link.juejin.cn/?target=http://cost.chennick.wang">在线地址</a>，同学们可以在实战部分，对照着线上页面。</p></blockquote><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>编写底部导航栏</li><li>创建图标公用组件</li><li>路由控制底部导航栏的显隐</li></ul><h2 id="编写底部导航栏"><a href="#编写底部导航栏" class="headerlink" title="编写底部导航栏"></a>编写底部导航栏</h2><p>我们先观察我们今天要实现的底部导航长啥样，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b876655d1d4cc98bc64701893070f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>上图红框中的底部导航栏，在很多业务场景下都是需要的，三个导航栏对应着三个不同的三个页面组件，分别是「账单」、「统计」、「我的」。这三个页面组件是需要导航栏的。如果我们点击内页如账单详情页，则底部的导航栏会被隐藏，这就需要我们在导航栏的控制上，下一些功夫。</p><p>话不多说，我们在上一章的代码基础上添加导航栏组件，在 <code>src</code> 目录下新建 <code>components</code> 目录，专门用于放置一些公用组件，我们再在 <code>components</code> 目录下新建 <code>NavBar</code> 目录，用于编写底部导航栏，代码如下所示：</p><p><strong>Nav/index.jsx</strong></p><pre><code class="js">import React, &#123; useState &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &#123; TabBar &#125; from &quot;zarm&quot;;import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;import s from &quot;./style.module.less&quot;;const NavBar = (&#123; showNav &#125;) =&gt; &#123;  const [activeKey, setActiveKey] = useState(&quot;/&quot;);  const navigateTo = useNavigate();  const changeTab = (path) =&gt; &#123;    setActiveKey(path);    navigateTo(path);  &#125;;  return (    &lt;TabBar      visible=&#123;showNav&#125;      className=&#123;s.tab&#125;      activeKey=&#123;activeKey&#125;      onChange=&#123;changeTab&#125;    &gt;      &lt;TabBar.Item itemKey=&quot;/&quot; title=&quot;账单&quot; /&gt;      &lt;TabBar.Item itemKey=&quot;/data&quot; title=&quot;统计&quot; /&gt;      &lt;TabBar.Item itemKey=&quot;/user&quot; title=&quot;我的&quot; /&gt;    &lt;/TabBar&gt;  );&#125;;NavBar.propTypes = &#123;  showNav: PropTypes.bool,&#125;;export default NavBar;</code></pre><p>代码解析：</p><p>首先是声明 <code>NavBar</code> 函数组件，它接收一个外部传入的 <code>showNav</code> 属性，用于控制导航栏的显示隐藏。</p><p>通过 <code>useNavigate</code> 钩子方法，拿到路由实例 <code>navigateTo</code>，它内部含有很多路由的方法，在上述代码中，我们使用到的是 <code>navigateTo</code> 进行路由跳转。</p><p>在页面中，引入 <code>TabBar</code> 组件，它接受几个属性：</p><ul><li>visible：用于控制导航栏的显示隐藏。</li><li>activeKey：当前被点击的导航栏。</li><li>onChange：点击导航栏之后的回调方法，<code>path</code> 参数为 <code>TabBar.Item</code> 的 <code>itemKey</code> 属性。</li></ul><blockquote><p>TabBar 官方文档：<a href="https://link.juejin.cn/?target=https://zarm.gitee.io/%23/components/tab-bar">zarm.gitee.io/#/component…</a></p></blockquote><p>所以当你点击导航栏的时候，<code>changeTab</code> 方法便会被触发，执行内部的 <code>setActiveKey</code> 和 <code>navigateTo</code>，他们的作用分别是设置当前点击的高亮和让页面跳转到对应的页面组件。</p><p>说到跳转到对应的组件，’/‘、’/data’、’/user’ 这三个路由对应的三个组件我们还未编写，这里我们在 <code>container</code> 目录下新建这三个页面组件，作为占位。</p><pre><code class="js">// Home/index.jsximport React from &#39;react&#39;const Home = () =&gt; &#123;  return &lt;div&gt;首页&lt;/div&gt;&#125;export default Home// Data/index.jsximport React from &#39;react&#39;const Data = () =&gt; &#123;  return &lt;div&gt;数据&lt;/div&gt;&#125;export default Data// User/index.jsximport React from &#39;react&#39;const User = () =&gt; &#123;  return &lt;div&gt;个人中心&lt;/div&gt;&#125;export default User</code></pre><p>别忘了，前往 <code>router/index.js</code> 添加路由配置，如果不添加这个配置，调用 <code>navigateTo</code> 这个方法，就无法匹配到对应的页面组件，代码如下：</p><pre><code class="js">// router/index.jsimport Home from &quot;@/container/Home&quot;;import Data from &quot;@/container/Data&quot;;import User from &quot;@/container/User&quot;;const routes = [  &#123;    path: &quot;/&quot;,    component: Home,  &#125;,  &#123;    path: &quot;/data&quot;,    component: Data,  &#125;,  &#123;    path: &quot;/user&quot;,    component: User,  &#125;,];export default routes;</code></pre><p>这时，我们还缺少一步，将导航栏组件引入 <code>App.jsx</code> 入口页面，如下所示：</p><pre><code class="js">// App.jsx...import NavBar from &#39;@/components/NavBar&#39;;...function App() &#123;  return &lt;Router&gt;    &lt;ConfigProvider primaryColor=&#123;&#39;#007fff&#39;&#125;&gt;      &lt;&gt;       &lt;Routes&gt;        &#123;routes.map(route =&gt; &lt;Route exact key=&#123;route.path&#125; path=&#123;route.path&#125; element=&#123;&lt;route.component /&gt;&#125; /&gt;)&#125;       &lt;/Routes&gt;      &lt;NavBar showNav=&#123;showNav&#125; /&gt;     &lt;/&gt;    &lt;/ConfigProvider&gt;    &lt;NavBar showNav=&#123;true&#125; /&gt;  &lt;/Router&gt;&#125;</code></pre><p>通过 <code>npm run dev</code> 启动项目，浏览器展示效果如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ce0d3387fd41df97db10b054a6ae0a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>上图效果所示，注意地址栏的变化，点击相应的 <code>Tab</code>，调用的 <code>navigateTo</code> 方法，将地址栏的 <code>pathname</code> 改变，随之而来的是页面组件的改变。这个就应证了我们第 10 章给大家解释的单页面路由控制的原理。<code>navigateTo</code> 做的事情就是改变地址栏，地址栏一旦改变，就会触发地址所对应的组件渲染，如 <code>/data</code>，渲染的就是 <code>Data</code> 页面组件。</p><p>你会问为什么导航栏会一直显示在底部，我们来分析以下代码：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d46f4c1f214b4bae40240bccff4fbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>红色框是组件展示的区域，每个路径对应着一个组件，这个在 <code>router/index.js</code> 文件中也有所体现。</p><p>绿色框则代表导航栏的位置，也就是说，无论上面的组件怎么变化，底部的导航栏一直都是存在的。</p><h4 id="添加底部导航图标"><a href="#添加底部导航图标" class="headerlink" title="添加底部导航图标"></a>添加底部导航图标</h4><p>我们将图标写成公共组件，这样便于后面各个页面方便引入，我们新建 <code>components/CustomIcon/index.jsx</code>，添加如下代码：</p><pre><code class="js">import &#123; Icon &#125; from &quot;zarm&quot;;export default Icon.createFromIconfont(  &quot;//at.alicdn.com/t/font_2236655_w1mpqp7n1ni.js&quot;);</code></pre><p>上述代码，我们引入 <code>Icon</code>，执行它的自定义图标方法 <code>createFromIconfont</code>，它接收一个参数，为 <code>iconfont</code> 生产的静态脚本路径，你可以自己去 <a href="https://link.juejin.cn/?target=https://www.iconfont.cn/">官网</a> 配置，也可以直接用我提供的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe4857973a74a78a2cc2d2110e49c34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这里我已经为大家添加好了各个图标，地址就是上述代码的地址。</p><p>接着我们将其引入到代码中使用，打开 <code>components/NavBar/index.jsx</code> ，添加如下属性：</p><pre><code class="js">import CustomIcon from &#39;../CustomIcon&#39;;...&lt;TabBar.Item  itemKey=&quot;/&quot;  title=&quot;账单&quot;  icon=&#123;&lt;CustomIcon type=&quot;zhangdan&quot; /&gt;&#125;/&gt;&lt;TabBar.Item  itemKey=&quot;/data&quot;  title=&quot;统计&quot;  icon=&#123;&lt;CustomIcon type=&quot;tongji&quot; /&gt;&#125;/&gt;&lt;TabBar.Item  itemKey=&quot;/user&quot;  title=&quot;我的&quot;  icon=&#123;&lt;CustomIcon type=&quot;wode&quot; /&gt;&#125;/&gt;</code></pre><p>查看浏览器展示效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f7b75bd787a402795887b4893924916~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="底部导航栏的显示隐藏"><a href="#底部导航栏的显示隐藏" class="headerlink" title="底部导航栏的显示隐藏"></a>底部导航栏的显示隐藏</h2><p>我们在之前引入 <code>NavBar</code> 的代码中，将 <code>showNav</code> 属性写死为 <code>true</code>。此时，我们需要将其盘活，打开 <code>App.jsx</code>，添加如下代码：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123;  BrowserRouter as Router,  Routes,  Route,  useLocation,&#125; from &quot;react-router-dom&quot;;import NavBar from &quot;@/components/NavBar&quot;;import &#123; ConfigProvider &#125; from &quot;zarm&quot;;import routes from &quot;@/router&quot;;function App() &#123;  const location = useLocation(); // 拿到 location 实例  const &#123; pathname &#125; = location; // 获取当前路径  const needNav = [&quot;/&quot;, &quot;/data&quot;, &quot;/user&quot;]; // 需要底部导航栏的路径  const [showNav, setShowNav] = useState(false); // 是否展示 Nav  useEffect(() =&gt; &#123;    setShowNav(needNav.includes(pathname));  &#125;, [pathname]); // [] 内的参数若是变化，便会执行上述回调函数=  return (    &lt;Router&gt;      &lt;ConfigProvider primaryColor=&#123;&quot;#007fff&quot;&#125;&gt;        &lt;Switch&gt;          &#123;routes.map((route) =&gt; (            &lt;Route exact key=&#123;route.path&#125; path=&#123;route.path&#125;&gt;              &lt;route.component /&gt;            &lt;/Route&gt;          ))&#125;        &lt;/Switch&gt;      &lt;/ConfigProvider&gt;      &lt;NavBar showNav=&#123;true&#125; /&gt;    &lt;/Router&gt;  );&#125;export default App;</code></pre><p>当你刷新浏览器，控制台应该会报下面的错误：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3a8e99d9b4346ada136f513486912e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>执行 <code>useLocation</code> 时，报错 <code>location of undefined</code>。这是因为想要在函数组件内执行 <code>useLocation</code>，该组件必须被 <code>Router</code> 高阶组件包裹，我们做如下改动，将 <code>App.jsx</code> 的 <code>Router</code> 组件，前移到 <code>main.jsx</code> 内，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13889ca74b84460bb6205555cbc75fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>逻辑分析：</p><p>我们拿到 <code>pathname</code>，将其设置为 <code>useEffect</code> 钩子函数的第二个参数，监听它的变化，一旦 <code>pathname</code> 变化，便会触发回调函数执行 <code>setShowNav(needNav.includes(pathname))</code>，结果会传递给 <code>NavBar</code> 组件，从而控制组件的显示隐藏。<code>needNav</code> 为需要底部导航的路径值。</p><p>我们不妨做个测试，在 <code>container</code> 目录下新建一个测试页面组件 <code>Detail</code>，并且添加路由配置。</p><p>别忘记把组件属性修改成动态变量：</p><pre><code class="js">&lt;NavBar showNav=&#123;showNav&#125; /&gt;</code></pre><p>查看浏览器的展示效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c659b2430bab4985a86c2519eac7d62e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>导航栏可以用在很多地方，映射到 <code>PC</code> 网页就是左侧侧边导航，道理都是相通的。移动端放在下面控制，<code>PC</code> 端放在左边或者右边控制罢了。所以再次强调不要学完了一个知识点，就思维定势地认为只能用在某一个需求上，能做到融会贯通，才是判断一个好程序员的标准。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112、稀土掘金小册-记账本（三）react vite2.0 ZarmUI搭建开发环境</title>
      <link href="/2023/01/04/112-react/"/>
      <url>/2023/01/04/112-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>React</code> 技术栈的 <code>UI</code> 组件库相比 <code>Vue</code>，会少一些。我们耳熟能详的便是 <code>Antd</code>，但是它针对的是 <code>PC</code> 端的，我们的项目目前是一个 <code>H5</code> 的网页（不排除后期做一个 PC 端）。所以我选择了 <a href="https://link.juejin.cn/?target=https:https://zarm.gitee.io/%23/">Zarm</a>。</p><p>这里再次强调，不是 <code>Zarm</code> 就比别的移动端组件库好，只是目前我开发的这款记账本项目，<code>Zarm</code> 比较适合。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>构架工具 <code>Vite</code>。</li><li>前端框架 <code>React</code> 和路由 <code>react-router-dom</code>。</li><li><code>CSS</code> 预加载器 <code>Less</code>。</li><li><code>HTTP</code> 请求库 <code>axios</code>。</li><li>移动端分辨率适配 <code>flexible</code>。</li><li>跨域代理。</li></ul><h2 id="初始化-Vite-React-项目"><a href="#初始化-Vite-React-项目" class="headerlink" title="初始化 Vite + React 项目"></a>初始化 Vite + React 项目</h2><p><code>Vite</code> 官方提供两种初始化项目的方式，一种是如下所示，可以自由选择需要的前端框架。</p><pre><code class="bash">npm init @vitejs/app</code></pre><p>另一种则是直接用官方提供的模板，一键生成项目：</p><pre><code class="bash"># npm 6.xnpm init @vitejs/app react-vite-h5 --template react# npm 7+, 需要额外的双横线：npm init @vitejs/app react-vite-h5 -- --template react</code></pre><p>我们使用第二种方式初始化项目，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32661c92fce54016949d56b5a57399ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>安装完 <code>node_modules</code> 之后，通过 <code>npm run dev</code> 启动项目，如下所示代表成功了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/874d34fcf2394af585b2c42a11cef607~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="引入路由插件-react-router-dom"><a href="#引入路由插件-react-router-dom" class="headerlink" title="引入路由插件 react-router-dom"></a>引入路由插件 react-router-dom</h2><p>没有路由的项目，那就不是一个完整项目，而是一个页面而已。真实项目都是存在各种模块之间的切换，各个模块的功能组合在一起才能叫做一个项目。</p><p>首选安装 <code>react-router-dom</code>，指令如下：</p><pre><code class="bash">npm i react-router-dom -S</code></pre><p>在项目 <code>src</code> 目录下新增 <code>container</code> 目录用于放置页面组件，再在 <code>container</code> 下新增两个目录分别是 <code>Index</code> 和 <code>About</code> ，添加如下内容：</p><pre><code class="js">// Index/index.jsximport React from &#39;react&#39;export default function Index() &#123;  return &lt;div&gt;    Index  &lt;/div&gt;&#125;// About/index.jsximport React from &#39;react&#39;export default function About() &#123;  return &lt;div&gt;    About  &lt;/div&gt;&#125;</code></pre><p>再来新建 <code>src/router/index.js</code> 配置路由数组，添加如下内容：</p><pre><code class="js">// router/index.jsimport Index from &quot;../container/Index&quot;;import About from &quot;../container/About&quot;;const routes = [  &#123;    path: &quot;/&quot;,    component: Index,  &#125;,  &#123;    path: &quot;/about&quot;,    component: About,  &#125;,];export default routes;</code></pre><p>在 <code>App.jsx</code> 引入路由配置，实现切换浏览器路径，显示相应的组件：</p><pre><code class="js">// App.jsximport React, &#123; useState &#125; from &quot;react&quot;;import &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;import routes from &quot;../src/router&quot;;function App() &#123;  return (    &lt;&gt;      &lt;Routes&gt;        &#123;routes.map((route) =&gt; (          &lt;Route            exact            key=&#123;route.path&#125;            path=&#123;route.path&#125;            element=&#123;&lt;route.component /&gt;&#125;          /&gt;        ))&#125;      &lt;/Routes&gt;    &lt;/&gt;  );&#125;export default App;</code></pre><p>启动项目 <code>npm run dev</code>，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67090d0f61641539e3fcd9061d27474~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="引入-Zarm-UI-组件库"><a href="#引入-Zarm-UI-组件库" class="headerlink" title="引入 Zarm UI 组件库"></a>引入 Zarm UI 组件库</h2><p>首先通过如下指令安装它：</p><pre><code class="bash">npm install zarm -S</code></pre><p>修改 <code>App.jsx</code> 的代码，全局引入样式和中文包：</p><pre><code class="js">import React, &#123; useState &#125; from &quot;react&quot;;import &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;import &#123; ConfigProvider &#125; from &quot;zarm&quot;;import zhCN from &quot;zarm/lib/config-provider/locale/zh_CN&quot;;import &quot;zarm/dist/zarm.css&quot;;import routes from &quot;../src/router&quot;;function App() &#123;  return (    &lt;Router&gt;      &lt;ConfigProvider primaryColor=&#123;&quot;#007fff&quot;&#125; locale=&#123;zhCN&#125;&gt;        &lt;&gt;          &lt;Routes&gt;            &#123;routes.map((route) =&gt; (              &lt;Route                exact                key=&#123;route.path&#125;                path=&#123;route.path&#125;                element=&#123;&lt;route.component /&gt;&#125;              /&gt;            ))&#125;          &lt;/Routes&gt;        &lt;/&gt;      &lt;/ConfigProvider&gt;    &lt;/Router&gt;  );&#125;export default App;</code></pre><p>此时 <code>zarm</code> 的样式，已经全局引入了，我们先查看在 <code>/container/Index/index.jsx</code> 添加一个按钮是否生效：</p><pre><code class="js">// Index/index.jsximport React from &quot;react&quot;;import &#123; Button &#125; from &quot;zarm&quot;;export default function Index() &#123;  return (    &lt;div&gt;      Index      &lt;Button theme=&quot;primary&quot;&gt;按钮&lt;/Button&gt;    &lt;/div&gt;  );&#125;</code></pre><p>重启项目，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5196fda769074ec387a085af87b6bb92~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时恭喜你 🎉，你已经成功将组件引入项目中。</p><h4 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h4><p>组件虽然引入成功了，但是有一个问题，我不希望所有的组件样式都被一次性的引入，因为这样代码会比较冗余，我只需要引入我使用到的组件样式，实现「按需引入」。</p><p>我们先看看，就目前现在这个情况，打完包之后，静态资源有多大。运行指令 <code>npm run build</code> ，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba361939748e48499cab35833093c012~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>腚眼一看，全局引入样式的形式，直接打完包， <code>css</code> 静态资源就 <code>168.22kb</code> 了，我们尝试配置「按需引入」。</p><p>首先我们安装一个插件：</p><pre><code class="bash">npm i vite-plugin-style-import -D</code></pre><p>然后在 <code>vite.config.js</code> 配置文件内添加如下内容：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0314c0446e4654bfcc73e3dee44291~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bcf00b0cb0c4293a2daf92bef93f451~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>打完包之后，肉眼可见，<code>css</code> 提及从 <code>168.22kb</code> -&gt; <code>35.22kb</code>。这种方式也是前端性能优化的其中一种。</p><h2 id="配置-CSS-预处理器-Less"><a href="#配置-CSS-预处理器-Less" class="headerlink" title="配置 CSS 预处理器 Less"></a>配置 CSS 预处理器 Less</h2><p>项目中采用的 <code>Less</code> 作为 <code>CSS</code> 预处理器，它能设置变量以及一些嵌套逻辑，便于项目的样式编写。</p><p>安装 <code>less</code> 插件包，<code>npm i less -D</code>，因为上述配置我们使用的是 <code>less</code>，并且我们需要配置 <code>javascriptEnabled 为 true</code>，支持 <code>less</code> 内联 <code>JS</code>。</p><p>修改 <code>vite.config.js</code>，如下：</p><pre><code class="js">&#123;  plugins: [...]  css: &#123;    modules: &#123;      localsConvention: &#39;dashesOnly&#39;    &#125;,    preprocessorOptions: &#123;      less: &#123;        // 支持内联 JavaScript        javascriptEnabled: true,      &#125;    &#125;  &#125;,&#125;</code></pre><p>并且添加了 <code>css modules</code> 配置，这样我们就不用担心在项目中，自定义的样式重名的风险，我们尝试在 <code>/container/Index</code> 目录下添加样式文件 <code>style.module.less</code>，并且在 <code>/container/Index/index.jsx</code> 中引入它，如下：</p><pre><code class="css">.index &#123;  span &#123;    color: red;  &#125;&#125;// Index/index.jsximport React from &#39;react&#39;import &#123; Button &#125; from &#39;zarm&#39;import s from &#39;./style.module.less&#39;export default function Index() &#123;  return &lt;div className=&#123;s.index&#125;&gt;    &lt;span&gt;样式&lt;/span&gt;    &lt;Button theme=&#39;primary&#39;&gt;按钮&lt;/Button&gt;  &lt;/div&gt;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8866be0be4824492b94297eea2eb4ca3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时我只能再次恭喜你，<code>Less</code> 成功被引入。</p><h2 id="移动端项目适配-rem"><a href="#移动端项目适配-rem" class="headerlink" title="移动端项目适配 rem"></a>移动端项目适配 rem</h2><p>移动端项目，肯定是需要适配各种分辨率屏幕的，就比如你 10px 的宽度，在每个屏幕上的占比都是不一样的，我们这里不对分辨率做深入的探讨，我们目前的首要目的是完成项目移动端的分辨率适配。</p><p>首先我们需要安装 <code>lib-flexible</code>：</p><pre><code class="bash">npm i lib-flexible -S</code></pre><p>并在 <code>main.jsx</code> 中引入它：</p><pre><code class="js">import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;lib-flexible/flexible&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;ReactDOM.render(  &lt;React.StrictMode&gt;    &lt;App /&gt;  &lt;/React.StrictMode&gt;,  document.getElementById(&quot;root&quot;));</code></pre><p>然后再安装一个 <code>postcss-pxtorem</code>，它的作用是在你编写完 <code>css</code> 后，将你的单位自动转化为 <code>rem</code> 单位。</p><pre><code class="bash">npm i postcss-pxtorem</code></pre><p>在项目根目录新建 <code>postcss.config.js</code>：</p><pre><code class="js">// postcss.config.js// 用 vite 创建项目，配置 postcss 需要使用 post.config.js，之前使用的 .postcssrc.js 已经被抛弃// 具体配置可以去 postcss-pxtorem 仓库看看文档module.exports = &#123;  plugins: [    require(&quot;postcss-pxtorem&quot;)(&#123;      rootValue: 37.5,      propList: [&quot;*&quot;],      selectorBlackList: [&quot;.norem&quot;], // 过滤掉.norem-开头的class，不进行rem转换    &#125;),  ],&#125;;</code></pre><p>修改 <code>Index/style.module.less</code>：</p><pre><code class="css">.index &#123;  width: 200px;  height: 200px;  background: green;  span &#123;    color: red;  &#125;&#125;</code></pre><p>重启项目 <code>npm run dev</code>，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28c6f12ba2c446ef9f374f878636c1f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到，<code>200px</code> 已经被转化为 <code>5.3333rem</code>，我们设置的 <code>rootValue</code> 是 <code>37.5</code>，你可以换算一下 <code>5.33333 * 37.5 = 200</code>。</p><p>我们目前把浏览器调整成的是 <code>iphone 6</code>，<code>html</code> 的 <code>font-size</code> 为 <code>37.5px</code>，当我们手机变成其他尺寸的时候，这个 <code>font-size</code> 的值也会变化，这是 <code>flexible</code> 起到的作用，动态的变化 <code>html</code> 的 <code>font-size</code> 的值，从而让 <code>1rem</code> 所对应的 <code>px</code> 值一直都是动态适应变化的。</p><p>当我切换成 <code>iphone 6 plus</code> 时：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b787a8e1e96d4db58622c23d89592954~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>变成了 <code>41.4px</code>，而相应的，我们 <code>div</code> 还是 <code>5.33333rem</code>，所以此时 <code>div</code> 宽度就变大了，但是手机的屏幕宽度也变大了，这就不会影响视觉上的比例误差太大。</p><h2 id="二次封装-axios"><a href="#二次封装-axios" class="headerlink" title="二次封装 axios"></a>二次封装 axios</h2><p>说到这里，那就要涉及到项目的服务端 <code>API</code> 接口，我们在前面的章节里，已经完成了服务端的代码编写，但是此时我们的服务端项目是跑在 <code>http://127.0.0.1/7001</code> 端口上的。</p><p>此时你是可以在后续的请求中，使用 <code>http://127.0.0.1/7001</code> 作为项目的 <code>baseURL</code>。但是照顾到有些同学没有启动服务端项目，直奔前端项目来的。这里我已经将接口提前部署到了线上环境，供大家使用。接口地址是 <code>http://api.chennick.wang</code>。</p><p>所以在后续的封装过程中，我会提醒大家两种使用。</p><p>首先我们安装 <code>npm i axios -S</code>，在 <code>src</code> 目录下新建 <code>utils</code> 目录，并新建 <code>axios.js</code> 脚本：</p><pre><code class="js">// src/utils/axios.jsimport axios from &quot;axios&quot;;import &#123; Toast &#125; from &quot;zarm&quot;;const MODE = import.meta.env.MODE; // 环境变量axios.defaults.baseURL =  MODE == &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;axios.defaults.withCredentials = true;axios.defaults.headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;axios.defaults.headers[&quot;Authorization&quot;] = `$&#123;  localStorage.getItem(&quot;token&quot;) || null&#125;`;axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json&quot;;axios.interceptors.response.use((res) =&gt; &#123;  if (typeof res.data !== &quot;object&quot;) &#123;    Toast.show(&quot;服务端异常！&quot;);    return Promise.reject(res);  &#125;  if (res.data.code != 200) &#123;    if (res.data.msg) Toast.show(res.data.msg);    if (res.data.code == 401) &#123;      window.location.href = &quot;/login&quot;;    &#125;    return Promise.reject(res.data);  &#125;  return res.data;&#125;);export default axios;</code></pre><p>我逐行为大家分析上述代码的情况情况。</p><pre><code class="js">const MODE = import.meta.env.MODE;</code></pre><p><code>MODE</code> 是一个环境变量，通过 <code>Vite</code> 构建的项目中，环境变量在项目中，可以通过 <code>import.meta.env.MODE</code> 获取，环境变量的作用就是判断当前代码运行在开发环境还是生产环境。</p><pre><code class="js">axios.defaults.baseURL = &quot;development&quot; ? &quot;/api&quot; : &quot;http://api.chennick.wang&quot;;</code></pre><p><code>baseURL</code> 是 <code>axios</code> 的配置项，它的作用就是设置请求的基础路径，后续我们会在项目实战中有所体现。配置基础路径的好处就是，当请求地址修改的时候，可以在此统一配置。</p><pre><code class="js">axios.defaults.headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;axios.defaults.headers[&quot;Authorization&quot;] = `$&#123;  localStorage.getItem(&quot;token&quot;) || null&#125;`;axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json&quot;;</code></pre><p>上述三个配置是用于请求头的设置，<code>Authorization</code> 是我们在服务端鉴权的时候用到的，我们在前端设置好 <code>token</code>，服务端通过获取请求头中的 <code>token</code> 去验证每一次请求是否合法。</p><p>最后一行是配置 <code>post</code> 请求是，使用的请求体，这里默认设置成 <code>application/json</code> 的形式。</p><pre><code class="js">axios.interceptors.response.use((res) =&gt; &#123;  if (typeof res.data !== &quot;object&quot;) &#123;    Toast.show(&quot;服务端异常！&quot;);    return Promise.reject(res);  &#125;  if (res.data.code != 200) &#123;    if (res.data.msg) Toast.show(res.data.msg);    if (res.data.code == 401) &#123;      window.location.href = &quot;/login&quot;;    &#125;    return Promise.reject(res.data);  &#125;  return res.data;&#125;);</code></pre><p><code>interceptors</code> 为拦截器，拦截器的作用是帮你拦截每一次请求，你可以在回调函数中做一些“手脚”，再将数据 <code>return</code> 回去。上述代码就是拦截了响应内容，统一判断请求内容，如果非 200，则提示错误信息，<code>401</code> 的话，就是没有登录的用户，默认跳到 <code>/login</code> 页面。如果是正常的响应，则 <code>retrun res.data</code>。</p><p>最后我们将这个 <code>axios</code> 抛出，供页面组件请求使用。</p><p>在 <code>utils</code> 下新建一个 <code>index.js</code>，内容如下：</p><pre><code class="js">import axios from &quot;./axios&quot;;export const get = axios.get;export const post = axios.post;</code></pre><p>这样获取的时候，能少写几行代码，能少写点就少写点。</p><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p><code>baseURL</code> 为什么在 <code>development</code> 环境下，用 <code>/api</code> 这样的请求地址。其实它就是为了代理请求而配置的。</p><p>这样配置完后，在请求接口的时候，请求地址大概长这样：</p><pre><code class="js">/api/userInfo</code></pre><p>于是我们需要去配置代理，打开 <code>vite.config.js</code>，添加如下代码：</p><pre><code class="js">server: &#123;  proxy: &#123;    &#39;/api&#39;: &#123;      // 当遇到 /api 路径时，将其转换成 target 的值      target: &#39;http://api.chennick.wang/api/&#39;,      changeOrigin: true,      rewrite: path =&gt; path.replace(/^\/api/, &#39;&#39;) // 将 /api 重写为空    &#125;  &#125;&#125;</code></pre><p>这样配置完之后，开发环境下，<code>/api/userInfo</code> -&gt; <code>http://api.chennick.wang/api/userInfo</code>。这样就解决了大家老大难的跨域问题。</p><p>但是其实服务端只要设置好白名单，就不会有这样那样的跨域问题。</p><h2 id="resolve-alias-别名设置"><a href="#resolve-alias-别名设置" class="headerlink" title="resolve.alias 别名设置"></a>resolve.alias 别名设置</h2><p>这里我们必须得设置好别名，否则在页面中，你会写出很长一串类似这样的代码 <code>../../../</code>。</p><p>打开 <code>vite.config.js</code>，添加配置如下：</p><pre><code class="js">...import path from &#39;path&#39;export default defineConfig(&#123;  ...  resolve: &#123;    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;), // src 路径      &#39;utils&#39;: path.resolve(__dirname, &#39;src/utils&#39;) // src 路径    &#125;  &#125;,&#125;)</code></pre><p>此时我们便可以修改之前的代码如下：</p><p><strong>router/index.js</strong></p><pre><code class="js">import Index from &quot;@/container/Index&quot;;import About from &quot;@/container/About&quot;;</code></pre><p><strong>App.jsx</strong></p><pre><code class="js">import routes from &quot;@/router&quot;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>行文至此，我们的基础开发环境已经搭建完毕，涉及构建工具、前端框架、<code>UI</code> 组件库、<code>HTTP</code> 请求库、<code>CSS</code> 预加载器、跨域代理、移动端分辨率适配，这些知识都是一个合格的前端工程师应该具备的，所以请大家加油，将他们都通通拿下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111、稀土掘金小册-记账本（二）react vite</title>
      <link href="/2023/01/03/111-react/"/>
      <url>/2023/01/03/111-react/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我还是那句话，工具永远是服务于需求的。纵观整个前端生态的项目构建工具，有服务于 <code>React</code> 生态的 <code>create-react-app</code>、<code>umi</code>、<code>Next.js</code> 等。服务于 <code>Vue</code> 生态的 <code>Vue CLI</code>、<code>Vite</code>、<code>Nuxt.js</code> 等。它们都是耳熟能详的团队和大佬，为了解决各自需求而研发出来的前端构建工具。而我们要做的其实就是根据项目的需求，进行合理的选择和学习。说白了，在你没有决定权的时候，公司用什么，你就学什么。在你有话语权，能自己抉择的时候，哪个让你开发起来比较舒服，就用哪个。</p><p>这些构建工具中，有一个比较特殊，那就是 <code>Vite</code>，它是尤雨溪在发布 <code>Vue 3.0</code> 时，同步推出的一款前端构建工具。它不光服务于 <code>Vue</code>，同时也对其他的框架如 <code>React</code>、<code>Svelte</code>、<code>Preact</code> 都有一定的支持，我们本着学新不学旧的理念，在项目中引进了 <code>Vite</code> 作为构建工具。</p><p>在开始使用 <code>Vite</code> 之前，我们来认识一下它。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li><code>Vite</code> 是什么。</li><li><code>Vite</code> 与 <code>Webpack</code> 相比优势在哪里。</li><li><code>Vite</code> 的构建原理。</li></ul><h2 id="Vite-是什么"><a href="#Vite-是什么" class="headerlink" title="Vite 是什么"></a>Vite 是什么</h2><p>我们引用官方的一句话来介绍它，“下一代前端开发与构建工具”。</p><p>它有以下几个特点：</p><p>1、 快速启动，<code>Vite</code> 会在本地启动一个开发服务器，来管理开发环境的资源请求。</p><p>2、相比 <code>Webpack</code> 的开发环境打包构建，它在开发环境下是无需打包的，热更新相比 <code>Webpack</code> 会快很多。</p><p>3、原生 <code>ES Module</code>，要什么就当场给你什么。而 <code>Webpack</code> 则是先将资源构建好之后，再根据你的需要，分配给你想要的资源。</p><p>尤雨溪在发布 <code>Vite</code> 前，发过这么一条微博。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b6344806ae94c96b9060fb0a3b13381~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>从话语间可以看出，尤雨溪团队对该打包工具也是报以厚望，所以这里大家可以不必担心后续它们会放弃维护这个项目，当然也不能打包票。</p><h2 id="Vite-与-Webpack-相比优势在哪里"><a href="#Vite-与-Webpack-相比优势在哪里" class="headerlink" title="Vite 与 Webpack 相比优势在哪里"></a>Vite 与 Webpack 相比优势在哪里</h2><p>接下来我们来聊聊，为什么说它是下一代前端开发与构建工具。是不是当代构建工具出了什么问题？</p><p>我们知道当代的前端构建工具有很多，比较受欢迎的有 <code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code>等，绝大多数脚手架工具都是使用 <code>Webpack</code> 作为构建工具，如 <code>Vue-CLI</code>。</p><p>在利用 <code>Webpack</code> 作为构建工具时，开发过程中，每次修改代码，都会导致重新编译，随着项目代码量的增多，热更新的速度也随之变慢，甚至要几秒钟才能看到视图的更新。</p><p>生产环境下，它将各个模块之间通过编码的方式联系在一起，最终生成一个庞大的 <code>bundle</code> 文件。</p><p>导致这些问题出现的原因，有以下几点：</p><p>1、<code>HTTP 1.1</code> 时代，各个浏览器资源请求并发是有上限的（如谷歌浏览器为 6 个，这导致你必须要减少资源请求数）。</p><p>2、浏览器并不支持 <code>CommonJS</code> 模块化系统（它不能直接运行在浏览器环境下，它是 <code>Node</code> 提出的模块化规范，所以需要经过 <code>Webpack</code> 的打包，编译成浏览器可识别的 JS 脚本）</p><p>3、模块与模块之间的依赖顺序和管理问题（文件依赖层级越多，静态资源也就变得越多，如果一个资源有 100 个依赖关系，可能需要加载 100 个网络请求，这对生产环境可能是灾难，所以在生产环境最终会打包成一个 <code>bundle</code> 脚本，会提前进行资源按需加载的配置。）</p><h4 id="那么为什么现在又出现了不打包的构建趋势？"><a href="#那么为什么现在又出现了不打包的构建趋势？" class="headerlink" title="那么为什么现在又出现了不打包的构建趋势？"></a>那么为什么现在又出现了不打包的构建趋势？</h4><p>1、工程越来越庞大，热更新变得缓慢，十分影响开发体验。推动着我们不断地去创新，不断地尝试着去突破瓶颈。</p><p>2、各大浏览器已经开始慢慢的支持原生 <code>ES Module</code> (谷歌、火狐、<code>Safari</code>、<code>Edge</code> 的最新版本，都已支持。这让我们看到了希望)。</p><p>3、<code>HTTP 2.0</code> 采用的多路复用。不用太担心请求并发量的问题。</p><p>4、越来越多的 <code>npm</code> 包开始采用了原生 <code>ESM</code> 的开发形式。虽然还有很多包不支持，但是我相信这将会是趋势。</p><p>我们通过表格的形式，对比一下 <code>bundle</code> 和 <code>bundleless</code> 的区别。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff916f65816b469989198bdc2ec18fd1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="Vite-构建原理"><a href="#Vite-构建原理" class="headerlink" title="Vite 构建原理"></a>Vite 构建原理</h2><p>众所周知，<code>Vite</code> 的生产模式和开发模式是不同的概念。我们先聊聊，<code>Vite</code> 的开发模式。</p><p>首先要明确一点，<code>Vite</code> 在开发模式下，有一个 依赖预构建 的概念。</p><h4 id="什么是依赖预构建"><a href="#什么是依赖预构建" class="headerlink" title="什么是依赖预构建"></a>什么是依赖预构建</h4><p>在 <code>Vite</code> 启动开发服务器之后，它将第三方依赖的多个静态资源整合为一个，比如 <code>lodash</code>、<code>qs</code>、<code>axios</code> 等这类资源包，存入 ·node_modules/.vite 文件下。</p><h4 id="为什么需要依赖预构建"><a href="#为什么需要依赖预构建" class="headerlink" title="为什么需要依赖预构建"></a>为什么需要依赖预构建</h4><p>如果直接采用 <code>ES Module</code> 的形式开发代码，会产生一大串依赖，就好像俄罗斯套娃一样，一层一层的嵌套，在浏览器资源有限的情况下，同时请求大量的静态资源，会造成浏览器的卡顿，并且资源响应的时间也会变慢。</p><p>我们先不通过 <code>Vite</code>，而是手动搭建原生 <code>ES Module</code> 开发形式，通过引入 <code>lodash-es</code> 包，实现一个数组去重的小例子，来详细分析为什么需要依赖预构建。</p><p>新建 <code>test1</code> 文件夹，通过 <code>npm init -y</code> 初始化了一个前端工程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eabc5b637e734347b8e7965496669fee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>手动新建 <code>index.html</code>，通过 <code>script</code> 标签，引入 <code>main.js</code>。这里注意，需要将 <code>type</code> 属性设置为 <code>module</code>，这样才能支持 <code>ES Module</code> 模块化开发。</p><p>通过 <code>npm</code> 安装 <code>lodash-es</code>，这里我们之所以不使用 <code>lodash</code>，是因为 <code>lodash</code> 不是通过 <code>ES Module</code> 形式开发的，直接通过相对路径引入会报错，需要通过 <code>Webpack</code> 打包构建。</p><pre><code class="bash">npm i lodash-es</code></pre><p>新建 <code>main.js</code> 添加去重逻辑：</p><pre><code class="js">import uniq from &quot;./node_modules/lodash-es/uniq.js&quot;;const arr = [1, 2, 3, 3, 4];console.log(uniq(arr));</code></pre><p>这里我们采用 <code>VSCode</code> 的插件，<code>Live Server</code>，来启动项目。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30054fefbeaf485a96db8d4a4d8f5aad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>安装完之后，在项目中双击 <code>index.html</code>，找到右下角的 「Go Live」，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64858bc1bd3e4206a4b996c8ba4f5d74~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击后，自动启动一个 <code>Web</code> 服务，浏览器自动打开，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3858ec887f744781b6c45fadad638c2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>结果正确，数组中的 3 被去除了，接下来关键的一个点，我们点击 <code>Network</code> 查看，资源引入情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b9e60c097184e20a78cb8198968b199~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们只是获取去重方法，却意外引入了 59 资源，这是为什么呢？</p><p>我们先查看 <code>main.js</code> 内的代码，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f001d806817f4ed5a9ad521c9a91a6d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>代码中只有在首行通过 <code>import</code> 引入了 <code>./node_modules/lodash-es/uniq.js</code>，所以 <code>uniq.js</code> 被作为资源引入进来，我们再看 <code>uniq.js</code> 的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b21e238127c47ec8f69b16775b4bb08~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>uniq.js</code> 中，首行通过 <code>import</code> 引入了 <code>_baseUniq.js</code>，我们继续：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6392953fd6b043ea99355687a5569763~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>_baseUniq.js</code> 中，引入了上图箭头中的一些脚本，不用往下看，我盲猜这种俄罗斯套娃的模式，会一直引用到 <code>uniq.js</code> 相关的所有脚本代码。</p><p>这只是一个 <code>uniq</code> 方法，足足就引入了 59 个资源，这仿佛是在军训浏览器，也就是谷歌能跟它博弈几个回合，引入的包再多几个，我估计也是顶不住的。</p><p>所以这时候 <code>Vite</code> 便引入了「依赖预构建」的概念。</p><h4 id="依赖现预构建浅析"><a href="#依赖现预构建浅析" class="headerlink" title="依赖现预构建浅析"></a>依赖现预构建浅析</h4><p>同样的，再通过 <code>Vite</code> 构建出一个 <code>React</code> 项目，去实现上述逻辑，我们观察 <code>Vite</code> 是怎么作的。</p><p>首先通过 <code>Vite</code> 指令生成项目：</p><pre><code class="bash">npm init @vitejs/app test2 --template react</code></pre><p>并安装 <code>lodash-es</code>，修改入口脚本 <code>main.jsx</code>：</p><pre><code class="js">import uniq from &quot;lodash-es/uniq.js&quot;;const arr = [1, 2, 3, 3, 4];console.log(uniq(arr));</code></pre><p>我们观察浏览器的 <code>Network</code>，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce2afc266e84fa79ee8c9a0c0266c85~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>注意上图，执行 <code>npm run dev</code> 后，脚本中引用 <code>lodash-es/uniq</code> 的路径是在 <code>/node_modules/.vite</code> 文件夹下，并且左下角的请求资源数，也没有我们之前原生 <code>ES Module</code> 时的多，少了足足 3/4 还多。</p><p>再观察文件目录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c51aaea93420dac55e3ccca003222~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>lodash-es/uniq</code> 已经被 <code>Vite</code> 提前预编译到了 <code>.vite</code> 文件夹下，这样代码中直接去这个文件夹拿现成的包，就不必再递归地去加载很多静态资源脚本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节，通过实例分析，对 <code>Vite</code> 有了初步的了解。那么下一章节，我将带大家通过 <code>Vite</code> 去搭建一个 <code>React</code> 的完整开发环境。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110、稀土掘金小册-记账本（一） react hooks</title>
      <link href="/2022/12/30/110-react/"/>
      <url>/2022/12/30/110-react/</url>
      
        <content type="html"><![CDATA[<p><code>React</code> 早期的写法以 <code>Class</code> 类组件为主，附带一些纯用于展示的函数组件，但是函数组件是不能控制自身的状态的。</p><p>直到 16.8 版本出来之后，引入了全新的 <code>Hooks</code> 写法，这让之前的类写法就显得 比较累赘，函数组件的写法开始流行起来。函数组件引入了多种钩子函数如 <code>useEffect</code>、<code>useState</code>、<code>useRef</code>、<code>useCallback</code>、<code>useMemo</code>、<code>useReducer</code> 等等，通过这些钩子函数来管理函数组件的各自状态。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本章节我会通过一个请求，带大家入门整个 <code>React Hook</code> 知识体系。首先我们需要创建一个空项目，由于本实验采用的是 <code>Vite 2.0</code> 作为脚手架工具，所以我们的 <code>Node</code> 版本必须要在 <code>12.0.0</code> 以上，目前我的版本是 <code>12.6.0</code>。</p><p>我们通过指令新建一个联手项目，如下所示：</p><pre><code class="bash"># npm 6.xnpm init @vitejs/app hooks-demo --template react# npm 7+, 需要额外的双横线：npm init @vitejs/app hooks-demo -- --template react# yarnyarn create @vitejs/app hooks-demo --template react</code></pre><p>根据你的需求，选择上述三个其中一个。新建之后项目目录如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a994cd755bb34164ba5abff2c88af997~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><pre><code class="bash">npm installnpm run dev</code></pre><p>如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b82ef228cba417bb1f6f910c2406abf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>看到如上述所示代表项目已经启动成功了。</p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>接下来我们清空 <code>App.jsx</code>，添加如下代码：</p><pre><code class="js">import React, &#123; useState &#125; from &quot;react&quot;;function App() &#123;  const [data, setData] = useState([1, 2, 3, 4, 5]);  return (    &lt;div className=&quot;App&quot;&gt;      &#123;data.map((item, index) =&gt; (        &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;      ))&#125;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>函数内声明变量，可以通过 <code>useState</code> 方法，它接受一个参数，可以为默认值，也可以为一个函数。上述我们先分析默认值的情况，默认给一个数组 <code>[1, 2, 3, 4, 5]</code>，<code>data</code> 参数便可以直接在 <code>JSX</code> 模板中使用。</p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>此时，我们通过 <code>useEffect</code> 副作用，请求一个接口数据，如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;// 模拟数据接口，3 秒钟返回数据。const getList = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve([6, 7, 8, 9, 10]);    &#125;, 3000);  &#125;);&#125;;function App() &#123;  const [data, setData] = useState([1, 2, 3, 4, 5]);  useEffect(() =&gt; &#123;    (async () =&gt; &#123;      const data = await getList();      console.log(&quot;data&quot;, data);      setData(data);    &#125;)();  &#125;);  return (    &lt;div className=&quot;App&quot;&gt;      &#123;data.map((item, index) =&gt; (        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;      ))&#125;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>函数组件默认进来之后，会执行 <code>useEffect</code> 中的回调函数，但是当 <code>setData</code> 执行之后，<code>App</code> 组件再次刷新，刷新之后会再次执行 <code>useEffect</code> 的回调函数，这便会形成一个可怕的死循环，回调函数会一直被这样执行下去。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3187ae7425542beb62f3b207e27acb0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>所以这里引出 <code>useEffect</code> 的第二个参数。它是一个数组，数组内接收回调函数内使用到的状态参数，一旦在组件内改变了状态参数，则会触发副作用 <code>useEffect</code> 的回调函数执行。</p><p>所以我们如果传一个空数组 <code>[]</code>，则该副作用只会在组件渲染的时候，执行一次，如下所示：</p><pre><code class="js">useEffect(() =&gt; &#123;  (async () =&gt; &#123;    const data = await getList();    console.log(&quot;data&quot;, data);    setData(data);  &#125;)();&#125;, []);</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1c917ab81e41d19dbbf0ea5d31c4ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>执行一次之后，副作用不再被触发。</p><p>此时我们需要给请求一个 <code>query</code> 参数，如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;const getList = (query) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;query&quot;, query);      resolve([6, 7, 8, 9, 10]);    &#125;, 3000);  &#125;);&#125;;function App() &#123;  const [data, setData] = useState([1, 2, 3, 4, 5]);  const [query, setQuery] = useState(&quot;&quot;);  useEffect(() =&gt; &#123;    (async () =&gt; &#123;      const data = await getList(query);      console.log(&quot;data&quot;, data);      setData(data);    &#125;)();  &#125;, [query]);  return (    &lt;div className=&quot;App&quot;&gt;      &#123;data.map((item, index) =&gt; (        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;      ))&#125;      &lt;input        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入搜索值&quot;      /&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>此时我们改变 <code>query</code> 的值，副作用函数便会被执行，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef93bf033594ba0b2272f59a99e2447~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>所以，如果你的接口有查询参数，可以将参数设置在 <code>useEffect</code> 的第二个参数的数组值中，这样改变查询变量的时候，副作用便会再次触发执行，相应的函数也会重新带着最新的参数，获取接口数据。</p><h4 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h4><p>我们可以将上述的请求，抽离成一个自定义 <code>hook</code>，方便在多个地方调用，新建 <code>useApi.js</code> 如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;// 模拟请求const getList = (query) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;query&quot;, query);      resolve([6, 7, 8, 9, 10]);    &#125;, 3000);  &#125;);&#125;;// 自定义 hookconst useApi = () =&gt; &#123;  const [data, setData] = useState([1, 2, 3, 4, 5]);  const [query, setQuery] = useState(&quot;&quot;);  useEffect(() =&gt; &#123;    (async () =&gt; &#123;      const data = await getList();      console.log(&quot;data&quot;, data);      setData(data);    &#125;)();  &#125;, [query]);  return [&#123; data &#125;, setQuery];&#125;;export default useApi;</code></pre><p>如上述所示，最终将 <code>data</code> 数据，和设置请求参数的方法抛出，在 <code>App.jsx</code> 中做如下改动：</p><pre><code class="js">import React from &quot;react&quot;;import useApi from &quot;./useApi&quot;;function App() &#123;  const [&#123; data &#125;, setQuery] = useApi();  return (    &lt;div className=&quot;App&quot;&gt;      &#123;data.map((item, index) =&gt; (        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;      ))&#125;      &lt;input        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入搜索值&quot;      /&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>我们查看浏览器展示结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae7372c75f23457eb8d114c2bb5d56a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>上述这类自定义 <code>Hook</code> 的使用，在开发中也非常常见，比如有一个请求公共数据的接口，在多个页面中被重复使用，你便可通过自定义 <code>Hook</code> 的形式，将请求逻辑提取出来公用，这也是之前 <code>Class</code> 类组件所不能做到的。</p><h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>我们修改 <code>App.jsx</code>，在内部新增一个子组件，子组件接收父组件传进来的一个对象，作为子组件的 <code>useEffect</code> 的第二个依赖参数。</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;function Child(&#123; data &#125;) &#123;  useEffect(() =&gt; &#123;    console.log(&quot;查询条件：&quot;, data);  &#125;, [data]);  return &lt;div&gt;子组件&lt;/div&gt;;&#125;function App() &#123;  const [name, setName] = useState(&quot;&quot;);  const [phone, setPhone] = useState(&quot;&quot;);  const [kw, setKw] = useState(&quot;&quot;);  const data = &#123;    name,    phone,  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;input        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入姓名&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入电话&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入关键词&quot;      /&gt;      &lt;Child data=&#123;data&#125; /&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>当我们修改姓名和电话的时候，观察子组件是否监听到依赖的变化，执行 <code>useEffect</code> 内的回调函数。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c533fa2d7a44f491734454089b3b84~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时，上述的结果是我们预期的，我们只监听了 <code>name</code> 和 <code>phone</code> 两个参数，但是我们修改关键词输入框，会得到下面的结果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40462facac94aea91209bb5cbc1cedc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>子组件并没有监听 <code>kw</code> 的变化，但是结果却是子组件也被触发渲染了。原因其实是我们在父组件重新 <code>setKw</code> 之后，<code>data</code> 值和未作修改 <code>kw</code> 前的值已经不一样了。你可能会说，<code>data</code> 的值并没有变化，为什么说它已经不一样了呢？详细的分析我们放在后续部分，我们此时可以通过 <code>useMemo</code> 将 <code>data</code> 包装一下，告诉 <code>data</code> 它需要监听的值。</p><pre><code class="js">import React, &#123; useEffect, useState, useMemo &#125; from &quot;react&quot;;function Child(&#123; data &#125;) &#123;  useEffect(() =&gt; &#123;    console.log(&quot;查询条件：&quot;, data);  &#125;, [data]);  return &lt;div&gt;子组件&lt;/div&gt;;&#125;function App() &#123;  const [name, setName] = useState(&quot;&quot;);  const [phone, setPhone] = useState(&quot;&quot;);  const [kw, setKw] = useState(&quot;&quot;);  const data = useMemo(    () =&gt; (&#123;      name,      phone,    &#125;),    [name, phone]  );  return (    &lt;div className=&quot;App&quot;&gt;      &lt;input        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入姓名&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入电话&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入关键词&quot;      /&gt;      &lt;Child data=&#123;data&#125; /&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6a5ab0f6784e8bb1d45a7d2b5eb883~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这便是 <code>useMemo</code> 的作用，它相当于把父组件需要传递的参数做了一个标记，无论父组件其他状态更新任何值，都不会影响要传递给子组件的对象。</p><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>同理，<code>useCallback</code> 也是和 <code>useMemo</code> 有类似的功能，比如我们传递一个函数给子组件，如下所示：</p><pre><code class="js">import React, &#123; useEffect, useState, useCallback &#125; from &quot;react&quot;;function Child(&#123; callback &#125;) &#123;  useEffect(() =&gt; &#123;    callback();  &#125;, [callback]);  return &lt;div&gt;子组件&lt;/div&gt;;&#125;function App() &#123;  const [name, setName] = useState(&quot;&quot;);  const [phone, setPhone] = useState(&quot;&quot;);  const [kw, setKw] = useState(&quot;&quot;);  const callback = () =&gt; &#123;    console.log(&quot;我是callback&quot;);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;input        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入姓名&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入电话&quot;      /&gt;      &lt;input        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;        type=&quot;text&quot;        placeholder=&quot;请输入关键词&quot;      /&gt;      &lt;Child callback=&#123;callback&#125; /&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>当我们修改任何状态值，都会触发子组件的回调函数执行，但是 <code>callback</code> 没有作任何变化。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a9b334d4514959aa7cebe0006257a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>此时，我们给要传递的函数，包裹一层 <code>useCallback</code>，如下所示：</p><pre><code class="js">const callback = useCallback(() =&gt; &#123;  console.log(&quot;我是callback&quot;);&#125;, []);</code></pre><p>无论修改其他任何属性，都不会触发子组件的副作用：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1742b2a340c24cd4b439d17547265e48~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><blockquote><p>useCallback 的第二个参数同 <code>useEffect</code> 和 <code>useMemo</code> 的第二个参数，它是用于监听你需要监听的变量，如在数组内添加 <code>name</code>、<code>phone</code>、<code>kw</code> 等参数，当改变其中有个，都会触发子组件副作用的执行。</p></blockquote><p>所以，<code>useMemo</code> 和 <code>useCallback</code>，都能为「重复渲染」这个问题，提供很好的帮助。</p><h2 id="重新认识-useEffect"><a href="#重新认识-useEffect" class="headerlink" title="重新认识 useEffect"></a>重新认识 useEffect</h2><p>上述很多现象，都是因为你没有很好地去理解 <code>React Hooks</code> 函数组件写法的渲染机制。通过一个小例子，我们来重新认识 <code>useEffect</code>。</p><p>我们将上述 <code>App.jsx</code> 作如下修改：</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;function App() &#123;  const [count, setCount] = useState(0);  const handleClick = () =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + count);    &#125;, 3000);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;展示点击次数&lt;/button&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>我们作下列几个动作：</p><p>1、点击增加按钮两次，将 <code>count</code> 增加到 2。</p><p>2、点击「展示点击次数」。</p><p>3、在 <code>console.log</code> 执行之前，也就是 3 秒内，再次点击新增按钮 2 次，将 <code>count</code> 增加到 4。</p><p>按照正常的思路，浏览器应该打印出 <code>点击次数: 4</code>，我们来查看浏览器的展示效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1975c7d4488e4c9a854606cb4dfa1009~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>点击「展示点击次数」按钮，3 秒后，我们看到的结果是 <code>点击次数: 2</code>，这与我们的预期有出入。</p><p>函数组件 <code>App</code>，在每一次渲染都会被调用，而每一次调用都会形成一个独立的上下文，可以理解成一个快照。每一次渲染形成的快照，都是互相独立的。</p><p>默认进来的时候，形成一个快照，此时 <code>count</code> 为 0；当我们点击新增按钮第一次，执行 <code>setCount</code>，函数组件被刷新一次，此时的快照中，<code>count</code> 为 1；再次点击按钮，再次生成快照，此时的 <code>count</code> 为 2，此时点击 「展示点击次数」按钮，在这份快照中，我们的 <code>count</code> 参数就是 2。所以我们后面无论怎么新增 <code>count</code>，最终输出的结果 <code>count</code> 就是 2。</p><p>我们用一份伪代码来解释，大致如下：</p><pre><code class="js">// 默认初始化function App() &#123;  const count = 0; // useState 返回默认值  // ...  function handleClick() &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + count);    &#125;, 3000);  &#125;  // ...&#125;// 第一次点击function App() &#123;  const count = 1; // useState 返回值  // ...  function handleClick() &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + count);    &#125;, 3000);  &#125;  // ...&#125;// 第二次点击function App() &#123;  const count = 2; // useState 返回值  // ...  function handleAlertClick() &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + count);    &#125;, 3000);  &#125;  // ...&#125;</code></pre><p>上述代码中，第二次点击的快照中，<code>console.log(&#39;点击次数: &#39; + count);</code> 取的便是 <code>const count = 2</code>。</p><p>同理，我们可以直到，每次渲染函数组件时，<code>useEffect</code> 都是新的，都是不一样的。我们对上面的写法稍作改动。</p><pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;function App() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + count);    &#125;, 3000);  &#125;);  return (    &lt;div className=&quot;App&quot;&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bef605a7a9c45f19f950be4e94a0c31~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>每一次点击，都会重新执行 <code>useEffect</code> 内的回调，并且 <code>count</code> 值也是当时的快照的一个常量值。</p><p>这和之前的类组件是不同的，我们改成类组件的实现形式如下：</p><pre><code class="js">import React from &quot;react&quot;;export default class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0,    &#125;;  &#125;  componentDidUpdate() &#123;    setTimeout(() =&gt; &#123;      console.log(&quot;点击次数: &quot; + this.state.count);    &#125;, 3000);  &#125;  render() &#123;    return (      &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;        点击&#123;this.state.count&#125;次      &lt;/button&gt;    );  &#125;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c175d79f67284e59ad4e9794e2ff2355~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>类组件，声明之后，会在内部生成一个实例 <code>instance</code>，所有的数据都会存在类的上下文中，所以 <code>this.state.count</code> 会一直指向最新的 <code>count</code> 值。</p><p>说到这里，大家应该对 <code>React Hooks</code> 的函数组件写法有了新的认识。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>行文至此，希望让同学们能好好地阅读和学习本章节的内容，以及课后对 <code>React Hooks</code> 的拓展。更好的理解它，有助于写出可维护、可拓展的代码，技术本身是服务于业务需求的，但是你不能很好的利用技术的特点，那业务也很难达到做满意的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>109、CSS代码片段：布局、视觉、动画</title>
      <link href="/2022/12/20/109-css/"/>
      <url>/2022/12/20/109-css/</url>
      
        <content type="html"><![CDATA[<p>css 代码片段</p><span id="more"></span><h2 id="一、清除浮动的更好方式-浏览器支持情况：100"><a href="#一、清除浮动的更好方式-浏览器支持情况：100" class="headerlink" title="一、清除浮动的更好方式(浏览器支持情况：100%)"></a>一、清除浮动的更好方式(浏览器支持情况：100%)</h2><pre><code class="html">&lt;div class=&quot;clearfix&quot;&gt;  &lt;div class=&quot;floated&quot;&gt;float a&lt;/div&gt;  &lt;div class=&quot;floated&quot;&gt;float b&lt;/div&gt;  &lt;div class=&quot;floated&quot;&gt;float c&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.clearfix &#123;  border: solid 1px red;&#125;.clearfix::after &#123;  content: &quot;&quot;;  display: block;  clear: both;&#125;.floated &#123;  float: left;  margin-left: 20px;&#125;</code></pre><h2 id="二、不变宽高比"><a href="#二、不变宽高比" class="headerlink" title="二、不变宽高比"></a>二、不变宽高比</h2><p>给定宽度可变的元素，它将确保其高度以响应方式保持成比例（即，其宽高比保持不变）。</p><pre><code class="html">&lt;div class=&quot;constant-width-to-height-ratio&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.constant-width-to-height-ratio &#123;  background: #333;  width: 50%;&#125;.constant-width-to-height-ratio::before &#123;  content: &quot;&quot;;  padding-top: 100%;  float: left;&#125;.constant-width-to-height-ratio::after &#123;  content: &quot;&quot;;  display: block;  clear: both;&#125;</code></pre><p>1、width:50% 只设置父级元素的宽度<br>2、::before 为父级元素定义一个伪元素<br>3、padding-top: 100%; 设置伪元素的内上边距，这里的百分比的值是按照宽度计算的，所以会呈现为一个响应式的元素块。<br>4、此方法还允许将内容正常放置在元素内。</p><h2 id="三、display-table-居中"><a href="#三、display-table-居中" class="headerlink" title="三、display:table 居中"></a>三、display:table 居中</h2><p>使用 display:table 替代 flexbox 使子元素在其父元素中水平垂直居中。</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;center&quot;&gt;&lt;span&gt;Centered content&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container &#123;  border: 1px solid #333;  height: 250px;  width: 250px;&#125;.center &#123;  display: table;  height: 100%;  width: 100%;&#125;.center &gt; span &#123;  display: table-cell;  text-align: center;  vertical-align: middle;&#125;</code></pre><p>display：table 使.center 元素的行为类似于<code>&lt;table&gt;</code> HTML 元素;<br>设置.center 的宽高为 100%，使其填满父元素;<br>display：table-cell, 设置’.center &gt; span’的 table-cell 允许元素表现得像 HTML 元素;<br>text-align: center 使子元素水平居中;<br>vertical-align: middle 使子元素垂直居中;</p><p>外部父级必须有固定的宽高。</p><h2 id="四、子元素均匀分布"><a href="#四、子元素均匀分布" class="headerlink" title="四、子元素均匀分布"></a>四、子元素均匀分布</h2><pre><code class="html">&lt;div class=&quot;evenly-distributed-children&quot;&gt;  &lt;p&gt;Item1&lt;/p&gt;  &lt;p&gt;Item2&lt;/p&gt;  &lt;p&gt;Item3&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">.evenly-distributed-children &#123;  display: flex;  justify-content: space-between;&#125;</code></pre><p>display: flex :启动 flex 布局</p><p>justify-content: space-between：</p><p>均匀地水平分配子元素。 第一个子元素位于左边缘，而最后一个子元素位于右边缘。 或者，使用 justify-content：space-around 来分配子节点周围的空间，而不是它们之间。</p><h2 id="五、图片在容器中显示的更舒适"><a href="#五、图片在容器中显示的更舒适" class="headerlink" title="五、图片在容器中显示的更舒适"></a>五、图片在容器中显示的更舒适</h2><pre><code class="html">&lt;img class=&quot;image image-contain&quot; src=&quot;https://picsum.photos/600/200&quot; /&gt;&lt;img class=&quot;image image-cover&quot; src=&quot;https://picsum.photos/600/200&quot; /&gt;</code></pre><pre><code class="css">.image &#123;  background: #34495e;  border: 1px solid #34495e;  width: 200px;  height: 200px;&#125;.image-contain &#123;  object-fit: contain;  object-position: center;&#125;.image-cover &#123;  object-fit: cover;  object-position: right top;&#125;</code></pre><p>object-fit: contain 容器内显示整个图像，并且保持宽高比<br>object-fit: cover 用图像填充容器，并保持宽高比<br>object-position: [x] [y] 对图像的显示部位进行调整</p><h2 id="六、flexbox-居中-常用"><a href="#六、flexbox-居中-常用" class="headerlink" title="六、flexbox 居中(常用)"></a>六、flexbox 居中(常用)</h2><pre><code class="html">&lt;div class=&quot;flexbox-centering&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content.&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.flexbox-centering &#123;  display: flex;  justify-content: center;  align-items: center;  height: 100px;&#125;</code></pre><p>display: flex 启用 flex 局部<br>justify-content: center 子元素水平居中<br>align-items: center 子元素垂直居中</p><h2 id="七、将元素垂直居中于另一个元素"><a href="#七、将元素垂直居中于另一个元素" class="headerlink" title="七、将元素垂直居中于另一个元素"></a>七、将元素垂直居中于另一个元素</h2><pre><code class="html">&lt;div class=&quot;ghost-trick&quot;&gt;  &lt;div class=&quot;ghosting&quot;&gt;    &lt;p&gt;Vertically centered without changing the position property.&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.ghosting &#123;  height: 300px;  background: #0ff;&#125;.ghosting:before &#123;  content: &quot;&quot;;  display: inline-block;  height: 100%;  vertical-align: middle;&#125;p &#123;  display: inline-block;  vertical-align: middle;&#125;</code></pre><p>使用 ：before 伪元素的样式垂直对齐内联元素而不更改其 position 属性。</p><h2 id="八、grid-居中"><a href="#八、grid-居中" class="headerlink" title="八、grid 居中"></a>八、grid 居中</h2><pre><code class="html">&lt;div class=&quot;grid-centering&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content.&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.grid-centering &#123;  display: grid;  justify-content: center;  align-items: center;  height: 100px;&#125;</code></pre><p>display: grid 启用网格布局<br>justify-content: center 使子元素水平居中<br>align-items: center 使子元素垂直居中</p><h2 id="九、使最后一项占满剩余高度"><a href="#九、使最后一项占满剩余高度" class="headerlink" title="九、使最后一项占满剩余高度"></a>九、使最后一项占满剩余高度</h2><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div&gt;Div 1&lt;/div&gt;  &lt;div&gt;Div 2&lt;/div&gt;  &lt;div&gt;Div 3&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">html,body &#123;  height: 100%;  margin: 0;&#125;.container &#123;  height: 100%;  display: flex;  flex-direction: column;&#125;.container &gt; div:last-child &#123;  background-color: tomato;  flex: 1;&#125;</code></pre><p>height: 100% 将容器的高度设为视口的高度<br>display: flex 启用 flex<br>flex-direction: column 将项目的顺序设置成从上到下<br>flex-grow: 1 flexbox 会将容器的剩余可用空间应用于最后一个子元素。 父级必须具有视口高度。 flex-grow：1 可以应用于第一个或第二个元素，它将具有所有可用空间。</p><h2 id="十、屏外隐藏元素"><a href="#十、屏外隐藏元素" class="headerlink" title="十、屏外隐藏元素"></a>十、屏外隐藏元素</h2><pre><code class="html">&lt;a class=&quot;button&quot; href=&quot;https://www.baidu.com&quot;&gt;  Learn More &lt;span class=&quot;offscreen&quot;&gt; about baidu&lt;/span&gt;&lt;/a&gt;</code></pre><pre><code class="css">.offscreen &#123;  border: 0;  clip: rect(0 0 0 0);  height: 1px;  margin: -1px;  overflow: hidden;  padding: 0;  position: absolute;  width: 1px;&#125;</code></pre><p>删除所有边框<br>使用 clip 隐藏元素<br>设置宽高为 1px<br>使用 margin：-1px 取消元素的高度和宽度<br>隐藏元素的溢出<br>移除所有的 padding<br>绝对定位元素，使其不占用 DOM 中的空间</p><h2 id="十一、transform-居中子元素"><a href="#十一、transform-居中子元素" class="headerlink" title="十一、transform 居中子元素"></a>十一、transform 居中子元素</h2><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;child&quot;&gt;Centered content&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent &#123;  border: 1px solid #333;  height: 250px;  position: relative;  width: 250px;&#125;.child &#123;  left: 50%;  position: absolute;  top: 50%;  transform: translate(-50%, -50%);  text-align: center;&#125;</code></pre><h2 id="十二、多行文本截断显示"><a href="#十二、多行文本截断显示" class="headerlink" title="十二、多行文本截断显示"></a>十二、多行文本截断显示</h2><pre><code class="html">&lt;p class=&quot;truncate-text-multiline&quot;&gt;  Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy  eirmod tempor invidunt ut labore et.&lt;/p&gt;</code></pre><pre><code class="css">.truncate-text-multiline &#123;  overflow: hidden;  display: block;  height: 109.2px;  margin: 0 auto;  font-size: 26px;  line-height: 1.4;  width: 400px;  position: relative;&#125;.truncate-text-multiline:after &#123;  content: &quot;&quot;;  position: absolute;  bottom: 0;  right: 0;  width: 150px;  height: 36.4px;  background: linear-gradient(to right, rgba(0, 0, 0, 0), #f5f6f9 50%);&#125;</code></pre><p>overflow: hidden 防止内容溢出<br>width: 400px 确保元素有尺寸<br>height: 109.2px 计算的高度值，它等于 font-size <em>line-height</em> numberOfLines（在这种情况下为 26 <em>1.4</em> 3 = 109.2）<br>height: 36.4px 渐变容器的计算值，它等于 font-size <em>line-height（在这种情况下为 26</em> 1.4 = 36.4）<br>background: linear-gradient(to right, rgba(0, 0, 0, 0), #f5f6f9 50% 渐变从 透明到渐变从透明到＃f5f6f9</p><h2 id="十三、CSS-列表计数器"><a href="#十三、CSS-列表计数器" class="headerlink" title="十三、CSS 列表计数器"></a>十三、CSS 列表计数器</h2><pre><code class="html">&lt;ul&gt;  &lt;li&gt;List item&lt;/li&gt;  &lt;li&gt;List item&lt;/li&gt;  &lt;li&gt;    List item    &lt;ul&gt;      &lt;li&gt;List item&lt;/li&gt;      &lt;li&gt;List item&lt;/li&gt;      &lt;li&gt;List item&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="css">ul &#123;  counter-reset: counter;&#125;li::before &#123;  counter-increment: counter;  content: counters(counter, &quot;.&quot;) &quot; &quot;;&#125;</code></pre><p>counter-reset 初始化计数器，该值是计数器的名称。默认情况下，计数器从 0 开始。此属性还可用于将其值更改为任何特定数字。<br>counter-increment 用于可数的元素。 一旦计数器重置初始化，计数器的值可以增加或减少。<br>counter(name, style)显示节计数器的值。通常用于内容属性。此函数可以接收两个参数，第一个作为计数器的名称，第二个参数表示占位内容，例如 3.1 的小数点。<br>CSS 计数器对于制作轮廓列表特别有用，因为计数器的新实例是在子元素中自动创建的。使用 counters（）函数，可以在不同级别的嵌套计数器之间插入分隔文本。</p><h2 id="十四、自定义滚动条"><a href="#十四、自定义滚动条" class="headerlink" title="十四、自定义滚动条"></a>十四、自定义滚动条</h2><pre><code class="html">&lt;div class=&quot;custom-scrollbar&quot;&gt;  &lt;p&gt;    Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;br /&gt;    Iure id exercitationem nulla qui repellat laborum vitae, &lt;br /&gt;    molestias tempora velit natus. Quas, assumenda nisi. &lt;br /&gt;    Quisquam enim qui iure, consequatur velit sit?  &lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">.custom-scrollbar &#123;  height: 70px;  overflow-y: scroll;&#125;/* To style the document scrollbar, remove `.custom-scrollbar` */.custom-scrollbar::-webkit-scrollbar &#123;  width: 8px;&#125;.custom-scrollbar::-webkit-scrollbar-track &#123;  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);  border-radius: 10px;&#125;.custom-scrollbar::-webkit-scrollbar-thumb &#123;  border-radius: 10px;  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);&#125;</code></pre><h2 id="十五、自定义文本选择的样式"><a href="#十五、自定义文本选择的样式" class="headerlink" title="十五、自定义文本选择的样式"></a>十五、自定义文本选择的样式</h2><pre><code class="html">&lt;p class=&quot;custom-text-selection&quot;&gt;Select some of this text.&lt;/p&gt;</code></pre><pre><code class="css">::selection &#123;  background: aquamarine;  color: black;&#125;.custom-text-selection::selection &#123;  background: deeppink;  color: white;&#125;</code></pre><h2 id="十六、Focus-Within-伪类"><a href="#十六、Focus-Within-伪类" class="headerlink" title="十六、Focus Within 伪类"></a>十六、Focus Within 伪类</h2><pre><code class="html">&lt;div class=&quot;focus-within&quot;&gt;  &lt;form&gt;    &lt;label for=&quot;given_name&quot;&gt;Given Name:&lt;/label&gt;    &lt;input id=&quot;given_name&quot; type=&quot;text&quot; /&gt; &lt;br /&gt;    &lt;label for=&quot;family_name&quot;&gt;Family Name:&lt;/label&gt;    &lt;input id=&quot;family_name&quot; type=&quot;text&quot; /&gt;  &lt;/form&gt;&lt;/div&gt;</code></pre><pre><code class="css">form &#123;  border: 3px solid #2d98da;  color: #000000;  padding: 4px;&#125;form:focus-within &#123;  background: #f7b731;  color: #000000;&#125;</code></pre><p>伪类：：focus-within 将对应的样式应用于父元素（任何子元素被聚焦）。 例如，表单元素内的输入元素。</p><h2 id="十七、指定元素的全屏"><a href="#十七、指定元素的全屏" class="headerlink" title="十七、指定元素的全屏"></a>十七、指定元素的全屏</h2><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;p&gt;    &lt;em&gt;Click the button below to enter the element into fullscreen mode. &lt;/em&gt;  &lt;/p&gt;  &lt;div class=&quot;element&quot; id=&quot;element&quot;&gt;    &lt;p&gt;I change color in fullscreen mode!&lt;/p&gt;  &lt;/div&gt;  &lt;br /&gt;  &lt;button    onclick=&quot;var el = document.getElementById(&#39;element&#39;); el.requestFullscreen();&quot;  &gt;    Go Full Screen!  &lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container &#123;  margin: 40px auto;  max-width: 700px;&#125;.element &#123;  padding: 20px;  height: 300px;  width: 100%;  background-color: skyblue;&#125;.element p &#123;  text-align: center;  color: white;  font-size: 3em;&#125;.element:-ms-fullscreen p &#123;  visibility: visible;&#125;.element:fullscreen &#123;  background-color: #e4708a;  width: 100vw;  height: 100vh;&#125;</code></pre><p>:fullscreen 伪类选择器用于选择和设置以全屏模式显示的元素。</p><h2 id="十八、：not-伪类选择器"><a href="#十八、：not-伪类选择器" class="headerlink" title="十八、：not 伪类选择器"></a>十八、：not 伪类选择器</h2><pre><code class="html">&lt;ul class=&quot;css-not-selector-shortcut&quot;&gt;  &lt;li&gt;One&lt;/li&gt;  &lt;li&gt;Two&lt;/li&gt;  &lt;li&gt;Three&lt;/li&gt;  &lt;li&gt;Four&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="css">.css-not-selector-shortcut &#123;  display: flex;&#125;ul &#123;  padding-left: 0;&#125;li &#123;  list-style-type: none;  margin: 0;  padding: 0 0.75rem;&#125;li:not(:last-child) &#123;  border-right: 2px solid #d2d5e4;&#125;</code></pre><p>li:not(:last-child) 设置除 last：child 之外的所有 li 元素的样式，所以最后一个元素右侧没有 border.</p><h2 id="十九、斑马条纹列表"><a href="#十九、斑马条纹列表" class="headerlink" title="十九、斑马条纹列表"></a>十九、斑马条纹列表</h2><pre><code class="html">&lt;ul&gt;  &lt;li&gt;Item 01&lt;/li&gt;  &lt;li&gt;Item 02&lt;/li&gt;  &lt;li&gt;Item 03&lt;/li&gt;  &lt;li&gt;Item 04&lt;/li&gt;  &lt;li&gt;Item 05&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="css">li:nth-child(odd) &#123;  background-color: #eee;&#125;</code></pre><h2 id="二十、弹跳-loading-动画"><a href="#二十、弹跳-loading-动画" class="headerlink" title="二十、弹跳 loading 动画"></a>二十、弹跳 loading 动画</h2><pre><code class="html">&lt;div class=&quot;bouncing-loader&quot;&gt;  &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">@keyframes bouncing-loader &#123;  to &#123;    opacity: 0.1;    transform: translate3d(0, -1rem, 0);  &#125;&#125;.bouncing-loader &#123;  display: flex;  justify-content: center;&#125;.bouncing-loader &gt; div &#123;  width: 1rem;  height: 1rem;  margin: 3rem 0.2rem;  background: #8385aa;  border-radius: 50%;  animation: bouncing-loader 0.6s infinite alternate;&#125;.bouncing-loader &gt; div:nth-child(2) &#123;  animation-delay: 0.2s;&#125;.bouncing-loader &gt; div:nth-child(3) &#123;  animation-delay: 0.4s;&#125;</code></pre><h2 id="二十一、按钮边框动画"><a href="#二十一、按钮边框动画" class="headerlink" title="二十一、按钮边框动画"></a>二十一、按钮边框动画</h2><pre><code class="html">&lt;div class=&quot;button-border&quot;&gt;&lt;button class=&quot;button&quot;&gt;Submit&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="css">.button &#123;  background-color: #c47135;  border: none;  color: #ffffff;  outline: none;  padding: 12px 40px 10px;  position: relative;&#125;.button:before,.button:after &#123;  border: 0 solid transparent;  transition: all 0.25s;  content: &quot;&quot;;  height: 24px;  position: absolute;  width: 24px;&#125;.button:before &#123;  border-top: 2px solid #c47135;  left: 0px;  top: -5px;&#125;.button:after &#123;  border-bottom: 2px solid #c47135;  bottom: -5px;  right: 0px;&#125;.button:hover &#123;  background-color: #c47135;&#125;.button:hover:before,.button:hover:after &#123;  height: 100%;  width: 100%;&#125;</code></pre><p>before 和：after 伪元素作为在悬停时设置动画的边框。</p><h2 id="二十二、高度过度"><a href="#二十二、高度过度" class="headerlink" title="二十二、高度过度"></a>二十二、高度过度</h2><pre><code class="html">&lt;div class=&quot;trigger&quot;&gt;  Hover me to see a height transition.  &lt;div class=&quot;el&quot;&gt;content&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.el &#123;  transition: max-height 0.5s;  overflow: hidden;  max-height: 0;&#125;.trigger:hover &gt; .el &#123;  max-height: var(--max-height);&#125;</code></pre><h2 id="二十三、悬停阴影动画"><a href="#二十三、悬停阴影动画" class="headerlink" title="二十三、悬停阴影动画"></a>二十三、悬停阴影动画</h2><pre><code class="html">&lt;p class=&quot;hover-shadow-box-animation&quot;&gt;Box it!&lt;/p&gt;</code></pre><pre><code class="css">.hover-shadow-box-animation &#123;  display: inline-block;  vertical-align: middle;  transform: perspective(1px) translateZ(0);  box-shadow: 0 0 1px transparent;  margin: 10px;  transition-duration: 0.3s;  transition-property: box-shadow, transform;&#125;.hover-shadow-box-animation:hover,.hover-shadow-box-animation:focus,.hover-shadow-box-animation:active &#123;  box-shadow: 1px 10px 10px -10px rgba(0, 0, 24, 0.5);  transform: scale(1.2);&#125;</code></pre><h2 id="二十四、悬停下划线动画"><a href="#二十四、悬停下划线动画" class="headerlink" title="二十四、悬停下划线动画"></a>二十四、悬停下划线动画</h2><pre><code class="html">&lt;p class=&quot;hover-underline-box-animation&quot;&gt;Box it!&lt;/p&gt;</code></pre><pre><code class="css">.hover-underline-animation &#123;  display: inline-block;  position: relative;  color: #0087ca;&#125;.hover-underline-animation::after &#123;  content: &quot;&quot;;  position: absolute;  width: 100%;  transform: scaleX(0);  height: 2px;  bottom: 0;  left: 0;  background-color: #0087ca;  transform-origin: bottom right;  transition: transform 0.25s ease-out;&#125;.hover-underline-animation:hover::after &#123;  transform: scaleX(1);  transform-origin: bottom left;&#125;</code></pre><p>display: inline-block 使 p 成为内联块，以防止下划线跨越整行宽度而不仅仅是文本内容。<br>position: relative 设置父元素为相对定位<br>::after 定义一个伪元素<br>position: absolute 将伪元素脱离文档六，并将其相对于父元素定位<br>width: 100% 确保伪元素和父元素的宽度一致。<br>transform: scaleX(0) 最初将伪元素缩放为 0，因此他是看不见的。<br>bottom: 0 and left: 0 将伪元素放在父元素的左下角。<br>transition: transform 0.25s ease-out 设置动画效果为 ease-out,并且在 0.25 秒内完成。<br>transform-origin: bottom right 变换中心点到父元素的右下角。<br>:hover::after 然后使用 scaleX（1）将宽度转换为 100％，然后将中心点更改为左下角，允许它在悬停时从另一个方向转换出来。</p><h2 id="二十五、弹出菜单"><a href="#二十五、弹出菜单" class="headerlink" title="二十五、弹出菜单"></a>二十五、弹出菜单</h2><pre><code class="html">&lt;div class=&quot;reference&quot; tabindex=&quot;0&quot;&gt;  &lt;div class=&quot;popout-menu&quot;&gt;Popout menu&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.reference &#123;  position: relative;  background: tomato;  width: 100px;  height: 100px;&#125;.popout-menu &#123;  position: absolute;  visibility: hidden;  left: 100%;  background: #333;  color: white;  padding: 15px;&#125;.reference:hover &gt; .popout-menu,.reference:focus &gt; .popout-menu,.reference:focus-within &gt; .popout-menu &#123;  visibility: visible;&#125;</code></pre><p>left: 100% 弹出菜单从左侧偏移其父级宽度的 100％。<br>visibility: hidden<br>.reference:hover &gt; .popout-menu 鼠标悬停时，.popout-menu 显示<br>.reference:focus &gt; .popout-menu 聚焦时，.popout-menu 显示<br>.reference:focus-within &gt; .popout-menu 确保在焦点位于参考范围内时显示弹出窗口。</p><h2 id="二十六、悬停时，兄弟元素淡化"><a href="#二十六、悬停时，兄弟元素淡化" class="headerlink" title="二十六、悬停时，兄弟元素淡化"></a>二十六、悬停时，兄弟元素淡化</h2><pre><code class="html">&lt;div class=&quot;sibling-fade&quot;&gt;  &lt;span&gt;Item 1&lt;/span&gt; &lt;span&gt;Item 2&lt;/span&gt; &lt;span&gt;Item 3&lt;/span&gt;  &lt;span&gt;Item 4&lt;/span&gt; &lt;span&gt;Item 5&lt;/span&gt; &lt;span&gt;Item 6&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="css">span &#123;  padding: 0 1rem;  transition: opacity 0.2s;&#125;.sibling-fade:hover span:not(:hover) &#123;  opacity: 0.5;&#125;</code></pre><p>transition: opacity 0.2s 设置 0.2 秒的淡化动画。<br>.sibling-fade:hover span:not(:hover)当父级悬停时，选择当前未悬停的 span 子项并将其透明度更改为 0.5。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108、web components和vue+web components</title>
      <link href="/2022/12/15/108-vue3/"/>
      <url>/2022/12/15/108-vue3/</url>
      
        <content type="html"><![CDATA[<p>Web Components 提供了基于原生支持的、对视图层的封装能力，可以让单个组件相关的 javaScript、css、html 模板运行在以 html 标签为界限的局部环境中，不会影响到全局，组件间也不会相互影响 。 再简单来说：就是提供了我们自定义标签的能力，并且提供了标签内完整的生命周期 。</p><span id="more"></span><p>Custom elements（自定义元素）：JavaScript API，允许定义 custom elements 及其行为，然后可以在我们的用户界面中按照需要使用它们。</p><p>Shadow DOM（影子 DOM）：JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，开发者可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</p><p>HTML templates（HTML 模板）：和元素使开发者可以编写与 HTML 结构类似的组件和样式。然后它们可以作为自定义元素结构的基础被多次重用。</p><h2 id="一、web-components-示例："><a href="#一、web-components-示例：" class="headerlink" title="一、web components 示例："></a>一、web components 示例：</h2><p>btn.js</p><pre><code class="js">class Btn extends HTMLElement &#123;  constructor() &#123;    super();    const shadowDom = this.attachShadow(&#123; mode: &quot;open&quot; &#125;);    this.p = this.h(&quot;p&quot;);    this.p.innerText = &quot;jude&quot;;    this.p.setAttribute(      &quot;style&quot;,      &quot;width:100px;height:100px;border:1px solid #999;background:yellowgreen&quot;    );    shadowDom.appendChild(this.p);    // tempalte    this.template = this.h(&quot;template&quot;);    this.template.innerHTML = `      &lt;style&gt;        div&#123;          width:50px;          height:50px;          background:green;        &#125;      &lt;/style&gt;      &lt;div&gt;      我是template,上面的样式会被隔离      &lt;/div&gt;`;    shadowDom.appendChild(this.template.content.cloneNode(true));  &#125;  h(el) &#123;    return document.createElement(el);  &#125;  // 生命周期  // 当自定义元素第一次被连接到文档DOM时被调用  connectedCallback() &#123;    console.log(&quot;连接调用&quot;);  &#125;  // 当自定义元素与文档DOM断开连接时被调用  disconnectedCallback() &#123;    console.log(&quot;断开调用&quot;);  &#125;  // 当自定义元素被移动到新文档时被调用  adoptedCallback() &#123;    console.log(&quot;移动时调用&quot;);  &#125;  // 当自定义元素的第一个属性被增加、移除或者更改时被调用  attributeChangedCallback(attrName, oldVal, newVal) &#123;    console.log(&quot;改变调用&quot;, attrName, oldVal, newVal);  &#125;&#125;window.customElements.define(&quot;yu-btn&quot;, Btn);</code></pre><blockquote><p>这里存在一个问题，如果使用 window.customElements.define(“btn”, Btn)，会报错：Uncaught DOMException: Failed to execute ‘define’ on ‘CustomElementRegistry’: “btn” is not a valid custom element name,修改一下 name 即可</p></blockquote><p>index.html</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;./btn.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;yu-btn&gt;&lt;/yu-btn&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="二、vue-使用自定义组件"><a href="#二、vue-使用自定义组件" class="headerlink" title="二、vue 使用自定义组件"></a>二、vue 使用自定义组件</h2><p>defineCustomElement</p><p>首先需要告知 vue 这是一个自定义组件，跳过组件检查</p><pre><code class="ts">/*vite config ts 配置*/vue(&#123;  template: &#123;    compilerOptions: &#123;      isCustomElement: (tag) =&gt; tag.includes(&quot;yu-&quot;),    &#125;,  &#125;,&#125;);</code></pre><p>父组件：</p><blockquote><p>这里需要注意，传递参数 如果是对象需要序列化 他是作用于 标签上的</p></blockquote><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;yu-btn :title=&quot;JSON.stringify(name)&quot;&gt;&lt;/yu-btn&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, defineCustomElement &#125; from &quot;vue&quot;;//自定义元素模式  要开启这个模式，只需要将你的组件文件以 .ce.vue 结尾即可import customVueVue from &quot;./components/custom-vue.ce.vue&quot;;const Btn = defineCustomElement(customVueVue);customElements.define(&quot;yu-btn&quot;, Btn);const name = ref(&#123; a: 1 &#125;);&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;</code></pre><p>子组件：</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;title: &#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive &#125; from &quot;vue&quot;;defineProps&lt;&#123;  title: string;&#125;&gt;();&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107、Mac的MySQL无法启动</title>
      <link href="/2022/12/13/107-mysql/"/>
      <url>/2022/12/13/107-mysql/</url>
      
        <content type="html"><![CDATA[<p>安装好 MySQL 之后，在 Mac 的系统设置 最下方会新增一个 MySQL,点击之后，会出现 MySQL 的版本号:MySQL 8.0.32,点击 start MySQL Server,仍然无法启动。</p><span id="more"></span><p>解决方法：</p><pre><code class="shell">sudo chown -R mysql /usr/local/mysql/datasudo /usr/local/mysql/support-files/mysql.server start// 会出现success  MySQL启动成功</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106、ref小技巧</title>
      <link href="/2022/12/12/106.ref/"/>
      <url>/2022/12/12/106.ref/</url>
      
        <content type="html"><![CDATA[<p>使用 console.log 输出一个 ref 对象时，控制台查看结果时很不方便，Chrome 浏览器对此有一个格式化的处理。</p><span id="more"></span><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><pre><code class="js">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#39;vue&#39;const str = ref&lt;string&gt;(&#39;jude&#39;)console.log(&#39;str&#39;,str)&lt;/script&gt;</code></pre><p>控制台打印结果为</p><pre><code>RefImp&#123;  dep:undefined  __v_isRef:true  __v_isShallow:false  _rawValue:&#39;jude&#39;  _value:&#39;jude&#39;  value:&#39;jude&#39;&#125;</code></pre><p>点击控制台右上角设置按钮 — 偏好设置 — 启动自定义格式设置工具，此时控制台的打印结果就很明显了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105、typescript函数Class类型：函数重载和面向对象(三)</title>
      <link href="/2022/12/10/105-ts/"/>
      <url>/2022/12/10/105-ts/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：<strong>函数</strong>。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。</p><p>介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如<strong>重载</strong>与<strong>面向对象的编程</strong>等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的类型签名"><a href="#函数的类型签名" class="headerlink" title="函数的类型签名"></a>函数的类型签名</h3><p>如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了<strong>函数入参类型与函数返回值类型</strong>，它们同样使用<code>:</code>的语法进行类型标注。我们直接看最简单的例子：</p><pre><code class="typescript">function foo(name: string): number &#123;  return name.length;&#125;</code></pre><p>在函数类型中同样存在着类型推导。比如在这个例子中，你可以不写返回值处的类型，它也能被正确推导为 number 类型。</p><p>在 JavaScript 中，我们称 <code>function name () &#123;&#125;</code> 这一声明函数的方式为<strong>函数声明（*Function Declaration*）</strong>。除了函数声明以外，我们还可以通过<strong>函数表达式（*Function Expression*）</strong>，即 <code>const foo = function()&#123;&#125;</code> 的形式声明一个函数。在表达式中进行类型声明的方式是这样的：</p><pre><code class="typescript">const foo = function (name: string): number &#123;  return name.length;&#125;;</code></pre><p>我们也可以像对变量进行类型标注那样，对 <code>foo</code> 这个变量进行类型声明：</p><pre><code class="typescript">const foo: (name: string) =&gt; number = function (name) &#123;  return name.length;&#125;;</code></pre><p>这里的 <code>(name: string) =&gt; number</code> 看起来很眼熟，对吧？它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 TypeScript 中的<strong>函数类型签名</strong>。而实际的箭头函数，我们的类型标注也是类似的：</p><pre><code class="typescript">// 方式一const foo = (name: string): number =&gt; &#123;  return name.length;&#125;;// 方式二const foo: (name: string) =&gt; number = (name) =&gt; &#123;  return name.length;&#125;;</code></pre><p>在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性会非常差。因此，一般不推荐这么使用，要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>：</p><pre><code class="typescript">type FuncFoo = (name: string) =&gt; number;const foo: FuncFoo = (name) =&gt; &#123;  return name.length;&#125;;</code></pre><p>如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：</p><pre><code class="typescript">interface FuncFooStruct &#123;  (name: string): number;&#125;</code></pre><p>这时的 interface 被称为 <strong>Callable Interface</strong>，看起来可能很奇怪，但我们可以这么认为，interface 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型罢了。</p><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。</p><pre><code class="typescript">// 没有调用 return 语句function foo(): void &#123;&#125;// 调用了 return 语句，但没有返回值function bar(): void &#123;  return;&#125;</code></pre><p>原因和我们在原始类型与对象类型一节中讲到的：<strong>在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。</strong> 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数<strong>没有进行返回操作</strong>。但在上面的第二个例子中，其实更好的方式是使用 undefined ：</p><pre><code class="typescript">function bar(): undefined &#123;  return;&#125;</code></pre><p>此时我们想表达的则是，这个函数<strong>进行了返回操作，但没有返回实际的值</strong>。</p><h3 id="可选参数与-rest-参数"><a href="#可选参数与-rest-参数" class="headerlink" title="可选参数与 rest 参数"></a>可选参数与 rest 参数</h3><p>在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 <code>?</code> 描述一个可选属性一样，在函数类型中我们也使用 <code>?</code> 描述一个可选参数：</p><pre><code class="typescript">// 在函数逻辑中注入可选参数默认值function foo1(name: string, age?: number): number &#123;  const inputAge = age || 18; // 或使用 age ?? 18  return name.length + inputAge;&#125;// 直接为可选参数声明默认值function foo2(name: string, age: number = 18): number &#123;  const inputAge = age;  return name.length + inputAge;&#125;</code></pre><p>需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。毕竟在 JavaScript 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用 <code>?</code> 了，因为既然都有默认值，那肯定是可选参数啦。</p><pre><code class="typescript">function foo(name: string, age: number = 18): number &#123;  const inputAge = age || 18;  return name.length + inputAge;&#125;</code></pre><p>在某些情况下，这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。</p><p>对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：</p><blockquote><p>对于 any 类型，你可以简单理解为它包含了一切可能的类型，我们会在下一节详细介绍。</p></blockquote><pre><code class="typescript">function foo(arg1: string, ...rest: any[]) &#123;&#125;</code></pre><p>当然，你也可以使用我们前面学习的元祖类型进行标注：</p><pre><code class="typescript">function foo(arg1: string, ...rest: [number, boolean]) &#123;&#125;foo(&quot;linbudu&quot;, 18, true);</code></pre><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</p><pre><code class="typescript">function func(foo: number, bar?: boolean): string | number &#123;  if (bar) &#123;    return String(foo);  &#125; else &#123;    return foo * 599;  &#125;&#125;</code></pre><p>在这个实例中，函数的返回类型基于其入参 <code>bar</code> 的值，并且从其内部逻辑中我们知道，当 <code>bar</code> 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。</p><p>要想实现与入参关联的返回值类型，我们可以使用 TypeScript 提供的<strong>函数重载签名（*Overload Signature*）</strong>，将以上的例子使用重载改写：</p><pre><code class="typescript">function func(foo: number, bar: true): string;function func(foo: number, bar?: false): number;function func(foo: number, bar?: boolean): string | number &#123;  if (bar) &#123;    return String(foo);  &#125; else &#123;    return foo * 599;  &#125;&#125;const res1 = func(599); // numberconst res2 = func(599, true); // stringconst res3 = func(599, false); // number</code></pre><p>这里我们的三个 <code>function func</code> 其实具有不同的意义：</p><ul><li><code>function func(foo: number, bar: true): string</code>，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。</li><li><code>function func(foo: number, bar?: false): number</code>，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。</li><li><code>function func(foo: number, bar?: boolean): string | number</code>，函数的实现签名，会包含重载签名的所有可能情况。</li></ul><p>基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。</p><p>这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。</p><blockquote><p>你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。</p></blockquote><p>实际上，TypeScript 中的重载更像是伪重载，<strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。而在如 C++ 等语言中，重载体现在多个<strong>名称一致但入参不同的函数实现上</strong>，这才是更广义上的函数重载。</p><h3 id="异步函数、Generator-函数等类型签名"><a href="#异步函数、Generator-函数等类型签名" class="headerlink" title="异步函数、Generator 函数等类型签名"></a>异步函数、Generator 函数等类型签名</h3><p>对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：</p><pre><code class="typescript">async function asyncFunc(): Promise&lt;void&gt; &#123;&#125;function* genFunc(): Iterable&lt;void&gt; &#123;&#125;async function* asyncGenFunc(): AsyncIterable&lt;void&gt; &#123;&#125;</code></pre><p>其中，Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。而对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 <code>Promise&lt;T&gt;</code>（关于泛型我们会在后面进行详细了解）。</p><p>在函数这一节中，我们主要关注函数的类型标注。因为 TypeScript 中的函数实际上相比 JavaScript 也只是多在重载这一点上，我们需要着重掌握的仍然是类型标注。但在 Class 中，我们的学习重点其实更侧重于其语法与面向对象的编程理念。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="类与类成员的类型签名"><a href="#类与类成员的类型签名" class="headerlink" title="类与类成员的类型签名"></a>类与类成员的类型签名</h3><p>一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有<strong>构造函数</strong>、<strong>属性</strong>、<strong>方法</strong>和<strong>访问符（*Accessor*）</strong>，我们也只需要关注这三个部分即可。这里我要说明一点，有的同学可能认为装饰器也是 Class 的结构，但我个人认为它并不是 Class 携带的逻辑，不应该被归类在这里。</p><blockquote><p>而对于这些结构的具体意义以及 Class 的入门语法，你可以阅读阮一峰老师的 ES6 标准入门。</p></blockquote><p>属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：</p><pre><code class="typescript">class Foo &#123;  prop: string;  constructor(inputProp: string) &#123;    this.prop = inputProp;  &#125;  print(addon: string): void &#123;    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);  &#125;  get propA(): string &#123;    return `$&#123;this.prop&#125;+A`;  &#125;  set propA(value: string) &#123;    this.prop = `$&#123;value&#125;+A`;  &#125;&#125;</code></pre><p>唯一需要注意的是，setter 方法<strong>不允许进行返回值的类型标注</strong>，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致，这里我们不再赘述。</p><p>就像函数可以通过<strong>函数声明</strong>与<strong>函数表达式</strong>创建一样，类也可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建。很明显上面的写法即是类声明，而使用类表达式的语法则是这样的：</p><pre><code class="typescript">const Foo = class &#123;  prop: string;  constructor(inputProp: string) &#123;    this.prop = inputProp;  &#125;  print(addon: string): void &#123;    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);  &#125;  // ...&#125;;</code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 TypeScript 中我们能够为 Class 成员添加这些修饰符：<code>public</code> / <code>private</code> / <code>protected</code> / <code>readonly</code>。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。</p><p>这些修饰符应用的位置在成员命名前：</p><pre><code class="typescript">class Foo &#123;  private prop: string;  constructor(inputProp: string) &#123;    this.prop = inputProp;  &#125;  protected print(addon: string): void &#123;    console.log(`$&#123;this.prop&#125; and $&#123;addon&#125;`);  &#125;  public get propA(): string &#123;    return `$&#123;this.prop&#125;+A`;  &#125;  public set propA(value: string) &#123;    this.propA = `$&#123;value&#125;+A`;  &#125;&#125;</code></pre><blockquote><p>我们通常不会为构造函数添加修饰符，而是让它保持默认的 public。在扩展阅读中我们会讲到 private 修饰构造函数的场景。</p></blockquote><p>如果没有其他语言学习经验，你可能不太理解 public / private / protected 的意义，我们简单做个解释。</p><ul><li>public：此类成员在<strong>类、类的实例、子类</strong>中都能被访问。</li><li>private：此类成员仅能在<strong>类的内部</strong>被访问。</li><li>protected：此类成员仅能在<strong>类与子类中</strong>被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即<strong>不允许再访问受保护的成员</strong>。</li></ul><p>当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以<strong>在构造函数中对参数应用访问性修饰符</strong>：</p><pre><code class="typescript">class Foo &#123;  constructor(public arg1: string, private arg2: boolean) &#123;&#125;&#125;new Foo(&quot;linbudu&quot;, true);</code></pre><p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：</p><pre><code class="typescript">class Foo &#123;  static staticHandler() &#123;&#125;  public instanceHandler() &#123;&#125;&#125;</code></pre><p>不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 <code>Foo.staticHandler</code> 这种形式进行访问。我们可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别：</p><pre><code class="javascript">var Foo = /** @class */ (function () &#123;  function Foo() &#123;&#125;  Foo.staticHandler = function () &#123;&#125;;  Foo.prototype.instanceHandler = function () &#123;&#125;;  return Foo;&#125;)();</code></pre><p>从中我们可以看到，<strong>静态成员直接被挂载在函数体上</strong>，而<strong>实例成员挂载在原型上</strong>，这就是二者的最重要差异：<strong>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）</strong>。而原型对象上的实例成员则会<strong>沿着原型链进行传递</strong>，也就是能够被继承。</p><p>而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如我会用<strong>类 + 静态成员</strong>来收敛变量与 utils 方法：</p><pre><code class="typescript">class Utils &#123;  public static identifier = &quot;linbudu&quot;;  public static makeUHappy() &#123;    Utils.studyWithU();    // ...  &#125;  public static studyWithU() &#123;&#125;&#125;Utils.makeUHappy();</code></pre><h3 id="继承、实现、抽象类"><a href="#继承、实现、抽象类" class="headerlink" title="继承、实现、抽象类"></a>继承、实现、抽象类</h3><p>既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：</p><pre><code class="typescript">class Base &#123;&#125;class Derived extends Base &#123;&#125;</code></pre><p>对于这里的两个类，比较严谨的称呼是 <strong>基类（*Base*）</strong> 与 <strong>派生类（*Derived*）</strong>。当然，如果你觉得叫父类与子类更容易理解也没问题。关于基类与派生类，我们需要了解的主要是<strong>派生类对基类成员的访问与覆盖操作</strong>。</p><p>基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。我们在上面其实已经介绍过，派生类中可以访问到使用 <code>public</code> 或 <code>protected</code> 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但我们仍然可以通过 super 访问到基类中的方法：</p><pre><code class="typescript">class Base &#123;  print() &#123;&#125;&#125;class Derived extends Base &#123;  print() &#123;    super.print();    // ...  &#125;&#125;</code></pre><p>在派生类中覆盖基类方法时，我们并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？所以，TypeScript 4.3 新增了 <code>override</code> 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义：</p><pre><code class="typescript">class Base &#123;  printWithLove() &#123;&#125;&#125;class Derived extends Base &#123;  override print() &#123;    // ...  &#125;&#125;</code></pre><p>在这里 TS 将会给出错误，因为<strong>尝试覆盖的方法并未在基类中声明</strong>。通过这一关键字我们就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。</p><p>除了基类与派生类以外，还有一个比较重要的概念：<strong>抽象类</strong>。抽象类是对类结构与方法的抽象，简单来说，<strong>一个抽象类描述了一个类中应当有哪些成员（属性、方法等）</strong>，<strong>一个抽象方法描述了这一方法在实际实现中的结构</strong>。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的<strong>入参类型</strong>与<strong>返回值类型</strong>。</p><p>抽象类使用 abstract 关键字声明：</p><pre><code class="typescript">abstract class AbsFoo &#123;  abstract absProp: string;  abstract get absGetter(): string;  abstract absMethod(name: string): string;&#125;</code></pre><p>注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。我们可以实现（implements）一个抽象类：</p><pre><code class="typescript">class Foo implements AbsFoo &#123;  absProp: string = &quot;linbudu&quot;;  get absGetter() &#123;    return &quot;linbudu&quot;;  &#125;  absMethod(name: string) &#123;    return name;  &#125;&#125;</code></pre><p>此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中<strong>无法声明静态的抽象成员</strong>。</p><p>对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的。interface 不仅可以声明函数结构，也可以声明类的结构：</p><pre><code class="typescript">interface FooStruct &#123;  absProp: string;  get absGetter(): string;  absMethod(input: string): string;&#125;class Foo implements FooStruct &#123;  absProp: string = &quot;linbudu&quot;;  get absGetter() &#123;    return &quot;linbudu&quot;;  &#125;  absMethod(name: string) &#123;    return name;  &#125;&#125;</code></pre><p>在这里，我们让类去实现了一个接口。这里接口的作用和抽象类一样，都是<strong>描述这个类的结构</strong>。除此以外，我们还可以使用 <strong>Newable Interface</strong> 来描述一个类的结构（类似于描述函数结构的 <strong>Callable Interface</strong>）：</p><pre><code class="typescript">class Foo &#123;&#125;interface FooStruct &#123;  new (): Foo;&#125;declare const NewableFoo: FooStruct;const foo = new NewableFoo();</code></pre><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类，实际上我们了解的更多是新的语法，如访问性修饰符 <code>public</code> / <code>private</code> / <code>protected</code> ，操作修饰符 <code>readonly</code> ，静态成员 static ，抽象类 abstract ，以及 override 等在 JavaScript（ECMAScript）中不存在或实现并不完全的能力。</p><p>对于函数与类，你需要更多地实际使用才能掌握得更好。不妨继续对你手上的 JavaScript 进行改造，让函数与类都能披上类型的铠甲，获得完整的类型能力。</p><p>在下一节，我们将要接触的就是 JavaScript 中完全没有类似概念的新朋友了，它们是 TypeScript 类型编程最基础的一部分，包括了 any 、 unknown 、never 内置类型，以及类型断言等概念，这些类型工具会是你以后玩转类型编程时最常打交道的一部分。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？</p><pre><code class="typescript">class Foo &#123;  private constructor() &#123;&#125;&#125;</code></pre><p>看起来好像没什么问题，但是当你想要实例化这个类时，一行美丽的操作就会出现：<strong>类的构造函数被标记为私有，且只允许在类内部访问</strong>。</p><p>那这就很奇怪了，我们要一个不能实例化的类有啥用？摆设吗？</p><p>还真不是，有些场景下私有构造函数确实有奇妙的用法，比如像我一样把类作为 utils 方法时，此时 Utils 类内部全部都是静态成员，我们也并不希望真的有人去实例化这个类。此时就可以使用私有构造函数来阻止它被错误地实例化：</p><pre><code class="typescript">class Utils &#123;  public static identifier = &quot;linbudu&quot;;  private constructor() &#123;&#125;  public static makeUHappy() &#123;&#125;&#125;</code></pre><p>或者在一个类希望把实例化逻辑通过方法来实现，而不是通过 new 的形式时，也可以使用私有构造函数来达成目的。</p><p>你可能会想到，既然有私有构造函数，那没道理没有受保护的构造函数（<code>protected</code>）啊？还真有。但这里我想留给你自己去探寻，你可以先查找下这么做的意义，再想想，什么场景下我们非用它不可？</p><h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。</p><p>S，<strong>单一功能原则</strong>，<strong>一个类应该仅具有一种职责</strong>，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和写操作也应当被视为两种不同的职责，并被分配到两个类中。更进一步，对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来。</p><p>O，<strong>开放封闭原则</strong>，<strong>一个类应该是可扩展但不可修改的</strong>。即假设我们的业务中支持通过微信、支付宝登录，原本在一个 login 方法中进行 if else 判断，假设后面又新增了抖音登录、美团登录，难道要再加 else if 分支（或 switch case）吗？</p><pre><code class="typescript">enum LoginType &#123;  WeChat,  TaoBao,  TikTok,  // ...&#125;class Login &#123;  public static handler(type: LoginType) &#123;    if (type === LoginType.WeChat) &#123;    &#125; else if (type === LoginType.TikTok) &#123;    &#125; else if (type === LoginType.TaoBao) &#123;    &#125; else &#123;      throw new Error(&quot;Invalid Login Type!&quot;);    &#125;  &#125;&#125;</code></pre><p>当然不，基于开放封闭原则，我们应当将登录的基础逻辑抽离出来，不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑。</p><pre><code class="typescript">abstract class LoginHandler &#123;  abstract handler(): void;&#125;class WeChatLoginHandler implements LoginHandler &#123;  handler() &#123;&#125;&#125;class TaoBaoLoginHandler implements LoginHandler &#123;  handler() &#123;&#125;&#125;class TikTokLoginHandler implements LoginHandler &#123;  handler() &#123;&#125;&#125;class Login &#123;  public static handlerMap: Record&lt;LoginType, LoginHandler&gt; = &#123;    [LoginType.TaoBao]: new TaoBaoLoginHandler(),    [LoginType.TikTok]: new TikTokLoginHandler(),    [LoginType.WeChat]: new WeChatLoginHandler(),  &#125;;  public static handler(type: LoginType) &#123;    Login.handlerMap[type].handler();  &#125;&#125;</code></pre><p>L，<strong>里式替换原则</strong>，<strong>一个派生类可以在程序的任何一处对其基类进行替换</strong>。这也就意味着，子类完全继承了父类的一切，对父类进行了功能地扩展（而非收窄）。</p><p>I，<strong>接口分离原则</strong>，<strong>类的实现方应当只需要实现自己需要的那部分接口</strong>。比如微信登录支持指纹识别，支付宝支持指纹识别和人脸识别，这个时候微信登录的实现类应该不需要实现人脸识别方法才对。这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对。</p><p>D，<strong>依赖倒置原则</strong>，这是实现开闭原则的基础，它的核心思想即是<strong>对功能的实现应该依赖于抽象层</strong>，即不同的逻辑通过实现不同的抽象类。还是登录的例子，我们的登录提供方法应该基于共同的登录抽象类实现（LoginHandler），最终调用方法也基于这个抽象类，而不是在一个高阶登录方法中去依赖多个低阶登录提供方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104、typescript字面量类型和枚举(二)</title>
      <link href="/2022/12/07/104-ts/"/>
      <url>/2022/12/07/104-ts/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>了解了原始类型与对象类型以后，我们已经能完成简单场景的类型标注了。但这还远远不够，我们还可以让这些类型标注更精确一些。比如，有一个接口结构，它描述了响应的消息结构：</p><pre><code class="typescript">interface IRes &#123;  code: number;  status: string;  data: any;&#125;</code></pre><p>在大多数情况下，这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 / 10001 / 50000，status 可能是 <code>&quot;success&quot;</code> / <code>&quot;failure&quot;</code>。而上面的类型只给出了一个宽泛的 number（string），此时我们既不能在访问 code 时获得精确的提示，也失去了 TypeScript 类型即文档的功能。</p><p>这个时候要怎么做？</p><h2 id="字面量类型与联合类型"><a href="#字面量类型与联合类型" class="headerlink" title="字面量类型与联合类型"></a>字面量类型与联合类型</h2><p>我们可以使用联合类型加上字面量类型，把上面的例子改写成这样：</p><pre><code class="typescript">interface Res &#123;  code: 10000 | 10001 | 50000;  status: &quot;success&quot; | &quot;failure&quot;;  data: any;&#125;</code></pre><p>这个时候，我们就能在访问时获得精确地类型推导了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428d95d0eee4c269302df47bf45e7b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>对于 <code>declare var res: Res</code>，你可以认为它其实就是快速生成一个符合指定类型，但没有实际值的变量，同时它也不存在于运行时中。上面引入了一些新的概念，我们来一个一个了解。</p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>最开始你可能觉得很神奇，<code>&quot;success&quot;</code> 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做<strong>字面量类型（Literal Types）</strong>，它代表着比原始类型更精确的类型，同时也是原始类型的子类型（关于类型层级，我们会在后面详细了解）。</p><p>字面量类型主要包括<strong>字符串字面量类型</strong>、<strong>数字字面量类型</strong>、<strong>布尔字面量类型</strong>和<strong>对象字面量类型</strong>，它们可以直接作为类型标注：</p><pre><code class="typescript">const str: &quot;linbudu&quot; = &quot;linbudu&quot;;const num: 599 = 599;const bool: true = true;</code></pre><p>为什么说字面量类型比原始类型更精确？我们可以看这么个例子：</p><pre><code class="typescript">// 报错！不能将类型“&quot;linbudu599&quot;”分配给类型“&quot;linbudu&quot;”。const str1: &quot;linbudu&quot; = &quot;linbudu599&quot;;const str2: string = &quot;linbudu&quot;;const str3: string = &quot;linbudu599&quot;;</code></pre><p>上面的代码，原始类型的值可以包括任意的同类型值，而字面量类型要求的是<strong>值级别的字面量一致</strong>。</p><p>单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 <code>|</code>）一起使用，表达一组字面量类型：</p><pre><code class="typescript">interface Tmp &#123;  bool: true | false;  num: 1 | 2 | 3;  str: &quot;lin&quot; | &quot;bu&quot; | &quot;du&quot;;&#125;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>而联合类型你可以理解为，它代表了<strong>一组类型的可用集合</strong>，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，我们还可以将各种类型混合到一起：</p><pre><code class="typescript">interface Tmp &#123;  mixed: true | string | 599 | &#123;&#125; | (() =&gt; &#123;&#125;) | (1 | 2);&#125;</code></pre><p>这里有几点需要注意的：</p><ul><li>对于联合类型中的函数类型，需要使用括号<code>()</code>包裹起来</li><li>函数类型并不存在字面量类型，因此这里的 <code>(() =&gt; &#123;&#125;)</code> 就是一个合法的函数类型</li><li>你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中</li></ul><p>联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：</p><pre><code class="typescript">interface Tmp &#123;  user:    | &#123;        vip: true;        expires: string;      &#125;    | &#123;        vip: false;        promotion: string;      &#125;;&#125;declare var tmp: Tmp;if (tmp.user.vip) &#123;  console.log(tmp.user.expires);&#125;</code></pre><p>在这个例子中，user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true ，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）。这一能力的使用涉及类型守卫与类型控制流分析，我们会在后面的章节详细来说。</p><p>我们也可以通过类型别名来复用一组字面量联合类型：</p><pre><code class="typescript">type Code = 10000 | 10001 | 50000;type Status = &quot;success&quot; | &quot;failure&quot;;</code></pre><p>除了原始类型的字面量类型以外，对象类型也有着对应的字面量类型。</p><h3 id="对象字面量类型"><a href="#对象字面量类型" class="headerlink" title="对象字面量类型"></a>对象字面量类型</h3><p>类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：</p><pre><code class="typescript">interface Tmp &#123;  obj: &#123;    name: &quot;linbudu&quot;;    age: 18;  &#125;;&#125;const tmp: Tmp = &#123;  obj: &#123;    name: &quot;linbudu&quot;,    age: 18,  &#125;,&#125;;</code></pre><p>如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。对象字面量类型在实际开发中的使用较少，我们只需要了解。</p><p>总的来说，在需要更精确类型的情况下，我们可以使用字面量类型加上联合类型的方式，将类型从 string 这种宽泛的原始类型直接收窄到 <code>&quot;resolved&quot; | &quot;pending&quot; | &quot;rejected&quot;</code> 这种精确的字面量类型集合。</p><p>需要注意的是，<strong>无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值</strong>。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。</p><p>如果说字面量类型是对原始类型的进一步扩展（对象字面量类型的使用较少），那么枚举在某些方面则可以理解为是对对象类型的扩展。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举并不是 JavaScript 中原生的概念，在其他语言中它都是老朋友了（Java、C#、Swift 等）。目前也已经存在给 JavaScript（ECMAScript）引入枚举支持的 <a href="https://link.juejin.cn/?target=https://github.com/rbuckton/proposal-enum">proposal-enum</a> 提案，但还未被提交给 TC39 ，仍处于 Stage 0 阶段。</p><p>如果要和 JavaScript 中现有的概念对比，我想最贴切的可能就是你曾经写过的 constants 文件了：</p><pre><code class="javascript">export default &#123;  Home_Page_Url: &quot;url1&quot;,  Setting_Page_Url: &quot;url2&quot;,  Share_Page_Url: &quot;url3&quot;,&#125;;// 或是这样：export const PageUrl = &#123;  Home_Page_Url: &quot;url1&quot;,  Setting_Page_Url: &quot;url2&quot;,  Share_Page_Url: &quot;url3&quot;,&#125;;</code></pre><p>如果把这段代码替换为枚举，会是如下的形式：</p><pre><code class="typescript">enum PageUrl &#123;  Home_Page_Url = &quot;url1&quot;,  Setting_Page_Url = &quot;url2&quot;,  Share_Page_Url = &quot;url3&quot;,&#125;const home = PageUrl.Home_Page_Url;</code></pre><p>这么做的好处非常明显。首先，你拥有了更好的类型提示。其次，这些常量被真正地<strong>约束在一个命名空间</strong>下（上面的对象声明总是差点意思）。如果你没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增：</p><pre><code class="typescript">enum Items &#123;  Foo,  Bar,  Baz,&#125;</code></pre><p>在这个例子中，<code>Items.Foo</code> , <code>Items.Bar</code> , <code>Items.Baz</code>的值依次是 0，1，2 。</p><p>如果你只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。</p><pre><code class="typescript">enum Items &#123;  // 0  Foo,  Bar = 599,  // 600  Baz,&#125;</code></pre><p>在数字型枚举中，你可以使用延迟求值的枚举值，比如函数：</p><pre><code class="typescript">const returnNum = () =&gt; 100 + 499;enum Items &#123;  Foo = returnNum(),  Bar = 599,  Baz,&#125;</code></pre><p>但要注意，延迟求值的枚举值是有条件的。<strong>如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后（如上例），或者放在第一位</strong>：</p><pre><code class="typescript">enum Items &#123;  Baz,  Foo = returnNum(),  Bar = 599,&#125;</code></pre><p>TypeScript 中也可以同时使用字符串枚举值和数字枚举值：</p><pre><code class="typescript">enum Mixed &#123;  Num = 599,  Str = &quot;linbudu&quot;,&#125;</code></pre><p>枚举和对象的重要差异在于，<strong>对象是单向映射的</strong>，我们只能从键映射到键值。而<strong>枚举是双向映射的</strong>，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</p><pre><code class="typescript">enum Items &#123;  Foo,  Bar,  Baz,&#125;const fooValue = Items.Foo; // 0const fooKey = Items[0]; // &quot;Foo&quot;</code></pre><p>要了解这一现象的本质，我们需要来看一看枚举的编译产物，如以上的枚举会被编译为以下 JavaScript 代码：</p><pre><code class="typescript">&quot;use strict&quot;;var Items;(function (Items) &#123;  Items[(Items[&quot;Foo&quot;] = 0)] = &quot;Foo&quot;;  Items[(Items[&quot;Bar&quot;] = 1)] = &quot;Bar&quot;;  Items[(Items[&quot;Baz&quot;] = 2)] = &quot;Baz&quot;;&#125;)(Items || (Items = &#123;&#125;));</code></pre><p><code>obj[k] = v</code> 的返回值即是 v，因此这里的 <code>obj[obj[k] = v] = k</code> 本质上就是进行了 <code>obj[k] = v</code> 与 <code>obj[v] = k</code> 这样两次赋值。</p><p>但需要注意的是，仅有值为数字的枚举成员才能够进行这样的双向枚举，<strong>字符串枚举成员仍然只会进行单次映射</strong>：</p><pre><code class="typescript">enum Items &#123;  Foo,  Bar = &quot;BarValue&quot;,  Baz = &quot;BazValue&quot;,&#125;// 编译结果，只会进行 键-值 的单向映射(&quot;use strict&quot;);var Items;(function (Items) &#123;  Items[(Items[&quot;Foo&quot;] = 0)] = &quot;Foo&quot;;  Items[&quot;Bar&quot;] = &quot;BarValue&quot;;  Items[&quot;Baz&quot;] = &quot;BazValue&quot;;&#125;)(Items || (Items = &#123;&#125;));</code></pre><p>除了数字枚举与字符串枚举这种分类以外，其实还存在着普通枚举与常量枚举这种分类方式。</p><h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><p>常量枚举和枚举相似，只是其声明多了一个 const：</p><pre><code class="typescript">const enum Items &#123;  Foo,  Bar,  Baz,&#125;const fooValue = Items.Foo; // 0</code></pre><p>它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，你<strong>只能通过枚举成员访问枚举值</strong>（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象（如上面的 Items 对象），对枚举成员的访问会被<strong>直接内联替换为枚举的值</strong>。以上的代码会被编译为如下形式：</p><pre><code class="javascript">const fooValue = 0; /* Foo */ // 0</code></pre><blockquote><p>实际上，常量枚举的表现、编译产物还受到配置项 <code>--isolatedModules</code> 以及 <code>--preserveConstEnums</code> 等的影响，我们会在后面的 TSConfig 详解中了解更多。</p></blockquote><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节中，我们了解了字面量类型和枚举的使用，包括字面量类型的分类，与联合类型的结合使用，以及枚举与其编译产物等等。</p><p>对于字面量类型，我们可以使用它来提供更精确的类型标注。比如，你可以将如用户类型与请求状态码这一类属性的类型，都使用<strong>字面量类型＋联合类型</strong>的形式改写，获得更详细的类型信息与更严格的类型约束。</p><p>而对于枚举，我们可以使用它来替换掉之前使用对象进行常量收敛的代码，而如果你希望减少编译后的代码，可以进一步地使用在编译后会被完全抹除的常量枚举。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="类型控制流分析中的字面量类型"><a href="#类型控制流分析中的字面量类型" class="headerlink" title="类型控制流分析中的字面量类型"></a>类型控制流分析中的字面量类型</h3><p>除了手动声明字面量类型以外，实际上 TypeScript 也会在某些情况下将变量类型推导为字面量类型，看这个例子：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eecde2e8de214264a42dd74da8c8e17b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6931f3897d674a8d9803164e5f4d7f2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>你会发现，使用 const 声明的变量，其类型会从值推导出最精确的字面量类型。而对象类型则只会推导至符合其属性结构的接口，不会使用字面量类型：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742ad435155e41e293abedf0fe8d053e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>要解答这个现象，需要你回想 let 和 const 声明的意义。我们知道，使用 let 声明的变量是可以再次赋值的，在 TypeScript 中要求赋值类型始终与原类型一致（如果声明了的话）。因此对于 let 声明，<strong>只需要推导至这个值从属的类型即可</strong>。而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型，但对象类型变量仍可变（但同样会要求其属性值类型保持一致）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103、typescript理解原始类型和对象类型(一)</title>
      <link href="/2022/12/06/103-ts/"/>
      <url>/2022/12/06/103-ts/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="原始类型的类型标注"><a href="#原始类型的类型标注" class="headerlink" title="原始类型的类型标注"></a>原始类型的类型标注</h2><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures%23%E5%8E%9F%E5%A7%8B%E5%80%BC_primitive_values">JavaScript 的内置原始类型</a>,除了最常见的 number / string / boolean / null / undefined， ECMAScript 2015（ES6）、2020 (ES11) 又分别引入了 2 个新的原始类型：symbol 与 bigint 。在 TypeScript 中它们都有对应的类型注解：</p><pre><code class="typescript">const name: string = &quot;linbudu&quot;;const age: number = 24;const male: boolean = false;const undef: undefined = undefined;const nul: null = null;const obj: object = &#123; name, age, male &#125;;const bigintVar1: bigint = 9007199254740991n;const bigintVar2: bigint = BigInt(9007199254740991);const symbolVar: symbol = Symbol(&quot;unique&quot;);</code></pre><p>其中，除了 null 与 undefined 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念，因此这里我们只对 null 与 undefined 展开介绍。</p><h3 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h3><p>在 JavaScript 中，null 与 undefined 分别表示“<strong>这里有值，但是个空值</strong>”和“<strong>这里没有值</strong>”。而在 TypeScript 中，null 与 undefined 类型都是<strong>有具体意义的类型</strong>。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 <code>strictNullChecks</code> 检查的情况下，会<strong>被视作其他类型的子类型</strong>，比如 string 类型会被认为包含了 null 与 undefined 类型：</p><pre><code class="typescript">const tmp1: null = null;const tmp2: undefined = undefined;const tmp3: string = null; // 仅在关闭 strictNullChecks 时成立，下同const tmp4: string = undefined;</code></pre><p>除了上面介绍的原始类型以及 null、undefined 类型以外，在 TypeScript 中还存在着一个特殊的类型：void，它和 JavaScript 中的 void 同样不是一回事，我们接着往下看。</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>你是否看到过以下的 JavaScript 代码呢？</p><pre><code class="typescript">&lt;a href=&quot;javascript:void(0)&quot;&gt;清除缓存&lt;/a&gt;</code></pre><p>这里的 <code>void(0)</code> 等价于 <code>void 0</code>，即 <code>void expression</code> 的语法。void 操作符会执行后面跟着的表达式并返回一个 undefined，如你可以使用它来执行一个立即执行函数（IIFE）：</p><pre><code class="typescript">void (function iife() &#123;  console.log(&quot;Invoked!&quot;);&#125;)();</code></pre><p>能这么做是因为，void 操作符强制<strong>将后面的函数声明转化为了表达式</strong>，因此整体其实相当于：<code>void((function iife()&#123;&#125;)())</code>。</p><p>事实上，TypeScript 的原始类型标注中也有 void，但与 JavaScript 中不同的是，这里的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值，如：</p><pre><code class="typescript">function func1() &#123;&#125;function func2() &#123;  return;&#125;function func3() &#123;  return undefined;&#125;</code></pre><p>在这里，func1 与 func2 的返回值类型都会被隐式推导为 void，只有显式返回了 undefined 值的 func3 其返回值类型才被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。</p><blockquote><p>虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。</p></blockquote><p>这里可能有点绕，你可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型（注意与它们在 JavaScript 中的意义区分）。而 undefined 能够被赋值给 void 类型的变量，就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined 。null 类型也可以，但需要在关闭 <code>strictNullChecks</code> 配置的情况下才能成立。</p><pre><code class="typescript">const voidVar1: void = undefined;const voidVar2: void = null; // 需要关闭 strictNullChecks</code></pre><p>到这里，我们了解了 JavaScript 中原始数据类型到 TypeScript 原始类型概念地映射，你应当能感觉到 TypeScript 对 JavaScript 开发者的友好，大部分概念都能比较自然地过渡，下面的数组与对象的类型标注同样如此。</p><h2 id="数组的类型标注"><a href="#数组的类型标注" class="headerlink" title="数组的类型标注"></a>数组的类型标注</h2><p>数组同样是我们最常用的类型之一，在 TypeScript 中有两种方式来声明一个数组类型：</p><pre><code class="typescript">const arr1: string[] = [];const arr2: Array&lt;string&gt; = [];</code></pre><p>这两种方式是完全等价的，但其实更多是以前者为主，如果你将鼠标悬浮在 <code>arr2</code> 上，会发现它显示的类型签名是 <code>string[]</code>。数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用 <strong>元组（Tuple）</strong> 来代替数组要更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度地访问：</p><pre><code class="typescript">const arr3: string[] = [&quot;lin&quot;, &quot;bu&quot;, &quot;du&quot;];console.log(arr3[599]);</code></pre><p>这种情况肯定是不符合预期的，因为我们能确定这个数组中只有三个成员，并希望在越界访问时给出类型报错。这时我们可以使用元组类型进行类型标注：</p><pre><code class="typescript">const arr4: [string, string, string] = [&quot;lin&quot;, &quot;bu&quot;, &quot;du&quot;];console.log(arr4[599]);</code></pre><p>此时将会产生一个类型错误：**<em>长度为“3”的元组类型“[string, string, string]”在索引“599“处没有元素</em>**。除了同类型的元素以外，元组内部也可以声明多个与其位置强绑定的，不同类型的元素：</p><pre><code class="typescript">const arr5: [string, number, boolean] = [&quot;linbudu&quot;, 599, true];</code></pre><p>在这种情况下，对数组合法边界内的索引访问（即 0、1、2）将精确地获得对应位置上的类型。同时元组也支持了在某一个位置上的可选成员：</p><pre><code class="typescript">const arr6: [string, number?, boolean?] = [&quot;linbudu&quot;];// 下面这么写也可以// const arr6: [string, number?, boolean?] = [&#39;linbudu&#39;, , ,];</code></pre><p>对于标记为可选的成员，在 <code>--strictNullCheckes</code> 配置下会被视为一个 <code>string | undefined</code> 的类型。此时元组的长度属性也会发生变化，比如上面的元组 arr6 ，其长度的类型为 <code>1 | 2 | 3</code>：</p><pre><code class="typescript">type TupleLength = typeof arr6.length; // 1 | 2 | 3</code></pre><p>也就是说，这个元组的长度可能为 1、2、3。</p><blockquote><p>关于类型别名（type）、类型查询（typeof）以及联合类型，我们会在后面讲到，这里你只需要简单了解即可。</p></blockquote><p>你可能会觉得，元组的可读性实际上并不好。比如对于 <code>[string, number, boolean]</code>来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式。而在 TypeScript 4.0 中，有了具名元组（<a href="https://link.juejin.cn/?target=https://github.com/Microsoft/TypeScript/issues/28259">Labeled Tuple Elements</a>）的支持，使得我们可以为元组中的元素打上类似属性的标记：</p><pre><code class="typescript">const arr7: [name: string, age: number, male: boolean] = [&quot;linbudu&quot;, 599, true];</code></pre><p>有没有很酷？考虑到某些拼装对象太麻烦，我们完全可以使用具名元组来做简单替换。具名元组可选元素的修饰符将成为以下形式：</p><pre><code class="typescript">const arr7: [name: string, age: number, male?: boolean] = [  &quot;linbudu&quot;,  599,  true,];</code></pre><p>实际上除了显式地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式：</p><pre><code class="typescript">const arr1: string[] = [];const [ele1, ele2, ...rest] = arr1;</code></pre><p>对于数组，此时仍然无法检查出是否存在隐式访问，因为类型层面并不知道它到底有多少个元素。但对于元组，隐式的越界访问也能够被揪出来给一个警告：</p><pre><code class="typescript">const arr5: [string, number, boolean] = [&quot;linbudu&quot;, 599, true];// 长度为 &quot;3&quot; 的元组类型 &quot;[string, number, boolean]&quot; 在索引 &quot;3&quot; 处没有元素。const [name, age, male, other] = arr5;</code></pre><p>JavaScript 的开发者对元组 Tuple 的概念可能比较陌生，毕竟在 JavaScript 中我们很少声明定长的数组。但使用元组确实能帮助我们进一步提升<strong>数组结构的严谨性</strong>，包括基于位置的类型标注、避免出现越界访问等等。除了通过数组类型提升数组结构的严谨性，TypeScript 中的对象类型也能帮助我们提升对象结构的严谨性。接下来我们就一起来看看。</p><h2 id="对象的类型标注"><a href="#对象的类型标注" class="headerlink" title="对象的类型标注"></a>对象的类型标注</h2><p>作为 JavaScript 中使用最频繁的数据结构，对象的类型标注是我们本节要重点关注的部分。接下来我们会学习如何在 TypeScript 中声明对象、修饰对象属性，以及了解可能存在的使用误区。这些内容能够帮助你建立起对 TypeScript 中立体类型（我们可以理解为前面的原始类型是“<strong>平面类型</strong>”）的了解，正式入门 TypeScript 。</p><p>类似于数组类型，在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 interface ，你可以理解为它代表了这个对象对外提供的接口结构。</p><p>首先我们使用 interface 声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：</p><pre><code class="typescript">interface IDescription &#123;  name: string;  age: number;  male: boolean;&#125;const obj1: IDescription = &#123;  name: &quot;linbudu&quot;,  age: 599,  male: true,&#125;;</code></pre><p>这里的“描述”指：</p><ul><li>每一个属性的值必须<strong>一一对应</strong>到接口的属性类型</li><li>不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 <code>obj1.other = &#39;xxx&#39;</code> 这样属性访问赋值的形式</li></ul><p>除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括<strong>可选（Optional）</strong> 与 <strong>只读（Readonly）</strong> 这两种。</p><h3 id="修饰接口属性"><a href="#修饰接口属性" class="headerlink" title="修饰接口属性"></a>修饰接口属性</h3><p>类似于上面的元组可选，在接口结构中同样通过 <code>?</code> 来标记一个属性为可选：</p><pre><code class="typescript">interface IDescription &#123;  name: string;  age: number;  male?: boolean;  func?: Function;&#125;const obj2: IDescription = &#123;  name: &quot;linbudu&quot;,  age: 599,  male: true,  // 无需实现 func 也是合法的&#125;;</code></pre><p>在这种情况下，即使你在 obj2 中定义了 male 属性，但当你访问 <code>obj2.male</code> 时，它的类型仍然会是 <code>boolean | undefined</code>，因为毕竟这是我们自己定义的类型嘛。</p><p>假设新增一个可选的函数类型属性，然后进行调用：<code>obj2.func()</code> ，此时将会产生一个类型报错：**<em>不能调用可能是未定义的方法</em>**。但可选属性标记不会影响你对这个属性进行赋值，如：</p><pre><code class="typescript">obj2.male = false;obj2.func = () =&gt; &#123;&#125;;</code></pre><p>即使你对可选属性进行了赋值，TypeScript 仍然会使用<strong>接口的描述为准</strong>进行类型检查，你可以使用类型断言、非空断言或可选链解决（别急，我们在后面会讲到）。</p><p>除了标记一个属性为可选以外，你还可以标记这个属性为只读：<code>readonly</code>。很多同学对这一关键字比较陌生，因为以往 JavaScript 中并没有这一类概念，它的作用是<strong>防止对象的属性被再次赋值</strong>。</p><pre><code class="typescript">interface IDescription &#123;  readonly name: string;  age: number;&#125;const obj3: IDescription = &#123;  name: &quot;linbudu&quot;,  age: 599,&#125;;// 无法分配到 &quot;name&quot; ，因为它是只读属性obj3.name = &quot;林不渡&quot;;</code></pre><p>其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同。</p><ul><li>你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。</li><li>一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是<strong>类型 xxx 上不存在属性“push”这种</strong>。这一实现的本质是<strong>只读数组与只读元组的类型实际上变成了 ReadonlyArray，而不再是 Array。</strong></li></ul><h3 id="type-与-interface"><a href="#type-与-interface" class="headerlink" title="type 与 interface"></a>type 与 interface</h3><p>我也知道，很多同学更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而我更推荐的方式是，interface 用来描述<strong>对象、类的结构</strong>，而类型别名用来<strong>将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型</strong>。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题。</p><h3 id="object、Object-以及"><a href="#object、Object-以及" class="headerlink" title="object、Object 以及 { }"></a>object、Object 以及 { }</h3><p><code>object</code>、<code>Object</code> 以及<code>&#123;&#125;</code>（一个空对象）这三者的使用可能也会让部分同学感到困惑，所以我也专门解释下。</p><p>首先是 Object 的使用。被 JavaScript 原型链折磨过的同学应该记得，原型链的顶端是 Object 以及 Function，这也就意味着所有的原始类型与对象类型最终都指向 Object，在 TypeScript 中就表现为 Object 包含了所有的类型：</p><pre><code class="typescript">// 对于 undefined、null、void 0 ，需要关闭 strictNullChecksconst tmp1: Object = undefined;const tmp2: Object = null;const tmp3: Object = void 0;const tmp4: Object = &quot;linbudu&quot;;const tmp5: Object = 599;const tmp6: Object = &#123; name: &quot;linbudu&quot; &#125;;const tmp7: Object = () =&gt; &#123;&#125;;const tmp8: Object = [];</code></pre><p>和 Object 类似的还有 Boolean、Number、String、Symbol，这几个<strong>装箱类型（Boxed Types）</strong> 同样包含了一些超出预期的类型。以 String 为例，它同样包括 undefined、null、void，以及代表的 <strong>拆箱类型（Unboxed Types）</strong> string，但并不包括其他装箱类型对应的拆箱类型，如 boolean 与 基本对象类型，我们看以下的代码：</p><pre><code class="typescript">const tmp9: String = undefined;const tmp10: String = null;const tmp11: String = void 0;const tmp12: String = &quot;linbudu&quot;;// 以下不成立，因为不是字符串类型的拆箱类型const tmp13: String = 599; // Xconst tmp14: String = &#123; name: &quot;linbudu&quot; &#125;; // Xconst tmp15: String = () =&gt; &#123;&#125;; // Xconst tmp16: String = []; // X</code></pre><p><strong>在任何情况下，你都不应该使用这些装箱类型。</strong></p><p>object 的引入就是为了解决对 Object 类型的错误使用，它代表<strong>所有非原始类型的类型，即数组、对象与函数类型这些</strong>：</p><pre><code class="typescript">const tmp17: object = undefined;const tmp18: object = null;const tmp19: object = void 0;const tmp20: object = &quot;linbudu&quot;; // X 不成立，值为原始类型const tmp21: object = 599; // X 不成立，值为原始类型const tmp22: object = &#123; name: &quot;linbudu&quot; &#125;;const tmp23: object = () =&gt; &#123;&#125;;const tmp24: object = [];</code></pre><p>最后是<code>&#123;&#125;</code>，一个奇奇怪怪的空对象，如果你了解过字面量类型，可以认为<code>&#123;&#125;</code>就是一个对象字面量类型（对应到字符串字面量类型这样）。否则，你可以认为使用<code>&#123;&#125;</code>作为类型签名就是一个合法的，但<strong>内部无属性定义的空对象</strong>，这类似于 Object（想想 <code>new Object()</code>），它意味着任何非 null / undefined 的值：</p><pre><code class="typescript">const tmp25: &#123;&#125; = undefined; // 仅在关闭 strictNullChecks 时成立，下同const tmp26: &#123;&#125; = null;const tmp27: &#123;&#125; = void 0; // void 0 等价于 undefinedconst tmp28: &#123;&#125; = &quot;linbudu&quot;;const tmp29: &#123;&#125; = 599;const tmp30: &#123;&#125; = &#123; name: &quot;linbudu&quot; &#125;;const tmp31: &#123;&#125; = () =&gt; &#123;&#125;;const tmp32: &#123;&#125; = [];</code></pre><p>虽然能够将其作为变量的类型，但你实际上<strong>无法对这个变量进行任何赋值操作</strong>：</p><pre><code class="typescript">const tmp30: &#123;&#125; = &#123; name: &quot;linbudu&quot; &#125;;tmp30.age = 18; // X 类型“&#123;&#125;”上不存在属性“age”。</code></pre><p>这是因为它就是纯洁的像一张白纸一样的空对象，上面没有任何的属性（除了 toString 这种与生俱来的）。在类型层级一节我们还会再次见到它，不过那个时候它已经被称为“万物的起源”了。</p><p>最后，为了更好地区分 <code>Object</code>、<code>object</code> 以及<code>&#123;&#125;</code>这三个具有迷惑性的类型，我们再做下总结：</p><ul><li>在任何时候都<strong>不要，不要，不要使用</strong> Object 以及类似的装箱类型。</li><li>当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 <code>Record&lt;string, unknown&gt;</code> 或 <code>Record&lt;string, any&gt;</code> 表示对象，<code>unknown[]</code> 或 <code>any[]</code> 表示数组，<code>(...args: any[]) =&gt; any</code>表示函数这样。</li><li>我们同样要避免使用<code>&#123;&#125;</code>。<code>&#123;&#125;</code>意味着任何非 <code>null / undefined</code> 的值，从这个层面上看，使用它和使用 <code>any</code> 一样恶劣。</li></ul><h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>这一节，我们一起学习了 TypeScript 中原始类型、对象类型、数组（元组）的类型标注，以及对数组的只读、对象类型属性的访问性修饰。这里的知识其实可以分为两类：</p><ul><li>与 JavaScript 概念基本一致的部分，如原始类型与数组类型需要重点掌握，但因为思维方式基本没有变化，所以你可以认为你就是在写<strong>更严格一些的 JavaScript</strong>。</li><li>一些全新的概念，比如元组与 readonly 修饰等，这一部分你可能不会很快适应，需要稍微转换一下思维方式。我建议你可以从现在开始，有意识地在日常开发中去多多使用它们。</li></ul><p>另外，对于 readonly 这一修饰符，JavaScript 开发者可能需要一定的时间来理解和习惯，但它在工程层面确实是非常推荐的一种实践，可以使用只读标记来避免数组和对象被错误修改。当然，TypeScript 目前只能够帮助你在编译时做检查，类型信息在编译后都会被擦除，所以 readonly 并不会在实际运行时报错。</p><p>学习完这一小节后，不妨找出你曾经的 JavaScript 项目，试试用本章学到的知识为这些 JavaScript 代码添加一些类型，再把某些场景下的数组换成元组，为部分对象类型的属性添加 readonly，来感受 TypeScript 代码的严格之美。</p><p>在下一节我们要介绍的字面量类型以及枚举，在某些方面其实可以理解为是原始类型与对象类型的进一步延伸，也同样是日常会被重度使用的语法。在完成下一节的学习后，你就可以开始进一步地改造你的 JavaScript 项目，让那些类型变得更精确一些！</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h3><p>Symbol 在 JavaScript 中代表着一个唯一的值类型，它类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象 / Class 内部属性的情况。而在 TypeScript 中，symbol 类型并不具有这一特性，一百个具有 symbol 类型的对象，它们的 symbol 类型指的都是 TypeScript 中的同一个类型。为了实现“独一无二”这个特性，TypeScript 中支持了 unique symbol 这一类型声明，它是 symbol 类型的子类型，每一个 unique symbol 类型都是独一无二的。</p><pre><code class="typescript">const uniqueSymbolFoo: unique symbol = Symbol(&quot;linbudu&quot;);// 类型不兼容const uniqueSymbolBar: unique symbol = uniqueSymbolFoo;</code></pre><p>在 JavaScript 中，我们可以用 <code>Symbol.for</code> 方法来复用已创建的 Symbol，如 <code>Symbol.for(&quot;linbudu&quot;)</code> 会首先查找全局是否已经有使用 <code>linbudu</code> 作为 key 的 Symbol 注册，如果有，则返回这个 Symbol，否则才会创建新的 Symbol 。</p><p>在 TypeScript 中，如果要引用已创建的 unique symbol 类型，则需要使用类型查询操作符 typeof ：</p><pre><code class="typescript">declare const uniqueSymbolFoo: unique symbol;const uniqueSymbolBaz: typeof uniqueSymbolFoo = uniqueSymbolFoo;</code></pre><blockquote><p>以上代码实际执行时会报错，这是因为 uniqueSymbolFoo 是一个仅存在于类型空间的值，这里只是为了进行示例~</p></blockquote><blockquote><p>这里的 declare、typeof 等使用，都会在后面有详细地讲解。同时 unique symbol 在日常开发的使用非常少见，这里做了解就好~</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102、项目部署通用方案</title>
      <link href="/2022/12/03/102-deploy/"/>
      <url>/2022/12/03/102-deploy/</url>
      
        <content type="html"><![CDATA[<p>之前用过阿里巴巴的云效（codeup）管理代码及部署，通过搭建流水线的方式，前端提交完代码之后(前端提交代码时不用 npm run build)，可以按照简单的步骤将前端代码打包、发布(包括开发环境、测试环境)。</p><span id="more"></span><h2 id="一、为什么需要打包项目？"><a href="#一、为什么需要打包项目？" class="headerlink" title="一、为什么需要打包项目？"></a>一、为什么需要打包项目？</h2><p>浏览器只能识别并运行 <strong><code>html、css、js</code> 文件</strong> 。</p><p>那么换句话而言，项目中的 <code>.vue</code> 文件，浏览器是不认识的。</p><p>而打包的过程就是把 <code>.vue</code> 的 <strong>单文件组件</strong> 打包成 <code>html、css、js</code> 的文件，让浏览器进行识别，并展示我们的项目</p><h2 id="二、打包后的项目可以直接使用浏览器访问吗？"><a href="#二、打包后的项目可以直接使用浏览器访问吗？" class="headerlink" title="二、打包后的项目可以直接使用浏览器访问吗？"></a>二、打包后的项目可以直接使用浏览器访问吗？</h2><p>通过 <code>npm run build</code> 打包项目之后，打包的文件会被放入到 <code>dist</code> 文件夹中，其实我们可以直接双击 <code>index.html</code> 文件，可以发现，浏览器是 <strong>无法</strong> 显示项目的。</p><p>F12 查看控制台，发现抛出了很多错误。根据错误可以知道，无法显示项目的原因是一些文件找不到。</p><p>文件找不到的原因是我们打开 dist 下的 index.html 文件，在浏览器的 URL 其实是一个 file 协议，对应着的文件路径就会变成盘符下的 xxx,在我们当前的盘符下没有对应的文件，项目自然是无法访问的。</p><h2 id="三、为什么需要服务？"><a href="#三、为什么需要服务？" class="headerlink" title="三、为什么需要服务？"></a>三、为什么需要服务？</h2><p>项目需要通过一个服务托管，从而避免出现模块无法被找到等原因。</p><h2 id="四、明确域名、DNS、公网-IP、服务器、Nginx-之间的关系"><a href="#四、明确域名、DNS、公网-IP、服务器、Nginx-之间的关系" class="headerlink" title="四、明确域名、DNS、公网 IP、服务器、Nginx 之间的关系"></a>四、明确域名、DNS、公网 IP、服务器、Nginx 之间的关系</h2><ol><li>域名：<code>https://.baidu.com</code></li><li>DNS：域名解析服务器</li><li>公网 IP：服务器在网络中的唯一地址</li><li>服务器：服务部署的电脑</li><li>Nginx：网页服务</li></ol><h2 id="五、服务器的连接方式"><a href="#五、服务器的连接方式" class="headerlink" title="五、服务器的连接方式"></a>五、服务器的连接方式</h2><p>常见的连接服务器方式：<br>1、云商控制台中进行远程链接<br>2、SSH 工具（XShell）<br>3、SSH 指令远程登录</p><blockquote><p>SSH 工具-XShell</p></blockquote><p>1、新建会话<br>2、确定会话信息，协议为 SSH、主机为服务器 IP、端口号为 22<br>3、双击会话进行连接<br>4、输入用户名（默认为 root）<br>5、输入密码</p><blockquote><p>Nginx 环境处理</p></blockquote><ol><li><p><code>nginx</code> 编译时依赖 <code>gcc</code> 环境</p><pre><code>yum -y install gcc gcc-c++</code></pre></li><li><p>安装 <code>prce</code>，让 <code>nginx</code> 支持重写功能</p><pre><code>yum -y install pcre*</code></pre></li><li><p>安装 <code>zlib</code>，<code>nginx</code> 使用 <code>zlib</code> 对 <code>http</code> 包内容进行 <code>gzip</code> 压缩</p><pre><code>yum -y install zlib zlib-devel</code></pre></li><li><p>安装 <code>openssl</code>，用于通讯加密</p><pre><code>yum -y install openssl openssl-devel</code></pre></li><li><p>进行 <code>nginx</code> 安装</p></li><li><p>创建 <code>nginx</code> 文件夹</p></li><li><p>下载 <code>nginx</code> 压缩包</p><pre><code>wget https://nginx.org/download/nginx-1.11.5.tar.gz</code></pre></li><li><p>解压 <code>nginx</code></p><pre><code>tar -zxvf  nginx-1.11.5.tar.gz</code></pre></li><li><p>进入 <code>nginx-1.11.5</code> 目录</p><pre><code>cd nginx-1.11.5</code></pre></li><li><p>检查平台安装环境</p><pre><code>./configure --prefix=/usr/local/nginx</code></pre></li><li><p>进行源码编译</p><pre><code>make</code></pre></li><li><p>安装 <code>nginx</code></p><pre><code>make install</code></pre></li><li><p>查看 <code>nginx</code> 配置</p><pre><code>/usr/local/nginx/sbin/nginx -t</code></pre></li><li><p>制作 <code>nginx</code> 软连接</p></li><li><p>进入 <code>usr/bin</code> 目录</p><pre><code>cd /usr/bin</code></pre></li><li><p>制作软连接</p><pre><code>ln -s /usr/local/nginx/sbin/nginx nginx</code></pre></li><li><p>接下来制作配置文件</p></li><li><p>首先进入到 <code>nginx</code> 的默认配置文件中</p><pre><code>vim /usr/local/nginx/conf/nginx.conf</code></pre></li><li><p>在最底部增加配置项（按下 <code>i</code> 进入 输入模式）</p><pre><code>include /nginx/*.conf;</code></pre></li><li><p>按下 <code>esc</code> 键，通过 <code>:wq!</code> 保存并退出</p></li><li><p>创建新的配置文件</p><pre><code>touch /nginx/nginx.conf</code></pre></li><li><p>进入到 <code>/root/nginx/nginx.conf</code> 文件</p><pre><code>vim /nginx/nginx.conf</code></pre></li><li><p>写入如下配置</p><pre><code class="js">server &#123;    # 端口    listen       80;    # 域名    server_name  localhost;    # 资源地址    root   /nginx/dist/;    # 目录浏览    autoindex on;    # 缓存处理    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;    # 请求配置    location / &#123;        # 跨域        add_header Access-Control-Allow-Origin *;        # 返回 index.html        try_files $uri $uri/ /index.html;    &#125;&#125;</code></pre></li><li><p>通过 <code>:wq!</code> 保存退出</p></li><li><p>在 <code>root/nginx</code> 中创建 <code>dist</code> 文件夹</p><pre><code>mkdir /nginx/dist</code></pre></li><li><p>在 <code>nginx/dist</code> 中写入 <code>index.html</code> 进行测试</p></li><li><p>通过 <code>nginx -s reload</code> 重启服务</p></li><li><p>在 浏览器中通过，<code>IP</code> 测试访问</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101、富文本与markdown对文本的处理</title>
      <link href="/2022/12/01/101-markdown/"/>
      <url>/2022/12/01/101-markdown/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>编辑文本的 2 种方式：1、富文本; 2、markdown。这 2 种编辑形式在前端中有很多第 3 方库。</p><h2 id="一、创建文本基本结构"><a href="#一、创建文本基本结构" class="headerlink" title="一、创建文本基本结构"></a>一、创建文本基本结构</h2><h2 id="1-1-创建文本基本结构，主要分为三部分："><a href="#1-1-创建文本基本结构，主要分为三部分：" class="headerlink" title="1-1 创建文本基本结构，主要分为三部分："></a>1-1 创建文本基本结构，主要分为三部分：</h2><p>1、article-create 页面：基本结构</p><p>2、Editor 组件：富文本编辑器</p><p>3、Markdown 组件： markdown 编辑器</p><p>src 目录下的项目结构：</p><pre><code>views / article - create / components / Editor.vue;views / article - create / components / Markdown.vue;views / article - create / index.vue;</code></pre><h2 id="1-2-创建文本父组件"><a href="#1-2-创建文本父组件" class="headerlink" title="1-2 创建文本父组件"></a>1-2 创建文本父组件</h2><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;article-create&quot;&gt;    &lt;el-card&gt;      &lt;el-input        class=&quot;title-input&quot;        placeholder=&quot;请输入标题&quot;        v-model=&quot;title&quot;        maxlength=&quot;20&quot;        clearable      &gt;      &lt;/el-input&gt;      &lt;el-tabs v-model=&quot;activeName&quot;&gt;        &lt;el-tab-pane label=&quot;markdown&quot; name=&quot;markdown&quot;&gt;          &lt;markdown&gt;&lt;/markdown&gt;        &lt;/el-tab-pane&gt;        &lt;el-tab-pane label=&quot;富文本&quot; name=&quot;editor&quot;&gt;          &lt;editor&gt;&lt;/editor&gt;        &lt;/el-tab-pane&gt;      &lt;/el-tabs&gt;    &lt;/el-card&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import Editor from &quot;./components/Editor.vue&quot;;import Markdown from &quot;./components/Markdown.vue&quot;;import &#123; ref &#125; from &quot;vue&quot;;const activeName = ref(&quot;markdown&quot;);const title = ref(&quot;&quot;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.title-input &#123;  margin-bottom: 20px;&#125;&lt;/style&gt;</code></pre><h2 id="1-3-markdown-编辑器：tui-editor"><a href="#1-3-markdown-编辑器：tui-editor" class="headerlink" title="1-3 markdown 编辑器：tui.editor"></a>1-3 markdown 编辑器：tui.editor</h2><blockquote><p>安装 plugin：</p></blockquote><pre><code class="shell">npm i @toast-ui/editor@3.0.2</code></pre><blockquote><p>渲染 markdown 基本结构</p></blockquote><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;markdown-container&quot;&gt;    &lt;!-- 渲染区 --&gt;    &lt;div id=&quot;markdown-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;bottom&quot;&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmitClick&quot;&gt;提交&lt;/el-button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;&#125; from &quot;vue&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.markdown-container &#123;  .bottom &#123;    margin-top: 20px;    text-align: right;  &#125;&#125;&lt;/style&gt;</code></pre><blockquote><p>初始化 editor</p></blockquote><pre><code class="js">&lt;script setup&gt;import MkEditor from &#39;@toast-ui/editor&#39;import &#39;@toast-ui/editor/dist/toastui-editor.css&#39;// 国际化部分// import &#39;@toast-ui/editor/dist/i18n/zh-cn&#39;import &#123; onMounted &#125; from &#39;vue&#39;import &#123; useStore &#125; from &#39;vuex&#39;// Editor实例let mkEditor// 处理离开页面切换语言导致 dom 无法被获取let elonMounted(() =&gt; &#123;  el = document.querySelector(&#39;#markdown-box&#39;)  initEditor()&#125;)const store = useStore()const initEditor = () =&gt; &#123;  mkEditor = new MkEditor(&#123;    el,    height: &#39;500px&#39;,    previewStyle: &#39;vertical&#39;  &#125;)  mkEditor.getMarkdown()&#125;&lt;/script&gt;</code></pre><blockquote><p>新建文本及新建文本的提交</p></blockquote><p>接口定义：</p><pre><code class="js">// src/api/article.js/** * 创建文章 */export const createArticle = (data) =&gt; &#123;  return request(&#123;    url: &quot;/article/create&quot;,    method: &quot;POST&quot;,    data,  &#125;);&#125;;/** * 编辑文章详情 */export const articleEdit = (data) =&gt; &#123;  return request(&#123;    url: &quot;/article/edit&quot;,    method: &quot;POST&quot;,    data,  &#125;);&#125;;</code></pre><blockquote><blockquote><p>注意：markwodn 和富文本最终都会处理提交事件，将提交合并到一个模块实现</p></blockquote></blockquote><pre><code class="js">// src/views/article-create/components/commit.jsimport &#123; createArticle, articleEdit &#125; from &quot;@/api/article&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;export const commitArticle = async (data) =&gt; &#123;  const res = await createArticle(data);  ElMessage.success(&quot;创建成功！&quot;);  return res;&#125;;export const editArticle = async (data) =&gt; &#123;  const res = await articleEdit(data);  ElMessage.success(&quot;编辑成功！&quot;);  return res;&#125;;// 将此方法导入到markdown.vue中import &#123; commitArticle &#125; from &quot;./commit&quot;;</code></pre><blockquote><p>提交文本事件的触发</p></blockquote><pre><code class="js">// markdown.vueconst props = defineProps(&#123;  title: &#123;    required: true,    type: String  &#125;&#125;)const emits = defineEmits([&#39;onSuccess&#39;])...// 处理提交const onSubmitClick = async () =&gt; &#123;  // 创建文章  await commitArticle(&#123;    title: props.title,    content: mkEditor.getHTML()  &#125;)  // 重置一下  mkEditor.reset()  emits(&#39;onSuccess&#39;)&#125;</code></pre><blockquote><p>父组件中处理传递的 title，处理 onSuccess 事件</p></blockquote><pre><code class="js">// 创建成功const onSuccess = () =&gt; &#123;  title.value = &quot;&quot;;&#125;;</code></pre><blockquote><p>markdown 文本编辑</p></blockquote><pre><code class="js">// 路径为src/views/article-detail/index.vue&lt;template&gt;  &lt;div class=&quot;article-detail-container&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123; detail.title &#125;&#125;&lt;/h2&gt;    &lt;div class=&quot;header&quot;&gt;      &lt;span class=&quot;author&quot;&gt;        作者：&#123;&#123; detail.author &#125;&#125;      &lt;/span&gt;      &lt;span class=&quot;time&quot;&gt;        时间: &#123;&#123; $filters.relativeTime(detail.publicDate) &#125;&#125;      &lt;/span&gt;      &lt;el-button type=&quot;text&quot; class=&quot;edit&quot; @click=&quot;onEditClick&quot;&gt;编辑&lt;/el-button&gt;    &lt;/div&gt;    &lt;div class=&quot;content&quot; v-html=&quot;detail.content&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;import &#123; useRoute, useRouter &#125; from &#39;vue-router&#39;import &#123; articleDetail &#125; from &#39;@/api/article&#39;// 获取数据const route = useRoute()const articleId = route.params.idconst detail = ref(&#123;&#125;)const getArticleDetail = async () =&gt; &#123;  detail.value = await articleDetail(articleId)&#125;getArticleDetail()// 编辑const router = useRouter()const onEditClick = () =&gt; &#123;  router.push(`/article/editor/$&#123;articleId&#125;`)&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.article-detail-container &#123;  .title &#123;    font-size: 22px;    text-align: center;    padding: 12px 0;  &#125;  .header &#123;    padding: 26px 0;    .author &#123;      font-size: 14px;      color: #555666;      margin-right: 20px;    &#125;    .time &#123;      font-size: 14px;      color: #999aaa;      margin-right: 20px;    &#125;    .edit &#123;      float: right;    &#125;  &#125;  .content &#123;    font-size: 14px;    padding: 20px 0;    border-top: 1px solid #d4d4d4;    ;  &#125;&#125;&lt;/style&gt;</code></pre><blockquote><p>将数据传递给 markdown 组件</p></blockquote><pre><code class="js">&lt;markdown :title=&quot;title&quot; :detail=&quot;detail&quot; @onSuccess=&quot;onSuccess&quot;&gt;&lt;/markdown&gt;// 数据接收const props = defineProps(&#123;  title: &#123;    required: true,    type: String  &#125;,  detail: &#123;    type: Object  &#125;&#125;)</code></pre><blockquote><p>使用 watch 检测数据变化，存在 detail 时，将 detail 赋值给 mkEditor</p></blockquote><pre><code class="js">// 编辑相关watch(  () =&gt; props.detail,  (val) =&gt; &#123;    if (val &amp;&amp; val.content) &#123;      mkEditor.setHTML(val.content);    &#125;  &#125;,  &#123;    immediate: true,  &#125;);</code></pre><blockquote><p>markdown 组件中处理提交事件</p></blockquote><pre><code class="js">// 处理提交const onSubmitClick = async () =&gt; &#123;  if (props.detail &amp;&amp; props.detail._id) &#123;    // 编辑文章    await editArticle(&#123;      id: props.detail._id,      title: props.title,      content: mkEditor.getHTML(),    &#125;);  &#125; else &#123;    // 创建文章    await commitArticle(&#123;      title: props.title,      content: mkEditor.getHTML(),    &#125;);  &#125;  mkEditor.reset();  emits(&quot;onSuccess&quot;);&#125;;</code></pre><h2 id="1-4-富文本编辑器：wangEditor"><a href="#1-4-富文本编辑器：wangEditor" class="headerlink" title="1-4 富文本编辑器：wangEditor"></a>1-4 富文本编辑器：wangEditor</h2><blockquote><p>安装 plugin</p></blockquote><pre><code class="shell">npm i wangeditor@4.7.6</code></pre><blockquote><p>富文本的基本组件结构和 markdown 组件基本一致</p></blockquote><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;editor-container&quot;&gt;    &lt;div id=&quot;editor-box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;bottom&quot;&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmitClick&quot;&gt;提交&lt;/el-button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import E from &#39;wangeditor&#39;import &#123; onMounted, defineProps, defineEmits, watch &#125; from &#39;vue&#39;import &#123; useStore &#125; from &#39;vuex&#39;import &#123; commitArticle, editArticle &#125; from &#39;./commit&#39;const props = defineProps(&#123;  title: &#123;    required: true,    type: String  &#125;,  detail: &#123;    type: Object  &#125;&#125;)const emits = defineEmits([&#39;onSuccess&#39;])const store = useStore()// Editor实例let editor// 处理离开页面切换语言导致 dom 无法被获取let elonMounted(() =&gt; &#123;  el = document.querySelector(&#39;#editor-box&#39;)  initEditor()&#125;)const initEditor = () =&gt; &#123;  editor = new E(el)  editor.config.zIndex = 1  // 菜单栏提示  editor.config.showMenuTooltips = true  editor.config.menuTooltipPosition = &#39;down&#39;  editor.create()&#125;// 编辑相关watch(  () =&gt; props.detail,  val =&gt; &#123;    if (val &amp;&amp; val.content) &#123;      editor.txt.html(val.content)    &#125;  &#125;,  &#123;    immediate: true  &#125;)// 处理文本提交的事件const onSubmitClick = async () =&gt; &#123;  if (props.detail &amp;&amp; props.detail._id) &#123;    // 编辑文章    await editArticle(&#123;      id: props.detail._id,      title: props.title,      content: editor.txt.html()    &#125;)  &#125; else &#123;    // 创建文章    await commitArticle(&#123;      title: props.title,      content: editor.txt.html()    &#125;)  &#125;  editor.txt.html(&#39;&#39;)  emits(&#39;onSuccess&#39;)&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.editor-container &#123;  .bottom &#123;    margin-top: 20px;    text-align: right;  &#125;&#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100、vuex的缺点及从0写一个vuex的思路</title>
      <link href="/2022/11/29/100-vuex/"/>
      <url>/2022/11/29/100-vuex/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>1、用过 module，项目规模变大之后，单独一个 store 对象会过于庞大臃肿，通过模块方式可以拆分开来便于维护</p><p>2、可以按之前规则单独编写子模块代码，然后在主文件中通过<code>modules</code>选项组织起来：<code>createStore(&#123;modules:&#123;...&#125;&#125;)</code>。</p><p>3、不过使用时要注意访问子模块状态时需要加上注册时模块名：<code>store.state.a.xxx</code>，但同时<code>getters</code>、<code>mutations</code>和<code>actions</code>又在全局空间中，使用方式和之前一样。如果要做到完全拆分，需要在子模块加上<code>namespace</code>选项，此时再访问它们就要加上命名空间前缀。</p><p>很显然，模块的方式可以拆分代码，但是缺点也很明显，就是使用起来比较繁琐复杂，容易出错。而且类型系统支持很差，不能给我们带来帮助。pinia 显然在这方面有了很大改进，是时候切换过去了。</p><p>修改状态只能是<code>mutations</code>，<code>actions</code>只能通过提交<code>mutation</code>修改状态即可</p><p>官方文档说：更改 Vuex 的 store 中的状态的唯一方法是提交 <code>mutation</code>，<code>mutation</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的<strong>类型 (type)**和一个** 回调函数 (handler)</strong> 。<code>Action</code> 类似于 <code>mutation</code>，不同在于：<code>Action</code>可以包含任意异步操作，但它不能修改状态， 需要提交<code>mutation</code>才能变更状态。</p><p>因此，开发时，包含异步操作或者复杂业务组合时使用 action；需要直接修改状态则提交 mutation。但由于 dispatch 和 commit 是两个 API，容易引起混淆，实践中也会采用统一使用 dispatch action 的方式。</p><p>调用 dispatch 和 commit 两个 API 时几乎完全一样，但是定义两者时却不甚相同，mutation 的回调函数接收参数是 state 对象。action 则是与 Store 实例具有相同方法和属性的上下文 context 对象，因此一般会解构它为<code>&#123;commit, dispatch, state&#125;</code>，从而方便编码。另外 dispatch 会返回 Promise 实例便于处理内部异步结果。</p><p>实现上 commit(type)方法相当于调用<code>options.mutations[type](state)</code>；<code>dispatch(type)</code>方法相当于调用<code>options.actions[type](store)</code>，这样就很容易理解两者使用上的不同了。</p><blockquote><p>如何从零写一个 vuex？思路是什么？</p></blockquote><ol><li>官方说<code>vuex</code>是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个<code>vuex</code>：<ul><li>要实现一个<code>Store</code>存储全局状态</li><li>要提供修改状态所需 API：<code>commit(type, payload)</code>, <code>dispatch(type, payload)</code></li></ul></li><li>实现<code>Store</code>时，可以定义 Store 类，构造函数接收选项 options，设置属性 state 对外暴露状态，提供 commit 和 dispatch 修改属性 state。这里需要设置 state 为响应式对象，同时将 Store 定义为一个 Vue 插件。</li><li><code>commit(type, payload)</code>方法中可以获取用户传入<code>mutations</code>并执行它，这样可以按用户提供的方法修改状态。 <code>dispatch(type, payload)</code>类似，但需要注意它可能是异步的，需要返回一个 Promise 给用户以处理异步结果。</li></ol><pre><code class="js">class Store &#123;  constructor(options) &#123;    this.state = reactive(options.state);    this.options = options;  &#125;  commit(type, payload) &#123;    this.options.mutations[type].call(this, this.state, payload);  &#125;&#125;</code></pre><p>vuex 如何监听数据的变化？</p><blockquote><p>可以通过 watch 选项或者 watch 方法监听状态</p><p>可以使用 vuex 提供的 API：store.subscribe()</p></blockquote><p>watch 选项方式，可以以字符串形式监听<code>$store.state.xx</code>；subscribe 方式，可以调用 store.subscribe(cb),回调函数接收 mutation 对象和 state 对象，这样可以进一步判断 mutation.type 是否是期待的那个，从而进一步做后续处理。</p><p>watch 方式简单好用，且能获取变化前后值，首选；subscribe 方法会被所有 commit 行为触发，因此还需要判断 mutation.type，用起来略繁琐，一般用于 vuex 插件中。</p><pre><code class="js">// watchconst app = createApp(&#123;  watch: &#123;    &quot;$store.state.counter&quot;() &#123;      console.log(&quot;counter change!&quot;);    &#125;,  &#125;,&#125;);// subscriblestore.subscribe((mutation, state) =&gt; &#123;  if (mutation.type === &quot;add&quot;) &#123;    console.log(&quot;counter change in subscribe()!&quot;);  &#125;&#125;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>99、script标签写export为什么会报错?</title>
      <link href="/2022/11/27/99-script%E6%A0%87%E7%AD%BE%E5%86%99%E4%B8%8Aexport/"/>
      <url>/2022/11/27/99-script%E6%A0%87%E7%AD%BE%E5%86%99%E4%B8%8Aexport/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="一、脚本和模块"><a href="#一、脚本和模块" class="headerlink" title="一、脚本和模块"></a>一、脚本和模块</h4><p>​ JavaScript 有 2 种源文件，一种叫做脚本，一种叫做模块。这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前版本中，就只有一种源文件格式，即脚本。</p><p>​ 脚本是可以由浏览器或者 node 环境引入执行的，而模块智能有 JavaScript 代码用 import 引入执行。</p><p>​ 脚本具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块是被动行的 JavaScript 代码段，是等待被调用的库。</p><p>​ 实际上，<code>模块和脚本之间的区别仅仅在于是否包含import和export</code>。</p><p>​ 脚本是一种兼容之前的版本的定义，在这个模式下，没有 import 就不需要处理加载.js 文件问题。</p><p>​ 现代浏览器可以支持用 script 标签引入模块或者脚本，如果需要引入模块，必须给 script 标签添加 type=”module”。如果引入脚本，则不需要 type。</p><pre><code class="js">&lt;script type=&quot;module&quot; scr=&quot;XXX.js&quot;&gt;&lt;/script&gt;</code></pre><p>​ script 标签如果不加 type=“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会抛错。</p><p>​ 脚本可以包含语句。模块包含 3 中内容：import 声明、export 声明、语句。</p><p>​ <code>import声明</code>用法有 2 种：一个是<code>直接import一个模块</code>、另一个是``带from的import`（能引入模块里的一些信息）</p><pre><code class="js">import &quot;module&quot;; // 引入一个模块import m from &quot;module&quot;; // 把模块默认的导出值放入变量m</code></pre><p>​ 用法 1 直接 import 一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。</p><p>​ 用法 2 带 from 的 import 意思是引入模块中的一部分信息，可以把他们变成本地的变量。</p><p>​ 带 from 的 import 又分为 3 种用法：</p><pre><code class="js">import x from &quot;./a.js&quot;; // 引入模块中导出的默认值import &#123; a as x, modify &#125; from &quot;./a.js&quot;; // 引入模块中的变量import * as x from &quot;./a.js&quot;; // 把模块中所有的变量以类型对象属性的方式引入// 第一种方式还可以跟后两种组合使用import d, &#123; a as x, modify &#125; from &quot;./a.js&quot;;import d, * as x from &quot;./a.js&quot;;</code></pre><p>​ 语法要求不带 as 的默认值永远在最前。注意，这里的变量实际上仍然可以受到原来模块的控制。</p><p>示例代码：</p><p><code>模块a</code></p><pre><code class="js">export var a = 1;export function modify() &#123;  a = 2;&#125;</code></pre><p><code>模块b</code></p><pre><code class="js">import &#123; a, modify &#125; from &quot;./a.js&quot;;console.log(a);modify();console.log(a);</code></pre><p>​ 当我们调用修改变量的函数后，b 模块变量也跟着发生了改变。这说明导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。</p><p><code>export声明</code>：承担的是导出的任务。</p><p>​ 模块中导出变量的方式有两种，一种是独立使用 export 声明，一种是直接在声明型语句前添加 export 关键字。</p><p>​ 独立使用 export 声明就是一个 export 关键字加上变量名列表。</p><pre><code class="js">export &#123; a, b, c &#125;;</code></pre><p>​ 我们也可以直接在声明型语句前添加 export 关键字，这里的 export 可以加在任何声明性质的语句之前</p><pre><code class="js">varfunction(含async 和generator)classletconst</code></pre><p>​ export 还有一种特殊的用法，就是跟 default 联合使用。export default 表示到处一个默认变量值，它可以用于 function 和 class。这里导出的变量是没有名称的，可以使用 import x from ‘./a.js’ 这样的语法，在模块中引入。</p><p>​ export default 还支持一种语法，后面跟一个表达式</p><pre><code class="js">var a = &#123;&#125;;export default a;</code></pre><p>​ 但是，这里的行为跟导出变量是不一致，这里导出的是值，<code>导出的就是普通变量a的值，以后a的变化与导出的值就无关了</code>，修改变量 a，不会使得其他模块中引入的 default 值发生改变。</p><p>​ 在 import 语句前无法加入 export，但是我们可以直接使用 export from 语法</p><pre><code class="js">export a from &quot;a.js&quot;;</code></pre><p>​ JavaScript 引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处。</p><h4 id="二、函数体"><a href="#二、函数体" class="headerlink" title="二、函数体"></a>二、函数体</h4><blockquote><p>执行函数的行为通常是在 JavaScript 代码执行时，注册宿主环境的某些事件触发的，而执行的过程，就是执行函数体（函数的花括号中间的部分）。</p></blockquote><p>下面的 setTimeout 函数注册了一个函数给宿主，当一定时间之后，宿主就会执行这个函数。</p><pre><code class="js">setTimeout(function () &#123;  console.log(&quot;go&quot;);&#125;, 10000);</code></pre><p>宿主会为这样的函数创建宏任务。宏任务中可能会执行的代码包括脚本、模块、函数体。</p><p>函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了 return 语句可以用。</p><p><code>普通函数体</code>：</p><pre><code class="js">function foo() &#123;  //function body&#125;</code></pre><p><code>异步函数体</code>：</p><pre><code class="js">async function foo() &#123;  // function body&#125;</code></pre><p><code>生成器函数体</code>：</p><pre><code class="js">function* foo() &#123;  // function body&#125;</code></pre><p><code>异步生成器函数体</code>：</p><pre><code class="js">async function* foo() &#123;  // function body&#125;</code></pre><p>上面的 4 种函数体的区别在于：能否使用 await 或者 yield</p><p>类型 yield await return import&amp;export</p><p>普通函数体 X X √ X</p><p>异步函数体 X √ √ X</p><p>生成器函数体 √ X √ X</p><p>异步生成器函数体 √ √ √ X</p><p>脚本 X X X X</p><p>模块 X X X √</p><h4 id="三、预处理机制"><a href="#三、预处理机制" class="headerlink" title="三、预处理机制"></a>三、预处理机制</h4><p>JavaScript 语法的全局机制：预处理和指令序言。这 2 个机制对于我们解释一些 JavaScript 的语法现象非常重要。预处理机制可以理解 var 等声明类语句行为，指令序言可以解释严格模式。</p><p><code>预处理</code>：JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p><p><code>var声明</code>：var 声明永远作用于脚本、模块和函数体，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。</p><pre><code class="js">var a = 1;function foo() &#123;  console.log(a); // undefined  var a = 2;&#125;foo();</code></pre><p>上面的代码声明了一个脚本级别的 a，又声明了 foo 函数体级别的 a，函数体级的 var 出现在 console.log 语句之后。</p><p>预处理过程在执行前，所以有函数体级的变量 a，就不会去访问外层作用域中的变量 a 了，而函数体级的变量 a 此时还没有复制，所以是 undefined。</p><pre><code class="js">var a = 1;function foo() &#123;  console.log(a);  if (false) &#123;    var a = 2;  &#125;&#125;foo();</code></pre><p>这段代码比上一段代码在 var a = 2 之外多了一段 if，我们知道 if(false) 中的代码永远不会被执行，但是预处理阶段并不管这个，var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。所以这里结果跟前一段代码完全一样，我们会得到 undefined。</p><pre><code class="js">var a = 1;function foo() &#123;  var o = &#123; a: 3 &#125;;  with (o) &#123;    var a = 2;  &#125;  console.log(o.a);  console.log(a);&#125;foo();</code></pre><p>引入 with 语句，with(o)创建了一个作用域，并把 o 对象加入词法环境，在其中使用了 var a = 2 语句。</p><p>在预处理阶段，只认 var 中声明的变量，所以同样为 foo 的作用域创建了 a 这个变量，但是没有赋值。在执行阶段，当执行到 var a = 2 时，作用域变成了 with 语句内，这时候的 a 被认为访问到了对象 o 的属性 a，所以最终执行的结果，我们得到了 2 和 undefined。</p><p><code>function声明</code>：function 声明的行为，在全局（脚本、模块和函数体），function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值。</p><pre><code class="js">console.log(foo);function foo() &#123;&#125;</code></pre><p>在声明函数 foo 之前，打印函数 foo,我们可以发现，已经是函数 foo 的值了。</p><p>下面示例不再被提前赋值：</p><pre><code class="js">console.log(foo); // undefinedif (true) &#123;  function foo() &#123;&#125;&#125;</code></pre><p>function 声明出现在 if 等语句中，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值。</p><p>上述打印结果为 undefined，声明 function 在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。</p><p>出现在 if 等语句中的 function，在 if 创建的作用域中仍然会被提前，产生赋值效果。</p><p><code>class声明</code>：在全局的行为跟 function 和 var 都不一样。</p><p>在 class 声明前使用 class 类名，会抛出错误：</p><pre><code class="js">console.log(c); // c is not definedclass c &#123;&#125;</code></pre><p>这个抛错很像是 class 没有预处理，但实际上并非如此。</p><p>复杂一点的例子：</p><pre><code class="js">var c = 1;function foo() &#123;  console.log(c);  class c &#123;&#125;&#125;foo();</code></pre><p>上面的代码，把 class 放进了一个函数体中，在外层作用域中有变量 c。</p><p>执行后，我们看到，仍然抛出了错误，如果去掉 class 声明，则会正常打印出 1，也就是说，出现在后面的 class 声明影响了前面语句的结果。这说明，class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。</p><p>class 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。</p><h4 id="四、指令序言机制"><a href="#四、指令序言机制" class="headerlink" title="四、指令序言机制"></a>四、指令序言机制</h4><blockquote><p>脚本和模块都支持一种特别的语法，指令序言最早是为了 use strict 设计的，它规定了一种给 JavaScript 代码添加元信息的方式。</p></blockquote><pre><code class="js">&quot;use strict&quot;;function f() &#123;  console.log(this);&#125;f.call(null);</code></pre><p>null 原封不动地被当做 this 值打印了出来，这是严格模式的特征。</p><p>去掉严格模式，打印结果会变成 global。</p><p>‘use strict’是 JavaScript 标准中规定的唯一一种指令序言，但是设计指令序言的目的是留给 JavaScript 的引擎和实现者一些统一的表达式，在静态规定扫描时指定 JavaScript 代码的一些特性。</p><p>JavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。</p><pre><code class="js">function doSth() &#123;  //&#125;(&quot;use strict&quot;);var a = 1;// .....</code></pre><p>‘use strct’没有出现在最前，所以不是指令序言。</p><pre><code class="js">&quot;use strict&quot;; // 单引号也是指令序言function doSth() &#123;  // ....&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98、基于JavaScript开发灵活的数据应用--基本数据处理(一)</title>
      <link href="/2022/11/26/98-js-string-number-array/"/>
      <url>/2022/11/26/98-js-string-number-array/</url>
      
        <content type="html"><![CDATA[<p>现代编程语言中，最基本的数据格式都会是字符串和数字。字符串用于表达人类文明的自然语言，数字用于表达量化世界的各种数值。</p><span id="more"></span><h2 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h2><p>字符串的运用包括，字符串的创建、分割、大小写转换、拼接等</p><h4 id="1-1-创建字符串"><a href="#1-1-创建字符串" class="headerlink" title="1-1 创建字符串"></a>1-1 创建字符串</h4><p>在 JavaScript 中创建一个字符串跟其他语言并没有较大的区别，可以分别使用 ‘、” 和 ` 作为边界标识。</p><pre><code class="js">const str1 = &quot;string 1&quot;;const str2 = &quot;string 2&quot;;const str3 = `string 3`;</code></pre><p>从 JavaScript 的语法定义上 ‘ 和 “ 并没有太大的差别，但是 ` 的用途较为特殊。 同样可以以与 ‘ 和 “ 一样的使用方式使用，但也可以有更高级的用法。</p><p>例如：</p><pre><code class="js">const target = &quot;world&quot;;const word = `hello $&#123;target&#125;`; // =&gt; hello world</code></pre><p>同时 ` 也可以用于创建一个“多行字符串”，即字符串内容中包含多行文本。</p><h4 id="1-2-分割字符串"><a href="#1-2-分割字符串" class="headerlink" title="1-2 分割字符串"></a>1-2 分割字符串</h4><p>例如：如何将 “Hey jude,how is it going?” 转换为“hey jude how is it going”</p><p>二者不同之处在于，去除了文本中的标点符号、数字、大写字母转换为小写字母。</p><p>任务理解：去除标点符号、数字可以说是只保留英文字母，只需筛选出英文字母和空格即可，需要使用 ASCII 码进行甄别，大写字母的 ASCII 码范围为 65 到 90（即：A-Z），小写字母则为 97 到 122，空格的 ASCII 码为 32，换行符的 ASCII 码为 10。JS 中可以用 string.charCodeAt()方法获取字符串的 ASCII 码。</p><pre><code class="js">const originalText = &quot;Hey jude,how is it going?&quot;;let wordOnlyText = &quot;&quot;;for (let i = 0; i &lt; originalText.length; i++) &#123;  const letter = originalText[i];  const asciiCode = letter.charCodeAt();  if (    (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) ||    (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) ||    asciiCode === 32  ) &#123;    wordOnlyText += letter;  &#125;&#125;console.log(wordOnlyText); // =&gt; Hey judehow is it going</code></pre><p>将大写字母转换为小写字母</p><p>string.charCodeAt() 方法来获取字符的 ASCII 码，那么自然也有对应的方法用于将 ASCII 码转换为对应字符 String.fromCharCode(code)。</p><p>而从字母的 ASCII 码范围可以看到，将大写字母的 ASCII 码数值加上 32 便是其对应小写字母的 ASCII 码数值。</p><pre><code class="js">let lowerCaseText = &quot;&quot;;for (let i = 0; i &lt; wordOnlyText.length; ++i) &#123;  const letter = wordOnlyText[i];  const asciiCode = letter.charCodeAt();  if (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) &#123;    lowerCaseText += String.fromCharCode(asciiCode + 32);  &#125; else &#123;    lowerCaseText += letter;  &#125;&#125;console.log(lowerCaseText); // =&gt; hey judehow is it going</code></pre><p>在 JavaScript 中早就已经内置了将文本中的大写字母转换为小写字母的 API 了 —— string.toLowerCase()。</p><pre><code class="js">const lowerCaseText = wordOnlyText.toLowerCase();</code></pre><h4 id="1-3-字符串的分割"><a href="#1-3-字符串的分割" class="headerlink" title="1-3 字符串的分割"></a>1-3 字符串的分割</h4><p>最主要用到的方法便是 string.split(separator)，其中这个 separator 则是定义了用于分割字符串内容的“分割符”。</p><pre><code class="js">const originalText = `Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.`;let wordOnlyText = &quot;&quot;;for (let i = 0; i &lt; originalText.length; ++i) &#123;  const letter = originalText[i];  const asciiCode = letter.charCodeAt();  if (    (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) ||    (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) ||    asciiCode === 32  ) &#123;    wordOnlyText += letter;  &#125;&#125;const lowerCaseText = wordOnlyText.toLowerCase();const words = lowerCaseText.split(&quot; &quot;);console.log(words.length); //=&gt; 160</code></pre><h4 id="1-4-字符串的拼接"><a href="#1-4-字符串的拼接" class="headerlink" title="1-4 字符串的拼接"></a>1-4 字符串的拼接</h4><p>除了对字符串进行拆分以外，我们也常常需要将不同的信息通过各种方式拼装成一个完整的字符串信息。最常见的例子便是我们几乎每天都能遇见的，由程序自动发送的自动短信、自动邮件等。</p><p>字符串之间的连接可以直接使用 + 运算符完成。</p><pre><code class="js">const str1 = &quot;hello&quot;;const str2 = &quot;world&quot;;console.log(str1 + &quot; &quot; + str2); // =&gt; &#39;hello world&#39;</code></pre><p>使用 + 运算符是最基本的字符串拼接方式，适用于数据量较小的字符串拼接。数据量大时，我们需要将多个数据量‘嵌入’到文本模板中，这种情况通常可以使用模板引擎来实现这个功能。</p><pre><code class="js">const name = &quot;jude&quot;;const level = &quot;Gold&quot;;const message = `Hello,$&#123;name&#125;.Here is LOL account,you are the $&#123;level&#125; of our games.`;console.log(message);// =&gt; Hello,jude.// Here is LOL account,you are the Gold of our games.</code></pre><p>loading…</p><h2 id="二、对象字面量"><a href="#二、对象字面量" class="headerlink" title="二、对象字面量"></a>二、对象字面量</h2><h4 id="2-1-对象的内容读取"><a href="#2-1-对象的内容读取" class="headerlink" title="2-1 对象的内容读取"></a>2-1 对象的内容读取</h4><p>JavaScript 中对象内容读取十分的简单，如果属性键为字符串，且该字符串中只包含英文字母和下划线的话，可以直接用 <obj>.<key> 来读取属性值。</p><pre><code class="js">const person = &#123;  name: &quot;jude&quot;,  age: &quot;18&quot;,  skills: &#123;    title: &quot;vue&quot;,    desc: &quot;mvvm&quot;,    author: &quot;Evan You&quot;,  &#125;,  others: &quot;....&quot;,&#125;;console.log(person.name); // =&gt; judeconsole.log(person.skills.title); // =&gt; vue</code></pre><p>而当对象中所需要读取的目标属性键为数字、包含英文字母和下划线以外的字符串甚至是 Symbol 对象的时候，就需要使用 obj[key] 的形式来读取属性值了。</p><pre><code class="js">const obj = &#123;  1: 2,  &quot;a b c&quot;: &quot;d e f&quot;,  [Symbol.for(&quot;foo&quot;)]: &quot;bar&quot;,&#125;;console.log(obj[1]); // =&gt; 2console.log(obj[&quot;a b c&quot;]); // =&gt; d e fconsole.log(obj[Symbol.for(&quot;foo&quot;)]); // =&gt; bar</code></pre><h4 id="2-2-修改对象内容"><a href="#2-2-修改对象内容" class="headerlink" title="2-2 修改对象内容"></a>2-2 修改对象内容</h4><p>const 语句定义的对象是不能直接被替换，但是其中的内容依然是能被修改的。<br>在 JavaScript 中存在着“引用”和“值”的概念区别，对对象内容进行修改跟进行读取类似，只是在读取语句后面加上 = <new value> 即可。</p><pre><code class="js">const obj = &#123;  foo: &quot;bar&quot;,  1: 2,  &quot;a b c&quot;: &quot;d e f&quot;,  [Symbol.for(&quot;foo&quot;)]: &quot;bar&quot;,&#125;;obj.foo = &quot;read&quot;;obj[1] = 3;console.log(obj.foo); // =&gt; readconsole.log(obj[1]); // =&gt; 3</code></pre><p>当你需要为一个对象添加新的属性时，也是通过同样的方式添加属性。</p><pre><code class="js">const obj = &#123;&#125;;obj.foo = &quot;bar&quot;;obj[1] = 2;</code></pre><p>在一般情况下，无论是对对象进行添加、读取还是修改属性，都遵循着嵌套链完整的原则</p><pre><code class="js">const outer = &#123;  inner: &#123;&#125;,&#125;;outer.inner.foo = &quot;bar&quot;; // successouter.something.bar = 1; // error</code></pre><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><h4 id="3-1-数组增加内容"><a href="#3-1-数组增加内容" class="headerlink" title="3-1 数组增加内容"></a>3-1 数组增加内容</h4><p>向数组内增加内容包括向数组首端、末尾、中间添加新内容</p><blockquote><p>添加到末端：array.push()</p></blockquote><pre><code class="js">const array = [];array.push(1);console.log(array); // =&gt; [1]array.push(2, 3);console.log(array); // =&gt; [1,2,3]console.log(array.length); // 3</code></pre><blockquote><p>添加到首端: array.unshift()</p></blockquote><pre><code class="js">const array = [4, 5];array.unshift(3);console.log(array); // =&gt; [3,4,5]array.unshift(1, 2);console.log(array); // =&gt; [1,2,3,4,5]</code></pre><blockquote><p>添加到数组中间某一位置：array.splice(start,deleteCount,element,….)</p></blockquote><p>该方法第二个参数是 deleteCount，因为这个方法也可以用来删除数组中某一个位置开始的若干个元素，而当我们将这个参数设置为 0 的时候，该方法第三个以及后面的参数便会插入到下标为 start 的位置，后面的元素自动往后推导。</p><pre><code class="js">const array = [1, 2, 6, 7];array.splice(2, 0, 3);console.log(array); // =&gt; [1,2,3,6,7]array.splice(3, 0, 4, 5);console.log(array); // =&gt; [1,2,3,4,5,6,7]</code></pre><blockquote><p>查找内容：filter</p></blockquote><p>filter 过滤器的逻辑便是定义一个过滤函数，该函数会有序地被传入数组中当前下标的元素，而它则需要返回该函数是否符合其过滤要求，即结果为 true 或 false。</p><pre><code class="js">const array = [1, 2, 3, 4, 5, 6, 7, 8];const evenNumbers = array.filter(function (x) &#123;  return x % 2 == 0;&#125;);console.log(evenNumbers); // =&gt; [2,4,6,8]</code></pre><blockquote><p>删除内容：array.splice(start,deleteCount)</p></blockquote><pre><code class="js">const array = [1, 2, 3, 10, 4, 5];array.splice(3, 1);console.log(array); // =&gt; [1,2,3,4,5]</code></pre><blockquote><p>更新内容</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];array[0] = 10;console.log(array); // =&gt; [10,2,3,4,5]</code></pre><blockquote><p>封装数组操作工具</p></blockquote><p>虽然绝大多数操作都可以直接使用 JavaScript 中自带的 API 来实现，但是如 array.splice() 这种方法看上去就很容易产生操作错误。那么为了避免开发中的失误，我们可以通过定义一个抽象对象来封装一个用于操作数组的工具库。</p><pre><code class="js">const arrayUtils = &#123;  // 末端添加  append(array,...elements)&#123;    array.push(...elements)    return array  &#125;,  // 首端添加  prepend(array,...elements)&#123;    array.unshift(...elements)    return array  &#125;  // 中间插入  insert(array,index,...elements)&#123;    array.splice(index,0,...elements)    return array  &#125;  // 删除内容  remove(array,index)&#123;    array.splice(index,1)    return array  &#125;&#125;// 使用const array = []arrayUtils.append(array,3)arrayUtils.prepend(array,1)arrayUtils.insert(array,1,2)console.log(array) // =&gt; [1,2,3]arrayUtils.remove(array,1)console.log(array) // =&gt; [1,3]</code></pre><h4 id="3-2-数组转换-聚合"><a href="#3-2-数组转换-聚合" class="headerlink" title="3-2 数组转换/聚合"></a>3-2 数组转换/聚合</h4><blockquote><p>map</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];const addedArray = array.map(function (x) &#123;  return x + 2;&#125;);console.log(addedArray); // =&gt; [3,4,5,6,7]</code></pre><blockquote><p>reduce</p></blockquote><pre><code class="js">const array = [1,2,3,4]const sumResult = array.reduce(function(a,b)&#123;  return a + b&#125;)console.log(sumResult) // =&gt; 10function multi(array)&#123;  return array.reduce(function(a,b)&#123;    return a * b  &#125;)&#125;console.log(multi(array))// 函数式编程，进一步抽象封装const array = [1,2,3,4]function reduceFn(callback)&#123;  return funtion(array)&#123;    return array.reduce(callback)  &#125;&#125;const sum = reduceFn(function(a,b)&#123;  return a + b&#125;)const multi = reduceFn(function(a,b)&#123;  return a + b&#125;)console.log(sum(array)) // =&gt; 10console.log(multi(array)) // =&gt; 24</code></pre><blockquote><p>1、将数组[1,2,3,4,5] 转换为 [‘a1’,’a2’,’a3’,’a4’,’a5’]</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];const result = array.map((item) =&gt; &#123;  return &quot;a&quot; + item;&#125;);</code></pre><blockquote><p>将数组 [ 1, 2, 3, 4, 5 ] 转换为 [ ‘a1’, ‘b2’, ‘c3’, ‘d4’, ‘e5’ ]</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];const result = array.map((item) =&gt; &#123;  return String.fromCharCode(96 + item) + item;&#125;);console.log(result);</code></pre><blockquote><p>将数组 [ 1, 2, 3, 4, 5 ] 转换为 [ 1, 4, 9, 16, 25 ]</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];const result = array.map((item) =&gt; &#123;  return Math.pow(item, 2);&#125;);console.log(result);</code></pre><blockquote><p>查询 JavaScript 中 Array.prototype.map 方法的详细文档，并将数组 [ 0, 0, 0, 0, 0 ] 转换为 [ ‘A’, ‘B’, ‘C’, ‘D’, ‘E’ ]</p></blockquote><pre><code class="js">const array = [0, 0, 0, 0, 0];const result = array.map((item, index) =&gt; &#123;  return String.fromCharCode(65 + index);&#125;);console.log(result);</code></pre><blockquote><p>提取数组 [ 1, 2, 3, 4, 5 ] 中的 [ 2, 3, 4 ]</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4, 5];const result = array.filter((item) =&gt; &#123;  return item &gt; 1 &amp;&amp; item &lt; 5;&#125;);console.log(result);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>97、promise代码为什么比setTimeout先执行？</title>
      <link href="/2022/11/23/97-promise/"/>
      <url>/2022/11/23/97-promise/</url>
      
        <content type="html"><![CDATA[<p>​ 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p><span id="more"></span><h4 id="一、JavaScript-的执行"><a href="#一、JavaScript-的执行" class="headerlink" title="一、JavaScript 的执行"></a>一、JavaScript 的执行</h4><p>​ 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。</p><p>​ 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。</p><p>​ JavaScript 语言，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p><h4 id="二、宏观任务与微观任务"><a href="#二、宏观任务与微观任务" class="headerlink" title="二、宏观任务与微观任务"></a>二、宏观任务与微观任务</h4><p>​ JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。</p><blockquote><p>宏观任务的队列就相当于事件循环</p></blockquote><p>​ 在宏观任务中，JavaScript 的 promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此每个宏观任务中又包含一个微观任务队列。</p><p>MacroTask</p><p>​ microTask microTask microTask</p><p>MacroTask</p><p>​ microTask microTask microTask</p><p>MacroTask</p><p>​ 有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：<code>Promise 永远在队列尾部添加微观任务</code>。setTimeout 等宿主 API，则会添加宏观任务。</p><h4 id="三、Promise"><a href="#三、Promise" class="headerlink" title="三、Promise"></a>三、Promise</h4><p>​ Promise 是 JavaScript 语言提供的一种标准化的异步管理方式。promise 总体思想是，需要进行 IO、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（promise 的 then 方法回调）</p><pre><code class="js">function sleep(duration) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(resolve, duration);  &#125;);&#125;sleep(1000).then(() =&gt; console.log(&quot;finished&quot;));</code></pre><p>sleep 函数的作用：等候传入参数指定的时长。</p><p>Promise 的 then 回调是一个异步的执行过程。示例代码：</p><pre><code class="js">var test = new Promise(function (resolve, reject) &#123;  console.log(&quot;a&quot;);  resolve();&#125;);test.then(() =&gt; console.log(&quot;c&quot;));console.log(&quot;b&quot;);</code></pre><blockquote><p>打印顺序：a &gt; b &gt; c</p></blockquote><p>​ 在进入 console.log(‘b’)之前，毫无疑问 test 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。</p><p>当 setTimeout 和 Promise 混用，设置两段互不相干的异步操作：通过 setTimeout 执行 console.log(‘d’)，通过 Promise 执行 console.log(‘c’)</p><pre><code class="js">var test = new Promise(function (resolve, reject) &#123;  console.log(&quot;a&quot;);  resolve();&#125;);setTimeout(() =&gt; console.log(&quot;d&quot;), 0);test.then(() =&gt; console.log(&quot;c&quot;));console.log(&quot;b&quot;);</code></pre><p>我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。</p><p>理解<code>微任务始终先于宏任务</code>，示例：</p><pre><code class="js">// 执行一个耗时1秒的PromisesetTimeout(() =&gt; console.log(&quot;d&quot;), 0);var r = new Promise(function (resolve, reject) &#123;  resolve();&#125;);r.then(() =&gt; &#123;  var begin = Date.now();  while (Date.now() - begin &lt; 1000);  console.log(&quot;c1&quot;);  new Promise(function (resolve, reject) &#123;    resolve();  &#125;).then(() =&gt; console.log(&quot;c2&quot;));&#125;);</code></pre><p>执行顺序：c1 &gt; c2 &gt; d 。 即使耗时 1 秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行，这可以很好的解释了<code>微任务优先</code>的原理。</p><p>异步执行的顺序：</p><blockquote><p>1、分析有多少个宏任务</p><p>2、在每个宏任务中，分析有多少个微任务</p><p>3、根据调用次序，确定宏任务中的微任务执行次序</p><p>4、根据宏任务的触发规则和调用次序，确定宏任务的执行次序</p><p>5、确定整个顺序</p></blockquote><p>复杂的例子：</p><pre><code class="js">function sleep(duration) &#123;  return new Promise(function (resolve, reject) &#123;    console.log(&quot;b&quot;);    setTimeout(resolve, duration);  &#125;);&#125;console.log(&quot;a&quot;);sleep(5000).then(() =&gt; console.log(&quot;c&quot;));</code></pre><p>执行顺序：a &gt; b &gt; c 。setTimeout 把整个代码分割成了 2 个宏观任务，，不论是 5 秒还是 0 秒，都是一样。</p><p>第一个宏观任务中，包含了先后同步执行的 console.log(‘a’)和 console.log(‘b’)</p><p>setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(‘c’),最终输出的顺序为： a b c 。</p><p>​ Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。</p><h4 id="四、async-await"><a href="#四、async-await" class="headerlink" title="四、async/await"></a>四、async/await</h4><p>​ async/await 是 ES2016 新加入的特性，它提供了用 for、if 等结构来编写异步的方式。</p><p>它的运行时基础是 Promise。</p><p>​ async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。</p><p>async 函数是一种特殊语法，特征是在 function 关键字之前加上一个 async 关键字，这样就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。</p><pre><code class="js">function sleep(duration) &#123;  return new Promise(function (resolve, reject) &#123;    setTimeout(resolve, duration);  &#125;);&#125;async function foo() &#123;  console.log(&quot;a&quot;);  await sleep(2000);  console.log(&quot;b&quot;);&#125;foo();</code></pre><p>​ async 函数强大之处在于，它是可以嵌套的。</p><pre><code class="js">function sleep(duration) &#123;  return new Promise(function (resolve, reject) &#123;    setTimeout(resolve, duration);  &#125;);&#125;async function foo(name) &#123;  await sleep(2000);  console.log(name);&#125;async function foo2() &#123;  await foo(&quot;a&quot;);  await foo(&quot;b&quot;);&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>96、vue3的使用transition时，不写根标签的警告</title>
      <link href="/2022/11/22/96-transition/"/>
      <url>/2022/11/22/96-transition/</url>
      
        <content type="html"><![CDATA[<p>terminal 中的警告：[Vue warn]: Component inside <Transition> renders non-element root node that cannot be animated.</p><span id="more"></span><p>Vue3 支持 template 可以不写根标签，transition 使用组件动画必须含根标签</p><blockquote><p>解决方法：组件加回根标签 div</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>95、vue3.0使用sass预处理器使用::v-deep深度选择器抛出警告</title>
      <link href="/2022/11/21/95-v-deep/"/>
      <url>/2022/11/21/95-v-deep/</url>
      
        <content type="html"><![CDATA[<p>terminal 中的警告：::v-deep usage as a combinator has been deprecated. Use :deep(＜ inner-selector ＞)警告解决</p><span id="more"></span><p>警告的写法为：</p><pre><code class="css">.redirect:hover &#123;  color: v-bind(linkHoverColor);&#125;::v-deep .no-redirect &#123;  color: #97a8be;  cursor: text;&#125;</code></pre><p>正确写法：</p><pre><code class="css">.redirect:hover &#123;  color: v-bind(linkHoverColor);&#125;::v-deep(.no-redirect) &#123;  color: #97a8be;  cursor: text;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94、使用vue3+element-plus写后台管理系统：（四）</title>
      <link href="/2022/11/19/94-vue3-ele-plus-admin/"/>
      <url>/2022/11/19/94-vue3-ele-plus-admin/</url>
      
        <content type="html"><![CDATA[<p>包括后台项目 layout 基础架构、用户主动和被动退出、动态 menu 菜单、结构路由表、侧边菜单栏的收缩、组件状态驱动的动态 CSS 值</p><span id="more"></span><p>layout 基础架构布局</p><p>layout 基本布局结构包括：Menu 菜单栏、NavBar 顶部导航栏（包含个人信息）、Main（页面主要展示区域）</p><h4 id="1、登录成功进入首页之后，整个首页也就是上面说的分为三个部分"><a href="#1、登录成功进入首页之后，整个首页也就是上面说的分为三个部分" class="headerlink" title="1、登录成功进入首页之后，整个首页也就是上面说的分为三个部分"></a>1、登录成功进入首页之后，整个首页也就是上面说的分为三个部分</h4><p>创建三个对应的组件</p><blockquote><p>layout/components/Sidebar/index.vue<br>layout/components/Navbar.vue<br>layout/components/AppMain.vue</p></blockquote><h4 id="2、在layout-index引入创建的三个组件"><a href="#2、在layout-index引入创建的三个组件" class="headerlink" title="2、在layout/index引入创建的三个组件"></a>2、在<code>layout/index</code>引入创建的三个组件</h4><pre><code class="js">import Navbar from &quot;./components/Navbar.vue&quot;;import Sidebar from &quot;./components/Sidebar/index.vue&quot;;import AppMain from &quot;./components/AppMain&quot;;</code></pre><h4 id="3、layout-index对应的布局"><a href="#3、layout-index对应的布局" class="headerlink" title="3、layout/index对应的布局"></a>3、<code>layout/index</code>对应的布局</h4><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;app-wrapper&quot;&gt;    &lt;!-- 左侧 menu --&gt;    &lt;sidebar class=&quot;sidebar-container&quot; /&gt;    &lt;div class=&quot;main-container&quot;&gt;      &lt;div class=&quot;fixed-header&quot;&gt;        &lt;!-- 顶部的 navbar --&gt;        &lt;navbar /&gt;      &lt;/div&gt;      &lt;!-- 内容区 --&gt;      &lt;app-main /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="4、在-styles-文件夹下定义-3-个-scss-文件"><a href="#4、在-styles-文件夹下定义-3-个-scss-文件" class="headerlink" title="4、在 styles 文件夹下定义 3 个 scss 文件"></a>4、在 styles 文件夹下定义 3 个 scss 文件</h4><blockquote><p>variables.scss 定义常量<br>mixin.scss 定义通用的 css<br>sidebar.scss 处理 menu 菜单的样式</p></blockquote><pre><code class="css">// variables.scss// sidebar的样式  定义如下常量将其导出$menuText: #bfcbd9;$menuActiveText: #ffffff;$subMenuActiveText: #f4f4f5;$menuBg: #304156;$menuHover: #263445;$subMenuBg: #1f2d3d;$subMenuHover: #001528;$sideBarWidth: 210px;// JS 与 scss 共享变量，在 scss 中通过 :export 进行导出，在 js 中可通过 ESM 进行导入:export &#123;  menuText: $menuText;  menuActiveText: $menuActiveText;  subMenuActiveText: $subMenuActiveText;  menuBg: $menuBg;  menuHover: $menuHover;  subMenuBg: $subMenuBg;  subMenuHover: $subMenuHover;  sideBarWidth: $sideBarWidth;&#125;</code></pre><blockquote><p><code>注意</code>:这里是使用 :export{ } 方法将 css 常量导出</p></blockquote><p><code>mixin.scss</code></p><pre><code class="css">// mixin.scss@mixin clearfix &#123;  &amp;:after &#123;    content: &quot;&quot;;    display: table;    clear: both;  &#125;&#125;@mixin scrollBar &#123;  &amp;::-webkit-scrollbar-track-piece &#123;    background: #d3dce6;  &#125;  &amp;::-webkit-scrollbar &#123;    width: 6px;  &#125;  &amp;::-webkit-scrollbar-thumb &#123;    background: #99a9bf;    border-radius: 20px;  &#125;&#125;@mixin relative &#123;  position: relative;  width: 100%;  height: 100%;&#125;</code></pre><p><code>sidebar.scss</code></p><details><summary>点我展示代码</summary><pre><code class="css">// sidebar.scss#app &#123;  .main-container &#123;    min-height: 100%;    transition: margin-left 0.28s;    margin-left: $sideBarWidth;    position: relative;  &#125;  .sidebar-container &#123;    transition: width 0.28s;    width: $sideBarWidth !important;    height: 100%;    position: fixed;    top: 0;    bottom: 0;    left: 0;    z-index: 1001;    overflow: hidden;    // 重置 element-plus 的css    .horizontal-collapse-transition &#123;      transition: 0s width ease-in-out, 0s padding-left ease-in-out,        0s padding-right ease-in-out;    &#125;    .scrollbar-wrapper &#123;      overflow-x: hidden !important;    &#125;    .el-scrollbar__bar.is-vertical &#123;      right: 0px;    &#125;    .el-scrollbar &#123;      height: 100%;    &#125;    &amp;.has-logo &#123;      .el-scrollbar &#123;        height: calc(100% - 50px);      &#125;    &#125;    .is-horizontal &#123;      display: none;    &#125;    a &#123;      display: inline-block;      width: 100%;      overflow: hidden;    &#125;    .svg-icon &#123;      margin-right: 16px;    &#125;    .sub-el-icon &#123;      margin-right: 12px;      margin-left: -2px;    &#125;    .el-menu &#123;      border: none;      height: 100%;      width: 100% !important;    &#125;    .is-active &gt; .el-submenu__title &#123;      color: $subMenuActiveText !important;    &#125;    &amp; .nest-menu .el-submenu &gt; .el-submenu__title,    &amp; .el-submenu .el-menu-item &#123;      min-width: $sideBarWidth !important;    &#125;  &#125;  .hideSidebar &#123;    .sidebar-container &#123;      width: 54px !important;    &#125;    .main-container &#123;      margin-left: 54px;    &#125;    .submenu-title-noDropdown &#123;      padding: 0 !important;      position: relative;      .el-tooltip &#123;        padding: 0 !important;        .svg-icon &#123;          margin-left: 20px;        &#125;        .sub-el-icon &#123;          margin-left: 19px;        &#125;      &#125;    &#125;    .el-submenu &#123;      overflow: hidden;      &amp; &gt; .el-submenu__title &#123;        padding: 0 !important;        .svg-icon &#123;          margin-left: 20px;        &#125;        .sub-el-icon &#123;          margin-left: 19px;        &#125;        .el-submenu__icon-arrow &#123;          display: none;        &#125;      &#125;    &#125;    .el-menu--collapse &#123;      .el-submenu &#123;        &amp; &gt; .el-submenu__title &#123;          &amp; &gt; span &#123;            height: 0;            width: 0;            overflow: hidden;            visibility: hidden;            display: inline-block;          &#125;        &#125;      &#125;    &#125;  &#125;  .el-menu--collapse .el-menu .el-submenu &#123;    min-width: $sideBarWidth !important;  &#125;  .withoutAnimation &#123;    .main-container,    .sidebar-container &#123;      transition: none;    &#125;  &#125;&#125;.el-menu--vertical &#123;  &amp; &gt; .el-menu &#123;    .svg-icon &#123;      margin-right: 16px;    &#125;    .sub-el-icon &#123;      margin-right: 12px;      margin-left: -2px;    &#125;  &#125;  // 菜单项过长时  &gt; .el-menu--popup &#123;    max-height: 100vh;    overflow-y: auto;    &amp;::-webkit-scrollbar-track-piece &#123;      background: #d3dce6;    &#125;    &amp;::-webkit-scrollbar &#123;      width: 6px;    &#125;    &amp;::-webkit-scrollbar-thumb &#123;      background: #99a9bf;      border-radius: 20px;    &#125;  &#125;&#125;</code></pre></details><h4 id="5、创建的三个-scss-文件导入到-styles-index-scss"><a href="#5、创建的三个-scss-文件导入到-styles-index-scss" class="headerlink" title="5、创建的三个 scss 文件导入到 styles/index.scss"></a>5、创建的三个 scss 文件导入到 styles/index.scss</h4><pre><code class="css">// index.scss@import &quot;./variables.scss&quot;;@import &quot;./mixin.scss&quot;;@import &quot;./sidebar.scss&quot;;</code></pre><p><code>layout/index.vue</code>写入样式</p><pre><code class="css">&lt;style lang=&quot;scss&quot; scoped&gt;@import &#39;@/styles/mixin.scss&#39;;@import &#39;@/styles/variables.scss&#39;;.app-wrapper &#123;  @include clearfix;  position: relative;  height: 100%;  width: 100%;&#125;.fixed-header &#123;  position: fixed;  top: 0;  right: 0;  z-index: 9;  width: calc(100% - #&#123;$sideBarWidth&#125;);&#125;&lt;/style&gt;</code></pre><h4 id="6、侧边栏要实现主题更换功能，sidebar-赋值动态背景颜色"><a href="#6、侧边栏要实现主题更换功能，sidebar-赋值动态背景颜色" class="headerlink" title="6、侧边栏要实现主题更换功能，sidebar 赋值动态背景颜色"></a>6、<code>侧边栏</code>要实现<code>主题更换</code>功能，sidebar 赋值动态背景颜色</h4><pre><code class="html">&lt;template&gt;  ...  &lt;!-- 左侧 menu --&gt;  &lt;sidebar    class=&quot;sidebar-container&quot;    :style=&quot;&#123; backgroundColor: variables.menuBg &#125;&quot;  /&gt;  ...&lt;/template&gt;&lt;script setup&gt;  import variables from &quot;@/styles/variables.scss&quot;;&lt;/script&gt;</code></pre><h4 id="7、Navbar、Sidebar、AppMain-组件初始化代码占位及样式修改"><a href="#7、Navbar、Sidebar、AppMain-组件初始化代码占位及样式修改" class="headerlink" title="7、Navbar、Sidebar、AppMain 组件初始化代码占位及样式修改"></a>7、Navbar、Sidebar、AppMain 组件初始化代码占位及样式修改</h4><p>需要处理 AppMain 组件和 Navbar 组件重叠问题</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;app-main&quot;&gt;AppMain&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .app-main &#123;    min-height: calc(100vh - 50px);    width: 100%;    position: relative;    overflow: hidden;    padding: 61px 20px 20px 20px;    box-sizing: border-box;  &#125;&lt;/style&gt;</code></pre><h4 id="8、用户个人信息"><a href="#8、用户个人信息" class="headerlink" title="8、用户个人信息"></a>8、用户个人信息</h4><p>这里需要处理一下用户个人信息展示</p><p><code>api/sys.js</code>文件定义方法、axios 请求拦截器对 token 进行 header 注入</p><pre><code class="js">/** * 获取用户信息 */export const getUserInfo = () =&gt; &#123;  return request(&#123;    url: &quot;/sys/profile&quot;,  &#125;);&#125;;// utils/request.jsimport store from &quot;@/store&quot;;// 请求拦截器service.interceptors.request.use(  (config) =&gt; &#123;    // 在这个位置需要统一的去注入token    if (store.getters.token) &#123;      // 如果token存在 注入token      config.headers.Authorization = `Bearer $&#123;store.getters.token&#125;`;    &#125;    return config; // 必须返回配置  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);</code></pre><p>定义调用接口的动作<code>store/modules/user.js</code></p><pre><code class="js">import &#123; login, getUserInfo &#125; from &#39;@/api/sys&#39;...export default &#123;  namespaced: true,  state: () =&gt; (&#123;    ...    userInfo: &#123;&#125;  &#125;),  mutations: &#123;    ...    setUserInfo(state, userInfo) &#123;      state.userInfo = userInfo    &#125;  &#125;,  actions: &#123;    ...    async getUserInfo(context) &#123;      const res = await getUserInfo()      this.commit(&#39;user/setUserInfo&#39;, res)      return res    &#125;  &#125;&#125;</code></pre><p>在权限拦截时触发的动作<code>permission.js</code></p><pre><code class="js">    if (to.path === &#39;/login&#39;) &#123;      ...    &#125; else &#123;      // 判断用户资料是否获取      // 若不存在用户信息，则需要获取用户信息      if (!store.getters.hasUserInfo) &#123;        // 触发获取用户信息的 action        await store.dispatch(&#39;user/getUserInfo&#39;)      &#125;      next()    &#125;  &#125;</code></pre><p>写入判断用户信息<code>store/getters.js</code></p><pre><code class="js">const getters = &#123;  ...  userInfo: state =&gt; state.user.userInfo,  /**   * @returns true 表示已存在用户信息   */  hasUserInfo: state =&gt; &#123;    return JSON.stringify(state.user.userInfo) !== &#39;&#123;&#125;&#39;  &#125;&#125;</code></pre><h4 id="9、element-plus-的-dropdown-avatar-组件实现用户头像信息及用户主动退出功能"><a href="#9、element-plus-的-dropdown-avatar-组件实现用户头像信息及用户主动退出功能" class="headerlink" title="9、element-plus 的 dropdown avatar 组件实现用户头像信息及用户主动退出功能"></a>9、element-plus 的 dropdown avatar 组件实现用户头像信息及用户主动退出功能</h4><p><code>用户头像功能及下拉菜单栏</code></p><details><summary>点我展示代码</summary><pre><code class="html">// layout/components/navbar.vue&lt;template&gt;  &lt;div class=&quot;navbar&quot;&gt;    &lt;div class=&quot;right-menu&quot;&gt;      &lt;!-- 头像 --&gt;      &lt;el-dropdown class=&quot;avatar-container&quot; trigger=&quot;click&quot;&gt;        &lt;div class=&quot;avatar-wrapper&quot;&gt;          &lt;el-avatar            shape=&quot;square&quot;            :size=&quot;40&quot;            :src=&quot;$store.getters.userInfo.avatar&quot;          &gt;&lt;/el-avatar&gt;        &lt;/div&gt;        &lt;template #dropdown&gt;          &lt;el-dropdown-menu class=&quot;user-dropdown&quot;&gt;            &lt;router-link to=&quot;/&quot;&gt;              &lt;el-dropdown-item&gt; 首页 &lt;/el-dropdown-item&gt;            &lt;/router-link&gt;            &lt;el-dropdown-item divided&gt; 退出登录 &lt;/el-dropdown-item&gt;          &lt;/el-dropdown-menu&gt;        &lt;/template&gt;      &lt;/el-dropdown&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;  import &#123;&#125; from &quot;vue&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .navbar &#123;    height: 50px;    overflow: hidden;    position: relative;    background: #fff;    box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);    .right-menu &#123;      display: flex;      align-items: center;      float: right;      padding-right: 16px;      ::v-deep .avatar-container &#123;        cursor: pointer;        .avatar-wrapper &#123;          margin-top: 5px;          position: relative;          n .el-avatar &#123;            --el-avatar-background-color: none;            margin-right: 12px;          &#125;        &#125;      &#125;    &#125;  &#125;&lt;/style&gt;</code></pre></details><h4 id="10、主动退出功能-在-store-moduels-user-js-中，清除当前用户缓存数据、清除用户权限相关配置、返回到登录页"><a href="#10、主动退出功能-在-store-moduels-user-js-中，清除当前用户缓存数据、清除用户权限相关配置、返回到登录页" class="headerlink" title="10、主动退出功能:在 store/moduels/user.js 中，清除当前用户缓存数据、清除用户权限相关配置、返回到登录页"></a>10、<code>主动退出功能</code>:在 store/moduels/user.js 中，清除当前用户缓存数据、清除用户权限相关配置、返回到登录页</h4><pre><code class="js">import router from &#39;@/router&#39;logout() &#123;    this.commit(&#39;user/setToken&#39;, &#39;&#39;)    this.commit(&#39;user/setUserInfo&#39;, &#123;&#125;)    removeAllItem()    router.push(&#39;/login&#39;)&#125;</code></pre><p>退出按钮点击事件，触发 logout 的 action</p><pre><code class="js">import &#123; useStore &#125; from &quot;vuex&quot;;const store = useStore();const logout = () =&gt; &#123;  store.dispatch(&quot;user/logout&quot;);&#125;;</code></pre><h4 id="11、被动退出功能：token-过期、单一账户同时登录"><a href="#11、被动退出功能：token-过期、单一账户同时登录" class="headerlink" title="11、被动退出功能：token 过期、单一账户同时登录"></a>11、<code>被动退出功能</code>：token 过期、单一账户同时登录</h4><p>token 表示一个用户的身份令牌，对服务端而言，只认令牌不认人，所以说一旦其他人获取了你的 token，那么可以伪装成你，来获取对应的敏感数据。</p><p>为了保证用户的信息安全，那么对于 token 而言就被制定了很多安全策略。<br>token 的安全策略：动态 token、刷新 token、失效 token</p><p>选择时效 token：服务端处理 token 时效的同时，在前端主动介入 token 时效的处理中，从而保证用户信息的安全性。</p><p>实现方案：</p><blockquote><p>1、在用户登录时，记录当前登录时间<br>2、制定失效时长<br>3、接口调用时，根据当前时间对比登录时间，看是否超过了时效时长。如果未超过，则正常进行后续操作；如果超过，则进行退出登录操作</p></blockquote><pre><code class="js">// utils/auth.jsimport &#123; TIME_STAMP, TOKEN_TIMEOUT_VALUE &#125; from &quot;@/constant&quot;;import &#123; setItem, getItem &#125; from &quot;@/utils/storage&quot;;/** * 获取时间戳 */export function getTimeStamp() &#123;  return getItem(TIME_STAMP);&#125;/** * 设置时间戳 */export function setTimeStamp() &#123;  setItem(TIME_STAMP, Date.now());&#125;/** * 是否超时 */export function isCheckTimeout() &#123;  // 当前时间戳  var currentTime = Date.now();  // 缓存时间戳  var timeStamp = getTimeStamp();  return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE;&#125;// token时间戳export const TIME_STAMP = &quot;timeStamp&quot;;// 超时时长(毫秒) 两小时export const TOKEN_TIMEOUT_VALUE = 2 * 3600 * 1000;</code></pre><p>用户登录成功之后设置时间，到 store/user.js 的 login 中：</p><pre><code class="js">import &#123; setTimeStamp &#125; from &#39;@/utils/auth&#39;login(context, userInfo) &#123;      ...      return new Promise((resolve, reject) =&gt; &#123;        ...          .then(data =&gt; &#123;            ...            // 保存登录时间            setTimeStamp()            resolve()          &#125;)      &#125;)    &#125;,</code></pre><p>在<code>utils/request</code>对应的请求拦截器中进行主动介入</p><pre><code class="js">import &#123; isCheckTimeout &#125; from &#39;@/utils/auth&#39;if (store.getters.token) &#123;      if (isCheckTimeout()) &#123;        // 登出操作        store.dispatch(&#39;user/logout&#39;)        return Promise.reject(new Error(&#39;token 失效&#39;))      &#125;      ...    &#125;// 响应拦截器service.interceptors.response.use(  response =&gt; &#123;    ...  &#125;,  error =&gt; &#123;    // 处理 token 超时问题    if (      error.response &amp;&amp;      error.response.data &amp;&amp;      error.response.data.code === 401    ) &#123;      // token超时      store.dispatch(&#39;user/logout&#39;)    &#125;    ElMessage.error(error.message) // 提示错误信息    return Promise.reject(error)  &#125;)</code></pre><h4 id="12、临时menu菜单"><a href="#12、临时menu菜单" class="headerlink" title="12、临时menu菜单"></a>12、<code>临时menu菜单</code></h4><p>layout/Sidebar/SidebarMenu.vue</p><pre><code class="html">&lt;template&gt;  &lt;!-- 一级 menu 菜单 --&gt;  &lt;el-menu    :uniqueOpened=&quot;true&quot;    default-active=&quot;2&quot;    background-color=&quot;#545c64&quot;    text-color=&quot;#fff&quot;    active-text-color=&quot;#ffd04b&quot;  &gt;    &lt;!-- 子集 menu 菜单 --&gt;    &lt;el-submenu index=&quot;1&quot;&gt;      &lt;template #title&gt;        &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;        &lt;span&gt;导航一&lt;/span&gt;      &lt;/template&gt;      &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;      &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;    &lt;/el-submenu&gt;    &lt;!-- 具体菜单项 --&gt;    &lt;el-menu-item index=&quot;4&quot;&gt;      &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;      &lt;template #title&gt;导航四&lt;/template&gt;    &lt;/el-menu-item&gt;  &lt;/el-menu&gt;&lt;/template&gt;</code></pre><p>layout/Sidebar/index 导入该组件</p><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;&quot;&gt;    &lt;h1&gt;Admin&lt;/h1&gt;    &lt;el-scrollbar&gt;      &lt;sidebar-menu&gt;&lt;/sidebar-menu&gt;    &lt;/el-scrollbar&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import SidebarMenu from &#39;./SidebarMenu&#39;import &#123;&#125; from &#39;vue&#39;&lt;/script&gt;</code></pre><p>生成一个临时的 menu 菜单，从这个临时的 menu 菜单可以看出，el-menu 分为三部分：</p><blockquote><p><code>el-menu</code>：整个 menu 菜单<br><code>el-sub-menu</code>:子集 menu 菜单<br><code>el-menu-item</code>:具体菜单项</p></blockquote><h4 id="13、动态-menu-菜单处理"><a href="#13、动态-menu-菜单处理" class="headerlink" title="13、动态 menu 菜单处理"></a>13、动态 menu 菜单处理</h4><blockquote><p>动态 menu 菜单主要和动态路由表配合来实现用户权限的（后续需要完成用户权限）。动态 menu 菜单指的是：根据路由表的配置，自动生成对应的 menu 菜单，当路由表发生变化时，menu 菜单自动发生变化。</p></blockquote><p>实现步骤：</p><blockquote><p>1、定义路由表对应的 menu 菜单规则（核心步骤）<br>2、根据规则制定路由表<br>3、根据规则，一路路由表生成 menu 菜单</p></blockquote><p>上面步骤 1 的菜单规则制定：</p><blockquote><p>1、如果<code>meta &amp;&amp; meta.title &amp;&amp; meta.icon</code> ：则显示在 <code>menu</code> 菜单中，其中 <code>title</code> 为显示的内容，<code>icon</code> 为显示的图标。如果存在 children：则展示子菜单 el-sub-menu；否则展示 el-menu-item。<br>2、不显示在 menu 中</p></blockquote><h4 id="14、创建页面组件"><a href="#14、创建页面组件" class="headerlink" title="14、创建页面组件"></a>14、<code>创建页面组件</code></h4><p>views 文件夹下创建页面：<br>（1）、创建文章:article-create<br>（2）、文章详情:article-detail<br>（3）、文章列表:article-ranking<br>（4）、401 和 404 页面:error-page/401.vue 404.vue<br>（5）、导入:import<br>（6）、权限列表:permission-list<br>（7）、个人中心:profile<br>（8）、角色列表:role-list<br>（9）、用户信息:user-info<br>（10）、用户管理:user-manage</p><h4 id="15、用户权限处理"><a href="#15、用户权限处理" class="headerlink" title="15、用户权限处理"></a>15、用户权限处理</h4><p>需要先对路由表进行划分：私有路由表 privateRoutes(权限路由)、公有路由表 publicRoutes(非权限路由)</p><p><code>router/index.js</code></p><details><summary>显示详细代码</summary><pre><code class="js">// 私有路由表const privateRoutes = [  &#123;    path: &quot;/user&quot;,    component: layout,    redirect: &quot;/user/manage&quot;,    meta: &#123;      title: &quot;user&quot;,      icon: &quot;personnel&quot;,    &#125;,    children: [      &#123;        path: &quot;/user/manage&quot;,        component: () =&gt; import(&quot;@/views/user-manage/index&quot;),        meta: &#123;          title: &quot;userManage&quot;,          icon: &quot;personnel-manage&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/user/role&quot;,        component: () =&gt; import(&quot;@/views/role-list/index&quot;),        meta: &#123;          title: &quot;roleList&quot;,          icon: &quot;role&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/user/permission&quot;,        component: () =&gt; import(&quot;@/views/permission-list/index&quot;),        meta: &#123;          title: &quot;permissionList&quot;,          icon: &quot;permission&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/user/info/:id&quot;,        name: &quot;userInfo&quot;,        component: () =&gt; import(&quot;@/views/user-info/index&quot;),        meta: &#123;          title: &quot;userInfo&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/user/import&quot;,        name: &quot;import&quot;,        component: () =&gt; import(&quot;@/views/import/index&quot;),        meta: &#123;          title: &quot;excelImport&quot;,        &#125;,      &#125;,    ],  &#125;,  &#123;    path: &quot;/article&quot;,    component: layout,    redirect: &quot;/article/ranking&quot;,    meta: &#123;      title: &quot;article&quot;,      icon: &quot;article&quot;,    &#125;,    children: [      &#123;        path: &quot;/article/ranking&quot;,        component: () =&gt; import(&quot;@/views/article-ranking/index&quot;),        meta: &#123;          title: &quot;articleRanking&quot;,          icon: &quot;article-ranking&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/article/:id&quot;,        component: () =&gt; import(&quot;@/views/article-detail/index&quot;),        meta: &#123;          title: &quot;articleDetail&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/article/create&quot;,        component: () =&gt; import(&quot;@/views/article-create/index&quot;),        meta: &#123;          title: &quot;articleCreate&quot;,          icon: &quot;article-create&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/article/editor/:id&quot;,        component: () =&gt; import(&quot;@/views/article-create/index&quot;),        meta: &#123;          title: &quot;articleEditor&quot;,        &#125;,      &#125;,    ],  &#125;,];// 公开路由表const publicRoutes = [  &#123;    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/views/login/index&quot;),  &#125;,  &#123;    path: &quot;/&quot;,    // 注意：带有路径“/”的记录中的组件“默认”是一个不返回 Promise 的函数    component: layout,    redirect: &quot;/profile&quot;,    children: [      &#123;        path: &quot;/profile&quot;,        name: &quot;profile&quot;,        component: () =&gt; import(&quot;@/views/profile/index&quot;),        meta: &#123;          title: &quot;profile&quot;,          icon: &quot;el-icon-user&quot;,        &#125;,      &#125;,      &#123;        path: &quot;/404&quot;,        name: &quot;404&quot;,        component: () =&gt; import(&quot;@/views/error-page/404&quot;),      &#125;,      &#123;        path: &quot;/401&quot;,        name: &quot;401&quot;,        component: () =&gt; import(&quot;@/views/error-page/401&quot;),      &#125;,    ],  &#125;,];const router = createRouter(&#123;  history: createWebHashHistory(),  routes: [...publicRoutes, ...privateRoutes],&#125;);</code></pre></details><blockquote><p>注意：要在 <code>layout/AppMain.vue 中设置路由出口</code></p></blockquote><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;app-main&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="16、解析路由表，获取结构化数据"><a href="#16、解析路由表，获取结构化数据" class="headerlink" title="16、解析路由表，获取结构化数据"></a>16、解析路由表，获取结构化数据</h4><p>数据结构为</p><details><summary>显示详细代码</summary><pre><code class="json">[  &#123;    &quot;title&quot;: &quot;个人中心&quot;,    &quot;path&quot;: &quot;&quot;  &#125;,  &#123;    &quot;title&quot;: &quot;用户&quot;,    &quot;children&quot;: [      &#123;        &quot;title&quot;: &quot;员工管理&quot;,        &quot;path&quot;: &quot;&quot;      &#125;,      &#123;        &quot;title&quot;: &quot;角色列表&quot;,        &quot;path&quot;: &quot;&quot;      &#125;,      &#123;        &quot;title&quot;: &quot;权限列表&quot;,        &quot;path&quot;: &quot;&quot;      &#125;    ]  &#125;,  &#123;    &quot;title&quot;: &quot;文章&quot;,    &quot;children&quot;: [      &#123;        &quot;title&quot;: &quot;文章排名&quot;,        &quot;path&quot;: &quot;&quot;      &#125;,      &#123;        &quot;title&quot;: &quot;创建文章&quot;,        &quot;path&quot;: &quot;&quot;      &#125;    ]  &#125;]</code></pre></details><p>获取路由表数据的 2 中方式：</p><blockquote><p>1、router.options.routes:初始路由列表<br>2、router.getRoutes()：获取所有路由记录的完整列表（选择此种方法）</p></blockquote><p>在 layout/components/Sidebar/SidebarMenu 中</p><pre><code class="js">&lt;script setup&gt;  import &#123;useRouter&#125; from &#39;vue-router&#39; const router = useRouter()  console.log(router.getRoutes()) // 这里返回的是一个完整的路由表&lt;/script&gt;</code></pre><p>打印的结果是一个完整的路由表，里面存在一些问题：</p><blockquote><p>存在重复的路由数据<br>不满足该条件 meta &amp;&amp; meta.title &amp;&amp; meta.icon 的数据不应该存在</p></blockquote><h4 id="17、处理数据结构问题"><a href="#17、处理数据结构问题" class="headerlink" title="17、处理数据结构问题"></a>17、处理数据结构问题</h4><p>创建<code>utils/route.js</code>，里面 2 个函数方法：filterRouters()/generateMenus()很重要</p><details><summary>显示完整代码</summary><pre><code class="js">import path from &quot;path&quot;;/** * 返回所有子路由 */const getChildrenRoutes = (routes) =&gt; &#123;  const result = [];  routes.forEach((route) =&gt; &#123;    if (route.children &amp;&amp; route.children.length &gt; 0) &#123;      result.push(...route.children);    &#125;  &#125;);  return result;&#125;;/** * 处理脱离层级的路由：某个一级路由为其他子路由，则剔除该一级路由，保留路由层级 * @param &#123;*&#125; routes router.getRoutes() */export const filterRouters = (routes) =&gt; &#123;  const childrenRoutes = getChildrenRoutes(routes);  return routes.filter((route) =&gt; &#123;    return !childrenRoutes.find((childrenRoute) =&gt; &#123;      return childrenRoute.path === route.path;    &#125;);  &#125;);&#125;;/** * 判断数据是否为空值 */function isNull(data) &#123;  if (!data) return true;  if (JSON.stringify(data) === &quot;&#123;&#125;&quot;) return true;  if (JSON.stringify(data) === &quot;[]&quot;) return true;  return false;&#125;/** * 根据 routes 数据，返回对应 menu 规则数组 */export function generateMenus(routes, basePath = &quot;&quot;) &#123;  const result = [];  // 遍历路由表  routes.forEach((item) =&gt; &#123;    // 不存在 children &amp;&amp; 不存在 meta 直接 return    if (isNull(item.meta) &amp;&amp; isNull(item.children)) return;    // 存在 children 不存在 meta，进入迭代    if (isNull(item.meta) &amp;&amp; !isNull(item.children)) &#123;      result.push(...generateMenus(item.children));      return;    &#125;    // 合并 path 作为跳转路径    const routePath = path.resolve(basePath, item.path);    // 路由分离之后，存在同名父路由的情况，需要单独处理    let route = result.find((item) =&gt; item.path === routePath);    if (!route) &#123;      route = &#123;        ...item,        path: routePath,        children: [],      &#125;;      // icon 与 title 必须全部存在      if (route.meta.icon &amp;&amp; route.meta.title) &#123;        // meta 存在生成 route 对象，放入 arr        result.push(route);      &#125;    &#125;    // 存在 children 进入迭代到children    if (item.children) &#123;      route.children.push(...generateMenus(item.children, route.path));    &#125;  &#125;);  return result;&#125;</code></pre></details><h4 id="18、SidebarMenu-调用-filterRouters、generateMenus-方法"><a href="#18、SidebarMenu-调用-filterRouters、generateMenus-方法" class="headerlink" title="18、SidebarMenu 调用 filterRouters、generateMenus 方法"></a>18、SidebarMenu 调用 filterRouters、generateMenus 方法</h4><pre><code class="js">&lt;script setup&gt;import &#123; computed &#125; from &#39;vue&#39;import &#123; useRouter &#125; from &#39;vue-router&#39;import &#123; filterRouters, generateMenus &#125; from &#39;@/utils/route&#39;const router = useRouter()const routes = computed(() =&gt; &#123;  const filterRoutes = filterRouters(router.getRoutes())  return generateMenus(filterRoutes)&#125;)console.log(JSON.stringify(routes.value))&lt;/script&gt;</code></pre><h4 id="19、生成动态-menu-菜单"><a href="#19、生成动态-menu-菜单" class="headerlink" title="19、生成动态 menu 菜单"></a>19、生成动态 menu 菜单</h4><p>整个 menu 菜单，分为 3 个组件来进行处理</p><blockquote><p>1、SidebarMenu:处理数据，作为最顶层 menu 载体</p></blockquote><pre><code class="html">&lt;template&gt;  &lt;!-- 一级 menu 菜单 --&gt;  &lt;el-menu ...&gt;    &lt;sidebar-item      v-for=&quot;item in routes&quot;      :key=&quot;item.path&quot;      :route=&quot;item&quot;    &gt;&lt;/sidebar-item&gt;  &lt;/el-menu&gt;&lt;/template&gt;</code></pre><blockquote><p>2、SidebarItem：根据数据处理当前项为 el-sub-menu || el-menu-item</p></blockquote><pre><code class="html">&lt;template&gt;  &lt;!-- 支持渲染多级 menu 菜单 --&gt;  &lt;el-submenu v-if=&quot;route.children.length &gt; 0&quot; :index=&quot;route.path&quot;&gt;    &lt;template #title&gt;      &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt;    &lt;/template&gt;    &lt;!-- 循环渲染 --&gt;    &lt;sidebar-item      v-for=&quot;item in route.children&quot;      :key=&quot;item.path&quot;      :route=&quot;item&quot;    &gt;&lt;/sidebar-item&gt;  &lt;/el-submenu&gt;  &lt;!-- 渲染 item 项 --&gt;  &lt;el-menu-item v-else :index=&quot;route.path&quot;&gt;    &lt;menu-item :title=&quot;route.meta.title&quot; :icon=&quot;route.meta.icon&quot;&gt;&lt;/menu-item&gt;  &lt;/el-menu-item&gt;&lt;/template&gt;&lt;script setup&gt;  import MenuItem from &quot;./MenuItem&quot;;  import &#123; defineProps &#125; from &quot;vue&quot;;  // 定义 props  defineProps(&#123;    route: &#123;      type: Object,      required: true,    &#125;,  &#125;);&lt;/script&gt;</code></pre><blockquote><p>3、MenuItem:处理 el-menu-item 样式</p></blockquote><pre><code class="html">&lt;template&gt;  &lt;i v-if=&quot;icon.includes(&#39;el-icon&#39;)&quot; class=&quot;sub-el-icon&quot; :class=&quot;icon&quot;&gt;&lt;/i&gt;  &lt;svg-icon v-else :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;  &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup&gt;  import &#123; defineProps &#125; from &quot;vue&quot;;  defineProps(&#123;    title: &#123;      type: String,      required: true,    &#125;,    icon: &#123;      type: String,      required: true,    &#125;,  &#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><p>menu 菜单完成，还需解决样式问题、菜单路由跳转问题、默认激活项</p><p><code>样式修改</code>：store/getters 创建快捷访问（后续加入主题更换功能，样式不能写死）</p><pre><code class="js">import variables from &#39;@/styles/variables.scss&#39;const getters = &#123;  ...  cssVar: state =&gt; variables&#125;export default getters</code></pre><p><code>SidebarMenu</code>写入样式（el-menu 里的 router 是指定路由跳转， activeMenu 为默认激活项）</p><pre><code class="html">// template&lt;el-menu  :background-color=&quot;$store.getters.cssVar.menuBg&quot;  :text-color=&quot;$store.getters.cssVar.menuText&quot;  :active-text-color=&quot;$store.getters.cssVar.menuActiveText&quot;  :default-active=&quot;activeMenu&quot;  :unique-opened=&quot;true&quot;  router&gt;&lt;/el-menu&gt;// js&lt;script setup&gt;  ...  // 计算高亮 menu 的方法  const route = useRoute()  const activeMenu = computed(() =&gt; &#123;    const &#123; path &#125; = route    return path  &#125;)&lt;/script&gt;</code></pre><h4 id="20、菜单的伸缩功能"><a href="#20、菜单的伸缩功能" class="headerlink" title="20、菜单的伸缩功能"></a>20、菜单的伸缩功能</h4><p>创建<code>store/modules/app.js</code></p><pre><code class="js">export default &#123;  namespaced: true,  state: () =&gt; (&#123;    sidebarOpened: true,  &#125;),  mutations: &#123;    triggerSidebarOpened(state) &#123;      state.sidebarOpened = !state.sidebarOpened;    &#125;,  &#125;,  actions: &#123;&#125;,&#125;;</code></pre><p>在<code>store/index.js</code>中引入上面的 app.js</p><pre><code class="js">import app from &quot;./modules/app&quot;;export default createStore(&#123;  getters,  modules: &#123;    user,    app,  &#125;,&#125;);</code></pre><p>在 <code>store/getters</code> 中创建快捷访问</p><pre><code class="js">sidebarOpened: (state) =&gt; state.app.sidebarOpened;</code></pre><h4 id="21、创建收缩-icon-组件-hamburger"><a href="#21、创建收缩-icon-组件-hamburger" class="headerlink" title="21、创建收缩 icon 组件 hamburger"></a>21、创建收缩 icon 组件 hamburger</h4><p>创建<code>src/components/Hamburger/index.vue</code></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;hamburger-container&quot; @click=&quot;toggleClick&quot;&gt;    &lt;svg-icon class=&quot;hamburger&quot; :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;  import &#123; computed &#125; from &quot;vue&quot;;  import &#123; useStore &#125; from &quot;vuex&quot;;  const store = useStore();  const toggleClick = () =&gt; &#123;    store.commit(&quot;app/triggerSidebarOpened&quot;);  &#125;;  const icon = computed(() =&gt;    store.getters.sidebarOpened ? &quot;hamburger-opened&quot; : &quot;hamburger-closed&quot;  );&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .hamburger-container &#123;    padding: 0 16px;    .hamburger &#123;      display: inline-block;      vertical-align: middle;      width: 20px;      height: 20px;    &#125;  &#125;&lt;/style&gt;</code></pre><p>在<code>layout/components/Navbar.vue</code>中使用 Hamburger 组件</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;navbar&quot;&gt;    &lt;hamburger class=&quot;hamburger-container&quot; /&gt;    ...  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;  import Hamburger from &#39;@/components/Hamburger&#39;  ...&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .navbar &#123;    ...    .hamburger-container &#123;      line-height: 46px;      height: 100%;      float: left;      cursor: pointer;      // hover 动画      transition: background 0.5s;      &amp;:hover &#123;        background: rgba(0, 0, 0, 0.1);      &#125;    &#125;   ...  &#125;&lt;/style&gt;</code></pre><p>在<code>layout/components/Sidebar/SidebarMenu.vue</code>中添加控制 el-menu 的<code>collapse</code>属性</p><pre><code class="html">&lt;el-menu    :collapse=&quot;!$store.getters.sidebarOpened&quot;    ...</code></pre><p>在<code>layout/index.vue</code>中指定侧边栏的宽度和缩放动画</p><pre><code class="html">&lt;div  class=&quot;app-wrapper&quot;  :class=&quot;[$store.getters.sidebarOpened ? &#39;openSidebar&#39; : &#39;hideSidebar&#39;]&quot;&gt;  ...&lt;/div&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  ... .fixed-header &#123;    position: fixed;    top: 0;    right: 0;    z-index: 9;    width: calc(100% - #&#123;$sideBarWidth&#125;);    transition: width 0.28s;  &#125;  .hideSidebar .fixed-header &#123;    width: calc(100% - #&#123;$hideSideBarWidth&#125;);  &#125;&lt;/style&gt;&lt;style&gt;  // 在 `styles/variables.scss` 中指定 `hideSideBarWidth`  $hideSideBarWidth: 54px;&lt;/style&gt;</code></pre><h4 id="22、SidebarHeader-处理"><a href="#22、SidebarHeader-处理" class="headerlink" title="22、SidebarHeader 处理"></a>22、SidebarHeader 处理</h4><details><summary>显示详细代码</summary><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;&quot;&gt;    &lt;div class=&quot;logo-container&quot;&gt;      &lt;el-avatar size=&quot;44&quot; shape=&quot;square&quot; src=&quot;http://xxxxx.com&quot; /&gt;      &lt;h1 class=&quot;logo-title&quot; v-if=&quot;$store.getters.sidebarOpened&quot;&gt;Admin&lt;/h1&gt;    &lt;/div&gt;    ...  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .logo-container &#123;    height: 44px;    padding: 10px 0 22px 0;    display: flex;    align-items: center;    justify-content: center;    .logo-title &#123;      margin-left: 10px;      color: #fff;      font-weight: 600;      line-height: 50px;      font-size: 16px;      white-space: nowrap;    &#125;  &#125;&lt;/style&gt;</code></pre></details><blockquote><p>处理 el-avatar 的图片背景问题</p></blockquote><p>创建 <code>styles/element.scss</code>,然后将其导入到<code>style/index.scss</code></p><pre><code class="css">.el-avatar &#123;  --el-avatar-background-color: none;&#125;</code></pre><blockquote><p>处理动画问题</p></blockquote><p>在 <code>styles/variables.scss</code> 中，加入以下变量</p><pre><code class="css">$sideBarDuration: 0.28s;</code></pre><p><code>styles/sidebar.scss</code> 修改时长</p><pre><code class="css">  .main-container &#123;    transition: margin-left #&#123;$sideBarDuration&#125;;   ...  &#125;  .sidebar-container &#123;    transition: width #&#123;$sideBarDuration&#125;;      ...  &#125;</code></pre><p><code>layout/index</code> 修改样式</p><pre><code class="css">.fixed-header &#123;  ...  transition: width #&#123;$sideBarDuration&#125;;&#125;</code></pre><h4 id="23、组件状态驱动的动态-CSS-值"><a href="#23、组件状态驱动的动态-CSS-值" class="headerlink" title="23、组件状态驱动的动态 CSS 值"></a>23、组件状态驱动的动态 CSS 值</h4><pre><code class="html">&lt;template&gt; ... &lt;el-avatar :size=&quot;logoHeight&quot; ... &lt;/template&gt;&lt;script setup&gt;  ...  const logoHeight = 44&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;  .logo-container &#123;    height: v-bind(logoHeight) + &#39;px&#39;;  ...  &#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>93、使用vue3+element-plus写后台管理系统：（三）</title>
      <link href="/2022/11/10/93-vue3-ele-plus-admin/"/>
      <url>/2022/11/10/93-vue3-ele-plus-admin/</url>
      
        <content type="html"><![CDATA[<p>包括配置环境变量封装 axios、接口请求模块、vuex 登录请求动作、保存服务端的 token、登录鉴权</p><span id="more"></span><h2 id="一、配置环境变量及封装-axios-模块"><a href="#一、配置环境变量及封装-axios-模块" class="headerlink" title="一、配置环境变量及封装 axios 模块"></a>一、配置环境变量及封装 axios 模块</h2><p>在跟目录下创建.env.development .env.production 2 个文件</p><pre><code class="js">// .env.developmentENV = &quot;development&quot;;VUE_APP_BASE_API = &quot;/api&quot;;// .env.productionENV = &quot;production&quot;;VUE_APP_BASE_APIU = &quot;/prod-api&quot;;</code></pre><p>axios 的封装 utils 下创建 request.js</p><pre><code class="js">import axios from &quot;axios&quot;;const service = axios.create(&#123;  baseURL: process.env.VUE_APP_BASE_API,  timeout: 5000,&#125;);export default service;</code></pre><h2 id="二、封装登录请求动作"><a href="#二、封装登录请求动作" class="headerlink" title="二、封装登录请求动作"></a>二、封装登录请求动作</h2><p>根目录下的 src 下创建 api 文件夹，<code>touch sys.js</code></p><pre><code class="js">import request from &quot;@/utils/request&quot;;export const login = (data) =&gt; &#123;  return request(&#123;    url: &quot;/sys/login&quot;,    method: &quot;PSOT&quot;,    data,  &#125;);&#125;;</code></pre><p>将登录请求的动作封装到 vuex 的 action 中，在<code>store</code>文件夹下创建 modules 文件夹，在 modules 下<code>touch user.js</code>模块（此模块用于处理所有和用户相关的内容）</p><blockquote><p>安装 md5 插件，加密登录密码 yarn add md5</p></blockquote><pre><code class="js">// user.jsimport &#123; login &#125; from &#39;@/api/sys&#39;import md5 from &#39;md5&#39;export default &#123;  namespaced: true,  state: () =&gt; (&#123;&#125;),  mutations: &#123;&#125;,  actions: &#123;    login(context, userInfo) &#123;      const &#123; username, password &#125; = userInfo      return new Promise((resolve, reject) =&gt; &#123;        login(&#123;          username,          password: md5(password)        &#125;)          .then(data =&gt; &#123;            resolve()          &#125;)          .catch(err =&gt; &#123;            reject(err)          &#125;)      &#125;)    &#125;  &#125;&#125;// 在store/index.js中注册import &#123; createStore &#125; from &#39;vuex&#39;import user from &#39;./modules/user.js&#39;export default createStore(&#123;  modules:&#123;    user  &#125;&#125;)</code></pre><p>在登录页，触发定义的 action，此时存在一个问题就是，我们当前请求的接口不存在，需要使用 devServer 代理</p><pre><code class="js">// vue.config.jsmodule.exports = &#123;  devService: &#123;    proxy: &#123;      &quot;/api&quot;: &#123;        // 要代理的服务器地址， 不需要写api        target: &quot;https://api.xxx.com&quot;,        changeOrigin: true, // 是否跨域      &#125;,    &#125;,  &#125;,&#125;;</code></pre><p>重启项目，再次点击登录，就可以跳转到首页了。</p><h2 id="三、本地缓存的处理"><a href="#三、本地缓存的处理" class="headerlink" title="三、本地缓存的处理"></a>三、本地缓存的处理</h2><p>登录成功之后，前端会拿到后端返回的 token,我们需要将 token 进行缓存</p><p>缓存的 2 种方式：</p><blockquote><p>1、本地缓存：localStorage<br>2、全局状态管理： vuex</p></blockquote><p>localStorage 可以方便实现自动登录功能<br>保存在 vuex 中是为了后面在其他位置进行使用</p><h3 id="一-、localStorage"><a href="#一-、localStorage" class="headerlink" title="(一)、localStorage"></a>(一)、localStorage</h3><p>在 utils 文件夹下，新建 storage..js<br>1、封装 4 个方法</p><pre><code class="js">/** * 存储数据 */export const setItem = (key, value) =&gt; &#123;  // 将数组、对象类型的数据转化为 JSON 字符串进行存储  if (typeof value === &quot;object&quot;) &#123;    value = JSON.stringify(value);  &#125;  window.localStorage.setItem(key, value);&#125;;/** * 获取数据 */export const getItem = (key) =&gt; &#123;  const data = window.localStorage.getItem(key);  try &#123;    return JSON.parse(data);  &#125; catch (err) &#123;    return data;  &#125;&#125;;/** * 删除数据 */export const removeItem = (key) =&gt; &#123;  window.localStorage.removeItem(key);&#125;;/** * 删除所有数据 */export const removeAllItem = (key) =&gt; &#123;  window.localStorage.clear();&#125;;</code></pre><h3 id="二-、vuex-处理-token"><a href="#二-、vuex-处理-token" class="headerlink" title="(二)、vuex 处理 token"></a>(二)、vuex 处理 token</h3><p>在 store 的 user.js 中</p><pre><code class="js">import &#123; login &#125; from &#39;@/api/sys&#39;import md5 from &#39;md5&#39;import &#123; setItem, getItem &#125; from &#39;@/utils/storage&#39;// 常量目录 export const TOKEN = &#39;token&#39;import &#123; TOKEN &#125; from &#39;@/constant&#39;export default &#123;  namespaced: true,  state: () =&gt; (&#123;    token: getItem(TOKEN) || &#39;&#39;  &#125;),  mutations: &#123;    setToken(state, token) &#123;      state.token = token      setItem(TOKEN, token)    &#125;  &#125;,  actions: &#123;    login(context, userInfo) &#123;      ...          .then(data =&gt; &#123;            this.commit(&#39;user/setToken&#39;, data.data.data.token)            resolve()          &#125;)          ...      &#125;)    &#125;  &#125;&#125;</code></pre><h2 id="四、响应数据的统一处理"><a href="#四、响应数据的统一处理" class="headerlink" title="四、响应数据的统一处理"></a>四、响应数据的统一处理</h2><p>上面这一行代码<code>this.commit(&#39;user/setToken&#39;, data.data.data.token)</code>，需要使用 data.data.data.token，书写方式不美观。</p><pre><code class="js">import axios from &#39;axios&#39;import &#123; ElMessage &#125; from &#39;element-plus&#39;...// 响应拦截器service.interceptors.response.use(  response =&gt; &#123;    const &#123; success, message, data &#125; = response.data    //   要根据success的成功与否决定下面的操作    if (success) &#123;      return data    &#125; else &#123;      // 业务错误      ElMessage.error(message) // 提示错误消息      return Promise.reject(new Error(message))    &#125;  &#125;,  error =&gt; &#123;    // TODO: 将来处理 token 超时问题    ElMessage.error(error.message) // 提示错误信息    return Promise.reject(error)  &#125;)export default service</code></pre><p>上面的代码简写为：</p><pre><code class="js">this.commit(&quot;user/setToken&quot;, data.token);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>92、使用vue3+element-plus写后台管理系统：（二）</title>
      <link href="/2022/11/07/92-vue3-ele-plus-admin/"/>
      <url>/2022/11/07/92-vue3-ele-plus-admin/</url>
      
        <content type="html"><![CDATA[<p>包括 element-plus 的安装、登录、svg icons 的处理（坑：svg 不显示的问题）</p><span id="more"></span><h2 id="一、安装-element-plus"><a href="#一、安装-element-plus" class="headerlink" title="一、安装 element-plus"></a>一、安装 element-plus</h2><pre><code class="shell">npm install @element-plus/iconsyarn add @element-plus/iconspnpm install @element-plus/icons</code></pre><blockquote><p>安装成功，会出现一个 element-plus 安装成功和一个按钮</p></blockquote><h2 id="二、公开路由表配置"><a href="#二、公开路由表配置" class="headerlink" title="二、公开路由表配置"></a>二、公开路由表配置</h2><pre><code class="js">// router/router.jsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const publicRoutes = [  &#123;    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/views/login/index&quot;),  &#125;,];const router = createRouter(&#123;  history: createWebHistory(),  routes: publicRoutes,&#125;);export default router;</code></pre><h2 id="三、登录页"><a href="#三、登录页" class="headerlink" title="三、登录页"></a>三、登录页</h2><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;login-container&quot;&gt;    &lt;el-form      class=&quot;login-form&quot;      ref=&quot;loginFormRef&quot;      :model=&quot;loginForm&quot;      :rules=&quot;loginRules&quot;    &gt;      &lt;div class=&quot;title-container&quot;&gt;        &lt;h3 class=&quot;title&quot;&gt;后台管理系统&lt;/h3&gt;      &lt;/div&gt;      &lt;el-form-item prop=&quot;username&quot;&gt;        &lt;span class=&quot;svg-container&quot;&gt;          &lt;svg-icon icon=&quot;user&quot; /&gt;        &lt;/span&gt;        &lt;el-input          placeholder=&quot;username&quot;          name=&quot;username&quot;          type=&quot;text&quot;          v-model=&quot;loginForm.username&quot;        &gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;span class=&quot;svg-container&quot;&gt;          &lt;svg-icon icon=&quot;password&quot; /&gt;        &lt;/span&gt;        &lt;el-input          placeholder=&quot;password&quot;          name=&quot;password&quot;          :type=&quot;passwordType&quot;          v-model=&quot;loginForm.password&quot;        &gt;&lt;/el-input&gt;        &lt;span class=&quot;show-pwd&quot;&gt;          &lt;svg-icon            :icon=&quot;passwordType === &#39;password&#39; ? &#39;eye&#39; : &#39;eye-open&#39;&quot;            @click=&quot;onChangePwdType&quot;          &gt;&lt;/svg-icon&gt;        &lt;/span&gt;      &lt;/el-form-item&gt;      &lt;el-button        type=&quot;primary&quot;        style=&quot;width:100%;margin-bottom: 30px&quot;        :loading=&quot;loading&quot;        @click=&quot;handleLogin&quot;        &gt;login      &lt;/el-button&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>js</p><pre><code class="js">&lt;script setup&gt;import &#123; ref, computed &#125; from &#39;vue&#39;import &#123; validatePassword &#125; from &#39;./rules&#39;import &#123; useStore &#125; from &#39;vuex&#39;import &#123; useRouter &#125; from &#39;vue-router&#39;// 数据源const loginForm = ref(&#123;  username: &#39;super-admin&#39;,  password: &#39;123456&#39;&#125;)// 验证规则const loginRules = ref(&#123;  username: [&#123;    required: true,    trigger: &#39;blur&#39;,    message: computed(() =&gt; &#123;      return &#39;error&#39;    &#125;)  &#125;  ],  password: [    &#123;      required: true,      trigger: &#39;blur&#39;,      validator: validatePassword()    &#125;  ]&#125;)// 处理密码const passwordType = ref(&#39;password&#39;)const onChangePwdType = () =&gt; &#123;  if (passwordType.value === &#39;password&#39;) &#123;    passwordType.value = &#39;text&#39;  &#125; else &#123;    passwordType.value = &#39;password&#39;  &#125;&#125;// 登录const loading = ref(false)const loginFormRef = ref(null)const router = useRouter()const store = useStore()const handleLogin = () =&gt; &#123;  loginFormRef.value.validate(valid =&gt; &#123;    if (!valid) return    loading.value = false    store.dispatch(&#39;user/login&#39;, loginForm.value).then(() =&gt; &#123;      loading.value = false      router.push(&#39;/&#39;)    &#125;).catch(err =&gt; &#123;      console.log(err)      loading.value = false    &#125;)  &#125;)&#125;&lt;/script&gt;</code></pre><p>校验规则：</p><pre><code class="js">export const validatePassword = () =&gt; &#123;  return (rule, value, callback) =&gt; &#123;    if (value.length &lt; 6) &#123;      // callback(new Error(i18n.global.t(&#39;msg.login.passwordRule&#39;)))      callback(new Error(&quot;error&quot;));    &#125; else &#123;      callback();    &#125;  &#125;;&#125;;</code></pre><p>登录页样式：</p><pre><code class="scss">&lt;style lang=&quot;scss&quot; scoped&gt;$bgColor: #2d3a4b;$dark_gray: #889aa4;$light_gray: #eee;$cursor: #fff;.login-container &#123;  min-height: 100%;  width: 100%;  background-color: $bgColor;  overflow: hidden;  .login-form &#123;    position: relative;    width: 520px;    max-width: 100%;    padding: 160px 35px 0;    margin: 0 auto;    overflow: hidden;    ::v-deep .el-form-item &#123;      border: 1px solid rgba(255, 255, 255, 0.1);      background-color: rgba(0, 0, 0, 0.1);      border-radius: 5px;      color: #454545;    &#125;    ::v-deep .el-input &#123;      display: inline-block;      height: 47px;      width: 85%;      input &#123;        background: transparent;        border: 0px;        -webkit-appearance: none;        border-radius: 0px;        padding: 12px 5px 12px 15px;        color: $light_gray;        height: 47px;        caret-color: $cursor;      &#125;    &#125;  &#125;&#125;.svg-container &#123;  padding: 6px 5px 6px 15px;  color: $dark_gray;  vertical-align: middle;  display: inline-block;&#125;.title-container &#123;  position: relative;  .title &#123;    font-size: 26px;    color: $light_gray;    margin: 0px auto 40px auto;    text-align: center;    font-weight: bold;  &#125;  ::v-deep .lang-select &#123;    position: absolute;    top: 4px;    right: 0;    background-color: white;    font-size: 22px;    padding: 4px;    border-radius: 4px;    cursor: pointer;  &#125;&#125;.show-pwd &#123;  position: absolute;  right: 10px;  top: 7px;  font-size: 16px;  color: $dark_gray;  cursor: pointer;  user-select: none;&#125;&lt;/style&gt;</code></pre><p>全局样式：src/styles/index.scss</p><pre><code class="scss">html,body &#123;  height: 100%;  margin: 0;  padding: 0;  -moz-osx-font-smoothing: grayscale;  -webkit-font-smoothing: antialiased;  text-rendering: optimizeLegibility;  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft      YaHei, Arial, sans-serif;&#125;#app &#123;  height: 100%;&#125;*,*:before,*:after &#123;  box-sizing: inherit;  margin: 0;  padding: 0;&#125;a:focus,a:active &#123;  outline: none;&#125;a,a:focus,a:hover &#123;  cursor: pointer;  color: inherit;  text-decoration: none;&#125;div:focus &#123;  outline: none;&#125;.clearfix &#123;  &amp;:after &#123;    visibility: hidden;    display: block;    font-size: 0;    content: &quot; &quot;;    clear: both;    height: 0;  &#125;&#125;</code></pre><p>导入全局样式</p><pre><code class="js">import &quot;./styles/index.scss&quot;;</code></pre><p><code>这里有个坑：</code> 登录页输入框的 svg 小图标不显示</p><h2 id="四、icon-图标处理方法：SvgIcon"><a href="#四、icon-图标处理方法：SvgIcon" class="headerlink" title="四、icon 图标处理方法：SvgIcon"></a>四、icon 图标处理方法：SvgIcon</h2><p>结合 vue-element-admin 项目的借鉴，将 icon 图标分为 element-plus 图标和自定义引入图标</p><blockquote><p>自定义 SVG 图标组件的能力：显示外部引入图标和项目内的 svg 图标</p></blockquote><p>封装 SvgIcon 组件</p><pre><code class="html">&lt;template&gt;  &lt;div    v-if=&quot;isExternal&quot;    :style=&quot;styleExternalIcon&quot;    class=&quot;svg-external-icon svg-icon&quot;    :class=&quot;className&quot;  /&gt;  &lt;svg v-else class=&quot;svg-icon&quot; :class=&quot;className&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;</code></pre><pre><code class="js">// utils/validate.js/** * 判断是否为外部资源 */export function isExternal(path) &#123;  return /^(https?:|mailto:|tel:)/.test(path)&#125;&lt;script setup&gt;import &#123; isExternal as external &#125; from &#39;@/utils/validate&#39;import &#123; defineProps, computed &#125; from &#39;vue&#39;const props = defineProps(&#123;  icon: &#123;    type: String,    required: true  &#125;,  className: &#123;    type: String,    default: &#39;&#39;  &#125;&#125;)// 判断是否为外部图标const isExternal = computed(() =&gt; external(props.icon))// 外部图标样式const styleExternalIcon = computed(() =&gt; (&#123;  mask: `url($&#123;props.icon&#125;) no-repeat 50% 50%`,  &#39;-webkit-mask&#39;: `url($&#123;props.icon&#125;) no-repeat 50% 50%`&#125;))// 项目内图标const iconName = computed(() =&gt; `#icon-$&#123;props.icon&#125;`)&lt;/script&gt;</code></pre><p>样式</p><pre><code class="scss">.svg-icon &#123;  width: 1em;  height: 1em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;&#125;.svg-external-icon &#123;  background-color: currentColor;  mask-size: cover !important;  display: inline-block;&#125;</code></pre><p>上面只处理了外部 svg 图标的展示，还要处理 element-plus 的图标</p><p>// 创建 icons 文件夹 内部包含：内部 svg 图标、SvgIcon 全局注册</p><pre><code class="js">import SvgIcon from &quot;@/components/SvgIcon&quot;;// 通过 require.context() 函数来创建自己的 contextconst svgRequire = require.context(&quot;./svg&quot;, false, /\.svg$/);// 此时返回一个 require 的函数，可以接受一个 request 的参数，用于 require 的导入。// 该函数提供了三个属性，可以通过 require.keys() 获取到所有的 svg 图标// 遍历图标，把图标作为 request 传入到 require 导入函数中，完成本地 svg 图标的导入svgRequire.keys().forEach((SvgIcon) =&gt; svgRequire(SvgIcon));export default (app) =&gt; &#123;  app.component(&quot;svg-icon&quot;, SvgIcon);&#125;;</code></pre><p>main.js 引入 svgIcon</p><pre><code class="js">// 导入 svgIconimport installIcons from &quot;@/icons&quot;;installIcons(app);</code></pre><p><code>此时，svg图标仍然不显示</code>，还需要使用 svg-sprite-loader 处理 svg 图标</p><pre><code class="shell">npm i --save-dev svg-sprite-loader@6.0.9</code></pre><p>配置 vue.config.js</p><pre><code class="js">const path = require(&quot;path&quot;);function resolve(dir) &#123;  return path.join(__dirname, dir);&#125;module.exports = &#123;  chainWebpack(config) &#123;    // 设置 svg-sprite-loader    config.module.rule(&quot;svg&quot;).exclude.add(resolve(&quot;src/icons&quot;)).end();    config.module      .rule(&quot;icons&quot;)      .test(/\.svg$/)      .include.add(resolve(&quot;src/icons&quot;))      .end()      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options(&#123;        symbolId: &quot;icon-[name]&quot;,      &#125;)      .end();  &#125;,&#125;;</code></pre><p>至此，svg 图标可以正常显示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91、使用vue3+element-plus写后台管理系统：（一）</title>
      <link href="/2022/10/16/91-vue3-ele-plus-admin/"/>
      <url>/2022/10/16/91-vue3-ele-plus-admin/</url>
      
        <content type="html"><![CDATA[<p>创建项目及代码格式提交规范（备注：遇见 2 个坑：yarn 问题、git cz 提交空格问题）</p><span id="more"></span><h2 id="一、vue-cli-创建项目"><a href="#一、vue-cli-创建项目" class="headerlink" title="一、vue-cli 创建项目"></a>一、vue-cli 创建项目</h2><p>vue-cli 版本应当大于 4.5.13</p><p>升级 vue-cli</p><pre><code class="shell">npm update -g @vue/cli</code></pre><p>创建项目</p><pre><code class="shell">vue create vue3-admin// 进入模板选择Vue CLI v4.5.13? Please pick a preset:  Default ([Vue 2] babel, eslint)  Default (Vue 3) ([Vue 3] babel, eslint)&gt; Manually select features  // 选择手动配置// ----------------------------------------------------------? Check the features needed for your project: (*) Choose Vue version // 选择 vue 版本 (*) Babel // 使用 babel ( ) TypeScript // 不使用 ts ( ) Progressive Web App (PWA) Support // 不使用 PWA (*) Router // 添加 vue-router (*) Vuex // 添加 vuex&gt;(*) CSS Pre-processors // 使用 css 预处理器 (*) Linter / Formatter // 代码格式化 ( ) Unit Testing // 不配置测试 ( ) E2E Testing  // // 不配置测试// ---------------------------------------------------------- Choose a version of Vue.js that you want to start the project with  2.x&gt; 3.x // 选择 vue 3.0 版本// ---------------------------------------------------------- Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) n // 不使用 history模式 的路由// ---------------------------------------------------------- ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default):&gt; Sass/SCSS (with dart-sass) // 使用基于 dart-sass 的 scss 预处理器  Sass/SCSS (with node-sass)  Less  Stylus// ----------------------------------------------------------? Pick a linter / formatter config:  ESLint with error prevention only  ESLint + Airbnb config&gt; ESLint + Standard config // 使用 ESLint 标准代码格式化方案  ESLint + Prettier// ----------------------------------------------------------? Pick additional lint features: (*) Lint on save //&gt;(*) Lint and fix on commit  // 保存时 &amp;&amp; 提交时，都进行 lint// ----------------------------------------------------------? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files // 单独的配置文件  In package.json// ---------------------------------------------------------- Save this as a preset for future projects? (y/N) n // 不存储预设</code></pre><p>进入项目，然后启动项目</p><p><code>创建项目这里的坑</code>:<a href="mailto:&#106;&#x65;&#115;&#116;&#45;&#119;&#x6f;&#114;&#x6b;&#101;&#x72;&#64;&#x32;&#x38;&#x2e;&#49;&#46;&#51;">&#106;&#x65;&#115;&#116;&#45;&#119;&#x6f;&#114;&#x6b;&#101;&#x72;&#64;&#x32;&#x38;&#x2e;&#49;&#46;&#51;</a>: The engine “node” is incompatible with this module. Expe</p><blockquote><p>解决方法： yarn config set ignore-engines true</p></blockquote><h2 id="二、ESLint-和-Prettier-解决代码格式问题"><a href="#二、ESLint-和-Prettier-解决代码格式问题" class="headerlink" title="二、ESLint 和 Prettier 解决代码格式问题"></a>二、ESLint 和 Prettier 解决代码格式问题</h2><p>创建项目时，已经选择了 eslint，配置文件为.eslintrc.js</p><p>vscode 下载<code>prettier</code>插件，创建.prettierrc 文件，配置如下：</p><pre><code class="js">&#123;  // 不尾随分号  &quot;semi&quot;: false,  // 使用单引号  &quot;singleQuote&quot;: true,  // 多行逗号分割的语法中，最后一行不加逗号  &quot;trailingComma&quot;: &quot;none&quot;&#125;</code></pre><p>vscode 设置中，搜索<code>Format On Save</code>,然后勾选<code>在保存时格式化文件。</code></p><p>还要解决一个问题就是 eslint 和 prettier 的冲突问题，例如 created 钩子函数后面会有一个空格，prettier 会将空格去掉</p><p>解决方法：</p><pre><code class="js">// .eslintrc.js  rules规则下添加&#39;space-before-function-paren&#39;: &#39;off&#39;</code></pre><h2 id="三、git-提交规范"><a href="#三、git-提交规范" class="headerlink" title="三、git 提交规范"></a>三、git 提交规范</h2><p>1、全局安装 commitizen</p><pre><code class="shell">npm install -g commitizen@4.2.4</code></pre><p>2、安装并配置 cz-customizable</p><pre><code class="shell">npm i cz-customizable@6.3.0 --save-dev</code></pre><p>配置：</p><pre><code class="js">// package.json&quot;config&quot;:&#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;  &#125;&#125;</code></pre><p>3、根目录下创建.cz-config.js 自定义提示文件</p><pre><code class="js">module.exports = &#123;  // 可选类型  types: [    &#123; value: &quot;feat&quot;, name: &quot;feat:     新功能&quot; &#125;,    &#123; value: &quot;fix&quot;, name: &quot;fix:      修复&quot; &#125;,    &#123; value: &quot;docs&quot;, name: &quot;docs:     文档变更&quot; &#125;,    &#123; value: &quot;style&quot;, name: &quot;style:    代码格式(不影响代码运行的变动)&quot; &#125;,    &#123;      value: &quot;refactor&quot;,      name: &quot;refactor: 重构(既不是增加feature，也不是修复bug)&quot;,    &#125;,    &#123; value: &quot;perf&quot;, name: &quot;perf:     性能优化&quot; &#125;,    &#123; value: &quot;test&quot;, name: &quot;test:     增加测试&quot; &#125;,    &#123; value: &quot;chore&quot;, name: &quot;chore:    构建过程或辅助工具的变动&quot; &#125;,    &#123; value: &quot;revert&quot;, name: &quot;revert:   回退&quot; &#125;,    &#123; value: &quot;build&quot;, name: &quot;build:    打包&quot; &#125;,  ],  // 消息步骤  messages: &#123;    type: &quot;请选择提交类型:&quot;,    customScope: &quot;请输入修改范围(可选):&quot;,    subject: &quot;请简要描述提交(必填):&quot;,    body: &quot;请输入详细描述(可选):&quot;,    footer: &quot;请输入要关闭的issue(可选):&quot;,    confirmCommit: &quot;确认使用以上信息提交？(y/n/e/h)&quot;,  &#125;,  // 跳过问题  skipQuestions: [&quot;body&quot;, &quot;footer&quot;],  // subject文字长度默认是72  subjectLimit: 72,&#125;;</code></pre><p>4、使用 git cz 代替 git commit</p><p>5、git hooks 校验提交信息</p><p>2 个工具的的使用：</p><blockquote><ol><li><a href="https://github.com/conventional-changelog/commitlint">commitlint</a>：用于检查提交信息</li></ol></blockquote><blockquote><ol start="2"><li><a href="https://github.com/typicode/husky">husky</a>：是<code>git hooks</code>工具</li></ol></blockquote><blockquote><blockquote><p>npm 版本大于 7.x</p></blockquote></blockquote><p>5.1 安装 commitlint</p><pre><code class="shell">npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4</code></pre><p>5.2 创建 commitlint.config.js(编码格式为 UTF-8)</p><pre><code class="js">module.exports = &#123;  // 继承的规则  extends: [&quot;@commitlint/config-conventional&quot;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &quot;type-enum&quot;: [      2,      &quot;always&quot;,      [        &quot;feat&quot;, // 新功能 feature        &quot;fix&quot;, // 修复 bug        &quot;docs&quot;, // 文档注释        &quot;style&quot;, // 代码格式(不影响代码运行的变动)        &quot;refactor&quot;, // 重构(既不增加新功能，也不是修复bug)        &quot;perf&quot;, // 性能优化        &quot;test&quot;, // 增加测试        &quot;chore&quot;, // 构建过程或辅助工具的变动        &quot;revert&quot;, // 回退        &quot;build&quot;, // 打包      ],    ],    // subject 大小写不做校验    &quot;subject-case&quot;: [0],  &#125;,&#125;;</code></pre><p>5.3 安装 husky</p><pre><code class="shell">npm install husky@7.0.1 --save-dev// 启动hooks，生成.huskynpx husky install// 在 `package.json` 中生成 `prepare` 指令（ **需要 npm &gt; 7.0 版本** ）npm set-script prepare &quot;husky install&quot;// 执行 `prepare` 指令npm run prepare// 添加 `commitlint` 的 `hook` 到 `husky`中，并指令在 `commit-msg` 的 `hooks` 下执行 `npx --no-install commitlint --edit &quot;$1&quot;` 指令npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;</code></pre><p>不符合规范的将不能提交</p><p>5.4 通过 pre-commit 检测提交时代码规范</p><pre><code class="shell">// 执行npx husky add .husky/pre-commit &quot;npx eslint --ext .js,.vue src&quot; // 添加 `commit` 时的 `hook` （`npx eslint --ext .js,.vue src` 会在执行到该 hook 时运行// 上面操作会在.husky文件下生成pre-commit</code></pre><blockquote><p>vscode 提交<br>源代码管理 -&gt; stage all changes -&gt; git cz -&gt; 选择提交类型 -&gt; git push</p></blockquote><p><img src="https://cdn.staticaly.com/gh/HeyJudeYQ/Image-Host@master/20221116/githook.6nw71q0vos40.png" alt="git cz"></p><p><code>这里有个坑：</code></p><blockquote><p>在<code>请简要描述提交（必填）</code> 这一步填写信息时，需要加一个空格</p></blockquote><p>5.5 lint-staged 自动修复格式错误(无需安装，创建项目时自带)</p><pre><code class="js">// package.json&quot;lint-staged&quot;: &#123;    &quot;src/**/*.&#123;js,vue&#125;&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;</code></pre><p>修改 <code>.husky/pre-commit</code> 文件</p><pre><code class="js">#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npx lint-staged</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90、相对时间及时间国际化的处理</title>
      <link href="/2022/08/15/90-relativeTime/"/>
      <url>/2022/08/15/90-relativeTime/</url>
      
        <content type="html"><![CDATA[<p>相对时间可以理解为最后一次“打招呼”的时间和当前时间的差值。例如：2 小时前，1 天前，1 年前等</p><span id="more"></span><h2 id="一、relativeTime-函数"><a href="#一、relativeTime-函数" class="headerlink" title="一、relativeTime 函数"></a>一、relativeTime 函数</h2><p>使用 day.js 将后端返回的时间戳处理为相对时间（1 小时前，1 天前等格式）</p><pre><code class="js">import dayjs from &quot;dayjs&quot;;import rTime from &quot;dayjs/plugin/relativeTime&quot;;// 处理语言import &quot;dayjs/locale/zh-cn&quot;;import store from &quot;@/store&quot;;// 时间格式处理： 2022-08-15const dateFilter = (val, format = &quot;YYYY-MM-DD&quot;) =&gt; &#123;  if (!isNaN(val)) &#123;    val = parseInt(val);  &#125;  return dayjs(val).format(format);&#125;;// 加载相对时间插件dayjs.extend(rTime);// 相对时间处理function relativeTime(val) &#123;  if (!isNaN(val)) &#123;    val = parseInt(val);  &#125;  return dayjs()    .locale(store.getters.langeage === &quot;zh&quot; ? &quot;zh-cn&quot; : &quot;en&quot;)    .to(dayjs(val));&#125;export default (app) =&gt; &#123;  app.config.globalProperties.$filters = &#123;    dateFilter,    relativeTime,  &#125;;&#125;;</code></pre><blockquote><p>app.config.globalProperties 是挂载在 vue 实例上面的，所以可以直接在 template 里面访问</p></blockquote><h2 id="二、组件内处理为相对时间"><a href="#二、组件内处理为相对时间" class="headerlink" title="二、组件内处理为相对时间"></a>二、组件内处理为相对时间</h2><pre><code class="html">&lt;el-table ref=&quot;tableRef&quot; :data=&quot;tableData&quot; border&gt;  &lt;el-table-column    v-for=&quot;(item, index) in tableColumns&quot;    :key=&quot;index&quot;    :prop=&quot;item.prop&quot;    :label=&quot;item.label&quot;  &gt;    // 相对时间的处理    &lt;template #default=&quot;&#123; row &#125;&quot; v-if=&quot;item.prop === &#39;publicDate&#39;&quot;&gt;      &#123;&#123; $filters.relativeTime(row.publicDate) &#125;&#125;    &lt;/template&gt;  &lt;/el-table-column&gt;&lt;/el-table&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>89、vue-loader 是什么？</title>
      <link href="/2022/08/14/89%E3%80%81vue-loader/"/>
      <url>/2022/08/14/89%E3%80%81vue-loader/</url>
      
        <content type="html"><![CDATA[<p>vue-loader 是用于处理单文件的 webpack loader。在 Vue 组件中，分为 template\script\style,结合其他 loader,我们可以用 Pug 编写<code>&lt;tempalte&gt;&lt;/tempalte&gt;</code>,用 Sass/Less 编写<code>&lt;style&gt;&lt;/style&gt;</code>,用 js/ts 编写<code>&lt;script&gt;&lt;/script&gt;</code></p><span id="more"></span><p>webpack 打包时，会以 loader 方式调用 vue-loader, vue-loader 被执行时，它会对单文件组件的每个语言块用单独的 loader 链处理，最后将这些单独的块装配成最终的组件模块。</p><p>vue-loader 会调用@vue-compiler-sfc 模块解析 SFC 源码为一个描述符，然后为每个语言块生成 import 代码。</p><pre><code class="js">// 模板import render from &#39;xxx.vue?vue&amp;type=template&#39;// scriptimport script from &#39;xxx.vue?vue&amp;type=script&#39;import * from &quot;xxx.vue?vue&amp;type=script&quot;// 样式import &#39;xxx.vue?vue&amp;type=style&amp;index=1&#39;script.render = renderexport default script</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue-loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88、Vue3和Vue2</title>
      <link href="/2022/08/11/88%E3%80%81vue3-vue2/"/>
      <url>/2022/08/11/88%E3%80%81vue3-vue2/</url>
      
        <content type="html"><![CDATA[<p>vue3 的 2 种响应式实现、Vue2 项目如何升级到 Vue3 等等。。。</p><span id="more"></span><p>一、options api 选项式 API</p><p>Options Api 可以理解为就是组件的各个选项，data、methods、computed、watch 等等就像是组件的一个个选项，在对应的选项里做对应的事情。</p><pre><code class="js">export default &#123;    data () &#123;        return &#123;            // 定义响应式数据的选项        &#125;    &#125;,    methods: &#123;        // 定义相关方法的选项    &#125;,    computed: &#123;        // 计算属性的选项    &#125;,    watch: &#123;        // 监听数据的选项    &#125;    ...&#125;</code></pre><p>在 data 中定义的数据，是无法做到响应式的，那是因为 Object.definePropety 只会对 data 选项中的数据进行递归拦截</p><p>在实际项目的开发过程中，数据定义在 data 中，方法定义在 methods 中，当我们的代码多起来，比如达到四、五百行的时候，如果我们想改动某个功能，就要去 data 中改数据，再去 methods 中改方法，来回地寻找。</p><p>二、composition api 组合式 api</p><p>1、Composition Api</p><blockquote><p>支持将相同的功能模块代码写在一起，甚至可以将某个功能单独的封装成函数，随意导入引用；也可以将任意的数据定义成响应式，再也不用局限于 data 中，我们只需要将每个实现的功能组合起来就可以了。</p></blockquote><p>示例：</p><pre><code class="js">&lt;template&gt;    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;    import &#123; ref &#125; from &quot;vue&quot;;    let count = ref(0);&lt;/script&gt;</code></pre><p>2、watchEffect</p><p>(1)、watchEffect 是立即执行的，不需要添加 immediate 属性。</p><p>(2)、watchEffect 不需要指定对某个具体的数据监听，watchEffect 会根据内容自动去感知，所以我们也可以在一个 watchEffect 中添加多个数据的监听处理</p><p>(3)、watchEffect 不能获取数据改变之前的值。</p><p>同时，watchEffect 会返回一个对象 watchEffectStop，通过执行 watchEffectStop，我们可以控制监听在什么时候结束。</p><blockquote><p>简单理解 watchEffect 会在第一次运行时创建副作用函数并执行一次，如果存在响应式变量，取值会触发 get 函数，这个时候收集依赖存储起来，当其他地方给响应式变量重新赋值的时候，set 函数中会触发方法派发更新，执行收集到的副作用函数，如果不存在响应式变量，就不会被收集触发</p></blockquote><blockquote><p>1、watchEffect 立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数。watch 侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数。<br>2、watchEffect(effect)是一种特殊 watch，传入的函数既是依赖收集的数据源，也是回调函数。如果我们不关心响应式数据变化前后的值，只是想拿这些数据做些事情，那么 watchEffect 就是我们需要的。watch 更底层，可以接收多种数据源，包括用于依赖收集的 getter 函数，因此它完全可以实现 watchEffect 的功能，同时由于可以指定 getter 函数，依赖可以控制的更精确，还能获取数据变化前后的值，因此如果需要这些时我们会使用 watch。<br>3、watchEffect 在使用时，传入的函数会立刻执行一次。watch 默认情况下并不会执行回调函数，除非我们手动设置 immediate 选项。<br>4、watchEffect(fn)相当于 watch(fn,fn,{immediate:true})</p></blockquote><p>vue3 不再只能有一个根元素</p><p>为什么在 vue2 时，只能拥有一个根元素？而 Vue3 可以写多个根节点？</p><blockquote><p>因为 vdom 是一颗单根树形结构，patch 方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个 vdom，自然应该满足这个要求。vue3 中之所以可以写多个根节点，是因为引入了 Fragment 的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个 Fragment 节点，把多个根节点作为它的 children。将来 patch 的时候，如果发现是一个 Fragment 节点，则直接遍历 children 创建或更新。</p></blockquote><p>3、ref 和 reactive</p><p>ref 和 reactive 的区别是什么呢，我们可以这样简单理解，它们都是用来定义响应式数据的，但是 ref 是用来给简单的数据类型定义响应式数据的，比如 number、string、boolean 等，而 reactive 是针对复杂的数据结构的，比如一个对象。</p><p>它们写法的区别主要在：ref 定义的数据，修改的时候是需改 xxx.value 的，而 reactive 定义的不用，产生这个区别的原因是它们实现响应式的方法不一样。</p><p>4、小结</p><blockquote><p>Options Api</p></blockquote><p>1、选项式的 api，相关代码必须写在规定的选项中，导致相同功能的代码被分割，代码量上来后查找相关代码很麻烦，后期维护修改难度较大。</p><p>2、数据都挂载在同一个 this 下，对 typescript 的支持不友好，类型推断很麻烦。</p><p>3、代码的复用能力很差。</p><blockquote><p>Composition Api</p></blockquote><p>1、组合式 api，代码定义很自由，相同功能代码整合到一起，查找修改都很方便。</p><p>2、公共代码的复用很简单，不同功能的代码也可以自由组合。</p><p>3、Vue 相关的 api 都是通过 import 导入的，这在打包的时候很友好。</p><p>另外，vue3 是支持 options api 的写法的</p><p>三、Vue3 响应式的实现</p><p>在 Vue2.x 中，响应式的机制深入人心，我们只需要在 data 中定义我们需要的数据，就会在初始化时被自动转为响应式数据。</p><p>但是在 Vue2 中，响应式的使用还存在一些限制，比如对象属性的增加和删除等并不能被监听到，在 Vue3 中，重新设计了响应式系统来解决这些问题。</p><h4 id="1、Vue2-x-的响应式——Object-defineProperty"><a href="#1、Vue2-x-的响应式——Object-defineProperty" class="headerlink" title="1、Vue2.x 的响应式——Object.defineProperty"></a>1、Vue2.x 的响应式——Object.defineProperty</h4><p>Vue2 响应式失效的现象</p><pre><code class="js">&lt;template&gt;    &lt;div&gt;        &lt;span&gt;姓名：&lt;/span&gt;        &lt;span&gt;&#123;&#123;person.name&#125;&#125;&lt;/span&gt;        &lt;span&gt;年龄：&lt;/span&gt;        &lt;span&gt;&#123;&#123;person.age&#125;&#125;&lt;/span&gt;        &lt;button @click=&quot;changeName&quot;&gt;修改姓名&lt;/button&gt;        &lt;button @click=&quot;addAge&quot;&gt;增加年龄&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;export default &#123;    data () &#123;        return &#123;            person: &#123;                name: &#39;小明&#39;            &#125;        &#125;     &#125;,     methods: &#123;         addAge() &#123;             this.person.age = &#39;18&#39;;         &#125;,         changeName() &#123;             this.person.name = &#39;小红&#39;;         &#125;     &#125;    ...&#125;</code></pre><p>data 里面只定义了一个响应式对象 person，我们定义了 2 个方法，一个是修改名称、一个是增加年龄，但是使用增加年龄方法时，会给响应式对象添加一个新的属性 age，页面上的年龄部分并不会发生改变。</p><p>Vue2 是通过 Object.defineProperty 循环遍历拦截 data 中的数据来实现响应式的。</p><blockquote><p><strong>Object.defineProperty 其实不是真正的代理，而应该是拦截</strong></p></blockquote><p>而且 Object.defineProperty 也不是对对象进行拦截，而是拦截对象的具体的某个属性。</p><pre><code class="js">const person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123;  set(value) &#123;    console.log(&quot;name:&quot;, value);  &#125;,  get() &#123;    return &quot;小明&quot;;  &#125;,&#125;);console.log(person.name);</code></pre><p>Vue2.x 的响应式实现其实就是递归遍历 data 中返回的对象，对每一个属性都使用 Object.defineProperty 进行拦截，而不在 data 中被初始化的数据是没有添加拦截的。</p><p>Vue2 如何添加和删除响应式数据？</p><p>需要额外的 api 来实现，Vue.$set 和Vue.$delete 方法分别实现添加、删除响应式数据</p><p>Vue2 响应式的局限性</p><blockquote><p>1、无法监听整个对象，只能对每个属性单独监听。</p></blockquote><blockquote><p>2、无法监听对象的属性的新增，删除（需要补充额外的 api 来解决）。</p></blockquote><blockquote><p>3、无法监听数组的变化。</p></blockquote><h4 id="2、Vue3-的响应式-proxy"><a href="#2、Vue3-的响应式-proxy" class="headerlink" title="2、Vue3 的响应式-proxy"></a>2、Vue3 的响应式-proxy</h4><blockquote><p>proxy 是真正地对整个对象进行代理，因为 proxy 可以劫持整个对象，所以 Object.defineProperty 中新增，删除某个属性无法检测的问题就不存在了，同时 proxy 也可以检测数组的变化</p></blockquote><pre><code class="js">const person = &#123;  name: &quot;小明&quot;,  age: 18,&#125;;const personProxy = new Proxy(person, &#123;  get: function (target, prop) &#123;    console.log(`获取了$&#123;prop&#125;:`, target[prop]);    return target[prop];  &#125;,  set: function (target, prop, value) &#123;    console.log(`修改了$&#123;prop&#125;:`, value);    target[prop] = value;  &#125;,&#125;);console.log(&quot;name:&quot;, personProxy.name); // 获取了name:小明personProxy.age = 20; // 修改了age:20</code></pre><p>参数 target，表示当前代理的对象，prop 是我们具体要操作的属性，set 多了一个参数 value 是我们对新属性的赋值。</p><p>从方法的参数我们其实就能看出来，proxy 是真的对整个对象进行拦截的，我们如果有新增或删除的属性，也不需要单独去添加处理，可以直接被检测代理。</p><p>在添加删除属性时，无需额外的 api。proxy 不支持 IE11。</p><p>vue3 另外一个代理的方法，那就是对象本身的 get、set 方法</p><pre><code class="js">const count = &#123;  _value: 0,  set value(num) &#123;    console.log(&quot;修改了count:&quot;, num);    this._value = num;  &#125;,  get value() &#123;    console.log(&quot;获取了count&quot;);    return this._value;  &#125;,&#125;;console.log(count.value); // 获取了countcount.value = 1; // 修改了count: 1</code></pre><p>这其实就是为什么我们使用 ref 定义的数据，赋值和取值的时候需要使用 xxx.value 了</p><p>一个 Vue3 composition api 常用的工具集：VueUse</p><h2 id="四、Vue2-升级到-Vue3-的非兼容性变更"><a href="#四、Vue2-升级到-Vue3-的非兼容性变更" class="headerlink" title="四、Vue2 升级到 Vue3 的非兼容性变更"></a>四、Vue2 升级到 Vue3 的非兼容性变更</h2><p>Vue3 中做了很多重构，有部分内容对于 Vue2 来说是不兼容的，所以说 Vue2 的代码直接升级到 Vue3 是不能直接运行的。</p><h4 id="1、createApp-的非兼容性变更"><a href="#1、createApp-的非兼容性变更" class="headerlink" title="1、createApp 的非兼容性变更"></a>1、createApp 的非兼容性变更</h4><p>Vue2 根实例挂载及全局组件注册方法：</p><pre><code class="js">import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 引入全局组件import GlobalComponent from &quot;./GlobalComponent.vue&quot;;// 注册全局组件Vue.component(&quot;GlobalComponent&quot;, GlobalComponent);new Vue(&#123;  render: (h) =&gt; h(App),&#125;).$mount(&quot;#app&quot;);</code></pre><p>Vue3 不直接在 Vue 对象上进行操作了，而是通过 createApp 来创建一个 App 应用实例，所有的操作都在 App 上进行</p><pre><code class="js">import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;createApp(App).mount(&quot;#app&quot;);</code></pre><p>现在我们想要在一个 App 上引入 store，就可以使用下面的写法(<strong>全局对象被共享是一件非常危险的事情</strong>)</p><pre><code class="js">// 引入封装好的storeimport store from &quot;./store&quot;;createApp(App).use(store).mount(&quot;#app&quot;);createApp(App2).mount(&quot;#app2&quot;);</code></pre><p>App 实例上的 store 不会影响 App2</p><h4 id="2、api-的-import-导入"><a href="#2、api-的-import-导入" class="headerlink" title="2、api 的 import 导入"></a>2、api 的 import 导入</h4><blockquote><p><strong>我们在使用这些挂载在 Vue 对象下的 Api 时，需要经过 import 导入的方式来使用。</strong></p></blockquote><pre><code class="js">import &#123; nextTick &#125; from &#39;vue&#39;;nextTick(() =&gt; &#123;    ...&#125;)</code></pre><p>按需加载的使用。</p><p>在 Vue2 的 Api 中，都是挂载在 Vue 下面，那么在打包的时候，会不管你有没有使用到这个 Api，都会一起打包进去，如果都是这样，随着 Vue 的全局 Api 越来越多，冗余的代码也就越多，打包的耗时、体积或者说代价也就越大。</p><p>在 Vue3 中，通过 import 导入 Api 来使用，那我们在打包的时候，则只会将对应的模块打包进去，做到真正的用了多少就打包多少，就算 Vue 中再增加多少代码，也不会影响我们打包的项目。</p><h4 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h4><p>升级 Vue3 不仅需要更换 Vue 版本，还有一些非兼容性变更内容需要了解</p><ol><li>全局的操作不再使用 Vue 实例，而是使用通过 createApp 创建的 app 实例。</li><li>全局和内部 API 已经被重构，需要使用 import 导入使用，并且支持 tree-shake。</li></ol><p>如何将 localStorage 中的数据变成响应式的？</p><pre><code class="js">// tool.jsimport &#123; ref, watchEffect &#125; from &quot;vue&quot;;const useLocalStorage = (name, value = &#123;&#125;) =&gt; &#123;  const localData = ref(JSON.parse(localStorage.getItem(name)) || value);  watchEffect(() =&gt; &#123;    // 监听本地localstorage数据对应的响应式变量更改    localStorage.setItem(name, JSON.stringify(localData.value));  &#125;);  return localData;&#125;;export &#123; useLocalStorage &#125;;</code></pre><p>假设有一个计数器，需要将数据同步到本地的 localStorage 中，我们只需要在计数器文件中引入 useLocalStorage 方法即可：</p><pre><code class="js">&lt;script setup&gt;  import &#123;useLocalStorage&#125; from &#39;./useLocalStorage&#39;;  // 定义响应式数据  let count = useLocalStorage(&#39;count&#39;, 0);  const addCount = () =&gt; &#123;    count.value ++;  &#125;&lt;/script&gt;</code></pre><h2 id="五、如何将-Vue2-项目升级到-Vue3"><a href="#五、如何将-Vue2-项目升级到-Vue3" class="headerlink" title="五、如何将 Vue2 项目升级到 Vue3?"></a>五、如何将 Vue2 项目升级到 Vue3?</h2><h4 id="1、项目升级方法一"><a href="#1、项目升级方法一" class="headerlink" title="1、项目升级方法一"></a>1、项目升级方法一</h4><p>将 vue-cli 升级到高版本</p><p>Vue 的依赖版本升级到 vue3,需要安装@vue/compat</p><blockquote><blockquote><p>注意@vue/compat 的版本号需要与 Vue 的版本号保持一致</p></blockquote></blockquote><p>@vue/compat 是 Vue2 和 Vue3 的一个过渡产物，@vue/compat 可以运行在 Vue2 的环境下，但会对 Vue3 不兼容或者废弃的部分进行警告，我们引入@vue/compat 后，只需要根据警告的内容进行修改就可以了。<br>通过@vue/compat 也可以对警告进行分类过滤，单独针对某一些问题进行修改.</p><p>安装完 Vue 和@vue/compat 的依赖后，还需要在项目根目录下新增 vue.config.js 文件，包含以下内容:</p><pre><code class="js">// vue.config.jsmodule.exports = &#123;  chainWebpack: (config) =&gt; &#123;    config.resolve.alias.set(&quot;vue&quot;, &quot;@vue/compat&quot;);    config.module      .rule(&quot;vue&quot;)      .use(&quot;vue-loader&quot;)      .tap((options) =&gt; &#123;        return &#123;          ...options,          compilerOptions: &#123;            compatConfig: &#123;              MODE: 2,            &#125;,          &#125;,        &#125;;      &#125;);  &#125;,&#125;;</code></pre><p>运行项目，根据警告信息的内容去 Vue 官网的特性参考中查询具体的错误原因，以及修改方案。</p><p>vue-router 和 vuex 都要升级到 v4，Element-ui 也要更新到 Vue3 对应的版本（element-plus）</p><p>vue3 版本 router 部分的写法：</p><pre><code class="js">import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;import Home from &quot;../pages/home.vue&quot;;import Login from &quot;../pages/login.vue&quot;;const routes = [  &#123;    path: &quot;/home&quot;,    component: Home,  &#125;,  &#123;    path: &quot;/&quot;,    component: Login,  &#125;,];export default createRouter(&#123;  history: createWebHashHistory(),  routes,&#125;);</code></pre><pre><code class="js">// main.jsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import routers from &quot;./router&quot;;const app = createApp(App);app.use(routers).mount(&quot;#app&quot;);</code></pre><h4 id="2、项目升级方法二：gogocode"><a href="#2、项目升级方法二：gogocode" class="headerlink" title="2、项目升级方法二：gogocode"></a>2、项目升级方法二：gogocode</h4><p>1、安装最新的 gogocode-cli</p><pre><code class="js">npm install gogocode-cli -g</code></pre><p>2、在需要升级的项目根目录下，运行下面的指令</p><pre><code class="js">gogocode -s ./src -t gogocode-plugin-vue -o ./src-out</code></pre><p>-s 后面指的是需要升级的源码文件夹，-o 后面的参数指的是升级后的代码输出位置</p><p>3、代码转换了还不够，我们项目的依赖都要升级到对应版本<br>GOGOCode 可以帮我们把 package.json 里面的 Vue/Vuex/Vue-router/Vue 编译工具升级到适配 Vue3 的版本，在项目根目录下执行以下指令</p><pre><code class="js">gogocode -s package.json -t gogocode-plugin-vue -o package.json</code></pre><p>虽然使用了 GOGOCode，但也不代表我们的项目就可以直接完成升级，项目中如果用到了其他 Vue2 版本的组件库，还是需要我们自己去升级 Vue3 对应的版本，包括一些 Api 的变化都要我们自己去手动调整，并且使用 GOGOCode 也有一些转化规则是不支持的，具体的可以参考 GOGOCode 的转化规则覆盖。</p><h2 id="六、vite"><a href="#六、vite" class="headerlink" title="六、vite"></a>六、vite</h2><h4 id="1、什么是-ES-Module？"><a href="#1、什么是-ES-Module？" class="headerlink" title="1、什么是 ES Module？"></a>1、什么是 ES Module？</h4><blockquote><p>将 JavaScript 程序拆分为可按需导入的单独模块的机制，简单来说就是我们可以对 JavaScript 模块化开发，通过 import 和 export 来导入导出我们的模块内容</p></blockquote><p>Vite 在冷启动的时候，将代码分为依赖和源码两部分，源码部分通常会使用 ESModules 或者 CommonJS 拆分到大量小模块中，而对于依赖部分，Vite 使用 Esbuild 对依赖进行预构建</p><p>Esbuild 的优势：</p><p>1、语言优势，Esbuild 使用 Go 语言开发，相对于 JavaScript，Go 语言是一种编译型语言，在编译阶段就已经将源码转译为机器码。</p><p>2、多线程，Rollup 和 webpack 都没有使用多线程的能力，而 Esbuild 在算法上进行了大量的优化，充分的利用了多 CPU 的优势。</p><h4 id="2、搭建-vite-项目"><a href="#2、搭建-vite-项目" class="headerlink" title="2、搭建 vite 项目"></a>2、搭建 vite 项目</h4><pre><code class="js">// node 16.3.0npm init vite@latest</code></pre><h4 id="3、vite-项目的目录"><a href="#3、vite-项目的目录" class="headerlink" title="3、vite 项目的目录"></a>3、vite 项目的目录</h4><pre><code class="js">    |-- .gitignore    |-- index.html    |-- package-lock.json    |-- package.json    |-- README.md    |-- vite.config.js    |-- .vscode    |   |-- extensions.json    |-- public    |   |-- favicon.ico    |-- src        |-- App.vue        |-- main.js        |-- assets        |   |-- logo.png        |-- components            |-- HelloWorld.vue// src/|-- src    |-- App.vue    |-- main.js    |-- api           -- 请求数据，接口文件    |-- assets        -- 静态资源    |-- commons       -- 公共文件（公共方法，封装函数）    |-- components    -- Vue组件    |-- pages         -- 模块页面    |-- router        -- 路由文件    |-- store         -- 数据管理</code></pre><h4 id="4、安装-vue-router-的-4-x-版本"><a href="#4、安装-vue-router-的-4-x-版本" class="headerlink" title="4、安装 vue-router 的 4.x 版本"></a>4、安装 vue-router 的 4.x 版本</h4><pre><code class="js">npm install vue-router@4</code></pre><p>在 router 文件下新建 router.js 文件来增加路由控制，</p><pre><code class="js">import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;import Login from &quot;../pages/login.vue&quot;;import Home from &quot;../pages/home.vue&quot;;const routes = [  &#123;    path: &quot;/login&quot;,    component: Login,  &#125;,  &#123;    path: &quot;/home&quot;,    component: Home,  &#125;,];const router = createRouter(&#123;  history: createWebHashHistory(),  routes,&#125;);export default router;</code></pre><p>createRouter 用来创建一个可以被 Vue 应用程序使用的路由实例，需要传入两个参数，history 是表示路由的历史记录，我们可以选择使用 createWebHistory、createWebHashHistory 来分别创建 HTML5 历史记录和 hash 历史记录，我们这里选择创建 hash 历史记录</p><h2 id="七、输入路由的时候是怎么获取到页面的"><a href="#七、输入路由的时候是怎么获取到页面的" class="headerlink" title="七、输入路由的时候是怎么获取到页面的"></a>七、输入路由的时候是怎么获取到页面的</h2><blockquote><p>当我们在浏览器中输入一个地址后，浏览器会根据路径构建一个请求，接下来就会对输入的域名进行 DNS 解析，得到正确的 IP 地址，然后和得到的 IP 地址建立 TCP 链接，发送 HTTP 请求，服务器接收到请求后，就会返回响应的 HTML 内容。完成了请求和响应后，浏览器拿到了返回的 HTML 字符串，转换成 DOM 树结构，经过对 DOM 的样式计算，最终生成布局，在页面上进行合成渲染</p></blockquote><h2 id="八、性能优化"><a href="#八、性能优化" class="headerlink" title="八、性能优化"></a>八、性能优化</h2><p>1、路由懒加载：有效拆分 APP 尺寸，访问时才异步加载</p><p>(1)当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样会更加高效，是一种优化手段。</p><p>(2)一般来说，对所有的路由都使用动态导入是个好主意。</p><p>(3)给 component 选项配置一个返回 Promise 组件的函数就可以定义懒加载路由。例如：<br>{ path: ‘/users/:id’, component: () =&gt; import(‘./views/UserDetails’) }</p><p>(4)结合注释() =&gt; import(/_ webpackChunkName: “group-user” _/ ‘./UserDetails.vue’)可以做 webpack 代码分块<br>vite 中结合 rollupOptions 定义分块</p><p>(5)路由中不能使用异步组件</p><p>2、keep-alive 缓存页面：避免和重复创建组件实例，且能保留缓存组件状态</p><p>3、v-show 复用 DOM：避免重复创建组件</p><p>4、v-once 和 v-memo:不再变化的数据使用 v-once；按条件跳过更新时使用 v-memo</p><p>5、长列表性能优化：如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</p><p>6、事件的销毁：Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件</p><p>7、图片懒加载：图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。可以使用 vue-lazyload</p><p>8、第三方插件按需引入：例如组件库（element-plus）</p><p>9、服务端渲染：首屏渲染慢，可以考虑 SSR \ SSG</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>87、element的表单校验自动定位到未校验成功位置</title>
      <link href="/2022/08/09/87.element-validator/"/>
      <url>/2022/08/09/87.element-validator/</url>
      
        <content type="html"><![CDATA[<p>遇到的项目问题是在每个折叠面板里边都有不同的表单，用 element 上的校验时，若有没填写的表单或不符合表单格式的要求，则自动展开该折叠面板，且页面定位到没校验成功的表单。</p><span id="more"></span><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code class="js">this.$refs.form.validate((valid, object) =&gt; &#123;  if (valid) &#123;    alert(&quot;submit!&quot;);  &#125; else &#123;    let split = &quot;&quot;;    for (let i in object) &#123;      let dom = this.$refs[i];      if (Object.prototype.toString.call(dom) !== &quot;[object Object]&quot;) &#123;        //这里是针对遍历的情况（多个输入框），取值为数组        dom = dom[0];        // 第一个未填写必填项的表单被记录，这个是为了处理如何把校验未成功的第一个面板展开        split = dom.prop;        let index = split.indexOf(&quot;.&quot;);        let last = split.lastIndexOf(&quot;.&quot;);        // 通过未填写的表单索引展开折叠面板        this.activeName = Number(split.slice(index + 1, last));        break;      &#125;      dom.$el.scrollIntoView(&#123;        //滚动到指定节点        block: &quot;center&quot;, //值有start,center,end，nearest，当前显示在视图区域中间        behavior: &quot;smooth&quot;, //值有auto、instant,smooth，缓动动画（当前是慢速的）      &#125;);    &#125;    console.log(&quot;error submit!!&quot;);    return false;  &#125;&#125;);</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code class="js"> submit(formName) &#123;    this.$refs[formName][&quot;validate&quot;]((valid) =&gt; &#123;      if (valid) &#123;      &#125; else &#123;        setTimeout(()=&gt;&#123;            var isError= document.getElementsByClassName(&quot;is-error&quot;);            isError[0].querySelector(&#39;input&#39;).focus();          &#125;,100);          return false;      &#125;    &#125;);  &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>86、canvas电子签名</title>
      <link href="/2022/08/08/86.signature/"/>
      <url>/2022/08/08/86.signature/</url>
      
        <content type="html"><![CDATA[<p>canvas电子签名</p><span id="more"></span><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      #cvs &#123;        background-color: #000;        background: #000;      &#125;      body &#123;        height: 100vh;        background-color: rgb(26, 25, 25);      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;canvas id=&quot;cvs&quot;&gt;&lt;/canvas&gt;    &lt;div style=&quot;margin-top: 50px&quot;&gt;      &lt;button id=&quot;clear&quot;&gt;清空&lt;/button&gt;      &lt;button id=&quot;back&quot;&gt;回退&lt;/button&gt;      &lt;button id=&quot;save&quot;&gt;保存&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;      let width = 800;      let height = 400;      let isDownin = false;      let lastX = 0;      let lastY = 0;      let cacheData = [];      const cvs = document.getElementById(&quot;cvs&quot;);      const ctx = cvs.getContext(&quot;2d&quot;);      cvs.width = width;      cvs.height = height;      cvs.addEventListener(&quot;mousedown&quot;, (e) =&gt; &#123;        isDownin = true;        lastX = e.pageX;        lastY = e.pageY;        let cacheItem = ctx.getImageData(0, 0, width, height);        cacheData.push(cacheItem);        ctx.moveTo(lastX, lastY);      &#125;);      cvs.addEventListener(&quot;mousemove&quot;, (e) =&gt; &#123;        if (!isDownin) return;        drawLine(e.pageX, e.pageY);        ctx.stroke();      &#125;);      cvs.addEventListener(&quot;mouseup&quot;, (e) =&gt; &#123;        isDownin = false;      &#125;);      function drawLine(x, y) &#123;        ctx.beginPath();        ctx.lineWidth = 8;        ctx.strokeStyle = &quot;#fff&quot;;        ctx.lineCap = &quot;round&quot;;        ctx.lineJoin = &quot;round&quot;;        ctx.moveTo(lastX, lastY);        ctx.lineTo(x, y);        ctx.stroke();        lastX = x;        lastY = y;      &#125;      /* 清空 */      const clear = document.getElementById(&quot;clear&quot;);      clear.onclick = () =&gt; &#123;        ctx.clearRect(0, 0, width, height);      &#125;;      /* 回退 */      const back = document.getElementById(&quot;back&quot;);      back.onclick = () =&gt; &#123;        if (cacheData.length === 0) return;        ctx.putImageData(cacheData.pop(), 0, 0);      &#125;;      const save = document.getElementById(&quot;save&quot;);      save.onclick = () =&gt; &#123;        cvs.toBlob((blob) =&gt; &#123;          const a = document.createElement(&quot;a&quot;);          document.body.append(a);          a.download = `签名.png`;          a.href = URL.createObjectURL(blob);          a.click();          a.remove();        &#125;);      &#125;;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>85、常用代码片段</title>
      <link href="/2022/08/06/85.js-function/"/>
      <url>/2022/08/06/85.js-function/</url>
      
        <content type="html"><![CDATA[<p>整理一些常用的代码片段</p><span id="more"></span><h2 id="一、数组重排序"><a href="#一、数组重排序" class="headerlink" title="一、数组重排序"></a>一、数组重排序</h2><pre><code class="js">const shuffle = (arr) =&gt; arr.sort(() =&gt; Math.random() - 0.5);const arr = [1, 2, 3, 4, 5];console.log(shuffle(arr));</code></pre><h2 id="二、复制到剪切板"><a href="#二、复制到剪切板" class="headerlink" title="二、复制到剪切板"></a>二、复制到剪切板</h2><pre><code class="js">const copyToClipboard = (text) =&gt;  navigator.clipboard &amp;&amp;  navigator.clipboard.writeText &amp;&amp;  navigator.clipboard.writeText(text);copyToClipboard(&quot;Hello World!&quot;);</code></pre><h2 id="三、滚动到顶部"><a href="#三、滚动到顶部" class="headerlink" title="三、滚动到顶部"></a>三、滚动到顶部</h2><p>behavior:”smooth”：开启平滑滚动</p><pre><code class="js">const scrollToTop = (element) =&gt;  element.scrollIntoView(&#123; behavior: &quot;smooth&quot;, block: &quot;start&quot; &#125;);</code></pre><h2 id="四、检测设备"><a href="#四、检测设备" class="headerlink" title="四、检测设备"></a>四、检测设备</h2><pre><code class="js">const detectDeviceType = () =&gt;  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(    navigator.userAgent  )    ? &quot;Mobile&quot;    : &quot;Desktop&quot;;console.log(detectDeviceType());</code></pre><h2 id="五、深拷贝对象"><a href="#五、深拷贝对象" class="headerlink" title="五、深拷贝对象"></a>五、深拷贝对象</h2><pre><code class="js">const deepCopy = (obj) =&gt; JSON.parse(JSON.stringify(obj));</code></pre><h2 id="六、等待函数"><a href="#六、等待函数" class="headerlink" title="六、等待函数"></a>六、等待函数</h2><pre><code class="js">const wait = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));const asyncFn = async () =&gt; &#123;  await wait(1000);  console.log(&quot;等待异步函数执行结束&quot;);&#125;;asyncFn();</code></pre><h2 id="七、生成随机色"><a href="#七、生成随机色" class="headerlink" title="七、生成随机色"></a>七、生成随机色</h2><pre><code class="js">const generateRandomHexColor = () =&gt;  `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16)&#125;`;console.log(generateRandomHexColor());</code></pre><h2 id="八、数组结构与树结构的转换"><a href="#八、数组结构与树结构的转换" class="headerlink" title="八、数组结构与树结构的转换"></a>八、数组结构与树结构的转换</h2><p>数组结构数据</p><pre><code class="js">const arrayData = [  &#123; id: 2, title: &quot;中国&quot;, parent_id: 0 &#125;,  &#123; id: 3, title: &quot;上海&quot;, parent_id: 2 &#125;,  &#123; id: 4, title: &quot;浦东新区&quot;, parent_id: 3 &#125;,  &#123; id: 5, title: &quot;新场古镇&quot;, parent_id: 4 &#125;,  &#123; id: 6, title: &quot;湖南省&quot;, parent_id: 2 &#125;,  &#123; id: 1, title: &quot;俄罗斯&quot;, parent_id: 0 &#125;,];</code></pre><p>方法一、使用递归：</p><p>1、递归需分为两个函数来完成<br>2、 以为返回的递归函数主要处理查找 id 添加 children<br>3、 由转化函数将结果返回</p><pre><code class="js">/** * 递归查找添加children * @param &#123;数组数据&#125; data * @param &#123;存放返回结果&#125; result * @param &#123;父id&#125; pid */function getChildren(data, result, pid) &#123;  for (const item of data) &#123;    if (item.parent_id === pid) &#123;      const newItem = &#123; children: [], ...item &#125;;      result.push(newItem);      getChildren(data, newItem.children, item.id);    &#125;  &#125;&#125;/** * 转化方法 * @param &#123;数组数据&#125; data * @param &#123;父id&#125; pid * @returns */function arrayToTree(data, pid) &#123;  let result = [];  getChildren(data, result, pid);  return result;&#125;console.log(arrayToTree(arrayData, 0));</code></pre><p>方法二、reduce</p><pre><code class="js">/** * 数组结构转为树结构 * @param &#123;*&#125; data 数组数据 * @returns */function arrayToTree(data) &#123;  const result = [];  const obj = data.reduce((pre, cur) =&gt; &#123;    pre[cur.id] = cur;    return pre;  &#125;, &#123;&#125;);  for (let item of data) &#123;    if (item.parent_id === 0) &#123;      result.push(item);      continue;    &#125;    if (item.parent_id in obj) &#123;      const parent = obj[item.parent_id];      parent.children = parent.children || [];      parent.children.push(item);    &#125;  &#125;  return result;&#125;</code></pre><h2 id="九、树结构转数组结构"><a href="#九、树结构转数组结构" class="headerlink" title="九、树结构转数组结构"></a>九、树结构转数组结构</h2><p>数组结构</p><pre><code class="js">/** 树状形结构数据treeData */const treeData = [  &#123;    id: 2,    title: &quot;中国&quot;,    parent_id: 0,    children: [      &#123;        id: 3,        title: &quot;上海&quot;,        parent_id: 2,        children: [          &#123;            id: 4,            title: &quot;浦东新区&quot;,            parent_id: 3,            children: [&#123; id: 5, title: &quot;新场古镇&quot;, parent_id: 4 &#125;],          &#125;,        ],      &#125;,      &#123; id: 6, title: &quot;湖南省&quot;, parent_id: 2 &#125;,    ],  &#125;,  &#123; id: 1, title: &quot;俄罗斯&quot;, parent_id: 0 &#125;,];</code></pre><p>递归方法</p><pre><code class="js">/** * 树结构数组扁平化 * @param &#123;*&#125; data 树结构的数组 * @returns */function treeToArray(data) &#123;  return data.reduce((pre, cur) =&gt; &#123;    const &#123; children = [], ...item &#125; = cur;    return pre.concat([&#123; ...item &#125;], treeToArray(children));  &#125;, []);&#125;</code></pre><h2 id="十、数据类型验证"><a href="#十、数据类型验证" class="headerlink" title="十、数据类型验证"></a>十、数据类型验证</h2><pre><code class="js">function typeOf(obj) &#123;  const toString = Object.prototype.toString;  const map = &#123;    &quot;[object Boolean]&quot;: &quot;boolean&quot;,    &quot;[object Number]&quot;: &quot;number&quot;,    &quot;[object String]&quot;: &quot;string&quot;,    &quot;[object Function]&quot;: &quot;function&quot;,    &quot;[object Array]&quot;: &quot;array&quot;,    &quot;[object Date]&quot;: &quot;date&quot;,    &quot;[object RegExp]&quot;: &quot;regExp&quot;,    &quot;[object Undefined]&quot;: &quot;undefined&quot;,    &quot;[object Null]&quot;: &quot;null&quot;,    &quot;[object Object]&quot;: &quot;object&quot;,    &quot;[object FormData]&quot;: &quot;formData&quot;,  &#125;;  return map[toString.call(obj)];&#125;</code></pre><h2 id="十一、只能输入金额"><a href="#十一、只能输入金额" class="headerlink" title="十一、只能输入金额"></a>十一、只能输入金额</h2><pre><code class="html">:rules=&quot;&#123; required: itrue, validator: validatePrice, trigger: &#39;blur&#39; &#125;&quot;</code></pre><pre><code class="js">validatePrice(rule, value, callback) &#123;    if (!value) &#123;        callback(new Error(&#39;请输入价格&#39;))    &#125; else if (!/(^[1-9]\d*(\.\d&#123;1,2&#125;)?$)|(^0(\.\d&#123;1,2&#125;)?$)/.test(value)) &#123;        callback(new Error(&#39;请输入有效价格&#39;))    &#125; else if (value &gt;= 99999999) &#123;        callback(new Error(&#39;超过最大金额&#39;))    &#125; else &#123;        callback()    &#125;&#125;,</code></pre><h2 id="十二、数字单位：10000-转换为万（含：亿）"><a href="#十二、数字单位：10000-转换为万（含：亿）" class="headerlink" title="十二、数字单位：10000 转换为万（含：亿）"></a>十二、数字单位：10000 转换为万（含：亿）</h2><pre><code class="js">/** 数字超过一万转换为万 * @param &#123; Number &#125; value 数值 * @param &#123; Number &#125; decimal 保留几位小数 * @returns &#123; String &#125; */const transNumberToShort = (value, decimal = 2) =&gt; &#123;  const k = 10000;  const sizes = [&quot;&quot;, &quot;万&quot;, &quot;亿&quot;, &quot;万亿&quot;];  let i = undefined;  let str = &quot;&quot;;  if (value &lt; k) &#123;    str = value;  &#125; else &#123;    i = Math.floor(Math.log(value) / Math.log(k));    str = (value / Math.pow(k, i)).toFixed(decimal) + sizes[i];  &#125;  return str;&#125;;</code></pre><h2 id="十三、简单的数据双向绑定"><a href="#十三、简单的数据双向绑定" class="headerlink" title="十三、简单的数据双向绑定"></a>十三、简单的数据双向绑定</h2><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;input type=&quot;text&quot; id=&quot;a&quot; /&gt;      &lt;span id=&quot;b&quot;&gt;&lt;/span&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script&gt;    var obj = &#123;      val: null,    &#125;; //定义一个空对象    Object.defineProperty(obj, &quot;val&quot;, &#123;      // 这里的 val 就是 obj 里面的值      get: function () &#123;        return val;      &#125;,      set: function (newVal) &#123;        val = newVal; //定义val等于修改后的内容        if (!val) return; // 阻止显示 undefined        document.getElementById(&quot;a&quot;).value = val; //让文本框的内容等于val        document.getElementById(&quot;b&quot;).innerHTML = val; //让span的内容等于val      &#125;,    &#125;);    document.addEventListener(&quot;keyup&quot;, function (e) &#123;      //当在文本框输入内容时让对象里你定义的val等于文本框的值      obj.val = e.target.value;    &#125;);  &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="十四、数组大小排序"><a href="#十四、数组大小排序" class="headerlink" title="十四、数组大小排序"></a>十四、数组大小排序</h2><pre><code class="js">var num = [7, 8, 6, 5, 2];//倒序排列num.sort((a, b) =&gt; &#123;  return b - a;&#125;);//正序排列num.sort((a, b) =&gt; &#123;  return a - b;&#125;);</code></pre><h2 id="十五、js-从数组里面取出某两个值作为对象的-key-和-value"><a href="#十五、js-从数组里面取出某两个值作为对象的-key-和-value" class="headerlink" title="十五、js 从数组里面取出某两个值作为对象的 key 和 value"></a>十五、js 从数组里面取出某两个值作为对象的 key 和 value</h2><pre><code class="js">const data = [  &#123;    id: 1,    content: &quot;1111&quot;,  &#125;,  &#123;    id: 2,    content: &quot;2222&quot;,  &#125;,  &#123;    id: 3,    content: &quot;3333&quot;,  &#125;,];let lessonObj = data.reduce((obj, cur, index) =&gt; &#123;  obj[`config_$&#123;cur[&quot;id&quot;]&#125;`] = cur[&quot;content&quot;];  return obj;&#125;, &#123;&#125;);</code></pre><h2 id="十六、深拷贝、浅拷贝"><a href="#十六、深拷贝、浅拷贝" class="headerlink" title="十六、深拷贝、浅拷贝"></a>十六、深拷贝、浅拷贝</h2><blockquote><p>区别：浅拷贝地址还是指向原来那个内存地址，深拷贝是重新开辟一个内存地址</p></blockquote><blockquote><p>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间</p></blockquote><pre><code class="js">Object.assign()Array.prototype.slice(0)扩展运算符（...）</code></pre><blockquote><p>深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝</p></blockquote><pre><code class="js">// 方法一JSON.parse(JSON.stringify());// 方法二// 循环对象，把对象的 KEY 和 VALUE 存放到一个新的变量里面function deepClone(source) &#123;  const targetObj = source.constructor === Array ? [] : &#123;&#125;;  for (keys in source) &#123;    if (source.hasOwnProperty(keys)) &#123;      // 数组和对象      if (source[keys] &amp;&amp; typeof source[keys] === &quot;object&quot;) &#123;        // targetObj[keys] = targetObj[keys] === Array ? [] : &#123;&#125;; // 只是为了可读性，可要可不要        targetObj[keys] = deepClone(source[keys]);      &#125; else &#123;        // 基本类型        targetObj[keys] = source[keys];      &#125;    &#125;  &#125;  return targetObj;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84、Chrome快速切换搜索引擎</title>
      <link href="/2022/08/04/84.search/"/>
      <url>/2022/08/04/84.search/</url>
      
        <content type="html"><![CDATA[<p>如何在不同的搜索引擎的之间快速切换？其实谷歌浏览器（Chrome）自带了一个关键词功能，只需要稍加修改，就可以方便的实现搜索引擎切换，不需要额外安装任何特殊软件或者浏览器插件。</p><span id="more"></span><h2 id="一、Chrome浏览器的设置"><a href="#一、Chrome浏览器的设置" class="headerlink" title="一、Chrome浏览器的设置"></a>一、Chrome浏览器的设置</h2><p>1、打开<code>Chrome浏览器的设置</code>，找到<code>搜索引擎设置</code>，然后点击<code>管理搜索引擎</code>。 </p><p>2、进入后会看到各个搜索引擎的设置项，我们以百度为例，点击这一条右侧的三个小点，然后点击<code>编辑</code></p><p>3、在弹出来的对话框中，把<code>关键词</code>这一项改为一个更简洁的关键词，例如“bd”，然后点击保存。</p><p>4、在Chrome搜索框内输入<code>关键词</code>，然后<code>tab</code>或者<code>空格</code>,即可切换输入法</p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83、egg-jwt用户鉴权、注册、登录及中间件</title>
      <link href="/2022/08/03/83-egg-jwt/"/>
      <url>/2022/08/03/83-egg-jwt/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="一、egg-jwt实现用户鉴权"><a href="#一、egg-jwt实现用户鉴权" class="headerlink" title="一、egg-jwt实现用户鉴权"></a>一、egg-jwt实现用户鉴权</h2><blockquote><p>用户鉴权，一种用于在通信网络中对试图访问来自服务提供商的服务的用户进行鉴权的方法。用于用户登陆到DSMP或使用数据业务时，业务网关或Portal发送此消息到DSMP，对该用户使用数据业务的合法性和有效性（状态是否为激活）进行检查。</p></blockquote><p>简单理解，鉴权就是用户在浏览网页或 <code>App</code> 时，通过约定好的方式，让网页和用户建立起一种相互信赖的机制，继而返回给用户需要的信息。</p><p>鉴权的机制：</p><ul><li>HTTP Basic Authentication</li><li>session-cookie</li><li>Token 令牌</li><li>OAuth(开放授权)</li></ul><p><code>token</code> 可以运用在如网页、客户端、小程序、浏览器插件等等领域。如果选用 <code>cookie</code> 的形式鉴权，在客户端和小程序就无法使用这套接口，因为它们没有域的概念，而 <code>cookie</code> 是需要存在某个域下。</p><h2 id="二、注册接口"><a href="#二、注册接口" class="headerlink" title="二、注册接口"></a>二、注册接口</h2><p>在 <code>controller</code> 目录下新建 <code>user.js</code> 用于编写用户相关的代码</p><pre><code class="js">// controller/user.js&#39;use strict&#39;;const Controller = require(&#39;egg&#39;).Controller;class UserController extends Controller &#123;  async register() &#123;    const &#123; ctx &#125; = this;    const &#123; username, password &#125; = ctx.request.body; // 获取注册需要的参数  &#125;&#125;module.exports = UserController;</code></pre><p>此时我们拿到了 <code>username</code> 和 <code>password</code>，我们需要判断两个参数是否为空。如果是空，则返回错误信息：</p><pre><code class="js">// 判空操作if (!username || !password) &#123;  ctx.body = &#123;    code: 500,    msg: &#39;账号密码不能为空&#39;,    data: null  &#125;  return&#125;</code></pre><p>此时我们还需要一个判断，根据用户传入的 <code>username</code> 去数据库的 <code>user</code> 表查询，是否已经被注册。</p><p>在 <code>service</code> 目录下新建 <code>user.js</code>，并且添加 <code>getUserByName</code> 方法用于根据 <code>username</code> 查找用户信息</p><pre><code class="js">//  service/user.js&#39;use strict&#39;;const Service = require(&#39;egg&#39;).Service;class UserService extends Service &#123;  // 通过用户名获取用户信息  async getUserByName(username) &#123;    const &#123; app &#125; = this;      try &#123;        const result = await app.mysql.get(&#39;user&#39;, &#123; username &#125;);        return result;      &#125; catch (error) &#123;        console.log(error);        return null;      &#125;  &#125;&#125;module.exports = UserService;</code></pre><blockquote><p>使用 async 和 await 时，如果想捕获错误，需要使用 try…catch 来捕获，如果代码运行过程中发生错误，都将会被 catch 捕获。</p></blockquote><p> <code>controller/user.js</code> 继续添加逻辑，在 「判空操作」逻辑下，判断是否已经被注册的逻辑：</p><pre><code class="js">// controller/user.jsasync register() &#123;  ...  // 验证数据库内是否已经有该账户名  const userInfo = await ctx.service.user.getUserByName(username) // 获取用户信息  // 判断是否已经存在  if (userInfo &amp;&amp; userInfo.id) &#123;    ctx.body = &#123;      code: 500,      msg: &#39;账户名已被注册，请重新输入&#39;,      data: null    &#125;    return  &#125;&#125;</code></pre><p>经过上述两层判断之后，接下便可将账号和密码写入数据库</p><pre><code class="js">// controller/user.js// 默认头像，放在 user.js 的最外，部避免重复声明。const defaultAvatar = &#39;http://s.yezgea02.com/1615973940679/WeChat77d6d2ac093e247c361f0b8a7aeb6c2a.png&#39;// 调用 service 方法，将数据存入数据库。const result = await ctx.service.user.register(&#123;  username,  password,  signature: &#39;世界和平。&#39;,  avatar: defaultAvatar&#125;);if (result) &#123;  ctx.body = &#123;    code: 200,    msg: &#39;注册成功&#39;,    data: null  &#125;&#125; else &#123;  ctx.body = &#123;    code: 500,    msg: &#39;注册失败&#39;,    data: null  &#125;&#125;</code></pre><p><code>service/user.js</code> 添加 <code>register</code> 写入数据库的方法</p><pre><code class="js">// service/user.js...// 注册async register(params) &#123;  const &#123; app &#125; = this;  try &#123;    const result = await app.mysql.insert(&#39;user&#39;, params);    return result;  &#125; catch (error) &#123;    console.log(error);    return null;  &#125;&#125;</code></pre><p>在 <code>router.js</code> 将接口抛出</p><pre><code class="js">// router.js&#39;use strict&#39;;/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123;  const &#123; router, controller &#125; = app;  router.post(&#39;/api/user/register&#39;, controller.user.register);&#125;;</code></pre><p>通过postman工具测试接口。</p><h2 id="三、登录接口"><a href="#三、登录接口" class="headerlink" title="三、登录接口"></a>三、登录接口</h2><blockquote><p>通过注册的「用户名」和「密码」，调用登录接口，接口会返回给我们一个 <code>token</code> 令牌</p></blockquote><p>每次发起请求，无论是获取数据，还是提交数据，我们都需要将 <code>token</code> 带上，以此来标识，此次获取(GET)或提交(POST)是哪一个用户的行为。</p><p> <code>egg-jwt</code> 有加密的功能，也有解密的功能。通过解密 <code>token</code> 拿到当初加密 <code>token</code> 时的信息，信息的内容大致就是当初注册时候的用户信息。</p><p>安装egg-jwt插件</p><pre><code class="shell">npm i egg-jwt -S</code></pre><p>Egg-jwt的<a href="https://link.juejin.cn/?target=https://github.com/okoala/egg-jwt%23readme">仓库地址</a></p><p>在 <code>config/plugin.js</code> 下添加插件：</p><pre><code class="js">jwt: &#123;  enable: true,  package: &#39;egg-jwt&#39;&#125;</code></pre><p><code>config/config.default.js</code> 下添加自定义加密字符串</p><pre><code class="js">config.jwt = &#123;  secret: &#39;YQ&#39;,&#125;;</code></pre><blockquote><p>secret<code>加密字符串，将在后续用于结合用户信息生成一串</code>token</p></blockquote><p>在 <code>/controller/user.js</code> 下新建 <code>login</code> 方法</p><pre><code class="js">async login() &#123;    // app 为全局属性，相当于所有的插件方法都植入到了 app 对象。    const &#123; ctx, app &#125; = this;    const &#123; username, password &#125; = ctx.request.body    // 根据用户名，在数据库查找相对应的id操作    const userInfo = await ctx.service.user.getUserByName(username)    // 没找到说明没有该用户    if (!userInfo || !userInfo.id) &#123;      ctx.body = &#123;        code: 500,        msg: &#39;账号不存在&#39;,        data: null      &#125;      return    &#125;    // 找到用户，并且判断输入密码与数据库中用户密码。    if (userInfo &amp;&amp; password != userInfo.password) &#123;      ctx.body = &#123;        code: 500,        msg: &#39;账号密码错误&#39;,        data: null      &#125;      return    &#125;       // 生成 token 加盐      // app.jwt.sign 方法接受两个参数，第一个为对象，对象内是需要加密的内容；第二个是加密字符串，上文已经提到过。    const token = app.jwt.sign(&#123;      id: userInfo.id,      username: userInfo.username,      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // token 有效期为 24 小时    &#125;, app.config.jwt.secret);    ctx.body = &#123;      code: 200,      message: &#39;登录成功&#39;,      data: &#123;        token      &#125;,    &#125;;&#125;</code></pre><p>把获取到的 <code>userInfo</code> 中的 <code>id</code> 和 <code>username</code> 两个属性，通过 <code>app.jwt.sign</code> 方法，结合 <code>app.config.jwt.secret</code> 加密字符串（之前声明的 <code>YQ</code>），生成一个 <code>token</code>。这个 <code>token</code> 会是一串很长的加密字符串</p><p>在 <code>/controller/user.js</code> 中，新增一个验证方法 <code>test</code></p><pre><code class="js">// 验证方法async test() &#123;  const &#123; ctx, app &#125; = this;  // 通过 token 解析，拿到 user_id  const token = ctx.request.header.authorization; // 请求头获取 authorization 属性，值为 token  // 通过 app.jwt.verify + 加密字符串 解析出 token 的值   const decode = await app.jwt.verify(token, app.config.jwt.secret);  // 响应接口  ctx.body = &#123;    code: 200,    message: &#39;获取成功&#39;,    data: &#123;      ...decode    &#125;  &#125;&#125;</code></pre><p>在路由 <code>router.js</code> 脚本中，将登录接口抛出</p><pre><code class="JS">&#39;use strict&#39;;/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123;  const &#123; router, controller &#125; = app;  router.post(&#39;/api/user/register&#39;, controller.user.register);  router.post(&#39;/api/user/login&#39;, controller.user.login);&#125;;</code></pre><h2 id="四、登录验证中间件"><a href="#四、登录验证中间件" class="headerlink" title="四、登录验证中间件"></a>四、登录验证中间件</h2><p>中间件我们可以理解成一个过滤器，举个例子，我们有 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 四个接口是需要用户权限的，如果我们要判断是否有用户权限的话，就需要在这四个接口的控制层去判断用户是否登录。</p><p>每个接口都验证存在的弊端</p><blockquote><p>1、每次编写新的接口，都要在方法内部做判断，这很费事。 2、一旦鉴权有所调整，我们需要修改每个用到判断登录的代码。</p></blockquote><p>在请求接口的时候，过一层中间件，判断该请求是否是登录状态下发起的。此时我们打开项目，在 <code>app</code> 目录下新新建一个文件夹 <code>middleware</code>，并且在该目录下新增 <code>jwtErr.js</code></p><pre><code class="js">&#39;use strict&#39;;module.exports = (secret) =&gt; &#123;  return async function jwtErr(ctx, next) &#123;    const token = ctx.request.header.authorization; // 若是没有 token，返回的是 null 字符串    let decode    if(token != &#39;null&#39; &amp;&amp; token) &#123;      try &#123;        decode = ctx.app.jwt.verify(token, secret); // 验证token        await next();      &#125; catch (error) &#123;        console.log(&#39;error&#39;, error)        ctx.status = 200;        ctx.body = &#123;          msg: &#39;token已过期，请重新登录&#39;,          code: 401,        &#125;        return;      &#125;    &#125; else &#123;      ctx.status = 200;      ctx.body = &#123;        code: 401,        msg: &#39;token不存在&#39;,      &#125;;      return;    &#125;  &#125;&#125;</code></pre><p>首先中间件默认抛出一个函数，该函数返回一个异步方法 <code>jwtErr</code>，<code>jewErr</code> 方法有两个参数 <code>ctx</code> 是上下文，可以在 <code>ctx</code> 中拿到全局对象 <code>app</code>。</p><p>首先，通过 <code>ctx.request.header.authorization</code> 获取到请求头中的 <code>authorization</code> 属性，它便是我们请求接口是携带的 <code>token</code> 值，如果没有携带 <code>token</code>，该值为字符串 <code>null</code>。我们通过 <code>if</code> 语句判断如果有 <code>token</code> 的情况下，使用 <code>ctx.app.jwt.verify</code> 方法验证该 <code>token</code> 是否存在并且有效，如果是存在且有效，则通过验证 <code>await next()</code> 继续执行后续的接口逻辑。否则判断是失效还是不存在该 <code>token</code>。</p><p>中间件完成后，我们在路由中<code>router.js</code> 去使用它</p><pre><code class="js">&#39;use strict&#39;;/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123;  const &#123; router, controller, middleware &#125; = app;  const _jwt = middleware.jwtErr(app.config.jwt.secret); // 传入加密字符串  router.post(&#39;/api/user/register&#39;, controller.user.register);  router.post(&#39;/api/user/login&#39;, controller.user.login);  router.get(&#39;/api/user/test&#39;, _jwt, controller.user.test); // 放入第二个参数，作为中间件过滤项&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>82、egg-mysql的增删改查</title>
      <link href="/2022/08/03/82-egg-mysql/"/>
      <url>/2022/08/03/82-egg-mysql/</url>
      
        <content type="html"><![CDATA[<p>MySQL安装成功后，在egg项目中安装egg-mysql插件，配置完成后，编写查询、新增、删除、编辑接口。</p><span id="more"></span><h2 id="一、安装MySQL"><a href="#一、安装MySQL" class="headerlink" title="一、安装MySQL"></a>一、安装MySQL</h2><p>版本选择MySQL 8.0.20  Mac Intel 版本</p><p>安装过程设置密码：0987654321</p><p>此时在terminal输入命令：</p><pre><code>mysql -u root -p</code></pre><p>Commod not found</p><p>1、termina进入 路径：/usr/local/mysql/bin  查看目录是否有mysql</p><p>如果存在，在此路径下执行：vim ~/.bash_profile</p><p>打开后，输入 i 键，进入编辑，在.bash_profile中添加mysql/bin的目录，完成后，ESC退出编辑，输入：wq回车保存</p><pre><code>PATH=$PATH:/usr/local/mysql/bin</code></pre><p>2、输入source  ~/.bash_profile      使配置生效</p><p>3、指令登录数据库：mysql -u root -p   输入密码：0987654321</p><p>4、开启服务：mysql.server start</p><h2 id="二、egg-js安装egg-mysql插件"><a href="#二、egg-js安装egg-mysql插件" class="headerlink" title="二、egg.js安装egg-mysql插件"></a>二、egg.js安装egg-mysql插件</h2><h4 id="1、安装egg-mysql及插件配置"><a href="#1、安装egg-mysql及插件配置" class="headerlink" title="1、安装egg-mysql及插件配置"></a>1、安装egg-mysql及插件配置</h4><pre><code class="shell">npm install egg-mysql</code></pre><p>config/plugin.js</p><pre><code class="js">&#39;use strict&#39;;/** @type Egg.EggPlugin */module.exports = &#123;  ejs: &#123;    enable: true,    package: &#39;egg-view-ejs&#39;  &#125;,  mysql: &#123;    enable: true,    package: &#39;egg-mysql&#39;  &#125;&#125;;</code></pre><p>config/plugin-default.js</p><pre><code class="js">exports.mysql = &#123;  // 单数据库信息配置  client: &#123;    // host    host: &#39;localhost&#39;,    // 端口号    port: &#39;3306&#39;,    // 用户名    user: &#39;root&#39;,    // 密码    password: &#39;数据库密码&#39;, // 初始化密码，没设置的可以不写    // 数据库名    database: &#39;test&#39;, // 我们新建的数据库名称  &#125;,  // 是否加载到 app 上，默认开启  app: true,  // 是否加载到 agent 上，默认关闭  agent: false,&#125;;</code></pre><h4 id="2、修改-service-home-js"><a href="#2、修改-service-home-js" class="headerlink" title="2、修改 service/home.js"></a>2、修改 <code>service/home.js</code></h4><pre><code class="js">&#39;use strict&#39;;const Service = require(&#39;egg&#39;).Service;class HomeService extends Service &#123;  async user() &#123;    const &#123; ctx, app &#125; = this;    const QUERY_STR = &#39;id, name&#39;;    let sql = `select $&#123;QUERY_STR&#125; from list`; // 获取 id 的 sql 语句    try &#123;      const result = await app.mysql.query(sql); // mysql 实例已经挂载到 app 对象下，可以通过 app.mysql 获取到。      return result;    &#125; catch (error) &#123;      console.log(error);      return null;    &#125;  &#125;&#125;module.exports = HomeService;</code></pre><h4 id="3、修改controller-home-js中的user方法"><a href="#3、修改controller-home-js中的user方法" class="headerlink" title="3、修改controller/home.js中的user方法"></a>3、修改controller/home.js中的user方法</h4><pre><code class="js">async user() &#123;  const &#123; ctx &#125; = this;  const result = await ctx.service.home.user();  ctx.body = result&#125;</code></pre><h4 id="4、路由配置"><a href="#4、路由配置" class="headerlink" title="4、路由配置"></a>4、路由配置</h4><pre><code class="js">router.get(&#39;/user&#39;, controller.home.user);</code></pre><h2 id="三、新增接口"><a href="#三、新增接口" class="headerlink" title="三、新增接口"></a>三、新增接口</h2><p>在 <code>service/home.js</code> 下新建一个函数 <code>addUser</code></p><pre><code class="js">// 新增async addUser(name) &#123;  const &#123; ctx, app &#125; = this;  try &#123;    const result = await app.mysql.insert(&#39;list&#39;, &#123; name &#125;); // 给 list 表，新增一条数据    return result;  &#125; catch (error) &#123;    console.log(error);    return null;  &#125;&#125;</code></pre><p>再为 <code>controller/home.js</code> 添加一个 <code>addUser</code> 方法</p><pre><code class="js">async addUser() &#123;  const &#123; ctx &#125; = this;  const &#123; name &#125; = ctx.request.body;  try &#123;    const result = await ctx.service.home.addUser(name);    ctx.body = &#123;      code: 200,      msg: &#39;添加成功&#39;,      data: null    &#125;  &#125; catch (error) &#123;    ctx.body = &#123;      code: 500,      msg: &#39;添加失败&#39;,      data: null    &#125;  &#125;&#125;</code></pre><p>配置路由</p><pre><code class="js">router.post(&#39;/add_user&#39;, controller.home.addUser);</code></pre><p>这个post请求需要使用postman测试接口是否成功。</p><h2 id="四、编辑接口"><a href="#四、编辑接口" class="headerlink" title="四、编辑接口"></a>四、编辑接口</h2><p>通过 <code>/user</code> 拿到了列表数据，我们可以通过 <code>id</code> 定位某条数据，去修改它的 <code>name</code> 属性。</p><p><code>/service/home.js</code>，添加编辑操作</p><pre><code class="js">// 编辑async editUser(id, name) &#123;  const &#123; ctx, app &#125; = this;  try &#123;    let result = await app.mysql.update(&#39;list&#39;, &#123; name &#125;, &#123;      where: &#123;        id      &#125;    &#125;);    return result;  &#125; catch (error) &#123;    console.log(error);    return null;  &#125;&#125;</code></pre><p><code>/controller/home.js</code> 添加如下代码：</p><pre><code class="js">// 编辑async editUser() &#123;  const &#123; ctx &#125; = this;  const &#123; id, name &#125; = ctx.request.body;  try &#123;    const result = await ctx.service.home.editUser(id, name);    ctx.body = &#123;      code: 200,      msg: &#39;添加成功&#39;,      data: null    &#125;  &#125; catch (error) &#123;    ctx.body = &#123;      code: 500,      msg: &#39;添加失败&#39;,      data: null    &#125;  &#125;&#125;</code></pre><p>配置路由：</p><pre><code class="js">router.post(&#39;/edit_user&#39;, controller.home.editUser);</code></pre><p>post请求需要使用postman工具测试接口</p><h2 id="五、删除接口"><a href="#五、删除接口" class="headerlink" title="五、删除接口"></a>五、删除接口</h2><p>在 <code>/service/home.js</code> 添加删除接口</p><pre><code class="js">// 删除async deleteUser(id) &#123;  const &#123; ctx, app &#125; = this;  try &#123;    let result = await app.mysql.delete(&#39;list&#39;, &#123; id &#125;);    return result;  &#125; catch (error) &#123;    console.log(error);    return null;  &#125;&#125;</code></pre><p><code>/controller/home.js</code> 添加相应的控制器方法</p><pre><code class="js">// 删除async deleteUser() &#123;  const &#123; ctx &#125; = this;  const &#123; id &#125; = ctx.request.body;  try &#123;    const result = await ctx.service.home.deleteUser(id);    ctx.body = &#123;      code: 200,      msg: &#39;删除成功&#39;,      data: null    &#125;  &#125; catch (error) &#123;    ctx.body = &#123;      code: 500,      msg: &#39;删除失败&#39;,      data: null    &#125;  &#125;&#125;</code></pre><p>添加相应路由：</p><pre><code class="js">// router.jsrouter.post(&#39;/delete_user&#39;, controller.home.deleteUser);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81、egg.js(二)</title>
      <link href="/2022/08/02/81-egg.js/"/>
      <url>/2022/08/02/81-egg.js/</url>
      
        <content type="html"><![CDATA[<p>Egg.js：<a href="https://issummer.cn/2021/06/20/egg/">https://issummer.cn/2021/06/20/egg/</a></p><span id="more"></span><h2 id="一、项目环境"><a href="#一、项目环境" class="headerlink" title="一、项目环境"></a>一、项目环境</h2><p>egg.js对node版本是有要求的，node&gt; 8.x npm &gt;= 6.1.0</p><p>目前电脑环境：node:12.6.0  npm 6.1.0</p><p>egg提供脚手架生成指令</p><pre><code class="shell">mkdir egg-example &amp;&amp; cd egg-examplenpm init egg --type=simplenpm i</code></pre><p>启动项目会出现报错：Cannot find module ‘fs/promise’</p><p>主要是由于node版本较低造成的，使用n 升级node版本到16.13.0 ,重新npm install，启动项目，报错消失。</p><h2 id="二、egg项目目录"><a href="#二、egg项目目录" class="headerlink" title="二、egg项目目录"></a>二、egg项目目录</h2><p><code>Egg</code> 作为一套解决方案，它内部高度集成了封装好的项目目录结构，现代开发俗称“约定式开发”。正常情况下，你从 0 开始搭建一个 <code>Node</code> 服务端代码，需要结合很多工具插件来辅助完成项目的搭建，而 <code>Egg</code> 则提前为你提供好了这些繁琐的初始工作，让你能专心与业务层面的开发。</p><p>当然，“约定式开发”也有不好的地方，很多配置项都是内部约定好的，在你想要用到某一个功能时，你可能需要去查阅 <code>Egg</code> 的官方文档是如何配置的，这就会消耗一点时间，但是相比之下，使用它的利大于弊。</p><h4 id="1、app-router-js"><a href="#1、app-router-js" class="headerlink" title="1、app/router.js"></a>1、<strong>app/router.js</strong></h4><p>用于配置 URL 路由规则，比如 <code>get</code> 请求，<code>npm run dev</code> 启动项目之后，直接在浏览器中访问启动的<code>端口 + 路径</code>，默认是 <code>http://localhost:7001/</code>，将会拿到 <code>app/controller</code> 文件夹下，<code>home.js</code> 脚本中 <code>index</code> 方法返回的内容。</p><p>这就是路由配置的作用，当然，抛出的形式有多种，如<code>router.get</code>、<code>router.post</code>、<code>router.delete</code>、<code>router.put</code> 等，都是支持的，更加具体的内容 <a href="https://link.juejin.cn/?target=https://eggjs.org/zh-cn/basics/router.html">Router 配置</a>。</p><h4 id="2、app-controller-xx"><a href="#2、app-controller-xx" class="headerlink" title="2、app/controller/xx"></a><strong>2、app/controller/xx</strong></h4><p>用于解析用户的输入，处理后返回相应的结果。通过请求路径将用户的请求基于 <code>method</code> 和 <code>URL</code> 分发到对应的 <code>Controller</code> 上，而 <code>Controller</code> 要做的事情就是响应用户的诉求。举个例子，我想拿到 A 用户的个人信息，于是我们要在控制器（Controller）里，通过请求携带的 A 用户的 id 参数，从数据库里获取指定用户的个人信息。</p><p>控制器需要做的就是处理数据和响应请求返回数据。更加详细的描述 <a href="https://link.juejin.cn/?target=https://eggjs.org/zh-cn/basics/controller.html">Controller 文档</a></p><h4 id="3、app-service-xx"><a href="#3、app-service-xx" class="headerlink" title="3、app/service/xx"></a><strong>3、app/service/xx</strong></h4><p>简单来说，<code>Service</code> 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层。初始化项目中未声明 <code>service</code> 文件夹，它是可选项，但是官方建议我们操作业务逻辑最好做一层封装。我们换一种理解方式，<code>Service</code> 层就是用于数据库的查询，我们尽量将粒度细化，这样以便多个 <code>Controller</code> 共同调用同一个 <code>Service</code>。更加详细的描述 <a href="https://link.juejin.cn/?target=https://eggjs.org/zh-cn/basics/service.html">Service 文档</a>。</p><h4 id="4、app-middleware-xx"><a href="#4、app-middleware-xx" class="headerlink" title="4、app/middleware/xx"></a><strong>4、app/middleware/xx</strong></h4><p>用于编写中间件，中间件的概念就是在路由配置里设置了中间件的路由，每次请求命中后，都要过一层中间件。在后续的开发中，也会利用到这个中间件的原理做用户鉴权。当用户未登录的情况下，是不能调用某些接口的。</p><p>每次都在 <code>Controller</code> 判断，当前请求是否携带有效的用户认证信息。接口一多，到处都是这样的判断，逻辑重复。所以，中间件在某种程度上，也算是优化代码结构的一种方式。更加详细的描述 <a href="https://link.juejin.cn/?target=https://eggjs.org/zh-cn/basics/middleware.html">Middleware 文档</a>。</p><h4 id="5、app-public-xx"><a href="#5、app-public-xx" class="headerlink" title="5、app/public/xx"></a><strong>5、app/public/xx</strong></h4><p>用于放置静态资源。会有一个上传静态资源的接口，包括图片、文本文档、excel、word等，都可以通过服务端读取文件之后，将其写入 <code>app/public</code> 文件夹中。在目前没有 <code>OSS</code> 服务的情况下，姑且先用这种方式存储静态资源，会消耗一点服务器的内存。</p><h4 id="6、config-config-env-js"><a href="#6、config-config-env-js" class="headerlink" title="6、config/config.{env}.js"></a><strong>6、config/config.{env}.js</strong></h4><p>用于编写配置文件。 <code>config/config.default.js</code> 文件，这个是 <code>Egg</code> 框架约定好的，在内部设置一些全局的配置常量，在任何地方都可以通过 <code>app.config</code> 获取到 <code>config.default.js</code> 文件内的配置项。</p><h4 id="7、config-plugin-js"><a href="#7、config-plugin-js" class="headerlink" title="7、config/plugin.js"></a><strong>7、config/plugin.js</strong></h4><p>用于配置需要加载的插件。比如 <code>egg-mysql</code>、<code>egg-cors</code>、<code>egg-jwt</code> 等官方提供的插件</p><h2 id="三、编写-GET-和-POST-接口"><a href="#三、编写-GET-和-POST-接口" class="headerlink" title="三、编写 GET 和 POST 接口"></a>三、编写 GET 和 POST 接口</h2><h4 id="GET-请求参数获取"><a href="#GET-请求参数获取" class="headerlink" title="GET 请求参数获取"></a><strong><code>GET</code> 请求参数获取</strong></h4><p>浏览器输入URL：<code>http:*//localhost:7001/?id=12</code></p><p>打开 <code>app/controller/home.js</code>，通过如下形式获取到浏览器查询参数</p><pre><code class="js">const Controller = require(&#39;egg&#39;).Controller;class HomeController extends Controller &#123;  async index() &#123;    const &#123; ctx &#125; = this;    const &#123; id &#125; = ctx.query;    ctx.body = id;  &#125;&#125;module.exports = HomeController;</code></pre><p>还有另一种获取申明参数，比如我希望通过这样一个地址获取用户参数 <code>/user/5</code>，想获取用户 <code>id</code> 为 <code>5</code> 的用户信息。<br>我们可以这样操作，首先添加路由，打开 <code>app/router.js</code> 添加一个路由：</p><pre><code class="js">&#39;use strict&#39;;/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123;  const &#123; router, controller &#125; = app;  router.get(&#39;/&#39;, controller.home.index);  router.get(&#39;/user/:id&#39;, controller.home.user);&#125;;</code></pre><p>其次在 <code>app/controller/home.js</code> 下添加一个 <code>user</code> 方法如下：</p><pre><code class="js">&#39;use strict&#39;;const Controller = require(&#39;egg&#39;).Controller;class HomeController extends Controller &#123;  async index() &#123;    const &#123; ctx &#125; = this;    const &#123; id &#125; = ctx.query;    ctx.body = id;  &#125;  // 获取用户信息  async user() &#123;    const &#123; ctx &#125; = this;    const &#123; id &#125; = ctx.params; // 通过 params 获取申明参数    ctx.body = id;  &#125;&#125;module.exports = HomeController;</code></pre><p>浏览器输入URL：<code>localhost:7001/user/123</code></p><p>网页会打印出：123</p><h4 id="post请求参数获取"><a href="#post请求参数获取" class="headerlink" title="post请求参数获取"></a><strong>post请求参数获取</strong></h4><p><code>POST</code> 接口需要借助 <code>Postman</code> 工具进行请求，因为通过浏览器无法手动发起 <code>POST</code> 请求，只能通过浏览器地址栏发起 <code>GET</code> 请求。</p><pre><code class="js">// app/router.js// ...router.post(&#39;/add&#39;, controller.home.add);</code></pre><pre><code class="js">// app/controller/home.js// post 请求方法async add() &#123;  const &#123; ctx &#125; = this;  const &#123; title &#125; = ctx.request.body;  // Egg 框架内置了 bodyParser 中间件来对 POST 请求 body 解析成 object 挂载到 ctx.request.body 上  ctx.body = &#123;    title  &#125;;&#125;</code></pre><p>用<code>Postman</code>发送post请求会出现报错，触发网络请求的安防策略</p><p><code>config/config.default.js</code> 做好白名单配置，全部允许请求：</p><pre><code class="js">config.security = &#123;  csrf: &#123;    enable: false,    ignoreJSON: true  &#125;,  domainWhiteList: [ &#39;*&#39; ], // 配置白名单&#125;;</code></pre><p>配置完成后，再次发送请求，可以看到请求成功，成功拿到服务端参数。</p><h4 id="从-Service-内获取数据"><a href="#从-Service-内获取数据" class="headerlink" title="从 Service 内获取数据"></a><strong>从 Service 内获取数据</strong></h4><p>模拟一下在 <code>Service</code> 中获取数据库的数据，在 <code>app</code> 目录下新建 <code>service</code>，并且创建一个 <code>home.js</code>，</p><pre><code class="js">&#39;use strict&#39;const Service = require(&#39;egg&#39;).Serviceclass HomeService extends Service &#123;  async user()&#123;    // 假设从数据库获取的用户信息    return &#123;      name:&#39;yu&#39;,      msg:&#39;i love you egg.js&#39;    &#125;  &#125;&#125;module.exports = HomeService</code></pre><p>在 <code>Controller</code> 内拿到上述方法</p><pre><code class="js">//  app/controller/home.js// 获取用户信息async user() &#123;  const &#123; ctx &#125; = this;  const &#123; name, msg &#125; = await ctx.service.home.user();  ctx.body = &#123;    name,    msg  &#125;&#125;</code></pre><p><code>Postman</code>打开<a href="http://127.0.0.1:7001/user/yu">http://127.0.0.1:7001/user/yu</a>  可以看到网页显示：{“name”:”yu”,”msg”:”i love you egg.js”}</p><h2 id="四、Egg-js-中使用前端模板"><a href="#四、Egg-js-中使用前端模板" class="headerlink" title="四、Egg.js 中使用前端模板"></a>四、Egg.js 中使用前端模板</h2><p>开发一些简单的网页，想快速部署到云服务器上，就可以使用前端模板的开发形式。</p><h4 id="1、首先安装插件-egg-view-ejs："><a href="#1、首先安装插件-egg-view-ejs：" class="headerlink" title="1、首先安装插件 egg-view-ejs："></a>1、首先安装插件 <code>egg-view-ejs</code>：</h4><pre><code class="shell">npm install egg-view-ejs -save</code></pre><h4 id="2、然后在-config-plugin-js-里面声明需要用到的插件："><a href="#2、然后在-config-plugin-js-里面声明需要用到的插件：" class="headerlink" title="2、然后在 config/plugin.js 里面声明需要用到的插件："></a>2、然后在 <code>config/plugin.js</code> 里面声明需要用到的插件：</h4><pre><code class="js">module.exports = &#123;  ejs: &#123;    enable: true,    package: &#39;egg-view-ejs&#39;  &#125;&#125;;</code></pre><h4 id="3、去-config-config-default-js-里配置-ejs-，这一步我们会将-ejs-的后缀改成-html-的后缀。"><a href="#3、去-config-config-default-js-里配置-ejs-，这一步我们会将-ejs-的后缀改成-html-的后缀。" class="headerlink" title="3、去 config/config.default.js 里配置 ejs ，这一步我们会将 .ejs 的后缀改成 .html 的后缀。"></a>3、去 <code>config/config.default.js</code> 里配置 <code>ejs</code> ，这一步我们会将 <code>.ejs</code> 的后缀改成 <code>.html</code> 的后缀。</h4><pre><code class="js">config.view = &#123;  mapping: &#123;&#39;.html&#39;: &#39;ejs&#39;&#125;  //左边写成.html后缀，会自动渲染.html文件&#125;;</code></pre><p>上述的配置，指的是将 <code>view</code> 文件夹下的 <code>.html</code> 后缀的文件，识别为 <code>.ejs</code>。</p><p>接着，在 <code>app</code> 目录下创建 <code>view</code> 文件夹，并且新建一个 <code>index.html</code> 文件，作为前端模板</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;&lt;%-title%&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 使用模板数据 --&gt;    &lt;h1&gt;&lt;%-title%&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>在 <code>Controller</code> 内把变量注入到 <code>index.html</code> 文件，模板通过 <code>&lt;%-xx%&gt;</code>关键字获取到传入的变量。</p><h4 id="4、修改-controller-home-js-下的-index-方法"><a href="#4、修改-controller-home-js-下的-index-方法" class="headerlink" title="4、修改 controller/home.js 下的 index 方法"></a>4、修改 <code>controller/home.js</code> 下的 <code>index</code> 方法</h4><pre><code class="js">async index() &#123;  const &#123; ctx &#125; = this;  // ctx.render 默认会去 view 文件夹寻找 index.html，这是 Egg 约定好的。  await ctx.render(&#39;index.html&#39;, &#123;    title: &#39;于齐&#39;, // 将 title 传入 index.html  &#125;);&#125;</code></pre><p>浏览器打开：localhost:7001  就会显示：于齐</p><p>上述开发模式便是前后端不分离的模式，在页面不复杂的情况下，整个项目不采用如 <code>React</code> 、<code>Vue</code> 这些前端框架，也是可以的。在上述代码 <code>ctx.render</code> 之前，我们可以从数据库获取想要的信息，作为参数塞入模板中，模板拿到数据，构建 <code>HTML</code>。如果是提交事件，可以通过原生 <code>ajax</code> 或者是引入一把梭专家 <code>jQuery</code>，提交数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80、使用 element-plus 版本升级后的问题清单</title>
      <link href="/2022/08/01/element-plus/"/>
      <url>/2022/08/01/element-plus/</url>
      
        <content type="html"><![CDATA[<p>element-plus 版本升级由@1.1.0-beta.15 升级到@2.0.4 版本时，在开发时遇到的问题整理及解决方法</p><span id="more"></span><h2 id="一、错误：-Can-39-t-reexport-the-named-export-39-xxx-39-from-non-EcmaScript-module-only-default-export-is-available-处理"><a href="#一、错误：-Can-39-t-reexport-the-named-export-39-xxx-39-from-non-EcmaScript-module-only-default-export-is-available-处理" class="headerlink" title="一、错误： Can&#39;t reexport the named export &#39;xxx&#39; from non EcmaScript module (only default export is available) 处理"></a>一、错误： <code>Can&#39;t reexport the named export &#39;xxx&#39; from non EcmaScript module (only default export is available)</code> 处理</h2><p>这个问题是 element plus 版本升级后，再运行项目，element plus 对 webpack 的一个编译处理。</p><p>解决方式：</p><p>在 vue.config.js 的 chainWebpack 下增加一个规则：</p><pre><code class="js">chainWebpack(config)&#123;  config.module  .rule(&quot;element-plus-2&quot;)  .test(/\.mjs$/)  // https://webpack.docschina.org/configuration/module/#ruletype  .type(&quot;javascript/auto&quot;)  .include.add(/node_modules/)  .end();&#125;</code></pre><h2 id="二、样式错误问题：input的白-蓝边、图片的灰色底"><a href="#二、样式错误问题：input的白-蓝边、图片的灰色底" class="headerlink" title="二、样式错误问题：input的白/蓝边、图片的灰色底"></a>二、样式错误问题：input的白/蓝边、图片的灰色底</h2><p>在做用户登录发现的el-input 存在的2个样式问题</p><pre><code class="css">// 处理 input 的白/蓝边.el-input__inner &#123;  box-shadow: none !important;  --el-select-input-focus-border-color: none !important;&#125;// 处理图片的灰色底.el-avatar &#123;  --el-avatar-bg-color: none !important;&#125;</code></pre><h2 id="三、tbody路径的变更"><a href="#三、tbody路径的变更" class="headerlink" title="三、tbody路径的变更"></a>三、tbody路径的变更</h2><p>1.x版本的element plus获取el元素的方式为：</p><pre><code class="js">const el = tableRef.value.$el.querySelectorAll(&#39;.el-table__body-wrapper &gt; table &gt; tbody&#39;)[0]</code></pre><p>2.x版本的element plus获取el元素的方式为</p><pre><code class="js">const el = tableRef.value.$el.querySelectorAll(&#39;.el-table__body &gt; tbody&#39;)[0]</code></pre><h2 id="四、中台项目侧边栏收起图标不显示问题"><a href="#四、中台项目侧边栏收起图标不显示问题" class="headerlink" title="四、中台项目侧边栏收起图标不显示问题"></a>四、中台项目侧边栏收起图标不显示问题</h2><p>查看控制台发现，#app .sidebar-container .svg-icon{margin-left:16px} 这个样式存在问题</p><p>解决方式：在侧边栏menu收起时，取消margin-left</p><pre><code class="css">.el-menu--collapse&#123;  .svg-icon&#123;    margin-right:0px;  &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79、ref-reactive</title>
      <link href="/2022/07/31/ref-reactive/"/>
      <url>/2022/07/31/ref-reactive/</url>
      
        <content type="html"><![CDATA[<p>ref/reactive 都能创建一个响应对象，这二者的区别是什么呢？</p><span id="more"></span><h2 id="一、reactive"><a href="#一、reactive" class="headerlink" title="一、reactive"></a>一、reactive</h2><blockquote><p>reactive 都能创建一个响应对象或数组</p></blockquote><p>1、reactive 用来创建引用类型的响应式数据</p><p>2、reactive 的本质是将每一层的数据都解析成 proxy 对象</p><p>3、reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一遍，重新渲染 dom</p><p>4、直接解构，响应性会丢失，需要用 toRefs 包裹。引用类型直接改变引用地址也会导致响应式丢失</p><pre><code class="html">&lt;tempalte&gt;  &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt;&lt;/tempalte&gt;</code></pre><pre><code class="js">// script 这里加了setup  没写setup需要在setup()&#123;&#125;内部定义 并返回（return）&lt;script setup&gt;import &#123; reactive &#125; from &quot;vue&quot;const state = reactive(&#123;count:0&#125;)&lt;/script&gt;</code></pre><h2 id="二、ref"><a href="#二、ref" class="headerlink" title="二、ref"></a>二、ref</h2><blockquote><p>vue3 提供了一个 ref()方法允许我们创建使用任何值类型的响应式 ref</p></blockquote><p>1、ref 用来创建基础类型的响应式数据</p><p>2、template 中默认调用 value 显示数据，script 中需要使用.value 调用</p><p>3、和 react ref 差不多，react 是.current 获取值，vue3 是.value</p><pre><code class="js">import &#123; ref &#125; from &quot;vue&quot;;const count = ref(0);console.log(count); // &#123; value:0 &#125;count.value++;console.log(count.value); // 2</code></pre><p>相关 API</p><p>1、Ref ts 定义 import { type Ref } from ‘vue’;</p><p>2、isRef 判断是否为 ref 对象。一般是 ref，toRef，toRefs 创建的变量</p><p>3、toRefs 将 reactive 对象解构为单个响应式对象</p><p>4、shallowRef 创建一个跟踪自身  .value  变化的 ref，但不会使其值也变成响应式的，简单理解为创建一个和 ref 相同结构的非响应式变量</p><p>5、triggerRef 强制更新页面 DOM。即使创建的 ref 没有变，想更新 dom 可以用</p><p>6、customRef 提供类似于 computed 的 get 和 set，可自定义 ref 行为</p><pre><code class="html">&lt;template&gt;  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; @some-event=&quot;callback&quot; /&gt;  &lt;div&gt;父组件监听事件：&#123;&#123; counts &#125;&#125;&lt;/div&gt;  &lt;p&gt;v-model&lt;/p&gt;  &lt;custom-input    :modelValue=&quot;searchText&quot;    @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;  /&gt;  &lt;Child /&gt;  &lt;h2&gt;    reactive方法用来创建响应式对象，它接收一个对象/数组参数，返回对象的响应式副本，当该对象的属性值发生变化，会自动更新使用该对象的地方。  &lt;/h2&gt;  &lt;div&gt;    Object:&#123;&#123; reactiveObj.name &#125;&#125;    &lt;span @click=&quot;setReactiveObj&quot;&gt;Update&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    Array:&#123;&#123; reactiveArr &#125;&#125;    &lt;span @click=&quot;setReactiveArr&quot;&gt;Update&lt;/span&gt;  &lt;/div&gt;  &lt;h2&gt;    ref 的作用就是将一个原始数据类型（primitive data    type）转换成一个带有响应式特性的数据类型，原始数据类型共有7个，分别是：String/    Number /BigInt /Boolean /Symbol /Null /Undefined。 ref的值在 JS/TS    中读取和修改时，需要使用 .value获取，在模版中读取是，不需要使用 .value。  &lt;/h2&gt;  &lt;div&gt;    String:&#123;&#123;refValue&#125;&#125;    &lt;button @click=&quot;setRefValue&quot;&gt;Update&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    Object:&#123;&#123; refObj.name &#125;&#125;    &lt;button @click=&quot;setRefObj&quot;&gt;Update&lt;/button&gt;  &lt;/div&gt;  &lt;h2&gt;vue3 reactive deep Obj/array&lt;/h2&gt;  &lt;div&gt;    Deep Object:&#123;&#123; reactiveDeepObj &#125;&#125;    &lt;button @click=&quot;setReactiveDeepObj&quot;&gt;Update&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    Deep Object Array: &#123;&#123; reactiveDeepArr &#125;&#125;    &lt;button @click=&quot;setReactiveDeepArr&quot;&gt;update&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;import CustomInput from &quot;./components/CustomInput.vue&quot;import Child from &quot;./components/Child.vue&quot;import &#123; ref, reactive, nextTick, provide &#125; from &quot;vue&quot;let counts = ref(10)const callback = () =&gt; &#123;  nextTick(() =&gt; &#123;    counts.value = 14  &#125;)&#125;const provideMsg = ref(&quot;provide message&quot;)provide(&quot;provideMsg&quot;, provideMsg)// reactivelet reactiveObj = reactive(&#123; name: &#39;jude&#39; &#125;)let setReactiveObj = () =&gt; &#123;  reactiveObj.name = &#39;hello,jude&#39;&#125;let reactiveArr = reactive([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])let setReactiveArr = () =&gt; &#123;  reactiveArr[1] = &#39;hello,jude!&#39;&#125;// Reflet refValue = ref(&#39;jude 1992&#39;)let setRefValue = () =&gt; &#123;  refValue.value = &#39;hello jude 1992&#39;&#125;let refObj = ref(&#123; name: &#39;jude 1992&#39; &#125;)let setRefObj = () =&gt; &#123;  refObj.value.name = &#39;hello jude 1992&#39;&#125;// reactive可以用在深层对象或者数组let reactiveDeepObj = reactive(  &#123;    user: &#123;      name: &#39;jude 1992&#39;    &#125;  &#125;)let setReactiveDeepObj = () =&gt; &#123;  reactiveDeepObj.user.name = &#39;hello  jude 1992&#39;&#125;let reactiveDeepArr = reactive(  [&#39;a&#39;, [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;], &#39;c&#39;, &#39;d&#39;])let setReactiveDeepArr = () =&gt; &#123;  reactiveDeepArr[1][1] = &quot;hello jude 1992&quot;&#125;// reactive 返回值和源对象不相等let reactivSource = &#123; name: &#39;jude 1992&#39; &#125;let reactiveData = reactive(reactivSource)console.log(reactivSource === reactiveData) // falseconsole.log(&#39;reactivSource&#39;, reactivSource);console.log(&#39;reactiveData&#39;, reactiveData);// ts写法// let refObjValue = ref &lt; string &gt; (&#39;jude 1992&#39;)// let reactiveObjValue = reactive &lt; &#123; name: string &#125; &gt; (&#123; name: &#39;jude 1992&#39; &#125;)&lt;/script&gt;</code></pre><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><blockquote><p>1.reactive 一般用于对象/数组类型的数据，都不需要使用 .value；<br>2.ref 一般用于基础数据类型的数据，在 JS 中读取和修改时，需要使用 .value，在模版中使用时则不需要；<br>3.reactive 可以修改深层属性值，并保持响应；<br>4.reactive 返回值和源对象不同；<br>5.reactive 的属性值可以是 ref 值；<br>6.ref 本质也是 reactive，ref(obj)等价于 reactive({value: obj})。</p></blockquote><blockquote><p>ref 接收内部值（inner value）返回响应式 Ref 对象，reactive 返回响应式代理对象;从定义上看 ref 通常用于处理单值的响应式，reactive 用于处理对象类型的数据响应式;两者均是用于构造响应式数据，但是 ref 主要解决原始值的响应式问题;ref 返回的响应式数据在 JS 中使用需要加上.value 才能访问其值，在视图中使用会自动脱 ref，不需要.value；ref 可以接收对象或数组等非原始值，但内部依然是 reactive 实现响应式；reactive 内部如果接收 Ref 对象会自动脱 ref；使用展开运算符(…)展开 reactive 返回的响应式对象会使其失去响应性，可以结合 toRefs()将值转换为 Ref 对象之后再展开;reactive 内部使用 Proxy 代理传入对象并拦截该对象各种操作（trap），从而实现响应式。ref 内部封装一个 RefImpl 类，并设置 get value/set value，拦截用户对值的访问，从而实现响应式。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78、js-cheat-sheet</title>
      <link href="/2022/07/30/js-cheat/"/>
      <url>/2022/07/30/js-cheat/</url>
      
        <content type="html"><![CDATA[<p>上传到图床上的4张图:JavaScript-Cheet-Sheet</p><span id="more"></span><h3 id="1、图1"><a href="#1、图1" class="headerlink" title="1、图1"></a>1、图1</h3><blockquote><p>-document/element/node/attr()/event()/EventTarget/clientRect()</p></blockquote><p><img src="https://cdn.staticaly.com/gh/HeyJudeYQ/Image-Host@master/20220919/JS-Cheat-Sheet_4.7j1b1pmevio0.webp" alt="JavaScript wiki1" title="js"></p><h3 id="2、图2"><a href="#2、图2" class="headerlink" title="2、图2"></a>2、图2</h3><blockquote><p>-window/screen/console/preformance/navigator/location/history</p></blockquote><p><img src="https://cdn.staticaly.com/gh/HeyJudeYQ/Image-Host@master/20220919/JS-Cheat-Sheet_3.5xvltiz2kh40.webp" alt="JavaScript wiki2"></p><h3 id="3、图3"><a href="#3、图3" class="headerlink" title="3、图3"></a>3、图3</h3><blockquote><p>-Math/Object/Set/Map/Promise/Generator/Proxy/Symbol/BigInt/Modules/json/</p></blockquote><p><img src="https://cdn.staticaly.com/gh/HeyJudeYQ/Image-Host@master/20220919/JS-Cheat-Sheet_2.lhqvhvi6fsg.webp" alt="JavaScript wiki3"></p><h3 id="4、图4"><a href="#4、图4" class="headerlink" title="4、图4"></a>4、图4</h3><blockquote><p>-number/string/array/date/function/Reg</p></blockquote><p><img src="https://cdn.staticaly.com/gh/HeyJudeYQ/Image-Host@master/20220919/JS-Cheat-Sheet_1.21ramjzckheo.webp" alt="JavaScript wiki4"></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77、使用element-ui开发问题清单</title>
      <link href="/2022/07/30/element-ui/"/>
      <url>/2022/07/30/element-ui/</url>
      
        <content type="html"><![CDATA[<p>整理使用 element-ui 开发时遇到的问题（包含“摘抄”其他开发人员开发遇到的问题 😁）</p><span id="more"></span><h2 id="1、去除-el-input-组件-type-”number”输入框聚焦时的上下箭头"><a href="#1、去除-el-input-组件-type-”number”输入框聚焦时的上下箭头" class="headerlink" title="1、去除 el-input 组件 type=”number”输入框聚焦时的上下箭头"></a>1、去除 el-input 组件 type=”number”输入框聚焦时的上下箭头</h2><pre><code class="css">/* 设置全局 */.clear-number-input.el-input::-webkit-outer-spin-button,.clear-number-input.el-input::-webkit-inner-spin-button &#123;  margin: 0;  -webkit-appearance: none !important;&#125;.clear-number-input.el-input input[type=&quot;number&quot;]::-webkit-outer-spin-button,.clear-number-input.el-input input[type=&quot;number&quot;]::-webkit-inner-spin-button &#123;  margin: 0;  -webkit-appearance: none !important;&#125;.clear-number-input.el-input &#123;  -moz-appearance: textfield;&#125;.clear-number-input.el-input input[type=&quot;number&quot;] &#123;  -moz-appearance: textfield;&#125;</code></pre><h2 id="2、el-input-输入框正则限制，绑定值未更新"><a href="#2、el-input-输入框正则限制，绑定值未更新" class="headerlink" title="2、el-input 输入框正则限制，绑定值未更新"></a>2、el-input 输入框正则限制，绑定值未更新</h2><p>输入框仅支持数字</p><pre><code class="html">&lt;el-input  v-model=&quot;form.num&quot;  placeholder=&quot;请输入数字&quot;  @keyup.native=&quot;form.num=form.num.replace(/[^\d.]/g,&#39;&#39;)&quot;&gt;&lt;/el-input&gt;</code></pre><h2 id="3、el-form-回车刷新页面（触发了表单默认的提交行为）"><a href="#3、el-form-回车刷新页面（触发了表单默认的提交行为）" class="headerlink" title="3、el-form 回车刷新页面（触发了表单默认的提交行为）"></a>3、el-form 回车刷新页面（触发了表单默认的提交行为）</h2><pre><code class="html">&lt;el-form inline @submit.native.prevent&gt;  &lt;el-form-item label=&quot;订单号&quot;&gt;    &lt;el-input      v-model=&quot;query.orderNo&quot;      :placeholder=&quot;输入订单号查询&quot;      clearable      @keyup.enter.native=&quot;enterInput&quot;    /&gt;  &lt;/el-form-item&gt;&lt;/el-form&gt;</code></pre><h2 id="4、el-table固定列最后一行显示不完全、表头与内容错位"><a href="#4、el-table固定列最后一行显示不完全、表头与内容错位" class="headerlink" title="4、el-table固定列最后一行显示不完全、表头与内容错位"></a>4、el-table固定列最后一行显示不完全、表头与内容错位</h2><pre><code class="css">.el-table__fixed-right &#123;  height:100% !important;&#125;// 全局设置 表头内容错位.el-table--scrollable-y .el-table__body-wrapper &#123; overflow-y: overlay !important;&#125;</code></pre><h2 id="5、表单校验只其中一个字段"><a href="#5、表单校验只其中一个字段" class="headerlink" title="5、表单校验只其中一个字段"></a>5、表单校验只其中一个字段</h2><p>仅校验手机号码（如果需要多个参数，将参数改为数组形式即可。）</p><pre><code class="js">this.$refs[&#39;form&#39;].validateField(&#39;mobile&#39;, valid =&gt; &#123;  if (valid) &#123;    // do something  &#125;&#125;)</code></pre><h2 id="6、el-table跨分页多选"><a href="#6、el-table跨分页多选" class="headerlink" title="6、el-table跨分页多选"></a>6、el-table跨分页多选</h2><pre><code class="html">&lt;el-table row-key=&quot;id&quot;&gt;  &lt;el-table-column type=&quot;selection&quot; reserve-selection&gt;&lt;/el-table-column&gt;&lt;/el-table&gt;</code></pre><h2 id="7、el-table内嵌el-input-focus失效"><a href="#7、el-table内嵌el-input-focus失效" class="headerlink" title="7、el-table内嵌el-input focus失效"></a>7、el-table内嵌el-input focus失效</h2><pre><code class="html">&lt;el-table&gt;  &lt;el-table-column label=&quot;名称&quot;&gt;    &lt;template&gt;      &lt;el-input ref=&quot;inputRef&quot; /&gt;    &lt;/template&gt;  &lt;/el-table-column&gt;&lt;/el-table&gt;// 无效this.$refs[&#39;inputRef&#39;].focus()this.$refs[&#39;inputRef&#39;][0].focus()this.$refs[&#39;inputRef&#39;].$el.children[0].focus()// 有效&lt;el-input id=&quot;inputRef&quot; /&gt;document.getElementById(&#39;inputRef&#39;).focus()</code></pre><h2 id="8、el-dialog-的-destroy-on-close-属性设置无效"><a href="#8、el-dialog-的-destroy-on-close-属性设置无效" class="headerlink" title="8、el-dialog 的 destroy-on-close 属性设置无效"></a>8、el-dialog 的 destroy-on-close 属性设置无效</h2><pre><code class="html">&lt;el-dialog :visible.sync=&quot;visible&quot; v-if=&quot;visible&quot; destroy-on-close&gt;&lt;/el-dialog&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76、vue3状态管理pinia及使用pinia解构不生效解决方法</title>
      <link href="/2022/07/29/pinia/"/>
      <url>/2022/07/29/pinia/</url>
      
        <content type="html"><![CDATA[<p>使用 pinia 时，解构 store 里的 helloWorld 和 count 时，没有发生响应式数据变化的情况。这是因为在使用 store 的过程中，如果直接进行进行解构的话，会破坏数据的响应，因此可以通过使用 storeToRefs 来解构。</p><span id="more"></span><h2 id="一、pinia-的使用时的问题复现"><a href="#一、pinia-的使用时的问题复现" class="headerlink" title="一、pinia 的使用时的问题复现"></a>一、pinia 的使用时的问题复现</h2><h3 id="1、stores-counter-js"><a href="#1、stores-counter-js" class="headerlink" title="1、stores:counter.js"></a>1、stores:counter.js</h3><pre><code class="js">import &#123; defineStore &#125; from &quot;pinia&quot;;// defineStore() 第一个参数：相当于为容器取一个名字 第二个参数为配置对象// state:存储全局状态  getters:监视、计算状态的变化，具有缓存功能// actions：对state里数据变化进行逻辑处理   （修改state全局状态数据）export const mainStore = defineStore(&quot;main&quot;, &#123;  state: () =&gt; &#123;    return &#123;      helloWorld: &quot;hello world !!!&quot;,      count: 0,    &#125;;  &#125;,  getters: &#123;&#125;,  actions: &#123;&#125;,&#125;);</code></pre><h3 id="2、组件：Test-vue"><a href="#2、组件：Test-vue" class="headerlink" title="2、组件：Test.vue"></a>2、组件：Test.vue</h3><pre><code class="html">&lt;template&gt;  &lt;!-- 非解构 --&gt;  &lt;!-- &lt;div&gt;&#123;&#123; store.helloWorld&#125;&#125;&#123;&#123;store.count&#125;&#125;&lt;/div&gt; --&gt;  &lt;!-- 解构 --&gt;  &lt;div&gt;&#123;&#123; helloWorld &#125;&#125;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><p>如果不使用storeToRefs，点击按钮不会生效。<br>storeToRefs的源码中，会先进行vue版本的判断，如果是Vue2版本，会直接返回toRefs(store),非Vue2环境，遍历对象的键值，会过滤掉store中的非ref/reactive对象，对于符合ref和reactive类型的值，将其复制到一个新的对象中refs中，最后返回refs</p><pre><code class="js">&lt;script setup&gt;  import &#123;storeToRefs&#125; from &quot;pinia&quot;  import &#123;mainStore&#125; from&#39;../stores/counter&#39;  const store = mainStore()   const &#123;(helloWorld, count)&#125; = storeToRefs(store)&lt;/script&gt;</code></pre><h3 id="3、组件：AddButton-vue"><a href="#3、组件：AddButton-vue" class="headerlink" title="3、组件：AddButton.vue"></a>3、组件：AddButton.vue</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;Add&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;  import &#123;mainStore&#125; from &#39;../stores/counter&#39;  const store = mainStore()  const handleClick = () =&gt; &#123;store.count++&#125;&lt;/script&gt;</code></pre><h3 id="4、App-vue"><a href="#4、App-vue" class="headerlink" title="4、App.vue"></a>4、App.vue</h3><pre><code class="html">&lt;template&gt;  &lt;header&gt;    &lt;img      alt=&quot;Vue logo&quot;      class=&quot;logo&quot;      src=&quot;@/assets/logo.svg&quot;      width=&quot;125&quot;      height=&quot;125&quot;    /&gt;    &lt;div class=&quot;wrapper&quot;&gt;      &lt;Test&gt;&lt;/Test&gt;      &lt;add-button&gt;&lt;/add-button&gt;    &lt;/div&gt;  &lt;/header&gt;  &lt;RouterView /&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;  import &#123;(RouterLink, RouterView)&#125; from &#39;vue-router&#39;  import Test from &#39;./components/Test.vue&#39;  import AddButton from &quot;./components/AddButton.vue&quot;&lt;/script&gt;</code></pre><h2 id="二、pinia如何修改状态数据"><a href="#二、pinia如何修改状态数据" class="headerlink" title="二、pinia如何修改状态数据"></a>二、pinia如何修改状态数据</h2><h3 id="1、-patch修改单个或者多个数据"><a href="#1、-patch修改单个或者多个数据" class="headerlink" title="1、$patch修改单个或者多个数据"></a>1、$patch修改单个或者多个数据</h3><pre><code class="html">  &lt;div&gt;&lt;button @click=&quot;handleClickPatch&quot;&gt;Add handleClickPatch&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; mainStore &#125; from &#39;../stores/counter&#39;;const store = mainStore()const handleClick = () =&gt; &#123;  store.count++;  // store.helloWorld = store.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; : &#39;yq&#39;&#125;// 1、修改状态数据 $patch  可同时修改多个数据的状态  参数为一个对象const handleClickPatch = () =&gt; &#123;  store.$patch(&#123;    count:store.count + 2,    helloWorld:store.helloWorld === &#39;yq&#39; ? &#39;HelloWorld&#39; : &#39;yq&#39;  &#125;)&#125;&lt;/script&gt;</code></pre><h3 id="2、-patch加函数形式修改状态数据"><a href="#2、-patch加函数形式修改状态数据" class="headerlink" title="2、$patch加函数形式修改状态数据"></a>2、$patch加函数形式修改状态数据</h3><blockquote><blockquote><p>适合修改复杂数据，例如数组、对象</p></blockquote></blockquote><pre><code class="html">  &lt;div&gt;&lt;button @click=&quot;handleClickMethod&quot;&gt;Add handleClickMethod&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; mainStore &#125; from &#39;../stores/counter&#39;;const store = mainStore()const handleClick = () =&gt; &#123;  store.count++;  // store.helloWorld = store.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; : &#39;yq&#39;&#125;// 1、修改状态数据 $patch  可同时修改多个数据的状态  参数为一个对象const handleClickPatch = () =&gt; &#123;  store.$patch(&#123;    count:store.count + 2,    helloWorld:store.helloWorld === &#39;yq&#39; ? &#39;HelloWorld&#39; : &#39;yq&#39;  &#125;)&#125;// 2、传递函数  适合复杂数据的修改，比如数组、对象的修改const handleClickMethod = () =&gt;&#123;  store.$patch((state) =&gt; &#123;    state.count++;    state.helloWorld = state.helloWorld === &#39;yq&#39; ? &#39;helloworld&#39; :&#39;yq&#39;  &#125;)&#125;&lt;/script&gt;</code></pre><h3 id="3、actions"><a href="#3、actions" class="headerlink" title="3、actions"></a>3、actions</h3><blockquote><p>在使用actions的时候，不能使用箭头函数，因为箭头函数绑定的是外部的this</p></blockquote><p>stores ：counter.js</p><pre><code class="js">export const mainStore = defineStore(&#39;main&#39;, &#123;  state:()=&gt;&#123;    return &#123;      helloWorld:&#39;hello world !!!&#39;,      count:0    &#125;  &#125;,  getters:&#123;  &#125;,  actions:&#123;    changeState()&#123;      this.count++      this.helloWorld = &#39;yq&#39;    &#125;  &#125;&#125;)</code></pre><p>组件:AddButton.vue</p><pre><code class="html">  &lt;div&gt;&lt;button @click=&quot;handleClickAction&quot;&gt; Add handleClickAction&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">const handleClickAction = () =&gt;&#123;  store.changeState()&#125;</code></pre><h3 id="4、getters"><a href="#4、getters" class="headerlink" title="4、getters"></a>4、getters</h3><p>store:counter.js</p><pre><code class="js">export const mainStore = defineStore(&#39;main&#39;, &#123;  state:()=&gt;&#123;    return &#123;      helloWorld:&#39;hello world !!!&#39;,      count:0,      phone:&#39;19542932249&#39;    &#125;  &#125;,  getters:&#123;    phoneHidden(state)&#123;      console.log(&quot;go  具有缓存 只会调用一次&quot;)      // 使用this关键字      // return this.phone.toString().replace(/^(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)$/, &#39;$1****$2&#39;)      return state.phone.toString().replace(/^(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)$/, &#39;$1****$2&#39;)    &#125;  &#125;,  actions:&#123;    // 在用actions的时候，不能使用箭头函数，因为箭头函数绑定的是外部的this    changeState()&#123;      this.count++      this.helloWorld = &#39;yq&#39;    &#125;  &#125;&#125;)</code></pre><blockquote><p>注意：getters里是可以使用this的</p></blockquote><p>写法如下：</p><pre><code class="ts">  getters:&#123;    phoneHidden():String&#123;      console.log(&quot;go  具有缓存 只会调用一次&quot;)      // 使用this关键字      // return this.phone.toString().replace(/^(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)$/, &#39;$1****$2&#39;)    &#125;  &#125;,</code></pre><p>组件：Test.vue</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; store.helloWorld&#125;&#125;&#123;&#123;store.count&#125;&#125;  &lt;/div&gt;  &lt;div&gt;    &#123;&#123; phoneHidden &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; storeToRefs &#125; from &quot;pinia&quot;;import &#123; mainStore &#125; from &#39;../stores/counter&#39;;const store = mainStore()const &#123; helloWorld,count,phoneHidden &#125; = storeToRefs(store)&lt;/script&gt;</code></pre><p>组件：AddButton.vue</p><pre><code class="html">  &lt;div&gt;&lt;button @click=&quot;handleClickChangePhone&quot;&gt;change phone&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; mainStore &#125; from &#39;../stores/counter&#39;;const store = mainStore()const handleClickChangePhone = () =&gt; &#123;  store.phone = &quot;18775352722&quot;&#125;&lt;/script&gt;</code></pre><h3 id="5、Github项目代码："><a href="#5、Github项目代码：" class="headerlink" title="5、Github项目代码："></a>5、Github项目代码：</h3><blockquote><p>github: <a href="https://github.com/HeyJudeYQ/pinia-demo">https://github.com/HeyJudeYQ/pinia-demo</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75、vue.$data表单暂存</title>
      <link href="/2022/07/28/localStorage/"/>
      <url>/2022/07/28/localStorage/</url>
      
        <content type="html"><![CDATA[<p>暂存表单信息</p><span id="more"></span><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;      &lt;el-form-item label=&quot;活动名称&quot;&gt;        &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;活动区域&quot;&gt;        &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;          &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;          &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;        &lt;/el-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;活动时间&quot;&gt;        &lt;el-col :span=&quot;11&quot;&gt;          &lt;el-date-picker            type=&quot;date&quot;            placeholder=&quot;选择日期&quot;            v-model=&quot;form.date1&quot;            style=&quot;width: 100%;&quot;          &gt;&lt;/el-date-picker&gt;        &lt;/el-col&gt;        &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;        &lt;el-col :span=&quot;11&quot;&gt;          &lt;el-time-picker            placeholder=&quot;选择时间&quot;            v-model=&quot;form.date2&quot;            style=&quot;width: 100%;&quot;          &gt;&lt;/el-time-picker&gt;        &lt;/el-col&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;即时配送&quot;&gt;        &lt;el-switch v-model=&quot;form.delivery&quot;&gt;&lt;/el-switch&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;活动性质&quot;&gt;        &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt;          &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;          &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;          &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;          &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;        &lt;/el-checkbox-group&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;特殊资源&quot;&gt;        &lt;el-radio-group v-model=&quot;form.resource&quot;&gt;          &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;          &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;        &lt;/el-radio-group&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;活动形式&quot;&gt;        &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.desc&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;        &lt;el-button @click=&quot;stash&quot;&gt;暂存&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script&gt;export default &#123;    data() &#123;        const stashStr = localStorage.getItem(&#39;stash&#39;)        const stash = stashStr ? JSON.parse(stashStr) : &#123;&#125;        return Object.assign(&#123;            form: &#123;                name: &#39;&#39;,                region: &#39;&#39;,                date1: &#39;&#39;,                date2: &#39;&#39;,                delivery: false,                type: [],                resource: &#39;&#39;,                desc: &#39;&#39;            &#125;        &#125;, stash)    &#125;,    methods: &#123;        onSubmit() &#123;            console.log(&#39;submit!&#39;);        &#125;,        stash() &#123;            localStorage.setItem(&#39;stash&#39;, JSON.stringify(this.$data));        &#125;    &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74、options-api &amp; composition-api</title>
      <link href="/2022/07/26/composition-api&amp;options-api/"/>
      <url>/2022/07/26/composition-api&amp;options-api/</url>
      
        <content type="html"><![CDATA[<p>在Vue2中，我们使用的是Options Api语法，而在Vue3中，编程语法方面改变的最大亮点应该就是Composition Api了。</p><span id="more"></span><h2 id="一、options-api"><a href="#一、options-api" class="headerlink" title="一、options api"></a>一、options api</h2><blockquote><p>options api 即选项式api,也就是组件的各个选项，例如：data、methods、computed、watch等等，对应的选项做对应的事情。</p></blockquote><p>在实际项目的开发过程中，数据定义在data中，方法定义在methods中，当我们的代码多起来，比如达到四、五百行的时候，如果我们想改动某个功能，就要去data中改数据，再去methods中改方法，来回地寻找。</p><p>相同功能的代码被分割，对后期的改动很不友好，如果换了一个新人接手，或者自己过一段时间再去看这段代码，估计没注释的话，那是相当费劲。 而且因为所有的数据都是挂载在this下面，typescript的类型推导也很麻烦，代码的复用、公共组件的导入导出也都很困难。Vue3新增了Composition Api来解决这些痛点。</p><h2 id="二、composition-api"><a href="#二、composition-api" class="headerlink" title="二、composition api"></a>二、composition api</h2><blockquote><p>Composition Api:组合式api,支持将相同的功能模块代码写在一起，甚至可以将某个功能单独的封装成函数，随意导入引用；也可以将任意的数据定义成响应式，再也不用局限于data中，我们只需要将每个实现的功能组合起来就可以了。</p></blockquote><p>watch：侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。</p><blockquote><p>watch() 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。(immediate:true 立即执行)，包含3个参数：侦听器的源、发生变化的回调函数（这个回调函数接受3个参数：新值、旧值、用于注册副作用清理的回调函数。）、可选参数（immediate：true/false 立即触发侦听器回调函数、deep:源是对象，强制深度遍历，flush:调整回调的刷新时机、onTrack/onTrigger:调试侦听器的依赖）</p></blockquote><p>注意：1、watchEffect是立即执行的，不需要添加immediate属性。<br>2、watchEffect不需要指定对某个具体的数据监听，watchEffect会根据内容自动去感知，所以我们也可以在一个watchEffect中添加多个数据的监听处理（如果watchEffect中没有任何响应式数据，会不会执行呢？大家可以试一下）。<br>3、watchEffect不能获取数据改变之前的值。</p><p>ref和reactive的区别是什么呢，我们可以这样简单理解，它们都是用来定义响应式数据的，但是ref是用来给简单的数据类型定义响应式数据的，比如number、string、boolean等，而reactive是针对复杂的数据结构的，比如一个对象。</p><p>ref定义的数据，修改的时候是需改xxx.value的，而reactive定义的不用</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73、关于使用element-ui的el-table组件：带分页打印表头</title>
      <link href="/2022/07/25/print/"/>
      <url>/2022/07/25/print/</url>
      
        <content type="html"><![CDATA[<p>使用 command（win : control） + p 打印时，如果页面的 table 分页后，想要将第二页之后的每个页面都加上表头，可以封装一个可复用的组件。</p><span id="more"></span><h2 id="一、编写可复用的组件"><a href="#一、编写可复用的组件" class="headerlink" title="一、编写可复用的组件"></a>一、编写可复用的组件</h2><p>代码如下：</p><p>ElTableHeader.vue</p><pre><code class="js">import &#123; Table &#125; from &quot;element-ui&quot;;export default &#123;  extends: Table,  mounted() &#123;    this.$nextTick(function () &#123;      let thead = this.$el.querySelector(&quot;.el-table__header-wrapper thead&quot;);      let theadNew = thead.cloneNode(true);      this.$el        .querySelector(&quot;.el-table__body-wrapper table&quot;)        .appendChild(theadNew);    &#125;);  &#125;,&#125;;</code></pre><pre><code class="css"> .el-table &gt;&gt;&gt; .el-table__body-wrapper thead &#123;        display: none;    &#125;    @media print &#123;        .el-table &gt;&gt;&gt; .el-table__header-wrapper &#123;            display: none;        &#125;        .el-table &gt;&gt;&gt; .el-table__body-wrapper thead &#123;            display: table-header-group;        &#125;    &#125;</code></pre><h2 id="二、全局注册及使用"><a href="#二、全局注册及使用" class="headerlink" title="二、全局注册及使用"></a>二、全局注册及使用</h2><h4 id="1、main-js引入"><a href="#1、main-js引入" class="headerlink" title="1、main.js引入"></a>1、main.js引入</h4><pre><code>import ElTableHeader from &quot;./components/ElTableHeader.vue&quot;Vue.component(&quot;el-table-header&quot;,ElTableHeader)</code></pre><h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><pre><code class="html">&lt;template&gt;  &lt;el-table-header :data=&quot;tableData&quot;&gt;  &lt;/el-table-header&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>72、关于使用element-ui的el-select组件下拉框错位问题</title>
      <link href="/2022/07/11/el-select/"/>
      <url>/2022/07/11/el-select/</url>
      
        <content type="html"><![CDATA[<p>使用 element-ui的el-form组件里使用el-selcet组件时，下拉框的el-select-item会出现向右偏移的问题。有2种方法可以解决下拉框错位的问题。</p><span id="more"></span><h2 id="一、方法一：margin-left-0px-important"><a href="#一、方法一：margin-left-0px-important" class="headerlink" title="一、方法一：margin-left:0px !important"></a>一、方法一：margin-left:0px !important</h2><p>在el-select添加一个类名：select-item</p><pre><code class="css">.select-item .el-form-item__content&#123;  margin-left:0px !important;&#125;</code></pre><h2 id="二、方法二：position-initial"><a href="#二、方法二：position-initial" class="headerlink" title="二、方法二：position:initial;"></a>二、方法二：position:initial;</h2><pre><code class="css">.select-item .el-form-item__content&#123;  position:initial;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71、headerSearch组件</title>
      <link href="/2022/06/25/headerSearch/"/>
      <url>/2022/06/25/headerSearch/</url>
      
        <content type="html"><![CDATA[<p>headerSearch组件:在指定搜索框中对当前应用中所有页面进行检索，以select形式展示出被检索的页面，以达到快速进入的目的；</p><span id="more"></span><h2 id="一、原理："><a href="#一、原理：" class="headerlink" title="一、原理："></a>一、原理：</h2><p>1、根据指定内容对所有页面进行检索；<br>2、以select形式展示检索出的页面；<br>3、通过检索页面可快速进入对应页面。</p><h2 id="二、方案："><a href="#二、方案：" class="headerlink" title="二、方案："></a>二、方案：</h2><p>1、创建 headerSearch 组件，用作样式展示和用户输入内容获取<br>2、获取所有的页面数据，用作被检索的数据源<br>3、根据用户输入内容在数据源中进行模糊搜索<br>4、把搜索到的内容以 select 进行展示<br>5、监听 select 的 change 事件，完成对应跳转</p><h2 id="三、代码："><a href="#三、代码：" class="headerlink" title="三、代码："></a>三、代码：</h2><details><summary>点击展示js代码</summary><pre><code class="html">&lt;template&gt;  &lt;div :class=&quot;&#123; show: isShow &#125;&quot; class=&quot;header-search&quot;&gt;    &lt;svg-icon      id=&quot;guide-search&quot;      class-name=&quot;search-icon&quot;      icon=&quot;search&quot;      @click.stop=&quot;onShowClick&quot;    /&gt;    &lt;el-select      ref=&quot;headerSearchSelectRef&quot;      class=&quot;header-search-select&quot;      v-model=&quot;search&quot;      filterable      default-first-option      remote      placeholder=&quot;Search&quot;      :remote-method=&quot;querySearch&quot;      @change=&quot;onSelectChange&quot;    &gt;      &lt;el-option        v-for=&quot;option in searchOptions&quot;        :key=&quot;option.item.path&quot;        :label=&quot;option.item.title.join(&#39; &gt; &#39;)&quot;        :value=&quot;option.item&quot;      &gt;&lt;/el-option&gt;    &lt;/el-select&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; computed, ref, watch &#125; from &#39;vue&#39;import &#123; generateRoutes &#125; from &#39;./FuseData&#39;import Fuse from &#39;fuse.js&#39;import &#123; filterRouters &#125; from &#39;@/utils/route&#39;import &#123; useRouter &#125; from &#39;vue-router&#39;import &#123; watchSwitchLang &#125; from &#39;@/utils/i18n&#39;// 控制 search 显示const isShow = ref(false)// el-select 实例const headerSearchSelectRef = ref(null)const onShowClick = () =&gt; &#123;  isShow.value = !isShow.value  headerSearchSelectRef.value.focus()&#125;// search 相关const search = ref(&#39;&#39;)// 搜索结果const searchOptions = ref([])// 搜索方法const querySearch = query =&gt; &#123;  if (query !== &#39;&#39;) &#123;    searchOptions.value = fuse.search(query)  &#125; else &#123;    searchOptions.value = []  &#125;&#125;// 选中回调const onSelectChange = val =&gt; &#123;  router.push(val.path)  onClose()&#125;// 检索数据源const router = useRouter()let searchPool = computed(() =&gt; &#123;  const filterRoutes = filterRouters(router.getRoutes())  return generateRoutes(filterRoutes)&#125;)/** * 搜索库相关 */let fuseconst initFuse = searchPool =&gt; &#123;  fuse = new Fuse(searchPool, &#123;    // 是否按优先级进行排序    shouldSort: true,    // 匹配算法放弃的时机， 阈值 0.0 需要完美匹配（字母和位置），阈值 1.0 将匹配任何内容。    threshold: 0.4,    // 匹配长度超过这个值的才会被认为是匹配的    minMatchCharLength: 1,    // 将被搜索的键列表。 这支持嵌套路径、加权搜索、在字符串和对象数组中搜索。    // name：搜索的键    // weight：对应的权重    keys: [      &#123;        name: &#39;title&#39;,        weight: 0.7      &#125;,      &#123;        name: &#39;path&#39;,        weight: 0.3      &#125;    ]  &#125;)&#125;initFuse(searchPool.value)/** * 关闭 search 的处理事件 */const onClose = () =&gt; &#123;  headerSearchSelectRef.value.blur()  isShow.value = false  searchOptions.value = []&#125;/** * 监听 search 打开，处理 close 事件 */watch(isShow, val =&gt; &#123;  if (val) &#123;    document.body.addEventListener(&#39;click&#39;, onClose)  &#125; else &#123;    document.body.removeEventListener(&#39;click&#39;, onClose)  &#125;&#125;)// 处理国际化watchSwitchLang(() =&gt; &#123;  searchPool = computed(() =&gt; &#123;    const filterRoutes = filterRouters(router.getRoutes())    return generateRoutes(filterRoutes)  &#125;)  initFuse(searchPool.value)&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.header-search &#123;  font-size: 0 !important;  .search-icon &#123;    cursor: pointer;    font-size: 18px;    vertical-align: middle;  &#125;  .header-search-select &#123;    font-size: 18px;    transition: width 0.2s;    width: 0;    overflow: hidden;    background: transparent;    border-radius: 0;    display: inline-block;    vertical-align: middle;    ::v-deep .el-input__inner &#123;      border-radius: 0;      border: 0;      padding-left: 0;      padding-right: 0;      box-shadow: none !important;      border-bottom: 1px solid #d9d9d9;      vertical-align: middle;    &#125;  &#125;  &amp;.show &#123;    .header-search-select &#123;      width: 210px;      margin-left: 10px;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre></details><h2 id="四、数据源："><a href="#四、数据源：" class="headerlink" title="四、数据源："></a>四、数据源：</h2><p>FuseData.js</p><details><summary>点击展示js代码</summary><pre><code class="js">import path from &#39;path&#39;import i18n from &#39;@/i18n&#39;/** * 筛选出可供搜索的路由对象 * @param routes 路由表 * @param basePath 基础路径，默认为 / * @param prefixTitle */export const generateRoutes = (routes, basePath = &#39;/&#39;, prefixTitle = []) =&gt; &#123;  // 创建 result 数据  let res = []  // 循环 routes 路由  for (const route of routes) &#123;    // 创建包含 path 和 title 的 item    const data = &#123;      path: path.resolve(basePath, route.path),      title: [...prefixTitle]    &#125;    // 当前存在 meta 时，使用 i18n 解析国际化数据，组合成新的 title 内容    // 动态路由不允许被搜索    // 匹配动态路由的正则    const re = /.*\/:.*/    if (      route.meta &amp;&amp;      route.meta.title &amp;&amp;      !re.exec(route.path) &amp;&amp;      !res.find(item =&gt; item.path === data.path)    ) &#123;      const i18ntitle = i18n.global.t(`msg.route.$&#123;route.meta.title&#125;`)      data.title = [...data.title, i18ntitle]      res.push(data)    &#125;    // 存在 children 时，迭代调用    if (route.children) &#123;      const tempRoutes = generateRoutes(route.children, data.path, data.title)      if (tempRoutes.length &gt;= 1) &#123;        res = [...res, ...tempRoutes]      &#125;    &#125;  &#125;  return res&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70、功能引导组件</title>
      <link href="/2022/06/20/guide/"/>
      <url>/2022/06/20/guide/</url>
      
        <content type="html"><![CDATA[<p>功能引导组件实现</p><span id="more"></span><h2 id="一、功能引导：driver-js"><a href="#一、功能引导：driver-js" class="headerlink" title="一、功能引导：driver.js"></a>一、功能引导：driver.js</h2><p>实现思路：</p><h4 id="1、定义导航数据"><a href="#1、定义导航数据" class="headerlink" title="1、定义导航数据"></a>1、定义导航数据</h4><pre><code class="html">&lt;svg-icon icon=&quot;guide&quot; @click=&quot;onClick&quot; /&gt;</code></pre><p>let driver = null</p><h4 id="2、实例化Driver"><a href="#2、实例化Driver" class="headerlink" title="2、实例化Driver"></a>2、实例化Driver</h4><p>需要安装driver.js</p><pre><code class="js">import Driver from &#39;driver.js&#39;import &#39;driver.js/dist/driver.min.css&#39;import &#123; onMounted &#125; from &#39;vue&#39;import &#123; useI18n &#125; from &#39;vue-i18n&#39;import steps from &#39;./steps&#39;import &#123; watchSwitchLang &#125; from &#39;@/utils/i18n&#39;const initDriver = () =&gt; &#123;  driver = new Driver(&#123;    animate: false,    // 禁止点击蒙版关闭    allowClose: false,    closeBtnText: i18n.t(&#39;msg.guide.close&#39;),    nextBtnText: i18n.t(&#39;msg.guide.next&#39;),    prevBtnText: i18n.t(&#39;msg.guide.prev&#39;)  &#125;)&#125;// 语言切换时，重新初始化 DriverwatchSwitchLang(initDriver)</code></pre><h4 id="3、定义触发方法"><a href="#3、定义触发方法" class="headerlink" title="3、定义触发方法"></a>3、定义触发方法</h4><pre><code class="js">const onClick = () =&gt; &#123;  driver.defineSteps(steps(i18n))  driver.start()&#125;</code></pre><h4 id="4、steps资源文件"><a href="#4、steps资源文件" class="headerlink" title="4、steps资源文件"></a>4、steps资源文件</h4><details><summary>点击展示js代码</summary><pre><code class="js">// 此处不需要导入 @/i18n 使用 i18n.global ，因为我们在 router 中 layout 不是按需加载，所以会在 Guide 会在 I18n 初始化完成之前被直接调用。导致 i18n 为 undefinedconst steps = i18n =&gt; &#123;  return [    // 起始    &#123;      element: &#39;#guide-start&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.guideTitle&#39;),        description: i18n.t(&#39;msg.guide.guideDesc&#39;),        position: &#39;bottom-right&#39;      &#125;    &#125;,    &#123;      element: &#39;#guide-hamburger&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.hamburgerTitle&#39;),        description: i18n.t(&#39;msg.guide.hamburgerDesc&#39;)      &#125;    &#125;,    &#123;      element: &#39;#guide-breadcrumb&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.breadcrumbTitle&#39;),        description: i18n.t(&#39;msg.guide.breadcrumbDesc&#39;)      &#125;    &#125;,    &#123;      element: &#39;#guide-search&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.searchTitle&#39;),        description: i18n.t(&#39;msg.guide.searchDesc&#39;),        position: &#39;bottom-right&#39;      &#125;    &#125;,    &#123;      element: &#39;#guide-full&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.fullTitle&#39;),        description: i18n.t(&#39;msg.guide.fullDesc&#39;),        position: &#39;bottom-right&#39;      &#125;    &#125;,    &#123;      element: &#39;#guide-theme&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.themeTitle&#39;),        description: i18n.t(&#39;msg.guide.themeDesc&#39;),        position: &#39;bottom-right&#39;      &#125;    &#125;,    &#123;      element: &#39;#guide-lang&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.langTitle&#39;),        description: i18n.t(&#39;msg.guide.langDesc&#39;),        position: &#39;bottom-right&#39;      &#125;    &#125;,    &#123;      element: &#39;#guide-tags&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.tagTitle&#39;),        description: i18n.t(&#39;msg.guide.tagDesc&#39;)      &#125;    &#125;,    &#123;      element: &#39;#guide-sidebar&#39;,      popover: &#123;        title: i18n.t(&#39;msg.guide.sidebarTitle&#39;),        description: i18n.t(&#39;msg.guide.sidebarDesc&#39;),        position: &#39;right-center&#39;      &#125;    &#125;  ]&#125;export default steps</code></pre></details><h4 id="5、引导高亮区域添加ID"><a href="#5、引导高亮区域添加ID" class="headerlink" title="5、引导高亮区域添加ID"></a>5、引导高亮区域添加ID</h4><p>示例：</p><pre><code class="html">&lt;svg-icon id=&quot;guide-hamburger&quot; class=&quot;hamburger&quot; :icon=&quot;icon&quot;&gt;&lt;/svg-icon&gt;&lt;!-- 面包屑 --&gt;&lt;breadcrumb id=&quot;guide-breadcrumb&quot; class=&quot;breadcrumb-container&quot; /&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69、screenfull组件</title>
      <link href="/2022/06/15/screenfull/"/>
      <url>/2022/06/15/screenfull/</url>
      
        <content type="html"><![CDATA[<p>screenfull组件:主要使用的是浏览器的2个API:Document.exitFullscreen():该方法用于请求从全屏模式切换到窗口模式；<br>Element.requestFullscreen()：该方法用于请求浏览器（user agent）将特定元素（甚至延伸到它的后代元素）置为全屏模式。<br>当通过document.getElementById(‘app’).requestFullscreen()在获取id=app的DOM之后，把该区域置为全屏</p><p>这种方法存在一定的问题（内容区域的AppMain）区域背景为黑色。</p><span id="more"></span><p>实现全屏显示模式，通常可以使用包装库：screenfull。</p><h2 id="一、实现"><a href="#一、实现" class="headerlink" title="一、实现"></a>一、实现</h2><p>1、安装screenfull</p><p>2、创建全屏组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;svg-icon      :icon=&quot;isFullscreen ? &#39;exit-fullscreen&#39; : &#39;fullscreen&#39;&quot;      @click=&quot;onToggle&quot;    /&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script setup&gt;import &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;import screenfull from &#39;screenfull&#39;// 是否全屏const isFullscreen = ref(false)// 监听变化const change = () =&gt; &#123;  isFullscreen.value = screenfull.isFullscreen&#125;// 切换事件const onToggle = () =&gt; &#123;  screenfull.toggle()&#125;// 设置侦听器onMounted(() =&gt; &#123;  screenfull.on(&#39;change&#39;, change)&#125;)// 删除侦听器onUnmounted(() =&gt; &#123;  screenfull.off(&#39;change&#39;, change)&#125;)&lt;/script&gt;</code></pre><p>3、引入全屏组件</p><pre><code class="html">&lt;screenfull class=&quot;right-menu-item hover-effect&quot; /&gt;</code></pre><pre><code class="js">import Screenfull from &#39;@/components/Screenfull&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>68、ESlint+Prettier+VSCode代码格式规范、git提交规范</title>
      <link href="/2022/06/07/eslint/"/>
      <url>/2022/06/07/eslint/</url>
      
        <content type="html"><![CDATA[<p>ESlint+Prettier+VSCode代码格式规范、git提交规范</p><span id="more"></span><h2 id="一、ESlint规范、Prettier格式化工具规范"><a href="#一、ESlint规范、Prettier格式化工具规范" class="headerlink" title="一、ESlint规范、Prettier格式化工具规范"></a>一、ESlint规范、Prettier格式化工具规范</h2><h3 id="1-eslintrc-js"><a href="#1-eslintrc-js" class="headerlink" title="1.  .eslintrc.js"></a>1.  .eslintrc.js</h3><pre><code class="js">// ESLint 配置文件遵循 commonJS 的导出规则，所导出的对象就是 ESLint 的配置对象// 文档：https://eslint.bootcss.com/docs/user-guide/configuringmodule.exports = &#123;  // 表示当前目录即为根目录，ESLint 规则将被限制到该目录下  root: true,  // env 表示启用 ESLint 检测的环境  env: &#123;    // 在 node 环境下启动 ESLint 检测    node: true  &#125;,  // ESLint 中基础配置需要继承的配置  extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;@vue/standard&quot;],  // 解析器  parserOptions: &#123;    parser: &quot;babel-eslint&quot;  &#125;,  // 需要修改的启用规则及其各自的错误级别  /**   * 错误级别分为三种：   * &quot;off&quot; 或 0 - 关闭规则   * &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)   * &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)   */  rules: &#123;    &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,    &#39;space-before-function-paren&#39;: &#39;off&#39;,    &#39;no-unused-expressions&#39;: &#39;off&#39;  &#125;&#125;;space-before-function-paren:off 关闭《方法名后增加空格》的规则</code></pre><h3 id="2、VSCode安装Prettier插件"><a href="#2、VSCode安装Prettier插件" class="headerlink" title="2、VSCode安装Prettier插件"></a>2、VSCode安装Prettier插件</h3><p>(1)新建.prettierrc  </p><pre><code class="js">&#123;  // 不尾随分号  &quot;semi&quot;: false,  // 使用单引号  &quot;singleQuote&quot;: true,  // 多行逗号分割的语法中，最后一行不加逗号  &quot;trailingComma&quot;: &quot;none&quot;&#125;</code></pre><p>(2)打开VSCode设置，搜索save,勾选Format On Save<br>VSCode默认一个tab是4个空格，可以修改成2个。</p><p>这样我们保存的代码，prettier会帮我们自动格式化成符合ESlint校验规则的代码。</p><h3 id="3、git提交规范"><a href="#3、git提交规范" class="headerlink" title="3、git提交规范"></a>3、git提交规范</h3><h4 id="1-、全局安装Commitizen"><a href="#1-、全局安装Commitizen" class="headerlink" title="(1)、全局安装Commitizen"></a>(1)、全局安装Commitizen</h4><pre><code class="js">npm install -g commitizen@4.2.4</code></pre><h4 id="2-、安装并配置cz-customizable"><a href="#2-、安装并配置cz-customizable" class="headerlink" title="(2)、安装并配置cz-customizable"></a>(2)、安装并配置cz-customizable</h4><pre><code>npm i cz-customizable@6.3.0 --save-dev</code></pre><p>在package.json中配置</p><pre><code class="json">  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;    &#125;  &#125;</code></pre><h4 id="3-、根目录下创建-cz-config-js自定义提示文件"><a href="#3-、根目录下创建-cz-config-js自定义提示文件" class="headerlink" title="(3)、根目录下创建.cz-config.js自定义提示文件"></a>(3)、根目录下创建.cz-config.js自定义提示文件</h4><pre><code class="js">module.exports = &#123;  // 可选类型  types: [    &#123; value: &#39;feat&#39;, name: &#39;feat:     新功能&#39; &#125;,    &#123; value: &#39;fix&#39;, name: &#39;fix:      修复&#39; &#125;,    &#123; value: &#39;docs&#39;, name: &#39;docs:     文档变更&#39; &#125;,    &#123; value: &#39;style&#39;, name: &#39;style:    代码格式(不影响代码运行的变动)&#39; &#125;,    &#123;      value: &#39;refactor&#39;,      name: &#39;refactor: 重构(既不是增加feature，也不是修复bug)&#39;    &#125;,    &#123; value: &#39;perf&#39;, name: &#39;perf:     性能优化&#39; &#125;,    &#123; value: &#39;test&#39;, name: &#39;test:     增加测试&#39; &#125;,    &#123; value: &#39;chore&#39;, name: &#39;chore:    构建过程或辅助工具的变动&#39; &#125;,    &#123; value: &#39;revert&#39;, name: &#39;revert:   回退&#39; &#125;,    &#123; value: &#39;build&#39;, name: &#39;build:    打包&#39; &#125;  ],  // 消息步骤  messages: &#123;    type: &#39;请选择提交类型:&#39;,    customScope: &#39;请输入修改范围(可选):&#39;,    subject: &#39;请简要描述提交(必填):&#39;,    body: &#39;请输入详细描述(可选):&#39;,    footer: &#39;请输入要关闭的issue(可选):&#39;,    confirmCommit: &#39;确认使用以上信息提交？(y/n/e/h)&#39;  &#125;,  // 跳过问题  skipQuestions: [&#39;body&#39;, &#39;footer&#39;],  // subject文字长度默认是72  subjectLimit: 72&#125;</code></pre><h4 id="4-、使用git-cz代替git-commit"><a href="#4-、使用git-cz代替git-commit" class="headerlink" title="(4)、使用git cz代替git commit"></a>(4)、使用git cz代替git commit</h4><p>并不是所有人都记得使用git cz  还需要加上Git Hooks</p><h3 id="4、Git-Hooks"><a href="#4、Git-Hooks" class="headerlink" title="4、Git Hooks"></a>4、Git Hooks</h3><p>Git Hooks常用的2个钩子：<br>1、commit-msg：可以用来规范化标准格式，并且可以按需指定是否要拒绝本次提交<br>2、pre-commit：会在提交前被调用，并且可以按需指定是否要拒绝本次提交</p><h4 id="（1）commitlint和husky-2个工具的安装与配置"><a href="#（1）commitlint和husky-2个工具的安装与配置" class="headerlink" title="（1）commitlint和husky 2个工具的安装与配置"></a>（1）commitlint和husky 2个工具的安装与配置</h4><pre><code>npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4</code></pre><p>创建commitlint.config.js</p><pre><code>echo &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js</code></pre><p>配置commitlint.config.js</p><pre><code class="js">module.exports = &#123;  // 继承的规则  extends: [&#39;@commitlint/config-conventional&#39;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;, // 新功能 feature        &#39;fix&#39;, // 修复 bug        &#39;docs&#39;, // 文档注释        &#39;style&#39;, // 代码格式(不影响代码运行的变动)        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)        &#39;perf&#39;, // 性能优化        &#39;test&#39;, // 增加测试        &#39;chore&#39;, // 构建过程或辅助工具的变动        &#39;revert&#39;, // 回退        &#39;build&#39; // 打包      ]    ],    // subject 大小写不做校验    &#39;subject-case&#39;: [0]  &#125;&#125;</code></pre><blockquote><p>注意：确保此文件为UTF-8编码格式</p></blockquote><p>安装husky:</p><pre><code>npm install husky@7.0.1 --save-dev</code></pre><p>启动hooks，生成.husky文件夹</p><pre><code>npx husky install</code></pre><p>在package.json中生成prepare指令（npm版本 &gt; 7.0）</p><pre><code>npm set-script prepare &quot;husky install&quot;</code></pre><p>执行prepare指令</p><pre><code>npm run prepare</code></pre><p>添加 commitlint 的 hook 到 husky中，并指令在 commit-msg 的 hooks 下执行 npx –no-install commitlint –edit “$1” 指令</p><pre><code>npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;</code></pre><p>pre-commit规避格式错误的提交<br>通过 husky 监测 pre-commit 钩子，在该钩子下执行 npx eslint –ext .js,.vue src 指令来去进行相关检测：</p><p>执行 npx husky add .husky/pre-commit “npx eslint –ext .js,.vue src” 添加 commit 时的 hook （npx eslint –ext .js,.vue src 会在执行到该 hook 时运行）</p><p>该操作会生成对应文件 pre-commit：</p><p>lint-staged 自动修复格式错误</p><pre><code class="json">  &quot;lint-staged&quot;: &#123;    &quot;src/**/*.&#123;js,vue&#125;&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;</code></pre><p>修改 .husky/pre-commit 文件</p><pre><code class="js">#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npx lint-staged</code></pre><h3 id="5、package-json"><a href="#5、package-json" class="headerlink" title="5、package.json"></a>5、package.json</h3><pre><code>  &quot;scripts&quot;: &#123;    &quot;prepare&quot;: &quot;husky install&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;    &#125;  &#125;,  &quot;gitHooks&quot;: &#123;    &quot;pre-commit&quot;: &quot;lint-staged&quot;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;src/**/*.&#123;js,vue&#125;&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67、ant-design-vue-table</title>
      <link href="/2022/05/10/ant-design-vue-table/"/>
      <url>/2022/05/10/ant-design-vue-table/</url>
      
        <content type="html"><![CDATA[<p>column列描述数据对象，customRender:生成复杂数据的渲染函数，参数分别为当前行的值，当前行数据，行索引，@return 里面可以设置表格行/列合并。</p><span id="more"></span><p>将列表里后端返回的空数据使用”-“填充。</p><pre><code class="js">const columns = [&#123;    title:&#39;开始时间&#39;，    dataIndex:&#39;start_date&#39;,    key:&#39;start_date&#39;,    align:&#39;center&#39;,    ellipsis:true,    width:250,    customRender: function (text, row, index) &#123;        if (row.start_date == null) &#123;            return &#39;-&#39;        &#125; else &#123;            return row.start_date        &#125;    &#125;,&#125;]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ant-design-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66、Mac系统升级后桌面文件夹及文件消失</title>
      <link href="/2022/04/19/mac-finder/"/>
      <url>/2022/04/19/mac-finder/</url>
      
        <content type="html"><![CDATA[<p>解决方式：终端输入如下命令即可</p><pre><code class="shell">defaults write com.apple.finder CreateDesktop -bool true; killall Finder// 显示/隐藏  隐藏文件command shift + .</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>65、响应式原理</title>
      <link href="/2022/04/12/reactive/"/>
      <url>/2022/04/12/reactive/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>1、什么是响应式？</p><p>数据变化可以被检测对这种变化做出响应的机制</p><p>2、Vue为什么需要响应式？</p><p>MVVM框架需要解决的核心问题技术就是连接数据层和视图层，<br>通过数据驱动应用，数据变化，试图更新，要做到这点就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。</p><p>3、响应式的好处？</p><p>通过数据响应式加上虚拟DOM和patch算法，开发人员只需要操作数据，关心业务，完全不用接触繁琐的DOM操作，大大提升开发效率，降低开发难度。</p><p>4、如何实现Vue的响应式？优缺点？</p><p>Vue2肿的数据响应式会根据数据类型来做不同处理，如果是对象采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并做出响应；<br>如果是数组则通过覆盖数组对象原型的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。<br>这种机制很好的解决了数据响应化问题，但是也存在一些缺点：<br>初始化时的递归遍历会造成性能损失；新增或者删除属性需要使用Vue.set/delete这些特殊的API才能生效；对于es6中新产生的Map、Set这些数据结构不支持。</p><pre><code class="js">function defineReactive(obj,key,val)&#123;  Object.defineProperty(obj,key,&#123;    get(key)&#123;&#125;,    set(key,val)&#123;&#125;  &#125;)&#125;</code></pre><p>5、Vue3如何实现响应式？</p><p>利用es6的Proxy代理响应式的数据。<br>好处：不需要特殊的api，初始化性能和内存小号都得到了大幅改善<br>由于响应化的实现代码抽取为独立的reactivity报，使得我们可以灵活的使用它，第三方的扩展开发更加的灵活</p><p>Proxy属性拦截的原理：利用get、set、deleteProperty这3个trap实现拦截</p><pre><code class="js">function reactive(obj)&#123;  return new Proxy(obj,&#123;    get(target,key)&#123;&#125;,    set(target,key,val)&#123;&#125;,    deleteProperty(target,key)&#123;&#125;  &#125;)&#125;</code></pre><p>proxy更快的原因：初始化时懒处理，用户访问才做拦截处理，初始化更快。</p><pre><code class="ts">// https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/baseHandlers.ts    if (isObject(res)) &#123;      // Convert returned value into a proxy as well. we do the isObject check      // here to avoid invalid value warning. Also need to lazy access readonly      // and reactive here to avoid circular dependency.      return isReadonly ? readonly(res) : reactive(res)    &#125;</code></pre><p>轻量的依赖关系保存：利用WeakMap\Map\Set保存响应式数据和副作用之间的依赖关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64、ant-design-vue-picker</title>
      <link href="/2022/04/06/ant-design-vue-picker/"/>
      <url>/2022/04/06/ant-design-vue-picker/</url>
      
        <content type="html"><![CDATA[<p>ant-design-vue 限制时间选择框,展示2天内数据且只能选择7日范围内（截止时间不得超过当日）</p><span id="more"></span><p>1、template</p><pre><code class="html">&lt;a-form-item label=&quot;时间&quot;&gt;  &lt;a-range-picker    v-model=&quot;rangeTime&quot;    :allowClear=&quot;false&quot;    :disabled-date=&quot;disableDate&quot;    @change=&quot;onChange&quot;    @openChange=&quot;openChange&quot;    :placeholder=&quot;[&#39;开始时间&#39;, &#39;结束时间&#39;]&quot;  /&gt;&lt;/a-form-item&gt;</code></pre><p>2、js</p><pre><code class="js">// datarangeTime: [moment(Date.now() - 1 * 24 * 3600 * 1000), moment(Date.now())],firstSelectTime: null,//  methods// 日期校验disableDate(current) &#123;  let nowDate = new Date()  nowDate.setMilliseconds(0)  nowDate.setSeconds(0)  nowDate.setMinutes(0)  nowDate.setHours(0)  let isOut30 = false  if (this.firstSelectTime) &#123;    if (      current &gt; this.firstSelectTime + 6 * 24 * 3600 * 1000 ||      current &lt; this.firstSelectTime - 6 * 24 * 3600 * 1000    ) &#123;      isOut30 = true    &#125;  &#125;  return current &amp;&amp; (current &gt; Date.now() || isOut30)&#125;,calendarChange(dates, dateStrings) &#123;  this.firstSelectTime = moment(Date.now() - 1 * 24 * 3600 * 1000)&#125;,openChange(status) &#123;  this.firstSelectTime = moment(Date.now() - 1 * 24 * 3600 * 1000)&#125;,</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ant-design-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63、ant-design-vue v-model.trim不生效</title>
      <link href="/2022/04/06/ant-design-vue-trim/"/>
      <url>/2022/04/06/ant-design-vue-trim/</url>
      
        <content type="html"><![CDATA[<p>同element-ui一样，el-input和a-input  均不支持v-model修饰符。</p><span id="more"></span><p>解决办法：</p><p>element-ui示例代码：</p><pre><code class="html">&lt;el-form-item&gt;    &lt;el-input        placeholder=&quot;请输入内容&quot;        v-model=&quot;queryInfo.name&quot;        @blur=&quot;queryInfo.name=$event.target.value.trim()&quot;        clearable        maxlength=&quot;11&quot;    &gt;    &lt;/el-input&gt;&lt;/el-form-item&gt;</code></pre><p>ant-design-vue示例代码：</p><pre><code class="html">&lt;a-form-item label=&quot;租户名称&quot;&gt;   &lt;a-input placeholder=&quot;请输入租户名称&quot; v-model=&quot;queryInfo.name&quot; allowClear /&gt;&lt;/a-form-item&gt;</code></pre><p>去空格函数</p><pre><code class="js">methods:&#123;    tirmHandler(target, prop)&#123;        if (target &amp;&amp; target[prop] &amp;&amp; target[prop].trim) &#123;            target[prop] = target[prop].trim()        &#125;    &#125;,    handleCnfirm()&#123;        this.trimHandler(this.queryInfo.name,&#39;name&#39;)    &#125;   &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ant-design-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62、权限管理</title>
      <link href="/2022/03/12/permmsion/"/>
      <url>/2022/03/12/permmsion/</url>
      
        <content type="html"><![CDATA[<ol><li>权限管理一般需求是页面权限和按钮权限的管理</li><li>具体实现的时候分后端和前端两种方案：<br>前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个 asyncRoutes‘数组，需要认证的页面在其路由的‘meta’中添加一个 roles*字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过‘router.addRoutes(accessRoutes)°方式动态添加路由即可。<br>后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过 addRoutes‘动态添加路由信息<br>按钮权限的控制通常会实现一个指令，例如V-permissin’，将按钮要求角色通过值传给vpermission指<br>令，在指令的 moutned钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。</li><li>纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61、js如何将base64转成16进制</title>
      <link href="/2022/03/01/base64To16/"/>
      <url>/2022/03/01/base64To16/</url>
      
        <content type="html"><![CDATA[<p>需求：将base64密文解密成16进制。</p><span id="more"></span><p>1、原生js的编码(btoa)和解码(atob)</p><pre><code class="js">var baseStr = &quot;http://www.baidu.com&quot;var encodedData = window.btoa(baseStr)console.log(encodedData) //aHR0cDovL3d3dy5iYWlkdS5jb20=var decodedData = window.atob(encodedData)console.log(decodedData) // http://www.baidu.com</code></pre><p>2、base64转16进制</p><pre><code class="js">    stringToHex(base64)&#123;      var raw = atob(base64)      var HEX = &#39;&#39;      for (var i = 0; i &lt; raw.length; i++) &#123;        var _hex = raw.charCodeAt(i).toString(16)        HEX += _hex.length == 2 ? _hex : &#39;0&#39; + _hex      &#125;      return HEX      // return HEX.toUpperCase()  将字符串转换成大写格式    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>60、什么是上位机、下位机?</title>
      <link href="/2022/02/28/Upper-Lower/"/>
      <url>/2022/02/28/Upper-Lower/</url>
      
        <content type="html"><![CDATA[<p>上位机在系统中起主控作用，主要作为系统的规划控制，属于决策层；而下位机是具体执行层，主要完成系统规划层下达的任务。</p><span id="more"></span><p>1.通常上位机和下位机通讯可以采用不同的通讯协议，可以有RS232的串口通讯或者采用RS485串行通讯。<br>当用计算机和PLC通讯的时候，不但可以采用传统的D形式的串行通讯，还可以采用更适合工业控制的双线的PROFIBUS-DP通讯。</p><p>2.上位机与下位机之间的关系：上位机给下位机发送控制命令，下位机收到此命令并执行相应的动作；<br>上位机给下位机发送状态获取命令，下位机收到此命令后调用传感器测量，然后转化为数字信息反馈给上位机；下位机主动发送状态信息或报警信息给上位机。</p><p>3.下位机指直接与机器相连接的计算机或单片机，一般用于接收和反馈上位机的指令，并且根据指令控制机器执行动作以及从机器传感器读取数据。<br>典型设备类型：PLC，stm32，51，FPGA，ARM等各类可编程芯片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59、ant-design-vue select下拉框组件</title>
      <link href="/2022/02/26/ant-design-vue/"/>
      <url>/2022/02/26/ant-design-vue/</url>
      
        <content type="html"><![CDATA[<p>问题：选中select的某一项，下拉框不显示已选择项？</p><span id="more"></span><p>解决方式：<br>    添加chang事件：</p><pre><code class="html">&lt;a-form-item label=&quot;状态&quot;&gt;    &lt;a-select v-model=&quot;queryInfo.statusCode&quot; placeholder=&quot;请选择状态&quot; allowClear @change=&quot;selectChange&quot;&gt;        &lt;a-select-option value=&quot;voltageStatusScope3&quot;&gt;一&lt;/a-select-option&gt;        &lt;a-select-option value=&quot;voltageStatusScope2&quot;&gt;二&lt;/a-select-option&gt;        &lt;a-select-option value=&quot;voltageStatusScope1&quot;&gt;三&lt;/a-select-option&gt;    &lt;/a-select&gt;&lt;/a-form-item&gt;</code></pre><pre><code class="js">selectChange()&#123;    this.$forceUpdate();&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ant-design-vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58、解决Homebrew安装失败</title>
      <link href="/2022/02/25/homebrew/"/>
      <url>/2022/02/25/homebrew/</url>
      
        <content type="html"><![CDATA[<p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p><span id="more"></span><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>官网安装方式：</p><pre><code class="js">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>官网安装一直失败。。。。(不适合国内用户)</p><h2 id="二、解决方式"><a href="#二、解决方式" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>1、终端输入：</p><pre><code class="js">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></pre><p>2、选择一个镜像</p><blockquote><p>1、中科大下载源<br>2、清华大学下载源 …</p></blockquote><p>3、查看本地软件库列表</p><pre><code class="js">brew ls</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>57、Vue2/Vue3 响应式原理</title>
      <link href="/2022/02/24/vue2-defineProperty/"/>
      <url>/2022/02/24/vue2-defineProperty/</url>
      
        <content type="html"><![CDATA[<p>Vue官网：当把一个普通的对象传入Vue实例作为data选项，Vue将遍历此对象所有的属性，并使用Object.defineProperty把这些数星星全部转化为getter/setter。Object.defineProperty是ES5中一个无法shim的特性（查了一下shim的意思：就是可以将新的API引入到旧的环境中，而且仅靠环境中的已有手段实现，Obejct.defineProperty无法在低级浏览器中的方法实现），这也就是Vue不支持IE8以及更低版本浏览器的原因。</p><span id="more"></span><h2 id="一、Vue无法检测对象属性添加或删除"><a href="#一、Vue无法检测对象属性添加或删除" class="headerlink" title="一、Vue无法检测对象属性添加或删除"></a>一、Vue无法检测对象属性添加或删除</h2><p>Object.defineProperty 没有对对象的新属性进⾏属性劫持 </p><blockquote><p>原因：由于Vue会在初始化实例时对对象的属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。</p></blockquote><pre><code class="js">var vm = new Vue(&#123;    data:&#123;        a:1    &#125;&#125;)vm.a 是响应式vm.b 是非响应式</code></pre><p>解决无法检测对象属性的增加、删除的方法：Vue.set(object,propertyName,value)(增加属性)、Vue.delete()（删除属性）</p><h2 id="二、Vue不能检测数组的变动"><a href="#二、Vue不能检测数组的变动" class="headerlink" title="二、Vue不能检测数组的变动"></a>二、Vue不能检测数组的变动</h2><p>数组是一个特殊的JavaScript对象，Vue没有对数组进⾏ Object.defineProperty 的属性劫持，所以会存在的问题：</p><p>不能检测数组变动的2类问题：</p><blockquote><p>1、当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>2、当你修改数组的长度时，例如：vm.items.length = newLength</p></blockquote><pre><code class="js">var vm = new Vue(&#123;    data:&#123;        items: [&#39;a&#39;&#39;,&#39;b&#39;,&#39;c&#39;]    &#125;&#125;)vvm.items[1] = &#39;x&#39; // 非响应式vm.items.length = 2 // 非响应式</code></pre><p>解决利用索引值设置一个数组项的方法：</p><blockquote><p>vm.$set(vm.items, indexOfItem, newValue)</p></blockquote><p>解决第2个问题：</p><blockquote><p>vm.items.splice(newLength)  // Array.prototype.slice</p></blockquote><h2 id="三、Vue2-为什么不劫持数组？"><a href="#三、Vue2-为什么不劫持数组？" class="headerlink" title="三、Vue2 为什么不劫持数组？"></a>三、Vue2 为什么不劫持数组？</h2><p>Vue2使用的Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty是可以监听数组下标变化的，对于javascript来讲，数组也是属于Object。</p><p>尤雨溪说过：为了性能！！！</p><p>原因：</p><blockquote><p>1、因为数组的位置不固定，数量多变，正常对象key对应value一般不会变，但是如果数组删除了某个元素。比如第一个元素被删除或者头部增加一个元素，那么将导致后面所有的key对应value错位，如果6个元素，也就会触发5次set。<br>2、数组元素可能非常非常多，每个元素进行劫持有一定浪费，这可能是Evan you对性能的考虑。<br>3、Vue将数组的7个变异方法进行了重写，也就是更改了Array原型上的方法达到劫持变化。</p></blockquote><p>Vue3 的 proxy<br>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。</p><p>Proxy可以劫持整个对象，并返回一个新的对象。</p><p>所以为什么proxy优于Object.defineProperty？</p><p>Object.defineProperty必须“预先”劫持属性。被劫持的属性才会被监听到。所以后添加的属性，需要手动再次劫持。</p><p>而proxy代理了整个对象，不需要预先劫持属性，而是在获取/修改的时候，通过get/set方法来告诉你key。所以不管如何新增属性，总是能被捕获到。</p><h2 id="四、Vue响应式原理"><a href="#四、Vue响应式原理" class="headerlink" title="四、Vue响应式原理"></a>四、Vue响应式原理</h2><p>整体思路是数据劫持+观察者模式：</p><p>对象内部通过 defineReactive ⽅法，使⽤ Object.defineProperty 将属性进⾏劫持（只会劫持已经存在的属性），数组则是通过重写数组⽅法来实现。当⻚⾯使⽤对应属性时，每个属性都拥有⾃⼰的 dep 属性，存放他所依赖的 watcher （依赖收集），当属性变化后会通知⾃⼰对应的 watcher 去更新(派发更新)。</p><blockquote><p>Vue响应式原理的核心：就是Observer、Dep、Watcher。Observer中进行响应式的绑定，在数据被读的时候，触发get方法，执行Dep来收集依赖，也就是收集Watcher。在数据被改的时候，触发set方法，通过对应的所有依赖(Watcher)，去执行更新。比如watch和computed就执行开发者自定义的回调方法。</p></blockquote><h2 id="五、为什么只对对象劫持，对数组方法进行重写？"><a href="#五、为什么只对对象劫持，对数组方法进行重写？" class="headerlink" title="五、为什么只对对象劫持，对数组方法进行重写？"></a>五、为什么只对对象劫持，对数组方法进行重写？</h2><blockquote><p>因为对象最多也就⼏⼗个属性，拦截起来数量不多，但是数组可能会有⼏百⼏千项，拦截起来⾮常耗性能，所以直接重写数组原型上的⽅法，是⽐较节省性能的⽅案</p></blockquote><h2 id="六、实现一个数据双向绑定"><a href="#六、实现一个数据双向绑定" class="headerlink" title="六、实现一个数据双向绑定"></a>六、实现一个数据双向绑定</h2><pre><code class="js">    &lt;input id=&quot;hangdleInput&quot; type=&quot;text&quot;&gt;    &lt;span id=&quot;hangdleValue&quot;&gt;&lt;/span&gt;    &lt;script&gt;        let obj =&#123;&#125;        let input = document.getElementById(&#39;hangdleInput&#39;)        let span = document.getElementById(&#39;hangdleValue&#39;)        Object.defineProperty(obj,&#39;text&#39;,&#123;            configurable: true,            enumerable: true,            get()&#123;                console.log(&#39;get data&#39;)            &#125;,            set(newVal)&#123;                console.log(&#39;set data&#39;)                input.value = newVal                span.innerHTML = newVal            &#125;        &#125;)        input.addEventListener(&#39;keyup&#39;,function(e)&#123;            obj.text = e.target.value        &#125;)    &lt;/script&gt;</code></pre><h2 id="七、Vue3-Proxy"><a href="#七、Vue3-Proxy" class="headerlink" title="七、Vue3 Proxy"></a>七、Vue3 Proxy</h2><blockquote><p>Vue2 的响应式是基于 Object.defineProperty 实现的<br>Vue3 的响应式是基于 ES6 的 Proxy 来实现的</p></blockquote><p>在Vue2.0中，数据双向绑定就是通过Object.defineProperty去监听对象的每一个属性，然后在get/set方法中通过发布订阅者模式来实现的数据响应，但是存在一定的缺陷，比如只能监听已存在的属性，对于新增删除属性就无能为力了，同时无法监听数组的变化，所以在Vue3.0中将其换成了功能更强大的ES6 Proxy。</p><p>Vue2的响应式函数:</p><pre><code class="js">// 响应式函数function reactive(obj, key, value) &#123;  Object.defineProperty(data, key, &#123;    get() &#123;      console.log(`访问了$&#123;key&#125;属性`)      return value    &#125;,    set(val) &#123;      console.log(`将$&#123;key&#125;由-&gt;$&#123;value&#125;-&gt;设置成-&gt;$&#123;val&#125;`)      if (value !== val) &#123;        value = val      &#125;    &#125;  &#125;)&#125;const data = &#123;  name: &#39;jude&#39;,  age: 18&#125;Object.keys(data).forEach(key =&gt; reactive(data, key, data[key]))console.log(data.name)// 访问了name属性// judedata.name = &#39;summer&#39; // 将name由-&gt;jude-&gt;设置成-&gt;summerconsole.log(data.name)// 访问了name属性// summer</code></pre><p>Vue3的响应式函数：</p><pre><code class="js">const data = &#123;  name: &#39;jude&#39;,  age: 18&#125;function reactive(target) &#123;  const handler = &#123;    get(target, key, receiver) &#123;      console.log(`访问了$&#123;key&#125;属性`)      return Reflect.get(target, key, receiver)    &#125;,    set(target, key, value, receiver) &#123;      console.log(`将$&#123;key&#125;由-&gt;$&#123;target[key]&#125;-&gt;设置成-&gt;$&#123;value&#125;`)      Reflect.set(target, key, value, receiver)    &#125;  &#125;  return new Proxy(target, handler)&#125;const proxyData = reactive(data)console.log(proxyData.name)// 访问了name属性// judeproxyData.name = &#39;summer&#39;// 将name由-&gt;jude-&gt;设置成-&gt;summerconsole.log(proxyData.name)// 访问了name属性// summer</code></pre><pre><code class="js">/*** target: 要兼容的对象，可以是一个对象，数组,函数等等* handler: 是一个对象，里面包含了可以监听这个对象的行为函数，比如上面例子里面的get与set* 同时会返回一个新的对象proxy, 为了能够触发handler里面的函数，必须要使用返回值去进行其他操作，比如修改值*/const proxy = new Proxy(target, handler)</code></pre><h3 id="1、handle-get、handle-set、handle-has、handler-deleteProperty"><a href="#1、handle-get、handle-set、handle-has、handler-deleteProperty" class="headerlink" title="1、handle.get、handle.set、handle.has、handler.deleteProperty"></a>1、handle.get、handle.set、handle.has、handler.deleteProperty</h3><blockquote><p>当通过proxy去读取对象里面的属性的时候，会进入到get钩子函数里面<br>当通过proxy去为对象设置修改属性的时候，会进入到set钩子函数里面<br>当使用in判断属性是否在proxy代理对象里面时，会触发has<br>当使用delete去删除对象里面的属性的时候，会进入deleteProperty钩子函数</p></blockquote><h3 id="2、Reflect"><a href="#2、Reflect" class="headerlink" title="2、Reflect"></a>2、Reflect</h3><blockquote><p>在上面，我们获取属性的值或者修改属性的值都是通过直接操作target来实现的，但实际上ES6已经为我们提供了在Proxy内部调用对象的默认行为的API: Reflect。</p></blockquote><pre><code class="js">const obj = &#123;&#125;const proxy = new Proxy(obj, &#123;  get(target,key,receiver) &#123;    return Reflect.get(target,key,receiver)  &#125;&#125;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56、HTTP的请求方法、状态码</title>
      <link href="/2022/02/23/http/"/>
      <url>/2022/02/23/http/</url>
      
        <content type="html"><![CDATA[<p>整理一下HTTP的请求方法、GET/POST方法的区别、HTTP状态码、跨域解决方法，最近面试也被问到这些问题。</p><span id="more"></span><h2 id="一、HTTP的请求方法"><a href="#一、HTTP的请求方法" class="headerlink" title="一、HTTP的请求方法"></a>一、HTTP的请求方法</h2><blockquote><p>GET: 通常是用来获取资源<br>POST： 提交数据<br>PUT： 修改数据<br>DELETE： 删除资源<br>HEAD: 获取资源的元信息</p></blockquote><h2 id="二、GET和POST请求的区别？"><a href="#二、GET和POST请求的区别？" class="headerlink" title="二、GET和POST请求的区别？"></a>二、GET和POST请求的区别？</h2><p>从字面意思来讲，GET就是拿、获得，POST就是给、邮寄。</p><p>1、缓存角度： GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会；</p><p>2、编码角度： GET只能进行URL编码，只能接受ASCII字符，而POST没有限制；</p><p>3、参数角度： GET一般将参数放在URL中，存在安全问题，POST放在请求体中，适合传输敏感信息</p><p>4、幂等性角度： GET是幂等，POST则不是。（幂等表示执行相同的操作，结果也是相同的）</p><p>5、TCP角度：GET会将请求报文一次性发出去，而POST会分为2个TCP数据包,先发header部分，如果服务器响应100，再发body部分。（Firefox浏览器的POST请求只会发一个TCP包）。</p><h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><blockquote><p>1XX: 协议处理的中间状态，还需要后续操作<br>2XX: 成功状态<br>3XX: 重定向状态，资源位置发生变动，需要重新请求<br>4XX: 请求报文有误<br>5XX: 服务端发生错误</p></blockquote><p>通常在开发过程中，常用到的状态码包括：<br>200：这个最常见，成功的状态码，通常在响应体中放有数据<br>204：与200的区别就在于响应头后没有body数据<br>206：表示部分内容，这个状态码在断点续传中可以看到（响应头字段为：Content-Range）</p><p>301: 永久重定向<br>302: 临时重定向<br>304: 协商缓存命中时返回这个304状态码</p><p>403： 服务器禁止访问<br>404： 资源未找到，在服务器上未找到相应的资源</p><p>500： 服务器出错了，一般将报错信息发送给后端，后端同学来检查</p><h2 id="四、HTTP、HTTP-2特点"><a href="#四、HTTP、HTTP-2特点" class="headerlink" title="四、HTTP、HTTP/2特点"></a>四、HTTP、HTTP/2特点</h2><h3 id="1、http特点"><a href="#1、http特点" class="headerlink" title="1、http特点"></a>1、http特点</h3><p>1、灵活可拓展。语义自由，只规定了基本格式；传输形式多样性，可传输文本、图片、视频等任意数据。</p><p>2、可靠传输。基于TCP/IP，继承了TCP特性。</p><p>3、请求-应答。一发一收、有来有回</p><p>4、无状态。每次的http请求都输独立、无关的，默认不需要保留状态信息。</p><h3 id="2、http缺点"><a href="#2、http缺点" class="headerlink" title="2、http缺点"></a>2、http缺点</h3><p>1、无状态。区分场景，无状态是优点也是缺点，例如长链接中，无状态就是缺点；如果就是获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，http成了优点。</p><p>2、明文传输：协议里的头部报文不使用二进制数据，而是文本形式。调试便利的同时，http报文信息暴露给了外界，容易被外界攻击。</p><h3 id="3、https-2的改进"><a href="#3、https-2的改进" class="headerlink" title="3、https/2的改进"></a>3、https/2的改进</h3><p>1、头部压缩：针对头部字段，采用压缩算法</p><p>2、多路复用：解决http对头阻塞问题</p><p>3、设置优先级：二进制分帧</p><p>4、服务器推送：不再是被动的接受请求、响应请求，能新建stream给客户端发送信息。</p><p>5、安全性：</p><h3 id="4、三次握手"><a href="#4、三次握手" class="headerlink" title="4、三次握手"></a>4、三次握手</h3><blockquote><p>三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p></blockquote><p>第一次握手：客户端发送网络包，服务端收到了。<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><h2 id="五、跨域及解决方式："><a href="#五、跨域及解决方式：" class="headerlink" title="五、跨域及解决方式："></a>五、跨域及解决方式：</h2><p>前后端分离的开发模式中，通常会遇到跨域问题，当一个ajax请求发出去了，服务器也响应了，但是前端拿不到响应数据，这主要是因为浏览器有一个同源策略。</p><h3 id="1、浏览器的同源策略"><a href="#1、浏览器的同源策略" class="headerlink" title="1、浏览器的同源策略"></a>1、浏览器的同源策略</h3><blockquote><p>浏览器遵循同源策略，即协议 + host主机 + port端口都相同时，视为同源，不存在跨域。<br>当浏览器发送Ajax请求时，只要当前的URL和目标URL不同源（协议、host、port有一个不相同，就是不同源），就存在跨域请求。</p></blockquote><h3 id="2、CROS：跨域资源共享"><a href="#2、CROS：跨域资源共享" class="headerlink" title="2、CROS：跨域资源共享"></a>2、CROS：跨域资源共享</h3><p>CORS是一个W3C标准，需要浏览器和服务器的共同支持。一般在服务端响应头返回Access-Control-Allow-Origin:* (也可以指定具体的源名)</p><blockquote><p>options 预检请求</p></blockquote><pre><code class="js">OPTIONS / HTTP/1.1Origin: 当前地址Host: xxx.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-Header</code></pre><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。</p><h3 id="3、Nginx反向代理"><a href="#3、Nginx反向代理" class="headerlink" title="3、Nginx反向代理"></a>3、Nginx反向代理</h3><blockquote><p>Nginx是高性能的反向代理服务器</p></blockquote><p>反向代理其实就是拿到客户端的请求，将请求转发给其他服务器，主要场景是维持服务器集群的负载均衡。即：反向代理帮其他的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。</p><p>例如：客户端域名：client.com  服务器域名：server.com,Nginx解决跨域的方法如下：</p><pre><code class="js">server &#123;  listen  80;  server_name  client.com;  location /api &#123;    proxy_pass server.com;  &#125;&#125;</code></pre><p>客户端首先访问client.com/api（此时不存在跨域），Nginx服务器作为反向代理，将请求转发给sever.com，响应返回时又将响应给到客户端，完成整个跨域请求。</p><h3 id="4、Jsonp"><a href="#4、Jsonp" class="headerlink" title="4、Jsonp"></a>4、Jsonp</h3><blockquote><p>通过给script标签的src填上目标地址发送GET请求（只支持GET请求），实现跨域请求拿到相应数据。</p></blockquote><h3 id="5、websocket"><a href="#5、websocket" class="headerlink" title="5、websocket"></a>5、websocket</h3><blockquote><p>websocket实现了客户端与服务端直接的持久连接，本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55、大文件断点续传</title>
      <link href="/2022/02/21/file-upload/"/>
      <url>/2022/02/21/file-upload/</url>
      
        <content type="html"><![CDATA[<p>关于大文件断点续传的问题,解决方案是Blob.prototype.slice方法，和数组的slice方法类似，使用slice方法可以返回源文件的切片。按照要求将源文件切位n个切片，将多个切片同时上传，源文件由一个大文件转换成n个小切片同时上传，可以大大减少上传时间。<br>需要注意的是上传到服务端的切片可能位置会发生改变，需要将切片的位置记录下来。</p><span id="more"></span><h2 id="一、服务端（Node-js）"><a href="#一、服务端（Node-js）" class="headerlink" title="一、服务端（Node.js）"></a>一、服务端（Node.js）</h2><p>服务端需要做的是：接受n个切片，并将这些切片在上传后合并。</p><p>需要注意的是：</p><p>1、合并切片的时间: 即n个切片什么时候上传完成</p><blockquote><p>前端上传的切片中带有切片的个数，服务端接受到切片的总数后自动合并<br>2、怎么合并切片<br>使用node.js的读写流(readStream/writeStream)，将所有切片的流传输到最终文件的流里。</p></blockquote><p>服务端：</p><blockquote><p>server<br>-index.js<br>-controller.js</p></blockquote><details><summary>点我展示代码</summary><pre><code class="js">// index.jsconst Controller = require(&quot;./controller&quot;);const http = require(&quot;http&quot;);const server = http.createServer();const controller = new Controller();server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  // 解决跨域     res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);  if (req.method === &quot;OPTIONS&quot;) &#123;    res.status = 200;    res.end();    return;  &#125;//   验证上传文件是否已上传  if (req.url === &quot;/verify&quot;) &#123;    await controller.handleVerifyUpload(req, res);    return;  &#125;    // 合并切片  if (req.url === &quot;/merge&quot;) &#123;    await controller.handleMerge(req, res);    return;  &#125;  if (req.url === &quot;/&quot;) &#123;    await controller.handleFormData(req, res);  &#125;&#125;);server.listen(3001, () =&gt; console.log(&quot;正在监听 3001 端口&quot;));</code></pre><pre><code class="js">// controller.js// 处理前端传来的FormDataconst multiparty = require(&quot;multiparty&quot;);const path = require(&quot;path&quot;);const fse = require(&quot;fs-extra&quot;);const extractExt = filename =&gt;  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录const pipeStream = (path, writeStream) =&gt;  new Promise(resolve =&gt; &#123;    //   创建可读流    const readStream = fse.createReadStream(path);    readStream.on(&quot;end&quot;, () =&gt; &#123;      fse.unlinkSync(path);      resolve();    &#125;);    readStream.pipe(writeStream);  &#125;);// 合并切片const mergeFileChunk = async (filePath, fileHash, size) =&gt; &#123;  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);  const chunkPaths = await fse.readdir(chunkDir);  // 根据切片下标进行排序  // 否则直接读取目录的获得的顺序可能会错乱  chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);  await Promise.all(    chunkPaths.map((chunkPath, index) =&gt;      pipeStream(        path.resolve(chunkDir, chunkPath),        // 指定位置创建可写流        fse.createWriteStream(filePath, &#123;          start: index * size,          end: (index + 1) * size        &#125;)      )    )  );  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录&#125;;const resolvePost = req =&gt;  new Promise(resolve =&gt; &#123;    let chunk = &quot;&quot;;    req.on(&quot;data&quot;, data =&gt; &#123;      chunk += data;    &#125;);    req.on(&quot;end&quot;, () =&gt; &#123;      resolve(JSON.parse(chunk));    &#125;);  &#125;);// 返回已经上传切片名const createUploadedList = async fileHash =&gt;  fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))    : [];module.exports = class &#123;  // 合并切片  async handleMerge(req, res) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename, size &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    await mergeFileChunk(filePath, fileHash, size);    res.end(      JSON.stringify(&#123;        code: 0,        message: &quot;file merged success&quot;      &#125;)    );  &#125;  // 处理切片  async handleFormData(req, res) &#123;    const multipart = new multiparty.Form();    //下面multipart.parse的回调中 fields 参数保存了FormData中的文件    multipart.parse(req, async (err, fields, files) =&gt; &#123;      if (err) &#123;        console.error(err);        res.status = 500;        res.end(&quot;process file chunk failed&quot;);        return;      &#125;      const [chunk] = files.chunk;      const [hash] = fields.hash;      const [fileHash] = fields.fileHash;      const [filename] = fields.filename;      const filePath = path.resolve(        UPLOAD_DIR,        `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`      );      const chunkDir = path.resolve(UPLOAD_DIR, fileHash);      // 文件存在直接返回      if (fse.existsSync(filePath)) &#123;        res.end(&quot;file exist&quot;);        return;      &#125;      // 切片目录不存在，创建切片目录      if (!fse.existsSync(chunkDir)) &#123;        await fse.mkdirs(chunkDir);      &#125;      // fs-extra 专用方法，类似 fs.rename 并且跨平台      // fs-extra 的 rename 方法 windows 平台会有权限问题      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835      await fse.move(chunk.path, path.resolve(chunkDir, hash));      res.end(&quot;received file chunk&quot;);    &#125;);  &#125;  // 验证是否已上传/已上传切片下标  async handleVerifyUpload(req, res) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    if (fse.existsSync(filePath)) &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: false        &#125;)      );    &#125; else &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: true,          uploadedList: await createUploadedList(fileHash)        &#125;)      );    &#125;  &#125;&#125;;</code></pre></details><h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><p>前端使用Vue+elementUI展示界面，当点击上传按钮时，slice方法将源文件做切片处理，将切片放入数组中返回，使用 hash+index 给每个切片做标识，用于上传完成后合并切片。<br>调用uploadChunks上传所有的切片，将切片、切片hash、切片名filename放入FormData中，使用promise.all并发上传所有切片。</p><p>断点续传原理在于前后端需要记住已经上传的切片，继续上传的时候就可以跳过之前已经上传的部分。</p><p>实现的方案：</p><blockquote><p>服务端保存已经上传的切片hash，前端每次上传前都向服务端获取已经上传的切片。</p></blockquote><p>这里也可以在前端使用localStorage记录已经上传的切片的hash，但是存在问题，就是换一个浏览器就失去已经上传的切片的hash了。</p><p>客户端、服务端都需要生成文件和切片的hash，根据文件内容生成hash。使用spark-md5根据文件内容计算出文件的hash值。</p><p>当文件比较大的时候，读取文件内容计算hash是非常耗时的，会引起UI阻塞，导致页面假死，解决方式是使用web-worker在worker线程计算hash。</p><p>实例化web-worker，参数是一个js文件路径不能跨域，需要单独创建一个hash.js文件放在public中，在worker中不允许访问dom，使用importScripts函数导入外部脚本spark-md5</p><pre><code class="js">// hash.jsself.importScripts(&quot;/spark-md5.min.js&quot;); // 导入脚本// 生成文件 hashself.onmessage = e =&gt; &#123;  const &#123; fileChunkList &#125; = e.data;  const spark = new self.SparkMD5.ArrayBuffer();  let percentage = 0;  let count = 0;  const loadNext = index =&gt; &#123;    const reader = new FileReader();    reader.readAsArrayBuffer(fileChunkList[index].file);    reader.onload = e =&gt; &#123;      count++;      spark.append(e.target.result);      if (count === fileChunkList.length) &#123;        self.postMessage(&#123;          percentage: 100,          hash: spark.end()        &#125;);        self.close();      &#125; else &#123;        percentage += 100 / fileChunkList.length;        self.postMessage(&#123;          percentage        &#125;);        loadNext(count);      &#125;    &#125;;  &#125;;  loadNext(0);&#125;;</code></pre><p>1、template</p><details><summary>点我展示代码</summary><pre><code class="html">    &lt;div&gt;      &lt;input        type=&quot;file&quot;        :disabled=&quot;status !== Status.wait&quot;        @change=&quot;handleFileChange&quot;      /&gt;      &lt;el-button @click=&quot;handleUpload&quot; :disabled=&quot;uploadDisabled&quot;        &gt;上传&lt;/el-button      &gt;      &lt;el-button @click=&quot;handleResume&quot; v-if=&quot;status === Status.pause&quot;        &gt;恢复&lt;/el-button      &gt;      &lt;el-button        v-else        :disabled=&quot;status !== Status.uploading || !container.hash&quot;        @click=&quot;handlePause&quot;        &gt;暂停&lt;/el-button      &gt;    &lt;/div&gt;    &lt;div&gt;      &lt;!-- &lt;div&gt;计算文件 hash&lt;/div&gt;      &lt;el-progress :percentage=&quot;hashPercentage&quot;&gt;&lt;/el-progress&gt; --&gt;      &lt;div&gt;总进度&lt;/div&gt;      &lt;el-progress :percentage=&quot;fakeUploadPercentage&quot;&gt;&lt;/el-progress&gt;    &lt;/div&gt;    &lt;el-table :data=&quot;data&quot;&gt;      &lt;el-table-column        prop=&quot;hash&quot;        label=&quot;切片hash&quot;        align=&quot;center&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;大小(KB)&quot; align=&quot;center&quot; width=&quot;120&quot;&gt;        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;          &#123;&#123; row.size | transformByte &#125;&#125;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;进度&quot; align=&quot;center&quot;&gt;        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;          &lt;el-progress            :percentage=&quot;row.percentage&quot;            color=&quot;#909399&quot;          &gt;&lt;/el-progress&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;</code></pre></details><p>2、js部分：设置切片大小 考虑到通用性，简单封装了XMLHttpRequest, 实际使用可以隐藏掉hash进度条</p><details><summary>点我展示代码</summary><pre><code class="js">&lt;script&gt;const SIZE = 100 * 1024 * 1024; // 切片大小const Status = &#123;  wait: &quot;wait&quot;,  pause: &quot;pause&quot;,  uploading: &quot;uploading&quot;&#125;;export default &#123;  name: &quot;app&quot;,  filters: &#123;    transformByte(val) &#123;      return Number((val / 1024).toFixed(0));    &#125;  &#125;,  data: () =&gt; (&#123;    Status,    container: &#123;      file: null,      hash: &quot;&quot;,      worker: null    &#125;,    hashPercentage: 0,    data: [],    requestList: [],    status: Status.wait,    // 当暂停时会取消 xhr 导致进度条后退    // 为了避免这种情况，需要定义一个假的进度条    fakeUploadPercentage: 0  &#125;),  computed: &#123;    uploadDisabled() &#123;      return (        !this.container.file ||        [Status.pause, Status.uploading].includes(this.status)      );    &#125;,    uploadPercentage() &#123;      if (!this.container.file || !this.data.length) return 0;      const loaded = this.data        .map(item =&gt; item.size * item.percentage)        .reduce((acc, cur) =&gt; acc + cur);      return parseInt((loaded / this.container.file.size).toFixed(2));    &#125;  &#125;,  watch: &#123;    uploadPercentage(now) &#123;      if (now &gt; this.fakeUploadPercentage) &#123;        this.fakeUploadPercentage = now;      &#125;    &#125;  &#125;,  methods: &#123;    // 暂停    handlePause() &#123;      this.status = Status.pause;      this.resetData();    &#125;,    resetData() &#123;      this.requestList.forEach(xhr =&gt; xhr?.abort());      this.requestList = [];      if (this.container.worker) &#123;        this.container.worker.onmessage = null;      &#125;    &#125;,    async handleResume() &#123;      this.status = Status.uploading;      const &#123; uploadedList &#125; = await this.verifyUpload(        this.container.file.name,        this.container.hash      );      await this.uploadChunks(uploadedList);    &#125;,    // xhr    request(&#123;      url,      method = &quot;post&quot;,      data,      headers = &#123;&#125;,      onProgress = e =&gt; e,      requestList    &#125;) &#123;      return new Promise(resolve =&gt; &#123;        const xhr = new XMLHttpRequest();        xhr.upload.onprogress = onProgress;        xhr.open(method, url);        Object.keys(headers).forEach(key =&gt;          xhr.setRequestHeader(key, headers[key])        );        xhr.send(data);        xhr.onload = e =&gt; &#123;          // 将请求成功的 xhr 从列表中删除          if (requestList) &#123;            const xhrIndex = requestList.findIndex(item =&gt; item === xhr);            requestList.splice(xhrIndex, 1);          &#125;          resolve(&#123;            data: e.target.response          &#125;);        &#125;;        // 暴露当前 xhr 给外部        requestList?.push(xhr);      &#125;);    &#125;,    // 生成文件切片    createFileChunk(file, size = SIZE) &#123;      const fileChunkList = [];      let cur = 0;      while (cur &lt; file.size) &#123;        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);        cur += size;      &#125;      return fileChunkList;    &#125;,    // 生成文件 hash（web-worker）    calculateHash(fileChunkList) &#123;      return new Promise(resolve =&gt; &#123;        this.container.worker = new Worker(&quot;/hash.js&quot;);        this.container.worker.postMessage(&#123; fileChunkList &#125;);        this.container.worker.onmessage = e =&gt; &#123;          const &#123; percentage, hash &#125; = e.data;          this.hashPercentage = percentage;          if (hash) &#123;            resolve(hash);          &#125;        &#125;;      &#125;);    &#125;,    handleFileChange(e) &#123;      const [file] = e.target.files;      if (!file) return;      this.resetData();      Object.assign(this.$data, this.$options.data());      this.container.file = file;    &#125;,    async handleUpload() &#123;      if (!this.container.file) return;      this.status = Status.uploading;      const fileChunkList = this.createFileChunk(this.container.file);      this.container.hash = await this.calculateHash(fileChunkList);      const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(        this.container.file.name,        this.container.hash      );      if (!shouldUpload) &#123;        this.$message.success(&quot;秒传：上传成功&quot;);        this.status = Status.wait;        return;      &#125;      this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;        fileHash: this.container.hash,        index,        hash: this.container.hash + &quot;-&quot; + index,        chunk: file,        size: file.size,        percentage: uploadedList.includes(index) ? 100 : 0      &#125;));      await this.uploadChunks(uploadedList);    &#125;,    // 上传切片，同时过滤已上传的切片    async uploadChunks(uploadedList = []) &#123;      const requestList = this.data        .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;          const formData = new FormData();          formData.append(&quot;chunk&quot;, chunk);          formData.append(&quot;hash&quot;, hash);          formData.append(&quot;filename&quot;, this.container.file.name);          formData.append(&quot;fileHash&quot;, this.container.hash);          return &#123; formData, index &#125;;        &#125;)        .map(async (&#123; formData, index &#125;) =&gt;          this.request(&#123;            url: &quot;http://localhost:3001&quot;,            data: formData,            onProgress: this.createProgressHandler(this.data[index]),            requestList: this.requestList          &#125;)        );      await Promise.all(requestList);      // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时      // 合并切片      if (uploadedList.length + requestList.length === this.data.length) &#123;        await this.mergeRequest();      &#125;    &#125;,    // 通知服务端合并切片    async mergeRequest() &#123;      await this.request(&#123;        url: &quot;http://localhost:3001/merge&quot;,        headers: &#123;          &quot;content-type&quot;: &quot;application/json&quot;        &#125;,        data: JSON.stringify(&#123;          size: SIZE,          fileHash: this.container.hash,          filename: this.container.file.name        &#125;)      &#125;);      this.$message.success(&quot;上传成功&quot;);      this.status = Status.wait;    &#125;,    // 根据 hash 验证文件是否曾经已经被上传过    // 没有才进行上传    async verifyUpload(filename, fileHash) &#123;      const &#123; data &#125; = await this.request(&#123;        url: &quot;http://localhost:3001/verify&quot;,        headers: &#123;          &quot;content-type&quot;: &quot;application/json&quot;        &#125;,        data: JSON.stringify(&#123;          filename,          fileHash        &#125;)      &#125;);      return JSON.parse(data);    &#125;,    // 用闭包保存每个 chunk 的进度数据    createProgressHandler(item) &#123;      return e =&gt; &#123;        item.percentage = parseInt(String((e.loaded / e.total) * 100));      &#125;;    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54、个人GitHub图床使用webp格式的图片</title>
      <link href="/2022/01/24/image-host/"/>
      <url>/2022/01/24/image-host/</url>
      
        <content type="html"><![CDATA[<p>使用图床，将本地图片上传到个人GitHub image-host 转换成webp格式的图片链接。</p><span id="more"></span><h3 id="1、什么是webp？"><a href="#1、什么是webp？" class="headerlink" title="1、什么是webp？"></a>1、什么是webp？</h3><blockquote><p>WebP is  是由 Google 公司开发的一种可提供有损和无损压缩的图片格式，支持透明度，目前已支持动图。</p></blockquote><h3 id="2、PicX图床的使用"><a href="#2、PicX图床的使用" class="headerlink" title="2、PicX图床的使用"></a>2、PicX图床的使用</h3><p>PicX 是一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了。</p><p>配置链接：<a href="https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE">https://picx-docs.xpoet.cn/tutorial/get-start.html#%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE</a></p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.1fp31abnh9sw.webp"></image></p><p>将本地图片上传至图床，上床成功后的图片会生成一个GitHub外链和cdn外链。</p><p><image src="https://cdn.jsdelivr.net/gh/HeyJudeYQ/Image-Host@master/image.27ywn4r0zskk.webp"></image></p>]]></content>
      
      
      
        <tags>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53、vue使用装饰器descriptor</title>
      <link href="/2022/01/20/decorator/"/>
      <url>/2022/01/20/decorator/</url>
      
        <content type="html"><![CDATA[<p>decorator装饰器通过对类、对象、方法、属性进行修饰，对其添加一些其他行为，即对一段代码进行二次包装。<br>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><span id="more"></span><h2 id="一、使用方法："><a href="#一、使用方法：" class="headerlink" title="一、使用方法："></a>一、使用方法：</h2><pre><code class="js">const decorator = (target,name,descriptor) =&gt; &#123;  var oldValue = descriptor.value  descriptor.value = function()&#123;    return oldValue.apply(this,arguments)  &#125;  return descriptor&#125;</code></pre><p>使用装饰器可以不需要关注代码内部的实现，增强了代码的可读性。</p><p>vue中使用装饰器：</p><p>项目中使用eslint，需要开启装饰器相关语法的检测。</p><pre><code class="js">// .eslintrc.js  parserOptions: &#123;    parser: &#39;babel-eslint&#39;,    ecmaFeatures:&#123;      legacyDecorators: true    &#125;  &#125;,</code></pre><h2 id="二、Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作："><a href="#二、Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作：" class="headerlink" title="二、Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作："></a>二、Vue项目使用Element-Ui组件库进行二次弹窗确认相关操作：</h2><p>1、工具函数decorator.js</p><pre><code class="js">// 需安装element-uiimport &#123; MessageBox, Message &#125; from &#39;element-ui&#39;/** * 确认框 * @param &#123;String&#125; title - 标题 * @param &#123;String&#125; content - 内容 * @param &#123;String&#125; confirmButtonText - 确认按钮名称 * @param &#123;Function&#125; callback - 确认按钮名称 * @returns   **/export function confirm (title, content, confirmButtonText = &#39;确定&#39;) &#123;  return function(target, name, descriptor) &#123;    // target:test（）      // name:test1       // descriptor: 装饰器属性     // 包括 ：configurable: true     // umerable: true    // value: ƒ ()     // writable: true    const originValue = descriptor.value    descriptor.value = function(...args) &#123;      MessageBox.confirm(content, title, &#123;        dangerouslyUseHTMLString: true,        distinguishCancelAndClose: true,        confirmButtonText: confirmButtonText      &#125;).then(originValue.bind(this, ...args)).catch(error =&gt; &#123;        if (error === &#39;close&#39; || error === &#39;cancel&#39;) &#123;          Message.info(&#39;用户取消操作&#39;)        &#125; else &#123;          Message.info(error)        &#125;      &#125;)    &#125;    return descriptor  &#125;&#125;</code></pre><p>2、页面引入装饰器函数</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;about&quot;&gt;    &lt;h1&gt;This is an about page&lt;/h1&gt;    &lt;p&gt;装饰器&lt;/p&gt;    &lt;button @click=&#39;test&#39;&gt;confirm&lt;/button&gt;&lt;button&gt;cancel&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">import &#123; confirm &#125; from &#39;./decorator.js&#39;export default &#123;  name: &#39;about&#39;,  methods: &#123;    @confirm(&#39;删除&#39;, &#39;确认删除?&#39;)    test () &#123;      // do something  调用接口      this.$message.success(&#39;success!!&#39;)    &#125;  &#125;&#125;</code></pre><h2 id="三、前端API请求缓存"><a href="#三、前端API请求缓存" class="headerlink" title="三、前端API请求缓存"></a>三、前端API请求缓存</h2><p>前端 API 请求缓存是前端性能优化的一个方案。</p><h3 id="1、key值错误提示"><a href="#1、key值错误提示" class="headerlink" title="1、key值错误提示"></a>1、key值错误提示</h3><pre><code class="js">const generateKeyError = new Error(&#39;Can not generate key from name and argument&#39;)</code></pre><h3 id="2、生成key值"><a href="#2、生成key值" class="headerlink" title="2、生成key值"></a>2、生成key值</h3><pre><code class="js">function generateKey(name,argument)&#123;  // 从argument 中获取数据然后变为数组  const params = Array.from(argument).join(&#39;,&#39;)  try&#123;    return `$&#123;name&#125;:$&#123;params&#125;`  &#125;catch&#123;    return generateKeyError  &#125;&#125;function decorate(handleDescription,entryArgs) &#123;  // 判断当前最后数据是否是descriptor ，如果是descriptor,直接使用  if(isDescriptor(entryArgs[entryArgs.length - 1]))&#123;    return handleDescription(...entryArgs,[])  &#125;else&#123;    return function()&#123;      return handleDescription(...Array.prototype.slice.call(arguments),entryArgs)    &#125;  &#125;&#125;function handleApiCache(target, name, descriptor, ...config) &#123;    // 拿到函数体并保存    const fn = descriptor.value    // 修改函数体    descriptor.value = function () &#123;         const key =  generateKey(name, arguments)        // key无法生成，直接请求 服务端数据        if (key === generateKeyError)  &#123;            // 利用刚才保存的函数体进行请求            return fn.apply(null, arguments)        &#125;        let promise = ExpriesCache.get(key)        if (!promise) &#123;            // 设定promise            promise = fn.apply(null, arguments).catch(error =&gt; &#123;                 // 在请求回来后，如果出现问题，把promise从cache中删除                ExpriesCache.delete(key)                // 返回错误                return Promise.reject(error)            &#125;)            // 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求            ExpriesCache.set(key, promise, config[0])        &#125;        return promise     &#125;    return descriptor;&#125;// 制定 修饰器function ApiCache(...args) &#123;    return decorate(handleApiCache, args)&#125;</code></pre><h3 id="3、api接口处使用ApiCache"><a href="#3、api接口处使用ApiCache" class="headerlink" title="3、api接口处使用ApiCache()"></a>3、api接口处使用ApiCache()</h3><pre><code class="js">class Api&#123;  // 缓存10s  @ApiCache(10)  getData(params1,params2)&#123;    return request.get(&#39;/getList&#39;)  &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>52、WebRTC音视频</title>
      <link href="/2022/01/19/webrtc/"/>
      <url>/2022/01/19/webrtc/</url>
      
        <content type="html"><![CDATA[<p>WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p><span id="more"></span><h3 id="一、WebRTC-音视频采集-API：MediaDevices-getUserMedia"><a href="#一、WebRTC-音视频采集-API：MediaDevices-getUserMedia" class="headerlink" title="一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()"></a>一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()</h3><blockquote><p>MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个 MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D 转换器等等），也可能是其它轨道类型。</p></blockquote><pre><code class="js">const constraints = &#123;  video: true,  audio: true,&#125;;//   非安全模式（非https/localhost）下 navigator.mediaDevices 会返回 undefinedtry &#123;  const stream = await navigator.mediaDevices.getUserMedia(constraints);  document.querySelector(&quot;video&quot;).srcObject = stream;&#125; catch (error) &#123;  console.error(error);&#125;</code></pre><h3 id="二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices"><a href="#二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices" class="headerlink" title="二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()"></a>二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()</h3><blockquote><p>MediaDevices 的方法 enumerateDevices() 请求一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等。 返回的 Promise (en-US) 完成时，会带有一个描述设备的 MediaDeviceInfo (en-US) 的数组。</p></blockquote><pre><code class="js">try &#123;  const devices = await navigator.mediaDevices.enumerateDevices();  this.videoinputs = devices.filter((device) =&gt; device.kind === &quot;videoinput&quot;);  this.audiooutputs = devices.filter((device) =&gt; device.kind === &quot;audiooutput&quot;);  this.audioinputs = devices.filter((device) =&gt; device.kind === &quot;audioinput&quot;);&#125; catch (error) &#123;  console.error(error);&#125;</code></pre><h3 id="三、点对点媒体协商方法"><a href="#三、点对点媒体协商方法" class="headerlink" title="三、点对点媒体协商方法"></a>三、点对点媒体协商方法</h3><p>媒体协商方法：</p><p>1、createOffer：</p><blockquote><p>createOffer 方法会生成描述信息的一个 blob 对象，它会帮助连接到本地机器。当你已经找到一个远端的 PeerConnection 并且打算设置建立本地的 PeerConnection 时，你可以使用该方法。</p></blockquote><pre><code class="js">var pc = new PeerConnection();pc.addStream(video);pc.createOffer(function(desc)&#123;  pc.setLocalDescription(desc, function() &#123;    // send the offer to a server that can negotiate with a remote client  &#125;);&#125;</code></pre><p>2、createAnswer：</p><blockquote><p>对从远方收到的 offer 进行回答。</p></blockquote><pre><code class="js">var pc = new PeerConnection();pc.setRemoteDescription(new RTCSessionDescription(offer), function () &#123;  pc.createAnswer(function (answer) &#123;    pc.setLocalDescription(answer, function () &#123;      // send the answer to the remote connection    &#125;);  &#125;);&#125;);</code></pre><h3 id="四、服务端：Koa-socket-io"><a href="#四、服务端：Koa-socket-io" class="headerlink" title="四、服务端：Koa + socket.io"></a>四、服务端：Koa + socket.io</h3><p>1、server.js</p><pre><code class="js">// server 端 server.jsconst Koa = require(&quot;koa&quot;);const socket = require(&quot;socket.io&quot;);const http = require(&quot;http&quot;);const app = new Koa();const httpServer = http.createServer(app.callback()).listen(3000, () =&gt; &#123;&#125;);socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;  // ....&#125;);// client 端 socket.jsimport io from &quot;socket.io-client&quot;;const socket = io.connect(window.location.origin);export default socket;</code></pre><p>2、点对点分别连接信令服务器，信令服务器记录房间信息</p><pre><code class="js">socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;  // 用户离开房间  sock.on(&quot;userLeave&quot;, () =&gt; &#123;    // ...  &#125;);  // 检查房间是否可加入  sock.on(&quot;checkRoom&quot;, () =&gt; &#123;    // ...  &#125;);  // ....&#125;);// client 端 Room.vueimport socket from &quot;../utils/socket.js&quot;;// 服务端告知用户是否可加入房间socket.on(&quot;checkRoomSuccess&quot;, () =&gt; &#123;  // ...&#125;);// 服务端告知用户成功加入房间socket.on(&quot;joinRoomSuccess&quot;, () =&gt; &#123;  // ...&#125;);//....</code></pre><p>3、A 端作为发起方向接收方 B 端发起视频邀请</p><p>在得到 B 同意视频请求后，双方都会创建本地的 RTCPeerConnection，添加本地视频流，其中发送方会创建 offer 设置本地 sdp 信息描述，并通过信令服务器将自己的 SDP 信息发送给对端</p><pre><code class="js">socket.on(&quot;answerVideo&quot;, async (user) =&gt; &#123;  VIDEO_VIEW.showInvideoModal();  // 创建本地视频流信息  const localStream = await this.createLocalVideoStream();  this.localStream = localStream;  document.querySelector(&quot;#echat-local&quot;).srcObject = this.localStream;  this.peer = new RTCPeerConnection();  this.initPeerListen();  this.peer.addStream(this.localStream);  if (user.sockId === this.sockId) &#123;    // 接收方  &#125; else &#123;    // 发送方 创建 offer    const offer = await this.peer.createOffer(this.offerOption);    await this.peer.setLocalDescription(offer);    socket.emit(&quot;receiveOffer&quot;, &#123; user: this.user, offer &#125;);  &#125;&#125;);</code></pre><p>4、收集自己的网络信息并发送给对方</p><pre><code class="js">initPeerListen () &#123;      // 收集自己的网络信息并发送给对端      this.peer.onicecandidate = (event) =&gt; &#123;        if (event.candidate) &#123; socket.emit(&#39;addIceCandidate&#39;, &#123; candidate: event.candidate, user: this.user &#125;); &#125;      &#125;;      // ....    &#125;</code></pre><p>5、当接收方 B 端通过信令服务器拿到对端发送方 A 端的含有 SDP 的 offer 信息后则会调用 setRemoteDescription 存储对端的 SDP 信息，创建及设置本地的 SDP 信息,并通过信令服务器传送含有本地 SDP 信息的 answer</p><pre><code class="js">socket.on(&quot;receiveOffer&quot;, async (offer) =&gt; &#123;  await this.peer.setRemoteDescription(offer);  const answer = await this.peer.createAnswer();  await this.peer.setLocalDescription(answer);  socket.emit(&quot;receiveAnsewer&quot;, &#123; answer, user: this.user &#125;);&#125;);</code></pre><p>6、当发起方 A 通过信令服务器接收到接收方 B 的 answer 信息后则也会调用 setRemoteDescription，这样双方就完成了 SDP 信息的交换</p><pre><code class="js">socket.on(&quot;receiveAnsewer&quot;, (answer) =&gt; &#123;  this.peer.setRemoteDescription(answer);&#125;);</code></pre><p>7、当双方 SDP 信息交换完成并且监听 icecandidate 收集到网络候选者通过信令服务器交换后，则会拿到彼此的视频流。</p><pre><code class="js">socket.on(&quot;addIceCandidate&quot;, async (candidate) =&gt; &#123;  await this.peer.addIceCandidate(candidate);&#125;);this.peer.onaddstream = (event) =&gt; &#123;  // 拿到对方的视频流  document.querySelector(&quot;#remote-video&quot;).srcObject = event.stream;&#125;;</code></pre><p>8、GitHub：<a href="https://github.com/HeyJudeYQ/webrtc">https://github.com/HeyJudeYQ/webrtc</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51、Vue项目中前端导出/导入Excel表格的实现</title>
      <link href="/2022/01/15/export-excel/"/>
      <url>/2022/01/15/export-excel/</url>
      
        <content type="html"><![CDATA[<p>后台管理系统中，通常有这样的需求:将当前 table 表格导出/导入 Excel 表格，实现方式通常为后端主导（后端使用插件，前端通过点击事件生成一个 a 标签，导出 Excel 表格）、前端主导（使用 xlsx、file-saver、script-loader 插件封装工具函数，通过点击事件，获取当前页面后台返回的表格数据)。</p><span id="more"></span><h2 id="一、前端导出-Excel-表格的实现"><a href="#一、前端导出-Excel-表格的实现" class="headerlink" title="一、前端导出 Excel 表格的实现"></a>一、前端导出 Excel 表格的实现</h2><h3 id="1、安装-plugin"><a href="#1、安装-plugin" class="headerlink" title="1、安装 plugin"></a>1、安装 plugin</h3><pre><code class="shell">npm install file-saver script-loader xlsx --save</code></pre><h3 id="2、Export2Excel-工具函数"><a href="#2、Export2Excel-工具函数" class="headerlink" title="2、Export2Excel 工具函数"></a>2、Export2Excel 工具函数</h3><details><summary>点我展示代码</summary><pre><code class="js">import &#123; saveAs &#125; from &quot;file-saver&quot;;import XLSX from &quot;xlsx&quot;;function generateArray(table) &#123;  var out = [];  var rows = table.querySelectorAll(&quot;tr&quot;);  var ranges = [];  for (var R = 0; R &lt; rows.length; ++R) &#123;    var outRow = [];    var row = rows[R];    var columns = row.querySelectorAll(&quot;td&quot;);    for (var C = 0; C &lt; columns.length; ++C) &#123;      var cell = columns[C];      var colspan = cell.getAttribute(&quot;colspan&quot;);      var rowspan = cell.getAttribute(&quot;rowspan&quot;);      var cellValue = cell.innerText;      if (cellValue !== &quot;&quot; &amp;&amp; cellValue == +cellValue) cellValue = +cellValue;      //Skip ranges      ranges.forEach(function (range) &#123;        if (          R &gt;= range.s.r &amp;&amp;          R &lt;= range.e.r &amp;&amp;          outRow.length &gt;= range.s.c &amp;&amp;          outRow.length &lt;= range.e.c        ) &#123;          for (var i = 0; i &lt;= range.e.c - range.s.c; ++i) outRow.push(null);        &#125;      &#125;);      //Handle Row Span      if (rowspan || colspan) &#123;        rowspan = rowspan || 1;        colspan = colspan || 1;        ranges.push(&#123;          s: &#123;            r: R,            c: outRow.length,          &#125;,          e: &#123;            r: R + rowspan - 1,            c: outRow.length + colspan - 1,          &#125;,        &#125;);      &#125;      //Handle Value      outRow.push(cellValue !== &quot;&quot; ? cellValue : null);      //Handle Colspan      if (colspan) for (var k = 0; k &lt; colspan - 1; ++k) outRow.push(null);    &#125;    out.push(outRow);  &#125;  return [out, ranges];&#125;function datenum(v, date1904) &#123;  if (date1904) v += 1462;  var epoch = Date.parse(v);  return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#125;function sheet_from_array_of_arrays(data, opts) &#123;  var ws = &#123;&#125;;  var range = &#123;    s: &#123;      c: 10000000,      r: 10000000,    &#125;,    e: &#123;      c: 0,      r: 0,    &#125;,  &#125;;  for (var R = 0; R != data.length; ++R) &#123;    for (var C = 0; C != data[R].length; ++C) &#123;      if (range.s.r &gt; R) range.s.r = R;      if (range.s.c &gt; C) range.s.c = C;      if (range.e.r &lt; R) range.e.r = R;      if (range.e.c &lt; C) range.e.c = C;      var cell = &#123;        v: data[R][C],      &#125;;      if (cell.v == null) continue;      var cell_ref = XLSX.utils.encode_cell(&#123;        c: C,        r: R,      &#125;);      if (typeof cell.v === &quot;number&quot;) cell.t = &quot;n&quot;;      else if (typeof cell.v === &quot;boolean&quot;) cell.t = &quot;b&quot;;      else if (cell.v instanceof Date) &#123;        cell.t = &quot;n&quot;;        cell.z = XLSX.SSF._table[14];        cell.v = datenum(cell.v);      &#125; else cell.t = &quot;s&quot;;      ws[cell_ref] = cell;    &#125;  &#125;  if (range.s.c &lt; 10000000) ws[&quot;!ref&quot;] = XLSX.utils.encode_range(range);  return ws;&#125;function Workbook() &#123;  if (!(this instanceof Workbook)) return new Workbook();  this.SheetNames = [];  this.Sheets = &#123;&#125;;&#125;function s2ab(s) &#123;  var buf = new ArrayBuffer(s.length);  var view = new Uint8Array(buf);  for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;  return buf;&#125;export function export_table_to_excel(id) &#123;  var theTable = document.getElementById(id);  var oo = generateArray(theTable);  var ranges = oo[1];  /* original data */  var data = oo[0];  var ws_name = &quot;SheetJS&quot;;  var wb = new Workbook(),    ws = sheet_from_array_of_arrays(data);  /* add ranges to worksheet */  // ws[&#39;!cols&#39;] = [&#39;apple&#39;, &#39;banan&#39;];  ws[&quot;!merges&quot;] = ranges;  /* add worksheet to workbook */  wb.SheetNames.push(ws_name);  wb.Sheets[ws_name] = ws;  var wbout = XLSX.write(wb, &#123;    bookType: &quot;xlsx&quot;,    bookSST: false,    type: &quot;binary&quot;,  &#125;);  saveAs(    new Blob([s2ab(wbout)], &#123;      type: &quot;application/octet-stream&quot;,    &#125;),    &quot;test.xlsx&quot;  );&#125;export function export_json_to_excel(&#123;  multiHeader = [],  header,  data,  filename,  merges = [],  autoWidth = true,  bookType = &quot;xlsx&quot;,&#125; = &#123;&#125;) &#123;  /* original data */  filename = filename || &quot;excel-list&quot;;  data = [...data];  data.unshift(header);  for (let i = multiHeader.length - 1; i &gt; -1; i--) &#123;    data.unshift(multiHeader[i]);  &#125;  var ws_name = &quot;SheetJS&quot;;  var wb = new Workbook(),    ws = sheet_from_array_of_arrays(data);  if (merges.length &gt; 0) &#123;    if (!ws[&quot;!merges&quot;]) ws[&quot;!merges&quot;] = [];    merges.forEach((item) =&gt; &#123;      ws[&quot;!merges&quot;].push(XLSX.utils.decode_range(item));    &#125;);  &#125;  if (autoWidth) &#123;    /*设置worksheet每列的最大宽度*/    const colWidth = data.map((row) =&gt;      row.map((val) =&gt; &#123;        /*先判断是否为null/undefined*/        if (val == null) &#123;          return &#123;            wch: 10,          &#125;;        &#125; else if (val.toString().charCodeAt(0) &gt; 255) &#123;          /*再判断是否为中文*/          return &#123;            wch: val.toString().length * 2,          &#125;;        &#125; else &#123;          return &#123;            wch: val.toString().length,          &#125;;        &#125;      &#125;)    );    /*以第一行为初始值*/    let result = colWidth[0];    for (let i = 1; i &lt; colWidth.length; i++) &#123;      for (let j = 0; j &lt; colWidth[i].length; j++) &#123;        if (result[j][&quot;wch&quot;] &lt; colWidth[i][j][&quot;wch&quot;]) &#123;          result[j][&quot;wch&quot;] = colWidth[i][j][&quot;wch&quot;];        &#125;      &#125;    &#125;    ws[&quot;!cols&quot;] = result;  &#125;  /* add worksheet to workbook */  wb.SheetNames.push(ws_name);  wb.Sheets[ws_name] = ws;  var wbout = XLSX.write(wb, &#123;    bookType: bookType,    bookSST: false,    type: &quot;binary&quot;,  &#125;);  saveAs(    new Blob([s2ab(wbout)], &#123;      type: &quot;application/octet-stream&quot;,    &#125;),    `$&#123;filename&#125;.$&#123;bookType&#125;`  );&#125;</code></pre></details><h3 id="3、导出函数"><a href="#3、导出函数" class="headerlink" title="3、导出函数"></a>3、导出函数</h3><p>a-button 为 ant-design-vue 的 button 组件</p><pre><code class="html">&lt;a-button  type=&quot;primary&quot;  icon=&quot;export&quot;  class=&quot;select-bottom&quot;  :loading=&quot;exportLoading&quot;  @click=&quot;handleExport&quot;  &gt;导出&lt;/a-button&gt;</code></pre><p>handleExport 导出函数</p><blockquote><p>1、点击导出按钮，去加载在 vendor 文件夹中的 Export2Excel 模块<br>2、import 方法执行完毕返回一个 promise 对象，在 then 方法中我们可以拿到使用的模块对象（excel）<br>3、Excel 导出参数部分的 data，是一个严格的二维数组，header 为导出的数据表头，filename 为导出的文件名，bookType 为导出文件类型，autoWidth 为单元格是否要自适应宽度。</p></blockquote><pre><code class="js">handleExport() &#123;    //由于是前端导出，所以只能导出当前页的数据    this.exportLoading = true;      import(&#39;@/vendor/Export2Excel&#39;).then(excel =&gt; &#123;        const header = [],          filterVal = [];        this.tableHead.forEach(item =&gt; &#123;          if (item.title != &#39;操作&#39; &amp;&amp; item.title != &#39;序号&#39;) &#123;            header.push(item.title);            filterVal.push(item.dataIndex);          &#125;        &#125;);        const data = formatJson(this.tableData, filterVal);        excel.export_json_to_excel(&#123;          header,          data,          filename: &#39;表单统计&#39;        &#125;);        this.exportLoading = false;      &#125;);    &#125;</code></pre><h2 id="二、前端导入-Excel-的实现"><a href="#二、前端导入-Excel-的实现" class="headerlink" title="二、前端导入 Excel 的实现"></a>二、前端导入 Excel 的实现</h2><h3 id="1、ant-design-vue-上传组件的使用"><a href="#1、ant-design-vue-上传组件的使用" class="headerlink" title="1、ant-design-vue 上传组件的使用"></a>1、ant-design-vue 上传组件的使用</h3><pre><code class="html">&lt;div class=&quot;file-wrapper relative&quot;&gt;  &lt;input    ref=&quot;excel-upload&quot;    type=&quot;file&quot;    accept=&quot;.xlsx, .xls&quot;    @change=&quot;handleChange&quot;    style=&quot;display:none&quot;  /&gt;  &lt;a-button    type=&quot;primary&quot;    icon=&quot;file-excel&quot;    size=&quot;large&quot;    style=&quot;z-index:99&quot;    @click=&quot;handleUpload&quot;    :loading=&quot;loading&quot;  &gt;    上传Excel  &lt;/a-button&gt;  &lt;p class=&quot;text&quot;&gt;请选择Excel上传 支持(xlsx,xls)格式&lt;/p&gt;&lt;/div&gt;&lt;!-- table组件 tableData:[]  tableHead:[] --&gt;&lt;a-card  :hoverable=&quot;true&quot;  :bordered=&quot;false&quot;  v-if=&quot;tableHead.length &gt; 0&quot;  style=&quot;margin-top:30px&quot;&gt;  &lt;standard-table    :pagination=&quot;false&quot;    :tableData=&quot;tableData&quot;    :tableHead=&quot;tableHead&quot;  /&gt;&lt;/a-card&gt;</code></pre><!-- 样式 --><pre><code class="css">.file-wrapper &#123;  width: 100%;  height: 350px;  line-height: 350px;  text-align: center;  background: #e6ecf4;  .text &#123;    position: absolute;    top: 50px;    left: 50%;    transform: translateX(-50%);  &#125;&#125;</code></pre><h3 id="2、导入函数"><a href="#2、导入函数" class="headerlink" title="2、导入函数"></a>2、导入函数</h3><pre><code class="js">// 引入xlsx table组件import XLSX from &quot;xlsx&quot;;import standardTable from &quot;@/components/standardTable/index&quot;;</code></pre><details><summary>点我展示代码</summary><pre><code class="js">    handleChange(e) &#123;      const file = e.target.files[0];      if (!file) return;      //判断格式      if (!this.isExcel(file)) &#123;        this.$message.warning(&#39;只能选择xlxs,xls文件&#39;);        return;      &#125;      //判断大小      if (file.size / 1024 / 1024 &gt; 1) &#123;        this.$message.warning(&#39;上传文件大小不能超过1M&#39;);        return;      &#125;      this.loading = true;      const reader = new FileReader();      reader.readAsArrayBuffer(file);      reader.onload = e =&gt; &#123;        const data = e.target.result;        const workbook = XLSX.read(data, &#123; type: &#39;array&#39; &#125;);        const firstSheetName = workbook.SheetNames[0];        const worksheet = workbook.Sheets[firstSheetName];        setTimeout(() =&gt; &#123;          this.loading = false;          const head = this.getHeaderRow(worksheet);          this.tableHead = head.map(item =&gt; &#123;            return &#123;              title: item,              dataIndex: item            &#125;;          &#125;);          const tableData = XLSX.utils.sheet_to_json(worksheet);          tableData.forEach(item =&gt; &#123;            item.id = parseInt(Math.random(0, 1) * 10000);          &#125;);          this.tableData = tableData;        &#125;, 500);      &#125;;    &#125;,    generateData(&#123; header, results &#125;) &#123;      this.excelData.header = header;      this.excelData.results = results;      this.onSuccess &amp;&amp; this.onSuccess(this.excelData);    &#125;,    //获取表头    getHeaderRow(sheet) &#123;      const headers = [];      const range = XLSX.utils.decode_range(sheet[&#39;!ref&#39;]);      let C;      const R = range.s.r;      for (C = range.s.c; C &lt;= range.e.c; ++C) &#123;        const cell = sheet[XLSX.utils.encode_cell(&#123; c: C, r: R &#125;)];        let hdr = &#39;UNKNOWN &#39; + C;        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell);        headers.push(hdr);      &#125;      return headers;    &#125;,    handleUpload() &#123;      this.$refs[&#39;excel-upload&#39;].click();    &#125;,    // 文件类型    isExcel(file) &#123;      return /\.(xlsx|xls|csv)$/.test(file.name);    &#125;</code></pre></details><h2 id="三、table-子组件"><a href="#三、table-子组件" class="headerlink" title="三、table 子组件"></a>三、table 子组件</h2><details><summary>点我展示代码</summary><pre><code class="html">&lt;div class=&quot;tableCommon-wrapper&quot;&gt;  &lt;a-table    :columns=&quot;tableHead&quot;    :dataSource=&quot;tableData&quot;    :loading=&quot;loading&quot;    :pagination=&quot;pagination&quot;    :row-selection=&quot;rowSelection&quot;    @change=&quot;handleTableChange&quot;    rowKey=&quot;id&quot;    :scroll=&quot;scroll&quot;  &gt;    &lt;template      slot-scope=&quot;text, record, index&quot;      :slot=&quot;slot&quot;      v-for=&quot;slot in Object.keys($scopedSlots).filter(key =&gt; key !== &#39;expandedRowRender&#39;)&quot;    &gt;      &lt;slot :name=&quot;slot&quot; v-bind=&quot;&#123; text, record, index &#125;&quot;&gt;&lt;/slot&gt;    &lt;/template&gt;  &lt;/a-table&gt;&lt;/div&gt;</code></pre><pre><code class="js">export default &#123;  name: &quot;standardTable&quot;,  props: &#123;    tableHead: &#123;      type: Array,      required: true,    &#125;,    tableData: &#123;      type: Array,      required: true,    &#125;,    loading: &#123;      type: Boolean,      default: false,    &#125;,    pagination: &#123;      type: Boolean | Object,    &#125;,    rowSelection: &#123;      type: Object,    &#125;,    scroll: &#123;      type: Object,    &#125;,  &#125;,  methods: &#123;    handleTableChange(val) &#123;      this.$emit(&quot;changeCurrent&quot;, val.current);    &#125;,  &#125;,&#125;;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50、CountTo:数字动态滚动</title>
      <link href="/2022/01/13/count-to/"/>
      <url>/2022/01/13/count-to/</url>
      
        <content type="html"><![CDATA[<p>vue使用vue-count-to实现数字的动态滚动功能，适用于数据可视化大屏项目中使用数字滚动。</p><span id="more"></span><pre><code class="js">// 1、安装vue-count-tonpm isntall vue-count-to// 2、组件内引入、注册 startVal endVal 类型为Number</code></pre><p>代码如下：</p><pre><code class="html">&lt;template&gt;  &lt;countTo :startVal=&#39;startVal&#39; :endVal=&#39;number&#39; :duration=&#39;3000&#39; :decimals=&#39;0&#39;  :autoplay=true&gt;&lt;/countTo&gt;&lt;/template&gt;&lt;script&gt;import countTo from &#39;vue-count-to&#39;;  export default&#123;    components:&#123;countTo&#125;,    props:&#123;      number: [Number, String],      startVal:&#123;        type:Number,        default:0      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49、websocket实现客户端和服务端的通信</title>
      <link href="/2022/01/03/websocket/"/>
      <url>/2022/01/03/websocket/</url>
      
        <content type="html"><![CDATA[<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。</p><span id="more"></span><h2 id="一、websocket特点："><a href="#一、websocket特点：" class="headerlink" title="一、websocket特点："></a>一、websocket特点：</h2><blockquote><p>1、建立在 TCP 协议之上，服务器端的实现比较容易。<br>2、与 HTTP 协议有着良好的兼容性，默认端口也是80和443。并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>3、数据格式比较轻量，性能开销小，通信高效。<br>4、可以发送文本，也可以发送二进制数据。<br>5、没有同源限制，客户端可以与任意服务器通信。<br>6、全双工(通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合,例如指 A→B 的同时 B→A ，是瞬时同步的)<br>7、协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p></blockquote><p>初始化websocket<br>1、创建websocket实例，参数为url<br>2、连接 websocket.onopen<br>3、server响应数据触发 websocket.onmessage<br>4、关闭websocket，websocket.onclose</p><pre><code class="js">// 构造函数 参数为urlconst wsurl = &quot;ws://localhost:8080&quot;;var ws = new Websocket(wsurl);// 连接状态readState 1  准备好发送和接受数据了ws.onopen = function()&#123;  ws.send(&#39;hello server! websocket is open now!&#39;)&#125;// 通过客户端的事件   发送信息给服务端ws.send(&#39;hello websocket&#39;);// 发生错误ws.onerror = function(event)&#123;  console.log(&quot;websocket error observed&quot;,event)&#125;// readState CLOSED  关闭websocketws.onclose = function(event)&#123;  let status_code = event.status;  let msg = event.msg;  console.log(&quot;websocket is closed now&quot;)&#125;// 响应数据的接收ws.onmessage = function(event)&#123;  let data = event.data;&#125;</code></pre><ul><li>路由改变，需要断开websocket连接，节省服务器开支。</li></ul><h2 id="二、心跳机制"><a href="#二、心跳机制" class="headerlink" title="二、心跳机制"></a>二、心跳机制</h2><blockquote><p>websocket在连接关闭的情况下触发onclose事件，连接异常触发onerror事件。网络状态不好的情况，onclose事件的触发灵敏度不高，可能会造成断网很久触发onclose事件，客户端又出现重新连接，客户端实时界面不友好。</p></blockquote><p>为了解决上面的情况，使用心跳重连机制，客户端在websocket连接成功后，执行心跳函数，首先向服务器发送’ping‘信息，服务器收到信息会返回’pong’信息。一定时间内，客户端收到服务器返回的信息，则表示连接正常，重置心跳函数；客户端在一定时间内没有收到心跳函数，表明没有连接成功，客户端关闭websocket,再执行重连操作。</p><p>解决方式：</p><details><summary>点我展示代码</summary><pre><code class="js">import &#123; mapActions, mapState &#125; from &#39;vuex&#39;;export default &#123;    name: &#39;Websocket&#39;,    data() &#123;        return &#123;            // 是否正在重连            lockReconnect: false,            socket: null,            reconnectTimeout: null,            timeout: 10 * 1000,            timer: null,            serverTimer: null        &#125;;    &#125;,    computed: &#123;        ...mapState([&#39;userInfo&#39;]),        wsuri() &#123;            return `$&#123;process.env.VUE_APP_WEBSOCKET_URI&#125;$&#123;this.userInfo.tenantId&#125;;$&#123;this.userInfo.userId&#125;`;        &#125;    &#125;,    async mounted() &#123;        await this.getUserInfo();        this.initWebSocket();    &#125;,    destroyed() &#123;        this.socket.close();    &#125;,    methods: &#123;        ...mapActions([&#39;getUserInfo&#39;]),        start(ws) &#123;            this.reset();            this.timer = setTimeout(() =&gt; &#123;                // console.log(&#39;发送心跳,后端收到后，返回一个心跳消息&#39;)                // onmessage拿到返回的心跳就说明连接正常                ws.send(&#39;ping&#39;);                this.serverTimer = setTimeout(() =&gt; &#123;                    // 如果超过一定时间还没响应(响应后触发重置)，说明后端断开了                    ws.close();                &#125;, this.timeout);            &#125;, this.timeout);        &#125;,        reset() &#123;            this.serverTimer &amp;&amp; clearTimeout(this.serverTimer);            this.timer &amp;&amp; clearTimeout(this.timer);        &#125;,        reconnect() &#123;            console.log(&#39;尝试重连&#39;);            if (this.lockReconnect) &#123;                return;            &#125;            this.lockReconnect = true;            this.reconnectTimeout &amp;&amp; clearTimeout(this.reconnectTimeout);            this.reconnectTimeout = setTimeout(() =&gt; &#123;                this.initWebSocket();                this.lockReconnect = false;            &#125;, 4 * 1000);        &#125;,        // 初始化websocket        initWebSocket() &#123;            try &#123;                if (&#39;WebSocket&#39; in window) &#123;                    this.socket = new WebSocket(this.wsuri);                &#125; else &#123;                    console.log(&#39;您的浏览器不支持websocket&#39;);                &#125;                this.socket.onopen = this.websocketOnOpen;                this.socket.onerror = this.websocketOnError;                this.socket.onmessage = this.websocketOnMessage;                this.socket.onclose = this.websocketClose;            &#125; catch (e) &#123;                this.reconnect();            &#125;        &#125;,        websocketOnOpen() &#123;            console.log(&#39;WebSocket连接成功&#39;, this.socket.readyState);            this.start(this.socket);            this.websocketSend();        &#125;,        websocketOnError(e) &#123;            console.log(&#39;WebSocket连接发生错误&#39;, e);            this.reconnect();        &#125;,        websocketOnMessage(e) &#123;            if (e.data === &#39;pong&#39;) &#123;                // 消息获取成功，重置心跳                this.start(this.socket);            &#125;        &#125;,        websocketClose(e) &#123;            console.log(&#39;connection closed (&#39; + e.code + &#39;)&#39;);            this.reconnect();        &#125;,        websocketSend() &#123;            this.socket.send(&#39;ping&#39;);        &#125;    &#125;&#125;;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48、用hook处理组件内定时器</title>
      <link href="/2022/01/01/hook/"/>
      <url>/2022/01/01/hook/</url>
      
        <content type="html"><![CDATA[<p>vue 项目使用 hook 处理组件内定时器的方式。一般是使用生命周期钩子函数beforeDestory来销毁定时器。从Vue源码的lifecycle.js中发现了一种拓展方法，可以提升代码的简洁性，而且还可以减少data里无用变量的定义。</p><span id="more"></span><h2 id="一、使用生命周期函数处理定时器"><a href="#一、使用生命周期函数处理定时器" class="headerlink" title="一、使用生命周期函数处理定时器"></a>一、使用生命周期函数处理定时器</h2><p>通常处理组件内定时器的步骤是下面这样的</p><pre><code class="js">export default&#123;    mounted()&#123;        this.timer = setInterval（() =&gt;&#123;            // do something        &#125;,1000）    &#125;,    beforeDestory()&#123;        clearInterval(this.timer);    &#125;&#125;</code></pre><h2 id="二、使用-hook-处理定时器"><a href="#二、使用-hook-处理定时器" class="headerlink" title="二、使用 hook 处理定时器"></a>二、使用 hook 处理定时器</h2><pre><code class="js">export default&#123;    mounted()&#123;        const timer = setInterval(() =&gt; &#123;            // do something        &#125;,1000);        this.$once(&#39;hook:beforeDestory&#39;,()=&gt; clearInterval(timer);)    &#125;&#125;</code></pre><h2 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景:"></a>三、适用场景:</h2><p>处理可视化图表的时候，我们需要在数据渲染到页面之前让页面有 loading 动画，mounted 挂载之后停止 loading，beforeUpdate 时开始 loading，updated 之后停止 loading。</p><p>使用 hook 处理:</p><pre><code class="tempalte">&lt;v-chart&gt;  @hook:mounted=&quot;loading = false&quot; @hook:beforeUpdated=&quot;loading = true&quot;  @hook:updated=&quot;loading = false&quot; :data=&quot;data&quot;&lt;/v-chart&gt;</code></pre><h2 id="四、补充说明：如何实现父组件监听子组件生命周期？"><a href="#四、补充说明：如何实现父组件监听子组件生命周期？" class="headerlink" title="四、补充说明：如何实现父组件监听子组件生命周期？"></a>四、补充说明：如何实现父组件监听子组件生命周期？</h2><h3 id="1、方法一：-emit"><a href="#1、方法一：-emit" class="headerlink" title="1、方法一：$emit"></a>1、方法一：$emit</h3><p>父组件给子组件传递多个回调函数，依赖子组件在自身的生命周期李通过vm.$emit的方式，调用父组件生命的回调函数。</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div&gt;        &lt;Child @mounted=&quot;onMounted&quot;            @updated=&quot;onUpdated&quot;            @beforeDestory=&quot;beforeDestory&quot;        &gt;        &lt;/Child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>子组件：</p><pre><code class="js">mounted()&#123;    this.$emit(&#39;mounted&#39;)&#125;,updated()&#123;    this.$emit(&#39;updated&#39;)&#125;,beforeDestory()&#123;    this.$emit(&#39;beforeDestory&#39;)&#125;</code></pre><h3 id="2、方法二：-hook"><a href="#2、方法二：-hook" class="headerlink" title="2、方法二：@hook"></a>2、方法二：@hook</h3><p>父组件模板</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;Child @hook:mounted=&quot;onMounted&quot;            @hook:updated=&quot;onUpdated&quot;            @hook:beforeDestory=&quot;beforeDestory&quot;        &gt;        &lt;/Child&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>vue源码的lifecycle.js中，Vue的生命周期各个阶段都会去调用一个callHook函数，这个函数支持2个参数：实例vm和生命周期钩子名称,callHook里面执行了vm.$emit(‘hook:’+hook)。</p><p>lifecycle.js源码片段（这个文件在Vue源码的src/core/instance/lifecycle.js）</p><pre><code class="js">// callHook函数export function callHook (vm: Component, hook: string) &#123;  // #7573 disable dep collection when invoking lifecycle hooks  pushTarget()  const handlers = vm.$options[hook]  const info = `$&#123;hook&#125; hook`  if (handlers) &#123;    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;      invokeWithErrorHandling(handlers[i], vm, null, vm, info)    &#125;  &#125;  if (vm._hasHookEvent) &#123;    vm.$emit(&#39;hook:&#39; + hook)  &#125;  popTarget()&#125;</code></pre><p>@hook原理：</p><blockquote><p>当我们在子组件上传了对应的@hook:mounted钩子，也就执行了vm.$on(‘hook:mounted’),vue实例在生命周期里本身就会执行vm.$emit(‘hook:mounted’),也触发了我们绑定给子组件的回调函数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47、git提交规范</title>
      <link href="/2021/12/22/git/"/>
      <url>/2021/12/22/git/</url>
      
        <content type="html"><![CDATA[<p>使用commitizen和cz-customizable规范代码提交</p><span id="more"></span><h3 id="1-安装commitizen和cz-customizable"><a href="#1-安装commitizen和cz-customizable" class="headerlink" title="1.安装commitizen和cz-customizable"></a>1.安装commitizen和cz-customizable</h3><pre><code class="js">npm install -g commitizen@4.2.4npm i cz-customizable@6.3.0 --save-dev</code></pre><h3 id="2-在package-json中进行新增"><a href="#2-在package-json中进行新增" class="headerlink" title="2.在package.json中进行新增"></a>2.在package.json中进行新增</h3><pre><code class="js">&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;node_modules/cz-customizable&quot;  &#125;&#125;</code></pre><h3 id="3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit"><a href="#3-在根目录下新建-cz-config-js文件并写入配置-之后就可以用-git-cz-来代替-git-commit" class="headerlink" title="3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit"></a>3.在根目录下新建.cz-config.js文件并写入配置 之后就可以用 git cz 来代替 git commit</h3><h3 id="4-使用husky进行强制git代码提交规范"><a href="#4-使用husky进行强制git代码提交规范" class="headerlink" title="4.使用husky进行强制git代码提交规范"></a>4.使用husky进行强制git代码提交规范</h3><pre><code class="js">npm install --save-dev @commitlint/config-conventional@12.1.4 @commitlint/cli@12.1.4npm install husky@7.0.1 --save-devnpx husky install</code></pre><h3 id="5-在package-json中新增指令"><a href="#5-在package-json中新增指令" class="headerlink" title="5.在package.json中新增指令"></a>5.在package.json中新增指令</h3><pre><code class="js">&quot;prepare&quot;: &quot;husky install&quot;</code></pre><h3 id="6-并执行"><a href="#6-并执行" class="headerlink" title="6.并执行"></a>6.并执行</h3><pre><code class="js">npm run prepare</code></pre><h3 id="7-新增husky配置文件-并往里面写入"><a href="#7-新增husky配置文件-并往里面写入" class="headerlink" title="7.新增husky配置文件 并往里面写入"></a>7.新增husky配置文件 并往里面写入</h3><pre><code class="js">npx husky add .husky/commit-msgnpx --no-install commitlint --edit</code></pre><h3 id="8、husky规范"><a href="#8、husky规范" class="headerlink" title="8、husky规范"></a>8、husky规范</h3><pre><code class="js">// commitlint.config.jsmodule.exports = &#123;  // 继承的规则  extends: [&#39;@commitlint/config-conventional&#39;],  // 定义规则类型  rules: &#123;    // type 类型定义，表示 git 提交的 type 必须在以下类型范围内    &#39;type-enum&#39;: [      2,      &#39;always&#39;,      [        &#39;feat&#39;, // 新功能 feature        &#39;fix&#39;, // 修复 bug        &#39;docs&#39;, // 文档注释        &#39;style&#39;, // 代码格式(不影响代码运行的变动)        &#39;refactor&#39;, // 重构(既不增加新功能，也不是修复bug)        &#39;perf&#39;, // 性能优化        &#39;test&#39;, // 增加测试        &#39;chore&#39;, // 构建过程或辅助工具的变动        &#39;revert&#39;, // 回退        &#39;build&#39; // 打包      ]    ],    // subject 大小写不做校验    &#39;subject-case&#39;: [0]  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>46、解决GitHub Pages绑定阿里域名CNAME消失</title>
      <link href="/2021/10/28/url/"/>
      <url>/2021/10/28/url/</url>
      
        <content type="html"><![CDATA[<p>hexo主题使用的是Claudia,部署到GitHub Pages时，CNAME会消失。</p><span id="more"></span><p>解决方式：</p><pre><code>// 1 cd sourcetouch CNAME// 2 输入阿里域名issummer.cn// 3 部署hexo g &amp;&amp; hexo d</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45、自定义input唤起键盘</title>
      <link href="/2021/10/20/input/"/>
      <url>/2021/10/20/input/</url>
      
        <content type="html"><![CDATA[<p>自定义 input 唤起键盘。移动端页面自定义 input 唤起键盘 return，有时需要将换行键改为搜索，为了达到更好的用户体验。<br>在 html5 中，我们可以将 input 的 type 修改为 search，这样修改之后，我们的安卓手机会变成搜索或者搜索符号、IOS 则会变成换行。</p><span id="more"></span><p>1、安卓手机</p><pre><code class="html">&lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot; /&gt;</code></pre><p>2、苹果 IOS 手机</p><p>与安卓手机不同的是，我们需要在外层包裹一个 form</p><pre><code class="html">    &lt;from action=&quot;javascript:return true&quot;&gt;        &lt;input type=&quot;search&quot; placeholder=&quot;请输入你要搜索的内容&quot; v-model=&quot;value&quot;&gt;    &lt;/form&gt;</code></pre><p>3、修改 search 的默认样式</p><pre><code class="css">input[type=&quot;search&quot;] &#123;  -webkit-appearance: none;&#125;input::-webkit-search-cancel-button &#123;  display: none; // 关闭按钮&#125;</code></pre><p>4、禁止输入法弹出的方法</p><blockquote><p>readonly 属性的使用</p></blockquote><p>点击输入框触发 focus 事件弹出时间 picker，将选择的开始时间、结束时间都显示在输入框里，这里加入只读 readonly 属性可以避免输入法的弹出。</p><pre><code class="html">&lt;input v-model=&quot;startDate&quot; readonly @focus=&quot;openStartPicker&quot; /&gt;&lt;input v-model=&quot;endDate&quot; readonly @focus=&quot;openEndPicker&quot; /&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44、vue3-v-model</title>
      <link href="/2021/10/14/vue3-4-v-model/"/>
      <url>/2021/10/14/vue3-4-v-model/</url>
      
        <content type="html"><![CDATA[<p>v-model 在 Vue2 版本的本质上不过是语法糖，v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。<br>Vue3 版本的 v-model 做了修改。</p><span id="more"></span><h2 id="1、实现方法一"><a href="#1、实现方法一" class="headerlink" title="1、实现方法一"></a>1、实现方法一</h2><blockquote><p>1、将内部原生 <code>input</code> 元素的 <code>value</code> attribute（属性） 绑定到 <code>modelValue</code> prop</p><p>2、输入新的值时在 <code>input</code> 元素上触发 <code>update:modelValue</code> 事件</p></blockquote><pre><code class="js">&lt;script setup&gt;defineProps([&#39;modelValue&#39;])defineEmits([&#39;update:modelValue&#39;])&lt;/script&gt;&lt;template&gt;  &lt;input    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#39;update:modelValue&#39;, $event.target.value)&quot;  /&gt;&lt;/template&gt;</code></pre><h2 id="2、实现方法二："><a href="#2、实现方法二：" class="headerlink" title="2、实现方法二："></a>2、实现方法二：</h2><p>利用计算属性:watch 具有 get 和 set 方法，get 方法需要返回 modelValue prop ,而 set 方法触发相应的事件。</p><pre><code class="js">&lt;script setup&gt;import &#123; computed &#125; from &#39;vue&#39;const props = defineProps([&#39;modelValue&#39;])const emit = defineEmits([&#39;update:modelValue&#39;])const value = computed(&#123;  get() &#123;    return props.modelValue  &#125;,  set(value) &#123;    emit(&#39;update:modelValue&#39;, value)  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;value&quot; /&gt;&lt;/template&gt;</code></pre><h2 id="3、多个-v-model-绑定"><a href="#3、多个-v-model-绑定" class="headerlink" title="3、多个 v-model 绑定"></a>3、多个 v-model 绑定</h2><pre><code class="js">&lt;script setup&gt;defineProps(&#123;  firstName: String,  lastName: String&#125;)defineEmits([&#39;update:firstName&#39;, &#39;update:lastName&#39;])&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;firstName&quot;    @input=&quot;$emit(&#39;update:firstName&#39;, $event.target.value)&quot;  /&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;lastName&quot;    @input=&quot;$emit(&#39;update:lastName&#39;, $event.target.value)&quot;  /&gt;&lt;/template&gt;</code></pre><pre><code class="html">&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot; /&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43、vue3-emits</title>
      <link href="/2021/10/11/vue3-3-emits/"/>
      <url>/2021/10/11/vue3-3-emits/</url>
      
        <content type="html"><![CDATA[<p>自定义事件不使用 emit:[‘event name’],会出现连续执行 2 次的一个 bug。</p><span id="more"></span><h2 id="一、问题复现"><a href="#一、问题复现" class="headerlink" title="一、问题复现"></a>一、问题复现</h2><p>Emits.vue</p><pre><code class="html">&lt;template&gt;  &lt;div @click=&quot;$emit(&#39;click&#39;)&quot;&gt;    &lt;p&gt;自定义事件&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>使用 Emits.vue</p><pre><code class="html">&lt;Emits @click=&quot;handleClick&quot;&gt;&lt;/Emits&gt;</code></pre><pre><code class="js">import Emits from &quot;./Emits.vue&quot;;export default &#123;  components: &#123;    Emits,  &#125;,  methods: &#123;    handleClick()&#123;      console.log(&quot;click me&quot;);    &#125;  &#125;,&#125;;</code></pre><p>点击自定义事件，会打印2次click me</p><h2 id="二、解决方法："><a href="#二、解决方法：" class="headerlink" title="二、解决方法："></a>二、解决方法：</h2><h4 id="方法1、在Emits-vue中加入以下代码"><a href="#方法1、在Emits-vue中加入以下代码" class="headerlink" title="方法1、在Emits.vue中加入以下代码"></a>方法1、在Emits.vue中加入以下代码</h4><pre><code class="js">emits:[&#39;click&#39;]</code></pre><h4 id="方法2、不要使用原生事件名称"><a href="#方法2、不要使用原生事件名称" class="headerlink" title="方法2、不要使用原生事件名称"></a>方法2、不要使用原生事件名称</h4><p>Emits.vue</p><pre><code class="html">&lt;template&gt;  &lt;div @click=&quot;$emit(&#39;my-click&#39;)&quot;&gt;    &lt;p &gt;自定义事件&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">&lt;script&gt;  export default &#123;    emits:[&#39;my-click&#39;]  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>引用处：</p><pre><code class="html">  &lt;Emits @my-click=&quot;handleClick&quot;&gt;&lt;/Emits&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42、vue3-传送门：teleport</title>
      <link href="/2021/10/02/vue3-2-teleport/"/>
      <url>/2021/10/02/vue3-2-teleport/</url>
      
        <content type="html"><![CDATA[<p>teleport: 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p><span id="more"></span><h2 id="一、teleport应用场景"><a href="#一、teleport应用场景" class="headerlink" title="一、teleport应用场景"></a>一、teleport应用场景</h2><p>一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方，最常见的例子就是全屏的模态框。</p><h2 id="二、模态框弹窗组件"><a href="#二、模态框弹窗组件" class="headerlink" title="二、模态框弹窗组件"></a>二、模态框弹窗组件</h2><p>新建ModalButton.vue组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;modalOpen = true&quot;&gt;弹出窗口&lt;/button&gt;    &lt;teleport to=&#39;body&#39;&gt;      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;        &lt;div&gt;我是弹窗          父元素为body          &lt;button @click=&quot;modalOpen=false&quot;&gt;关闭窗口&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/teleport&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="js">export default &#123;  // vue3兼容data写法  data() &#123;    return &#123;      modalOpen:true    &#125;  &#125;,&#125;</code></pre><pre><code class="css">.modal&#123;  position: absolute;  top: 0;  left:0;  right:0;  bottom: 0;  background-color: rgba(0,0,0,0.5);  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;&#125;.modal div&#123;  display: flex;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #fff;  width: 300px;  height: 300px;  padding: 5px;&#125;</code></pre><h2 id="三、ModalButton组件的应用"><a href="#三、ModalButton组件的应用" class="headerlink" title="三、ModalButton组件的应用"></a>三、ModalButton组件的应用</h2><pre><code class="html">  &lt;ModalButton&gt;&lt;/ModalButton&gt;</code></pre><pre><code class="js">// 加上文件类型后缀，不然会出现404 NOT FOUNDimport ModalButton from &quot;./ModalButton.vue&quot;;components:&#123;    ModalButton&#125;,  </code></pre><p>当弹窗显示的时候，审查元素.modal与#app位于body下的同一层级</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41、vue3-起始和新特性</title>
      <link href="/2021/09/25/vue3-1-start/"/>
      <url>/2021/09/25/vue3-1-start/</url>
      
        <content type="html"><![CDATA[<p>使用 vite 创建项目，以及 vue3 的 composition API 的使用</p><span id="more"></span><h2 id="一、创建项目（vue-cli-vite）"><a href="#一、创建项目（vue-cli-vite）" class="headerlink" title="一、创建项目（vue-cli + vite）"></a>一、创建项目（vue-cli + vite）</h2><p>使用 vite 可以更加快速的启动项目</p><pre><code class="js">npm init vite-app &lt;project-name&gt;cd project-namenpm install &amp;&amp; npm run dev</code></pre><h2 id="二、main-js"><a href="#二、main-js" class="headerlink" title="二、main.js"></a>二、main.js</h2><pre><code class="js">import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;./index.css&quot;;createApp(App).mount(&quot;#app&quot;);</code></pre><h2 id="三、组合式-API：composition-API"><a href="#三、组合式-API：composition-API" class="headerlink" title="三、组合式 API：composition API"></a>三、组合式 API：composition API</h2><blockquote><p>composition api 为 Vue 应用提供更好的逻辑复用和代码组织。</p></blockquote><p>setup()钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：</p><p>1、需要在非单文件组件中使用组合式 API 时。</p><p>2、需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。</p><h4 id="（一）、基本使用"><a href="#（一）、基本使用" class="headerlink" title="（一）、基本使用"></a>（一）、基本使用</h4><pre><code class="js">&lt;script&gt;import &#123; ref &#125; from &#39;vue&#39;export default &#123;  setup() &#123;    const count = ref(0)    // 返回值会暴露给模板和其他的选项式 API 钩子    return &#123;      count    &#125;  &#125;,  mounted() &#123;    console.log(this.count) // 0  &#125;&#125;&lt;/script&gt;</code></pre><pre><code class="html">&lt;template&gt;  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;</code></pre><blockquote><blockquote><p>Tip： setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</p></blockquote></blockquote><h4 id="（二）、创建响应式对象"><a href="#（二）、创建响应式对象" class="headerlink" title="（二）、创建响应式对象"></a>（二）、创建响应式对象</h4><p>方法1、</p><pre><code class="html">&lt;p&gt;&#123;&#123; data.counter &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; data.doubleCounter &#125;&#125;&lt;/p&gt;</code></pre><pre><code class="js">import &#123; computed,reactive,onMounted,onUnmounted,ref,toRefs,watch&#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    const data = reactive(&#123;      counter: 1,      doubleCounter: computed(() =&gt; data.counter * 2),    &#125;);    const msg1 = ref(&quot;some message&quot;);    // setup 最早有onMounted 无created beforeCreate    &#125;,    let timer;    onMounted(() =&gt; &#123;      timer = setInterval(() =&gt; &#123;        data.counter++;      &#125;, 1000);    &#125;);    onUnmounted(() =&gt; &#123;      clearInterval(timer);    &#125;);    return &#123; data, msg1 &#125;;  &#125;,&#125;;</code></pre><p>方法 2：toRefs:解构/展开返回响应式对象</p><pre><code class="html">  &lt;p&gt;&#123;&#123; msg1 &#125;&#125;&lt;/p&gt;  &lt;p&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt;  &lt;p&gt;&#123;&#123; doubleCounter &#125;&#125;&lt;/p&gt;  &lt;p ref=&quot;desc&quot;&gt;&lt;/p&gt;</code></pre><pre><code class="js">import &#123; computed,reactive,onMounted,onUnmounted,ref,toRefs,watch&#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    // useCounter函数使用了toRefs  所以我们可以展开使用counter doubleCounter    const &#123; counter, doubleCounter &#125; = useCounter();    // 单值响应式    const msg1 = ref(&quot;some message&quot;);    // 使用元素    const desc = ref(null);    // watch 侦听器    watch(counter, (val, oldVal) =&gt; &#123;      // 这里需要加上desc.value      const p = desc.value;      p.textContent = `counter change from $&#123;oldVal&#125; to $&#123;val&#125;`;    &#125;);    return &#123; counter, doubleCounter, msg1, desc &#125;;  &#125;,&#125;;function useCounter() &#123;  const data = reactive(&#123;    counter: 1,    doubleCounter: computed(() =&gt; data.counter * 2),  &#125;);  // setup 最早有onMounted 无created  let timer;  onMounted(() =&gt; &#123;    timer = setInterval(() =&gt; &#123;      data.counter++;    &#125;, 1000);  &#125;);  onUnmounted(() =&gt; &#123;    clearInterval(timer);  &#125;);  return toRefs(data);&#125;</code></pre><h5 id="三-、单值响应式声明：ref"><a href="#三-、单值响应式声明：ref" class="headerlink" title="(三)、单值响应式声明：ref"></a>(三)、单值响应式声明：ref</h5><pre><code class="js">const msg1 = ref(&quot;some msg&quot;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40、初识egg.js</title>
      <link href="/2021/06/20/egg/"/>
      <url>/2021/06/20/egg/</url>
      
        <content type="html"><![CDATA[<p>egg.js的使用,包括项目的创建、内置ctx对象、路由、controller控制层、post请求。</p><span id="more"></span><h3 id="1、创建-启动项目"><a href="#1、创建-启动项目" class="headerlink" title="1、创建/启动项目"></a>1、创建/启动项目</h3><p>直接使用下面的方式，无法创建项目</p><pre><code class="js">// 无法创建项目npm init egg --type=simple// 需要在后面指定淘宝源npm init egg --type=simple -r=https://registry.npm.taobao.orgnpm run dev</code></pre><h3 id="2、内置的ctx对象"><a href="#2、内置的ctx对象" class="headerlink" title="2、内置的ctx对象"></a>2、内置的ctx对象</h3><blockquote><p>ctx这个对象非常重要，请求来的参数，返回去的消息都需要通过ctx这个对象获取或者设置</p></blockquote><blockquote><p>ctx是继承koa的context对象通过设置ctx.body， 可以改变返回信息</p></blockquote><pre><code class="js">ctx &#123; request:    &#123; method: &#39;GET&#39;,     url: &#39;/&#39;,     header:       &#123; host: &#39;127.0.0.1:7001&#39;,        connection: &#39;keep-alive&#39;,        pragma: &#39;no-cache&#39;,        &#39;cache-control&#39;: &#39;no-cache&#39;,        &#39;sec-ch-ua&#39;: &#39;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#39;,        &#39;sec-ch-ua-mobile&#39;: &#39;?0&#39;,        &#39;sec-ch-ua-platform&#39;: &#39;&quot;macOS&quot;&#39;,        &#39;upgrade-insecure-requests&#39;: &#39;1&#39;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&#39;,        accept: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,        &#39;sec-fetch-site&#39;: &#39;none&#39;,        &#39;sec-fetch-mode&#39;: &#39;navigate&#39;,        &#39;sec-fetch-user&#39;: &#39;?1&#39;,        &#39;sec-fetch-dest&#39;: &#39;document&#39;,        &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,        &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;,        cookie: &#39;csrfToken=DpyybUjAh9JRzrCgx3itQifi&#39; &#125; &#125;,  response: &#123; status: 404, message: &#39;Not Found&#39;, header: &#123;&#125; &#125;,  app:    &#123; env: &#39;local&#39;,     name: &#39;eggjs&#39;,     baseDir: &#39;/Users/yq/Desktop/express&#39;,     subdomainOffset: 2,     config: &#39;&lt;egg config&gt;&#39;,     controller: &#39;&lt;egg controller&gt;&#39;,     httpclient: &#39;&lt;egg httpclient&gt;&#39;,     loggers: &#39;&lt;egg loggers&gt;&#39;,     middlewares: &#39;&lt;egg middlewares&gt;&#39;,     router: &#39;&lt;egg router&gt;&#39;,     serviceClasses: &#39;&lt;egg serviceClasses&gt;&#39; &#125;,  originalUrl: &#39;/&#39;,  req: &#39;&lt;original node req&gt;&#39;,  res: &#39;&lt;original node res&gt;&#39;,  socket: &#39;&lt;original node socket&gt;&#39; &#125;</code></pre><h3 id="3、路由"><a href="#3、路由" class="headerlink" title="3、路由"></a>3、路由</h3><p>在controller的home.js中写一个新的路由,</p><pre><code class="js">    async list()&#123;        const &#123; ctx &#125; = this        ctx.body = &#123;            code:200,            data:[                &#123;                    id:&#39;1&#39;,                    name:&#39;jude&#39;                &#125;,                &#123;                    id:&#39;2&#39;,                    name:&#39;summer&#39;                &#125;            ],            msg:&#39;success&#39;        &#125;    &#125;</code></pre><p>在router.js中匹配新写的路由</p><pre><code class="js">    router.get(&#39;/list&#39;,controller.home.list)</code></pre><p>打开127.0.0.1:7001/list即可看到效果</p><h3 id="4、Controller控制层"><a href="#4、Controller控制层" class="headerlink" title="4、Controller控制层"></a>4、Controller控制层</h3><p>在controller新建一个user.js</p><pre><code class="js">&#39;use strict&#39;const Controller = require(&#39;egg&#39;).Controllerclass UserController extends Controller &#123;    async info()&#123;        const &#123;ctx&#125; = this        ctx.body = &#123;            code:200,            data:&#123;                id:&#39;1&#39;,                name:&quot;jude&quot;                age:29,                gender:&quot;man&quot;            &#125;            msg::&quot;success&quot;        &#125;    &#125;&#125;module.exports = UserController</code></pre><p>配置新的路由</p><pre><code class="js">router.get(&#39;/user/info&#39;,controller.user.info)</code></pre><p>打开127.0.0.1:7001/user/info 即可看到效果</p><h3 id="5、post请求及配置CSRF跨域"><a href="#5、post请求及配置CSRF跨域" class="headerlink" title="5、post请求及配置CSRF跨域"></a>5、post请求及配置CSRF跨域</h3><p>安装跨域插件</p><pre><code class="js">npm install egg-cors --save</code></pre><p>配置config下的plugin.js和config.default.js</p><pre><code>// plugin.jsmoduel.exports = &#123;    cors:&#123;        enable:true,        package:&#39;egg-cors&#39;    &#125;&#125;// config.default.jsconfig.security = &#123;    csrf:&#123;        enable:true    &#125;,    domainWhiteList:[]&#125;config.cors = &#123;    origin:&quot;*&quot;,    allowMethods:&#39;GET,PUT,POST,DELETE.PATCH&#39;&#125;</code></pre><h3 id="6、创建post请求"><a href="#6、创建post请求" class="headerlink" title="6、创建post请求"></a>6、创建post请求</h3><pre><code class="js">// user.jsasync createUser()&#123;    const &#123;ctx &#125; = this    const result = &#123;        username:ctx.request.body.username,        age:ctx.request.body.age    &#125;    ctx.body = &#123;        code:200,        data:result,        msg:&#39;success&#39;    &#125;&#125;</code></pre><p>此时，打开ApiPost工具，选择post请求，输入请求地址+参数信息，即可看到响应信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39、堆和栈、变量复制、深拷贝与浅拷贝</title>
      <link href="/2021/05/25/stack-heap/"/>
      <url>/2021/05/25/stack-heap/</url>
      
        <content type="html"><![CDATA[<p>栈（stack）：主要存放的是基本类型的变量和对象的应用，其优势是存储速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。   </p><p>堆（heap）：用于引用类型（复杂数据类型：如数组对象、object对象）分配空间，运行时动态分配内存，存储速度较慢。</p><span id="more"></span><p>JavaScript中，内存分为三种类型：代码空间、栈空间、堆空间，其中代码空间用于存放可执行代码。</p><h2 id="一、堆栈内存空间"><a href="#一、堆栈内存空间" class="headerlink" title="一、堆栈内存空间"></a>一、堆栈内存空间</h2><h3 id="1、栈内存空间"><a href="#1、栈内存空间" class="headerlink" title="1、栈内存空间"></a>1、栈内存空间</h3><blockquote><p>用栈作为数据结构在内存中所申请的空间。</p></blockquote><h3 id="2、栈的特点："><a href="#2、栈的特点：" class="headerlink" title="2、栈的特点："></a>2、栈的特点：</h3><p>1、后进先出，最后添加进栈的元素最先出</p><p>2、访问栈底元素，必须拿掉它上面的元素</p><p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5631876df7b34b1cbe19f10ff5fe7b1a~tplv-k3u1fbpfcp-watermark.awebp"></image></p><p>js7种基本数据类型变量保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。</p><h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><blockquote><p>闭包中的基本数据类型变量是保存在堆内存里的，当函数执行完弹出调用栈后，返回内部函数的一个应用，这时候函数的变量就会转移到堆上，因此内部函数依然能访问到上一层函数的变量。</p></blockquote><h2 id="二、堆内存空间"><a href="#二、堆内存空间" class="headerlink" title="二、堆内存空间"></a>二、堆内存空间</h2><blockquote><p>用堆作为数据结构在内存中所申请的空间。<br>通常情况下，我们所说的堆数据结构指的就是二叉堆。</p></blockquote><h3 id="1、二叉堆的特点："><a href="#1、二叉堆的特点：" class="headerlink" title="1、二叉堆的特点："></a>1、二叉堆的特点：</h3><p>1、它是一颗完全二叉树</p><p>2、二叉堆不是最小堆就是最大堆</p><h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><blockquote><p>引用数据类型存储在堆内存中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。<br>引用数据类型会在栈中存储一个指针，这个指针指向堆内存空间中该实体的起始地址。<br>当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后，从堆中获得实体。</p></blockquote><pre><code class="js">// 基本数据类型-栈内存let name = &quot;大白&quot;;// 基本数据类型-栈内存let age = 20;// 基本数据类型-栈内存let info = null;// 对象指针存放在栈内存中，指针指向的对象放在堆内存中let msgObj = &#123;msg: &quot;测试&quot;, id: 5&#125;;// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中let ages = [19, 22, 57]</code></pre><p>上面代码中：</p><pre><code>1、创建了两个变量msgObj、ages，它们的值都是引用类型(object、array)2、堆内存空间采用二叉堆作为数据结构，msgObj与ages的具体值会存在堆内存空间中3、存储完成后，堆内存空间会返回这两个值的引用地址(指针)4、拿到引用地址后，这个引用地址会和它的变量名对应起来，存放在栈内存空间中5、在查找变量msgObj与ages的具体值时，会先从栈内存空间中获取它的引用地址6、获取到引用地址后，通过引用地址在堆内存空间的二叉堆中查找到对应的值。</code></pre><p>堆内存空间中的object，表示的是存储在空间中的其他对象的引用值</p><p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18fbd5bf395a42e5b6757c84a4768be7~tplv-k3u1fbpfcp-watermark.awebp"></image></p><h3 id="3、栈内存空间与堆内存的区别"><a href="#3、栈内存空间与堆内存的区别" class="headerlink" title="3、栈内存空间与堆内存的区别"></a>3、栈内存空间与堆内存的区别</h3><blockquote><p>堆内存空间：相当于一个采用二叉堆作为数据结构的容器。<br>堆内存：指的是一个引用类型的具体值<br>堆内存存在于堆内存空间中</p></blockquote><h2 id="三、变量复制"><a href="#三、变量复制" class="headerlink" title="三、变量复制"></a>三、变量复制</h2><h3 id="1、基本数据类型的复制"><a href="#1、基本数据类型的复制" class="headerlink" title="1、基本数据类型的复制"></a>1、基本数据类型的复制</h3><p>下面代码中，name、alias都是基本类型，值存储在栈内存，分别有各自独立的栈空间，因此修改了alias的值，name是不受影响的。</p><pre><code class="js">let name =&#39;jude&#39;let alias = namealias = &#39;summer&#39;console.log(name) // judeconsole.log(alias) // summer</code></pre><p>相当于复制前是这样的：</p><blockquote><p>name | jude</p></blockquote><p>复制后：</p><blockquote><p>alias | jude<br>name  | jude</p></blockquote><p>修改后:</p><blockquote><p>alias | summer<br>name  | jude</p></blockquote><h3 id="2、引用类型的复制"><a href="#2、引用类型的复制" class="headerlink" title="2、引用类型的复制"></a>2、引用类型的复制</h3><p>下面代码中，info、book都是引用类型，它们引用存在栈内存，值存在堆内存，它们的值指向同一块堆内存，栈内存中会复制一份相同的引用。</p><pre><code class="js">let book = &#123;title:&#39;book&#39;,id:1&#125;let info = bookinfo.title = &#39;javascript&#39;console.log(book.title) // javascript</code></pre><h2 id="四、深拷贝与浅拷贝"><a href="#四、深拷贝与浅拷贝" class="headerlink" title="四、深拷贝与浅拷贝"></a>四、深拷贝与浅拷贝</h2><h3 id="1、浅拷贝："><a href="#1、浅拷贝：" class="headerlink" title="1、浅拷贝："></a>1、浅拷贝：</h3><blockquote><p>引用数据类型在复制时，改了其中一个数据的值，另一个数据的值也会跟着改变，这种拷贝方式我们称为浅拷贝。</p></blockquote><h4 id="1-1-Object-asign"><a href="#1-1-Object-asign" class="headerlink" title="1.1 Object.asign()"></a>1.1 Object.asign()</h4><blockquote><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p></blockquote><pre><code class="js">let obj1 = &#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;,sports:&#39;basketball&#39; &#125;;let obj2 = Object.assign(&#123;&#125;, obj1);obj2.person.name = &quot;wade&quot;;obj2.sports = &#39;football&#39;console.log(obj1); // &#123; person: &#123; name: &#39;wade&#39;, age: 41 &#125;, sports: &#39;basketball&#39; &#125;</code></pre><h4 id="1-2-扩展运算符"><a href="#1-2-扩展运算符" class="headerlink" title="1.2 扩展运算符"></a>1.2 扩展运算符</h4><pre><code class="js">let obj1 = &#123; name: &#39;Kobe&#39;, address:&#123;x:100,y:100&#125;&#125;let obj2= &#123;... obj1&#125;obj1.address.x = 200;obj1.name = &#39;wade&#39;console.log(&#39;obj2&#39;,obj2) // obj2 &#123; name: &#39;Kobe&#39;, address: &#123; x: 200, y: 100 &#125; &#125;</code></pre><h4 id="1-3-Array-prototype-concat-Array-ptototype-slice"><a href="#1-3-Array-prototype-concat-Array-ptototype-slice" class="headerlink" title="1.3 Array.prototype.concat()/Array.ptototype.slice()"></a>1.3 Array.prototype.concat()/Array.ptototype.slice()</h4><pre><code class="js">let arr = [1, 3, &#123;    username: &#39;kobe&#39;&#125;];let arr2 = arr.concat();    arr2[2].username = &#39;wade&#39;;console.log(arr); //[ 1, 3, &#123; username: &#39;wade&#39; &#125; ]let arr = [1, 3, &#123;    username: &#39; kobe&#39;&#125;];let arr3 = arr.slice();arr3[2].username = &#39;wade&#39;console.log(arr); // [ 1, 3, &#123; username: &#39;wade&#39; &#125; ]</code></pre><h3 id="2、深拷贝："><a href="#2、深拷贝：" class="headerlink" title="2、深拷贝："></a>2、深拷贝：</h3><blockquote><p>引用类型复制到新的变量后，二者是独立的，不会因为一个的改变而影响到另一个<br>实际上就是重新在堆内存中开辟一块新的空间，把原对象的数据拷贝到这个新地址空间里来</p></blockquote><h4 id="2-1-深拷贝方法1："><a href="#2-1-深拷贝方法1：" class="headerlink" title="2.1 深拷贝方法1："></a>2.1 深拷贝方法1：</h4><blockquote><p>将对象转一遍JSON，缺点是只能转化一般常见的数据，function、undefined、正则等类型无法通过这种方法变回来。</p></blockquote><pre><code class="js">const data = &#123; name: &quot;jude&quot; &#125;;const obj = JSON.parse(JSON.stringify(data));obj.age = 20;console.log(&quot;data = &quot;, data);// data = &#123; name:&quot;jude&quot;&#125;console.log(&quot;obj = &quot;, obj);// obj = &#123;name:&#39;jude&#39;,age:20&#125;</code></pre><h4 id="2-2-深拷贝方法2："><a href="#2-2-深拷贝方法2：" class="headerlink" title="2.2 深拷贝方法2："></a>2.2 深拷贝方法2：</h4><blockquote><p>手动去写循环遍历</p></blockquote><pre><code class="js">const data = [&#123; name: &quot;jude&quot; &#125;];let obj = data.map(item =&gt; item);obj.push(&#123; name: &quot;summer&quot; &#125;);console.log(&quot;data = &quot;, data);// data = [&#123;name:&#39;jude&#39;&#125;]console.log(&quot;obj = &quot;, obj);// obj = [&#123;name:&#39;jude&#39;,name:&#39;summer&#39;&#125;]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38、Vue项目中的window.resize</title>
      <link href="/2021/05/19/resize/"/>
      <url>/2021/05/19/resize/</url>
      
        <content type="html"><![CDATA[<p>Vue项目中使用ECharts可视化图表时，图表自适应大小。根据窗口大小自动改变ECharts图表的宽度。</p><span id="more"></span><h3 id="一、防抖函数"><a href="#一、防抖函数" class="headerlink" title="一、防抖函数"></a>一、防抖函数</h3><p>页面频繁使用window.resize函数会使得页面非常卡顿，需要使用debounce防抖函数（无论触发了多少次回调，都只执行最后一次）。</p><pre><code class="js">/** * 函数防抖 * @param &#123;Function&#125; func * @param &#123;number&#125; delay * @param &#123;boolean&#125; immediate * @return &#123;*&#125; */export function debounce(func, delay, immediate = false) &#123;  let timer,context = this;  return (...args) =&gt; &#123;    if (immediate) &#123;      func.apply(context, args);      immediate = false;      return;    &#125;    clearTimeout(timer);    timer = setTimeout(() =&gt; &#123;      func.apply(context, args);    &#125;, delay);  &#125;;&#125;</code></pre><h3 id="二、resize函数"><a href="#二、resize函数" class="headerlink" title="二、resize函数"></a>二、resize函数</h3><pre><code class="js">// 工具函数的引入import &#123; debounce &#125; from &#39;@/utils/index.js&#39;;export default &#123;  data() &#123;    return &#123;      myChart: null,      resizeHandler: null    &#125;;  &#125;,  computed: &#123;    // 侧边栏的收缩    open() &#123;      return this.$store.state.setting.open;    &#125;  &#125;,  mounted() &#123;    this.resizeHandler = debounce(() =&gt; &#123;      if (this.myChart) &#123;        this.myChart.resize();      &#125;    &#125;, 100);    this.initResizeEvent();  &#125;,  methods: &#123;    //监听resize    initResizeEvent() &#123;      window.addEventListener(&#39;resize&#39;, this.resizeHandler);    &#125;,    //移除resize    destroyResizeEvent() &#123;      window.removeEventListener(&#39;resize&#39;, this.resizeHandler);    &#125;  &#125;,  beforeDestroy() &#123;    this.destroyResizeEvent();    if (!this.myChart) &#123;      return;    &#125;    this.myChart.dispose();    this.myChart.off(&#39;click&#39;);    this.myChart = null;  &#125;,  activated() &#123;    this.initResizeEvent();    if (this.myChart) &#123;      this.myChart.resize();    &#125;  &#125;,  deactivated() &#123;    this.destroyResizeEvent();  &#125;,  watch: &#123;    open() &#123;      if (this.myChart) &#123;        this.myChart.resize();      &#125;    &#125;  &#125;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37、typescript基础</title>
      <link href="/2021/05/15/typescript/"/>
      <url>/2021/05/15/typescript/</url>
      
        <content type="html"><![CDATA[<p>typescript基础知识,包括typescript的安装、函数、数组、字符串等。</p><span id="more"></span><h3 id="1、typescript的安装"><a href="#1、typescript的安装" class="headerlink" title="1、typescript的安装"></a>1、typescript的安装</h3><blockquote><p>1、安装node</p></blockquote><blockquote><p>2、安装typescript</p></blockquote><pre><code class="shell">sudo npm install typescript -g  //(mac 则需要添加sudo window则不需要)tsc -v // 查看版本号</code></pre><blockquote><p>3、hello world</p></blockquote><pre><code class="shell"># 初始化项目npm init -y# typescript配置文件tsc --init# 安装@type/node(解决模块声明问题)npm install @types/node --save-dev# 创建helloworld.ts文件touch helloworld.ts</code></pre><pre><code class="js">var a:String = &#39;hello world&#39;console.log(a)</code></pre><blockquote><p>4、将helloworld.ts转换成helloworld.js</p></blockquote><pre><code class="shell">tsc helloworld.ts  //将ts文件转换成js文件# 运行helloworld.jsnode helloworld.js  // 打印结果hello world</code></pre><h3 id="2、typescript函数的定义方式"><a href="#2、typescript函数的定义方式" class="headerlink" title="2、typescript函数的定义方式"></a>2、typescript函数的定义方式</h3><p>1、函数声明<br>    使用function和函数名来定义一个函数</p><pre><code class="ts">    function search(time:number) : string &#123;        return &#39;终于找到了丢失&#39; + time + &#39;天的dog--小七&#39;    &#125;    var time = 1    var result : string = search(time)    console.log(result)  // 终于找到了丢失一天的dog--小七</code></pre><p>2、函数表达式<br>    将函数赋值给一个变量，变量名就是函数名。通过变量名来调用函数</p><pre><code class="ts">    var Adc = function(n1:number,n2:number) : number &#123;        return n1++ + ++n2    &#125;    console.log(Adc(2,3))  // 6</code></pre><p>3、箭头函数<br>    typescript是支持ES6的。</p><pre><code class="ts">    var Jungle = (n1:number,n2:number) : number =&gt; &#123;        return n1 * n2    &#125;    console.log(Jungle(12,2) // 24</code></pre><pre><code>将ts文件转换为js文件：tsc function.ts  =&gt;  生成function.js  =&gt; 运行function.js,node function.js</code></pre><h3 id="3、typescript函数作用域"><a href="#3、typescript函数作用域" class="headerlink" title="3、typescript函数作用域"></a>3、typescript函数作用域</h3><blockquote><p>typescript也是有全局变量和局部变量的</p></blockquote><pre><code class="ts">    function star():void&#123;    var Jay = &#39;周杰伦&#39;        console.log(Jay)  // 周杰伦    &#125;    star()    console.log(star) // [Function:star]    var JayChou = &#39;周杰伦&#39;  // 此时JayChou是全局变量    function superstar():void&#123;    console.log(&#39;青花瓷是&#39; + JayChou + &#39;演唱的！&#39;) // 青花瓷是周杰伦演唱的！    &#125;    superstar()    console.log(JayChou) // 周杰伦</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119154050226-530021968.png"></p><h3 id="4、typescript数组"><a href="#4、typescript数组" class="headerlink" title="4、typescript数组"></a>4、typescript数组</h3><blockquote><p>ts中数据分为值类型和引用类型。</p></blockquote><p>1、什么是引用类型？</p><blockquote><p>引用类型是一种复合类型，引用类型中封装了很多属性，可以通过变量名和属性名来获取属性值或者调用属性的方法。</p></blockquote><pre><code class="ts">    let Jude = &#123;        name: &#39;Jude&#39;,        age: 28,        saySomething: function () &#123;            console.log(&#39;行到水穷处，坐看云起时！&#39;);        &#125;    &#125;    console.log(Jude.name) // Jude</code></pre><p>2、元祖– 一种特殊的数组</p><p>数组中允许含有多种类型的元素</p><pre><code class="ts">    let arr : [number,string]    arr = [123,&#39;123&#39;]    // console.log(arr) // [123,&#39;123]</code></pre><p>当我们写成这个样子，是会报错的</p><pre><code class="ts">    let arr : [number,sting]    arr = [&#39;123&#39;,123]</code></pre><pre><code>error1: Type &#39;string&#39; is not assignable to type &#39;number&#39;. error2: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><p><img src="https://img2018.cnblogs.com/blog/1912711/202001/1912711-20200119172755771-1404695424.png"></p><h3 id="5、typescript字符串"><a href="#5、typescript字符串" class="headerlink" title="5、typescript字符串"></a>5、typescript字符串</h3><p>1、Typescript中字符串的两种类型：</p><blockquote><p>基本类型字符串：由单引号或者双引号’包裹的’一串字符;</p></blockquote><blockquote><p>引用类型字符串：由new实例化的String类型。</p></blockquote><p>2、基本类型的字符串可以直接使用引用类型的属性和方法</p><pre><code class="ts">    let Jude: string = &#39;YQ&#39;    let JudeYQ: String = new String(&#39;JudeYQ&#39;)    console.log(Jude) // YQ    console.log(JudeYQ) // [String:&#39;JudeYQ&#39;]    // 基本类型的字符串可以直接使用引用类型的属性和方法    console.log(Jude.length) // 2    console.log(JudeYQ.length)  // 6</code></pre><p>3、字符串常用的方法</p><blockquote><p>字符串查找 indexOf()和lastIndexOf()，二者返回的都是字符串的下标。</p></blockquote><pre><code class="ts">    let word:string = &#39;西虹人瘦，燃烧我的卡路里&#39;    let Calorie: string = &#39;卡路里&#39;    console.log(word.indexOf(Calorie)) // 9    let ST:string = &#39;沈腾&#39;    console.log(word.indexOf(ST)) // -1 没有查找到返回-1    console.log(word.lastIndexOf(Calorie)) // 9 从字符串尾部开始查找字符串的位置 和indexOf（）返回的都是字符串下标</code></pre><blockquote><p>字符串的截取， substring()</p></blockquote><pre><code class="ts">    // 字符串的截取    console.log(word.substring(9)) // 卡路里    console.log(word.substring(9,12)) // 卡路里</code></pre><p>3、字符串的替换,replace()</p><pre><code class="ts">    console.log(word.replace(Calorie,&#39;腹肌&#39;))  // 西虹人瘦，燃烧我的腹肌</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36、父子组件的创建和挂载顺序</title>
      <link href="/2021/05/09/component-mounted/"/>
      <url>/2021/05/09/component-mounted/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>1、创建过程自上而下，挂载过程自下而上</p><p>父组件 created<br>子组件created<br>子组件mounted<br>父组件mounted</p><p>2、原因：</p><p>Vue创建过程是一个递归过程，先创建父组件，有子组件就会创建子组件，因此创建时先有父组件再有子组件；子组件首次创建会添加mounted钩子到队列，等到patch结束再执行他们，可见子组件的mounted钩子是先进入到队列中的，因此等到patch结束执行这些钩子时也先执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35、数组方法</title>
      <link href="/2021/05/02/array/"/>
      <url>/2021/05/02/array/</url>
      
        <content type="html"><![CDATA[<p>js 常用数组方法整理,包括常用的数组常用方法、高阶函数 forEach、filter、map。</p><span id="more"></span><h3 id="1、常用数组方法"><a href="#1、常用数组方法" class="headerlink" title="1、常用数组方法"></a>1、常用数组方法</h3><details><summary>点击展示代码</summary><pre><code class="js">// 1、删除数组的最后一项  pop()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop();console.log(fruits); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;var x = fruits.pop(); // Mango// 2、数组结尾添加一个新元素  push()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;); //&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;,&quot;Kiwi&quot;var x = fruits.push(&quot;Kiwi&quot;); // 5// 3、删除数组第一个元素    shift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 4、数组开头返回一个新元素   返回新数组长度   unshift()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); //&quot;Lemon&quot; &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 5、删除元素 delete  会留下数组未定义的空洞  可以使用pop shift替代var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // empty,&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 6、拼接数组  splice()  第一个参数 2 定义了应添加新元素的位置   第二个参数 定义应删除多少元素  其余参数  定义要添加的新元素  返回一个包含已删除项的数组var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;, &quot;Apple&quot;, &quot;Mango&quot;fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;); // &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;,// 7、删除元素 splice()  在数组中不留“空洞”的情况下移除元素var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); //&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;// 8、合并数组 concat()var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var myChildren = myGirls.concat(myBoys);// 9、裁剪数组 slice()   源数组不会删除任何元素   第一个参数  开始选取的元素  第二个参数  结束参数为止（不包含）var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1); // &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // &quot;Orange&quot;, &quot;Lemon&quot;   第2个元素 到 第4个元素  截取结果为第2个和第3个元素// 10、数组元素结合成字符串 join() 和 toString()var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.join(&quot;,&quot;); // Banana,Orange,Apple,Mangofruits.toString(); // Banana,Orange,Apple,Mango</code></pre></details><h3 id="2、高阶函数"><a href="#2、高阶函数" class="headerlink" title="2、高阶函数"></a>2、高阶函数</h3><h4 id="1、forEach"><a href="#1、forEach" class="headerlink" title="1、forEach"></a>1、forEach</h4><blockquote><p>forEach()方法对数组的每个元素执行一次给定的函数。</p></blockquote><p>for example：</p><pre><code class="js">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];array.forEach((e) =&gt; &#123;  console.log(e); // &#39;a&#39; &#39;b&#39; &#39;c&#39;&#125;);</code></pre><p>语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</p><p>参数介绍：</p><pre><code>callback：为数组中的每个元素执行的函数，该函数接收1~3个参数currentValue：数组中正在处理的当前元素index: 数组中正在处理的当前元素的索引array: forEach()正在操作的数组   数组对象本身thisArg：可选参数。当执行回调函数callback时，用作this的值。</code></pre><p>常见用法：</p><h5 id="（1）稀疏数组"><a href="#（1）稀疏数组" class="headerlink" title="（1）稀疏数组"></a>（1）稀疏数组</h5><blockquote><p>不对未初始化的值进行任何操作</p></blockquote><pre><code class="js">const arratSpace = [1, 3, , 7];let numCallbackRuns = 0;arratSpace.forEach(function (e) &#123;  console.log(e);  numCallbackRuns++;&#125;);console.log(&quot;numCallbackRuns:&quot;, numCallbackRuns);</code></pre><h5 id="2-for-循环转换成-forEach"><a href="#2-for-循环转换成-forEach" class="headerlink" title="(2)for 循环转换成 forEach"></a>(2)for 循环转换成 forEach</h5><pre><code class="js">const items = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];const copy = [];//for循环for (let i = 0; i &lt; items.length; i++) &#123;  copey.push(items[i]);&#125;// forEachitems.forEach(function (itme) &#123;  copy.push(item);&#125;);</code></pre><h5 id="3-thisArg-使用箭头函数-thisArg-参数会被忽略，因为箭头函数绑定了-this-值"><a href="#3-thisArg-使用箭头函数-thisArg-参数会被忽略，因为箭头函数绑定了-this-值" class="headerlink" title="(3)thisArg 使用箭头函数 thisArg 参数会被忽略，因为箭头函数绑定了 this 值"></a>(3)thisArg 使用箭头函数 thisArg 参数会被忽略，因为箭头函数绑定了 this 值</h5><h5 id="4-对象复制器函数"><a href="#4-对象复制器函数" class="headerlink" title="(4)对象复制器函数"></a>(4)对象复制器函数</h5><pre><code class="js">function copy(obj) &#123;  const copy = Object.create(Object.getPrototypeOf(obj));  const propNames = Object.getOwnPropertyNames(obj);  propNames.forEach(function (name) &#123;    const desc = Object.getOwnPropertyDescriptor(obj, name);    Object.defineProperty(copy, name, desc);  &#125;);  return copy;&#125;const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = copy(obj1); // obj2看起来和obj1一模一样</code></pre><h5 id="5-数组在迭代时被修改了，则其他元素会被跳过"><a href="#5-数组在迭代时被修改了，则其他元素会被跳过" class="headerlink" title="(5)数组在迭代时被修改了，则其他元素会被跳过"></a>(5)数组在迭代时被修改了，则其他元素会被跳过</h5><pre><code class="js">var words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];words.forEach(function (word) &#123;  console.log(word);  if (word === &quot;two&quot;) &#123;    words.shift();  &#125;&#125;);</code></pre><h5 id="6-promise-或-async-函数的使用"><a href="#6-promise-或-async-函数的使用" class="headerlink" title="(6)promise 或 async 函数的使用"></a>(6)promise 或 async 函数的使用</h5><pre><code class="js">let ratings = [5, 4, 5];let sum = 0;let sumFunction = async function (a, b) &#123;  return a + b;&#125;;ratings.forEach(async function (rating) &#123;  sum = await sumFunction(sum, rating);&#125;);console.log(sum); // 0</code></pre><h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><blockquote><p>filter()创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回满足条件的新数组，不满足则返回空数组。</p></blockquote><p>for example</p><pre><code class="js">const words = [&quot;111&quot;, &quot;222&quot;, &quot;333333&quot;, &quot;4444444&quot;, &quot;55555555&quot;];const result = words.filter((word) =&gt; &#123;  word.length &gt; 5;&#125;);console.log(result); // 333333  4444444    55555555</code></pre><p>语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p><p>参数：<br>callback:用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。</p><pre><code>element:数组中当前正在处理的元素index:正在处理的元素在数组中的索引array:调用filter的数组本身thisArg:执行callback时，用于this的值</code></pre><p>返回值：</p><pre><code>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</code></pre><p>用法：</p><h4 id="（1-筛选排除所有较小的值"><a href="#（1-筛选排除所有较小的值" class="headerlink" title="（1)筛选排除所有较小的值"></a>（1)筛选排除所有较小的值</h4><pre><code class="js">function isBig(e) &#123;  return e &gt;= 10;&#125;var filterd = [3, 6, 9, 14, 32].filter(isBig);// [14,32]</code></pre><h4 id="2-过滤-JSON-中的无效条目"><a href="#2-过滤-JSON-中的无效条目" class="headerlink" title="(2)过滤 JSON 中的无效条目"></a>(2)过滤 JSON 中的无效条目</h4><pre><code class="js">var arr = [  &#123; id: 12 &#125;,  &#123; id: -1 &#125;,  &#123; id: 0 &#125;,  &#123; id: 3 &#125;,  &#123; id: 14.4 &#125;,  &#123;&#125;,  &#123; id: null &#125;,  &#123; id: NaN &#125;,  &#123; id: &quot;undefined&quot; &#125;,];var entries = 0;function isNumber(obj) &#123;  return obj !== undefined &amp;&amp; typeof obj === &quot;number&quot; &amp;&amp; !isNaN(obj);&#125;function filterID(item) &#123;  if (isNumber(item.id) &amp;&amp; item.id !== 0) &#123;    return true;  &#125;  entries++;  return false;&#125;var arrId = arr.filter(filterID);console.log(arrId); // [&#123;id:12&#125;,&#123;id:-1&#125;,&#123;id:3&#125;,&#123;id:14.4&#125;]console.log(entries); // 5</code></pre><h4 id="3-在数组中搜索：根据搜索条件来过滤数组内容"><a href="#3-在数组中搜索：根据搜索条件来过滤数组内容" class="headerlink" title="(3)在数组中搜索：根据搜索条件来过滤数组内容"></a>(3)在数组中搜索：根据搜索条件来过滤数组内容</h4><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]function filterItems(query)&#123;    return fruits.filter(function(e)&#123;        return e.toLowerCase().indexOf(query.toLowerCase()) &gt; -1    &#125;)&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><p>上面是 es5 的写法，下面是 es6 的写法</p><pre><code class="js">var fruits [&#39;apple&#39;,&#39;banana&#39;,&#39;grapes&#39;,&#39;mango&#39;,&#39;orange&#39;]const filterItems = (query) =&gt;&#123;    return fruits.filter((e) =&gt;        e.toLowerCase().indexOf(query,toLowerCase()) &gt; -1    )&#125;console.log(filterItem(&#39;ap&#39;))   // [&#39;apple&#39;,&#39;grapes&#39;]console.log(filterItem(&#39;an&#39;))   // [&#39;banana&#39;,&#39;mango&#39;,&#39;orange&#39;]</code></pre><h3 id="3、map"><a href="#3、map" class="headerlink" title="3、map"></a>3、map</h3><blockquote><p>map()方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。 原数组不会改变</p></blockquote><pre><code class="js">const array = [1, 2, 3, 4];const maps = array.map((x) =&gt; x * 2);console.log(maps); // 2 4 6 8</code></pre><p>用法：</p><h4 id="1-格式化数组中的对象"><a href="#1-格式化数组中的对象" class="headerlink" title="(1)格式化数组中的对象"></a>(1)格式化数组中的对象</h4><pre><code class="js">var array = [  &#123; key: 1, value: 10 &#125;,  &#123; key: 2, value: 20 &#125;,  &#123; key: 3, value: 30 &#125;,];var formatterArray = array.map(function (obj) &#123;  var o = &#123;&#125;;  o[obj.key] = obj.value;  return o;&#125;);console.log(formatterArray); // [&#123;1:10&#125;,&#123;2:20&#125;,&#123;3:30&#125;]</code></pre><h4 id="2-使用包含一个参数的函数来构建一个数字数组"><a href="#2-使用包含一个参数的函数来构建一个数字数组" class="headerlink" title="(2)使用包含一个参数的函数来构建一个数字数组"></a>(2)使用包含一个参数的函数来构建一个数字数组</h4><pre><code class="js">var numbers = [1, 4, 9];var double = numbers.map(function (item) &#123;  return item * 2;&#125;);console.log(double); // [2,8,18]</code></pre><h2 id="includes比indexOf好在哪里？"><a href="#includes比indexOf好在哪里？" class="headerlink" title="includes比indexOf好在哪里？"></a>includes比indexOf好在哪里？</h2><blockquote><p>includes可以检测NaN，indexOf不能，includes内部使用了Number.isNaN对NaN进行了匹配</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34、iTerms、Node版本管理工具、nrm等的使用方法</title>
      <link href="/2021/05/02/tool/"/>
      <url>/2021/05/02/tool/</url>
      
        <content type="html"><![CDATA[<p>一些开发过程中需要使用的工具整理</p><span id="more"></span><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>快捷键</p><pre><code>    commond + t              // 新建标签页    commond + w              // 关闭标签    commond + enter          // 切换全屏(第一次切换至全屏，再commond + enter恢复到之前窗口)     commond + 左右方向键       // 切换标签    commond + +              // 窗口和字体变大    commond + -              // 窗口和字体变小</code></pre><h2 id="Node版本管理工具"><a href="#Node版本管理工具" class="headerlink" title="Node版本管理工具"></a>Node版本管理工具</h2><p>在开发的工程中，我们可能需要经常切换node版本来应对不同的开发环境，所以需要经常使用不同版本的node。</p><p>一、安装npm插件n ,通过n模块来管理node版本</p><p>1、全局安装n模块</p><pre><code>    npm instlal -g n </code></pre><p>2、安装当前稳定版本</p><pre><code>    n stable或者sudo n stable</code></pre><p>3、安装最新版本的</p><pre><code>    n latest或者sudo n latest</code></pre><p>4、安装指定版本的node</p><pre><code>    n v8.16.0</code></pre><p>5、卸载指定的node版本</p><pre><code>    n rm v8.16.0</code></pre><p>二、使用nvm管理node版本<br>1、安装nvm </p><pre><code>    brew install nvm</code></pre><p>2、使用nvm安装node版本</p><pre><code>    // 安装最新版本    nvm isntall node    // 安装指定版本    nvm install 8.16.0</code></pre><p>3、查看所有版本</p><pre><code>    nvm ls</code></pre><p>4、切换node版本</p><pre><code>    // 使用最新版本    nvm use node           // 使用指定版本    nvm use 8.16.0</code></pre><p>通常我会使用第二种方式<br>例如：</p><p>我在一个项目中使用的是<code>node@6.13.2</code>,</p><p>新项目使用的是<code>node@8.16.0</code>,</p><p>先要安装<code>node@8.16.0   nvm install 8.16.0</code></p><p>然后<code>nvm use 8.16.0</code></p><p>5、卸载指定版本的node</p><pre><code>    nvm uninstall  v6.13.2</code></pre><p>6、设置系统默认的node版本</p><pre><code>    nvm alias default v8.16.0</code></pre><p>这样使用的node的默认版本为8.16.0</p><h2 id="nrm切换npm源"><a href="#nrm切换npm源" class="headerlink" title="nrm切换npm源"></a>nrm切换npm源</h2><p>因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。</p><p>一、切换成淘宝源</p><p>1、config命令的使用</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><p>2、命令行指定</p><pre><code>npm i node --registry https://registry.npm.taobao.org info underscore </code></pre><p>3、编辑~/.npmrc，加入以下内容：</p><pre><code>registry = https://registry.npm.taobao.org</code></pre><p>二、nrm的使用</p><blockquote><p>nrm是一个可以切换、添加/删除/测试源的工具</p></blockquote><p>1、全局安装nrm</p><pre><code>npm install -g nrm  // mac如果出现权限问题，加上sudo</code></pre><p>2、安装完成，查看所有的可用源</p><pre><code>nrm ls</code></pre><p>3、添加源</p><pre><code>nrm add 源的名称  https:// 地址</code></pre><p>4、删除原</p><pre><code>nrm del 源的名字</code></pre><p>5、切换到某个源</p><pre><code>nrm use 源的名字</code></pre><p>6、测试源速度</p><pre><code>nrm test</code></pre><p>例如，我需要使用淘宝源，只需nrm use taobao就可以了，cnpm不要使用，容易出现莫名其妙的错误。</p><h2 id="前端常用的linux命令"><a href="#前端常用的linux命令" class="headerlink" title="前端常用的linux命令"></a>前端常用的linux命令</h2><p>常用的Linux命令</p><pre><code>1、vim test.html   创建新的文件    vim + 文件名.后缀2、ls     查看当前文件夹下的文件    ls -a  列出所有文件，包括隐藏文件    ls -1  每行列出一个文件，以单列形式列出3、cat test.html  将该文件内容打印显示出来   cat test1.html   cat test2.html   cat test1.html     test2.html&gt;test3.html   cat test3.html   将多个文件合并到目标文件中。   cat test1.html   cat test2.html   cat test1.html test2.html&gt;&gt;test4.html  将几个文件附加到目录文件中4、mv   移动或重命名文件和目录mv file1.txt file2.txt   将file1文件命名为file2用法： cat 1.txt mv 1.txt 2.txt mv file1.txt file2  将file1文本移动到file2目录  5、touch  file   命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。 touch newfile6、mkdir file    创建文件夹7、cd ../  返回当前文件夹的上一层 cd /    返回到根目录下8、rm -rf folder  删除文件夹</code></pre><h2 id="eslint的配置"><a href="#eslint的配置" class="headerlink" title="eslint的配置"></a>eslint的配置</h2><p>常用的配置</p><pre><code>module.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  &#39;extends&#39;: [    &#39;plugin:vue/essential&#39;,    &#39;@vue/standard&#39;  ],  rules: &#123;    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无console.log    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, // 生产环境 无debugger    &#39;indent&#39;: &#39;off&#39;,    // 函数定义时括号前面要不要有空格    &#39;space-before-function-paren&#39;: &#39;off&#39;  &#125;,  parserOptions: &#123;    parser: &#39;babel-eslint&#39;  &#125;&#125;</code></pre><h2 id="git提交代码"><a href="#git提交代码" class="headerlink" title="git提交代码"></a>git提交代码</h2><p>一、初始化本地仓库，提交代码，提交到远程git仓库</p><p>1、初始化代码仓库</p><pre><code>    git init</code></pre><p>2、将当前目录下的所有文件放到暂存区</p><pre><code>    git add .</code></pre><p>3、查看文件状态</p><pre><code>    git status</code></pre><p>4、添加提交的描述信息</p><pre><code>    git commit -m &quot;提交的描述信息&quot;</code></pre><p>5、远程仓库地址</p><pre><code>    git remote add origin &quot;远程仓库地址&quot;</code></pre><p>6、推送到远程仓库</p><pre><code>    git push -u origin master</code></pre><p>二、创建分支，提交代码到分支</p><p>1、创建切换分支</p><pre><code>    git checkout -b dev  dev为分支名称    git add .    git commit -m &#39;描述&#39;    git push --set-upstream origin dev1   将分支推送到远程仓库    切换到主分支    git checkout master    git merge dev  将dev合并到主分支    git push origin master  推送到远程仓库</code></pre><p>三、克隆指定分支</p><pre><code>    git clone -b master git@gitee.com:username/projectname.git    git clone -b admin git@gitee.com:username/projectname.git</code></pre><p>四、git reflog</p><pre><code>查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。</code></pre><h2 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键"></a>vscode快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>commond + B</td><td>显示/隐藏侧边栏</td></tr><tr><td>commond + shift + p</td><td>显示命令窗口</td></tr><tr><td>commond +</td><td>创建多个编辑器</td></tr><tr><td>commond + 1、2</td><td>聚焦到第1、第2个编辑器</td></tr><tr><td>commond + J 或者 Ctrl + `</td><td>显示隐藏控制台</td></tr><tr><td>commond + W</td><td>关闭当前文件</td></tr><tr><td>option + 左右方向键</td><td>单词之间移动光标</td></tr><tr><td>commond + 左右方向键</td><td>移动光标至最前、最后</td></tr><tr><td>commond + shift + \</td><td>代码块之间移动光标</td></tr></tbody></table><blockquote><p>fileheader插件的使用</p></blockquote><pre><code>commond+shift+p -&gt; fileheader -&gt; enter/* * @Author: Jude  * @Date: 2020-07-24 16:39:41  * @Last Modified by: Jude * @Last Modified time: 2020-07-24 16:40:34 */</code></pre><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre><h2 id="HBuilder真机调试"><a href="#HBuilder真机调试" class="headerlink" title="HBuilder真机调试"></a>HBuilder真机调试</h2><p>1、小米手机开发者模式如何打开（MIUI 11.0.4）</p><p>步骤：设置–我的设备–全部参数–（点击）MINI版本;</p><p>2、手机连接Mac：</p><p>Mac的关于本机–系统报告–USB–你所连接的device–厂商ID</p><p>3、打开Mac终端：</p><p>在终端执行如下命令：</p><pre><code class="shell">    echo xxxxxx &gt;&gt; ~/.android/adb_usb.ini （“xxxxxx”为厂商ID);</code></pre><p>4、重启HBuilderX;</p><p>这里如果出现了问题需要切换到HBuilderX自带的adb目录；</p><p>路径为：/Applications/HBuilderX-Alpha.app/Contents/HBuilderX/plugins/launcher/tools/adbs</p><p>在adbs目录下运行Terminal，输入：</p><pre><code class="shell">    ./adb kill-server</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33、时间格式化</title>
      <link href="/2021/04/28/time/"/>
      <url>/2021/04/28/time/</url>
      
        <content type="html"><![CDATA[<p>获取时间格式的方式、封装的一些函数方法</p><span id="more"></span><h2 id="一、常用时间格式"><a href="#一、常用时间格式" class="headerlink" title="一、常用时间格式"></a>一、常用时间格式</h2><pre><code class="js">    // 2021/3/10    let time = new Date().toLocaleDateString();    // 上午10:30:00    let times = new Date().toLocaleTimeString();    // 获取当前年份    2021年    let year = new Date().getFullYear();    // 获取当前月份  月份需要+1   3月份    let month = new Date().getMonth()+1;    // 获取当前月份日期   10号    let day = new Date().getDate();    // 获取当前星期几   三    let week = new Date().getDay();    // 获取当前季度   一季度    let season =  Math.floor((this.getMonth()+3)/3);</code></pre><h2 id="二、Vue3获取当前时间：格式：YYYY-MM-DD-hh-mm-ss"><a href="#二、Vue3获取当前时间：格式：YYYY-MM-DD-hh-mm-ss" class="headerlink" title="二、Vue3获取当前时间：格式：YYYY-MM-DD hh:mm:ss"></a>二、Vue3获取当前时间：格式：YYYY-MM-DD hh:mm:ss</h2><h4 id="1、封装工具函数："><a href="#1、封装工具函数：" class="headerlink" title="1、封装工具函数："></a>1、封装工具函数：</h4><pre><code class="js">import &#123; ref, onMounted, onUnmounted &#125; from &#39;vue&#39;function dateFilter (v) &#123;  let m = v.getMonth() + 1  m = m &lt; 10 ? &#39;0&#39; + m : m  let d = v.getDate()  d = d &lt; 10 ? &#39;0&#39; + d : d  return v.getFullYear() + &#39;-&#39; + m + &#39;-&#39; + d&#125;function timeFilter (v) &#123;  let h = v.getHours()  h = h &lt; 10 ? &#39;0&#39; + h : h  let m = v.getMinutes()  m = m &lt; 10 ? &#39;0&#39; + m : m  let s = v.getSeconds()  s = s &lt; 10 ? &#39;0&#39; + s : s  return h + &#39;:&#39; + m + &#39;:&#39; + s&#125;export function clock () &#123;  let now = new Date()  const date = ref(dateFilter(now))  const time = ref(timeFilter(now))  let task  const start = () =&gt; &#123;    task = setInterval(() =&gt; &#123;      now = new Date()      date.value = dateFilter(now)      time.value = timeFilter(now)    &#125;, 1000)  &#125;  onMounted(start)  onUnmounted(() =&gt; &#123;    task &amp;&amp; clearInterval(task)  &#125;)  return &#123;    date,    time,    start  &#125;&#125;</code></pre><h4 id="2、模板页面中使用"><a href="#2、模板页面中使用" class="headerlink" title="2、模板页面中使用"></a>2、模板页面中使用</h4><p>template:</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;time&quot;&gt;    &#123;&#123; date &#125;&#125; &#123;&#123; time &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>javascript:</p><pre><code class="js">&lt;script&gt;  import &#123; clock as useClock &#125; from &#39;../../utils/clock&#39;  export default &#123;    name: &#39;time&#39;,    setup () &#123;      const &#123; date, time &#125; = useClock()      return &#123;        date,        time      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32、javascript -- 对象</title>
      <link href="/2021/04/14/javascript-simple3/"/>
      <url>/2021/04/14/javascript-simple3/</url>
      
        <content type="html"><![CDATA[<p>对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p><span id="more"></span><p>在 JS 中，除了原始类型那么其他的都是对象类型了。<br>对象类型和原始类型不同的是：<br>原始类型存储的是值，对象类型存储的是地址（指针）。<br>当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，<br>但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p><h2 id="一、字符串方法"><a href="#一、字符串方法" class="headerlink" title="一、字符串方法"></a>一、字符串方法</h2><pre><code class="js">// 将字符串的字母转换成小写const str = &quot;Hello world&quot;;arr = str.split(&quot;&quot;).map(function (item) &#123;  return (item + &quot;&quot;).toLowerCase();&#125;);lowerStr = arr.join(&quot;&quot;);console.log(lowerStr);// 挑出大写字母const str = &quot;Permission is &quot;;reg = /[A-Z]/g;console.log(str.match(reg).join(&quot;&quot;));</code></pre><h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><p>基本数据类型：</p><blockquote><p>Number，String，Boolean，null，undefined，symbol，bigint</p></blockquote><p>引用数据类型:</p><blockquote><p>object function</p></blockquote><blockquote><p>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基 本类型值和执行代码的空间。</p><p>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p></blockquote><p>基本数据类型和引用数据类型的区别：</p><blockquote><ol><li>堆比栈空间大，栈比堆运行速度快。</li><li>堆内存是无序存储，可以根据引用直接获取。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li></ol></blockquote><p>Object.assign()：合并对象 Object.assign(target, …sources)</p><blockquote><ol><li>Object.assign 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖。</li><li>后续的 source 会覆盖前面的 source 的同名属性。</li><li>Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</li></ol></blockquote><p>Constructor:</p><blockquote><p>创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。</p></blockquote><p>map 和 forEach 区别</p><p>相同点：</p><blockquote><ol><li>都是循环遍历数组中的每一项</li><li>每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）</li><li>匿名函数中的 this 都是指向 window</li><li>只能遍历数组</li></ol></blockquote><p>不同点：</p><blockquote><ol><li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li><li>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</li></ol></blockquote><p>for…of:</p><blockquote><p>es6 新增的一个遍历方法，但<strong>只限于迭代器(iterator)</strong>, 所以普通的对象用 for..of 遍历<br>是会报错的。</p><p>包括 Array, Map, Set, String, TypedArray, arguments 对象</p></blockquote><p>indexOf str.indexOf(searchValue [, fromIndex]) searchValue：要被查找的字符串值。</p><blockquote><p>查找的字符串 searchValue 的<strong>第一次</strong>出现的索引，如果没有找到，则返回-1。</p><p>若被查找的字符串 searchValue 是一个空字符串，则返回 fromIndex。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样。</p><p>如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）</p><p>严格区分大小写</p><p>在使用 indexOf 检索数组时，用‘===’去匹配，意味着会检查数据类型</p></blockquote><p>Iframe 的优缺点？</p><p>优点：</p><blockquote><ol><li>iframe 能够原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</li><li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。</li></ol></blockquote><p>缺点：</p><blockquote><ol><li>iframe 会阻塞主页面的 onload 事件；</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。</li><li>iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li><li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。</li><li>很多的移动设备无法完全显示框架，设备兼容性差。</li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。</li></ol></blockquote><p>作用域：</p><blockquote><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p></blockquote><p>js 的 arguments 相关问题</p><blockquote><p>在 js 中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js 会把所传的参数全部存到一个叫 arguments 的对象里面。它是一个<strong>类数组数据由来</strong></p><p>Javascrip 中每个函数都会有一个 Arguments 对象实例 arguments，引用着函数的实参。它是寄生在 js 函数当中的，不能显式创建，arguments 对象只有函数开始时才可用</p></blockquote><p>instanceof 原理：判断实例属于什么类型</p><pre><code class="js">// 实现方法function new_instance_of(leftVaule, rightVaule) &#123;  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值  while (true) &#123;    if (leftVaule === null) &#123;      return false;    &#125;    if (leftVaule === rightProto) &#123;      return true;    &#125;    leftVaule = leftVaule.__proto__;  &#125;&#125;</code></pre><p>数组去重：</p><p>1、es6 Set 方法</p><pre><code class="js">function unique(arr) &#123;  return Array.from(new Set(arr));&#125;// 无法去除 &#123;&#125; 空对象// 简写[...new Set(arr)];</code></pre><p>2、es5 利用 for 循环嵌套，然后 splice 去重</p><pre><code class="js">function unique(arr) &#123;  for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] == arr[j]) &#123;        //第一个等同于第二个，splice方法删除第二个        arr.splice(j, 1);        j--;      &#125;    &#125;  &#125;  return arr;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr)); //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</code></pre><p>3、indexOf</p><pre><code class="js">function unique(arr) &#123;  if (!Array.isArray(arr)) &#123;    console.log(&quot;type error!&quot;);    return;  &#125;  var array = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    if (array.indexOf(arr[i]) === -1) &#123;      array.push(arr[i]);    &#125;  &#125;  return array;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</code></pre><p>4、sort</p><pre><code class="js">function unique(arr) &#123;  if (!Array.isArray(arr)) &#123;    console.log(&quot;type error!&quot;);    return;  &#125;  arr = arr.sort();  var arrry = [arr[0]];  for (var i = 1; i &lt; arr.length; i++) &#123;    if (arr[i] !== arr[i - 1]) &#123;      arrry.push(arr[i]);    &#125;  &#125;  return arrry;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重</code></pre><p>5、includes</p><pre><code class="js">function unique(arr) &#123;  if (!Array.isArray(arr)) &#123;    console.log(&quot;type error!&quot;);    return;  &#125;  var array = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    if (!array.includes(arr[i])) &#123;      //includes 检测数组是否有某个值      array.push(arr[i]);    &#125;  &#125;  return array;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</code></pre><p>6、<strong>hasOwnProperty</strong>:利用 hasOwnProperty 判断是否存在对象属性</p><pre><code class="js">function unique(arr) &#123;  var obj = &#123;&#125;;  return arr.filter(function (item, index, arr) &#123;    return obj.hasOwnProperty(typeof item + item)      ? false      : (obj[typeof item + item] = true);  &#125;);&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了</code></pre><p>7、filter</p><pre><code class="js">function unique(arr) &#123;  return arr.filter(function (item, index, arr) &#123;    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素    return arr.indexOf(item, 0) === index;  &#125;);&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</code></pre><p>8、递归去重</p><pre><code class="js">function unique(arr) &#123;  var array = arr;  var len = array.length;  array.sort(function (a, b) &#123;    //排序后更加方便去重    return a - b;  &#125;);  function loop(index) &#123;    if (index &gt;= 1) &#123;      if (array[index] === array[index - 1]) &#123;        array.splice(index, 1);      &#125;      loop(index - 1); //递归loop，然后数组去重    &#125;  &#125;  loop(len - 1);  return array;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</code></pre><p>9、Map 数据结构去重</p><blockquote><p>创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</p></blockquote><pre><code class="js">function arrayNonRepeatfy(arr) &#123;  let map = new Map();  let array = new Array(); // 数组用于返回结果  for (let i = 0; i &lt; arr.length; i++) &#123;    if (map.has(arr[i])) &#123;      // 如果有该key值      map.set(arr[i], true);    &#125; else &#123;      map.set(arr[i], false); // 如果没有该key值      array.push(arr[i]);    &#125;  &#125;  return array;&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</code></pre><p>10、<strong>利用 reduce+includes</strong></p><pre><code class="js">function unique(arr) &#123;  return arr.reduce(    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),    []  );&#125;var arr = [  1,  1,  &quot;true&quot;,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</code></pre><p>null 和 undefined 的区别</p><blockquote><p>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p></blockquote><p>undefined:</p><ol><li>声明了一个变量，但没有赋值</li><li>访问对象上不存在的属性</li><li>函数定义了形参，但没有传递实参</li><li>使用 void 对表达式求值</li></ol><p>null:空值</p><blockquote><p><strong>表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。</strong> 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p></blockquote><p>typeof null 为什么是 object？</p><blockquote><p>null 有属于自己的类型 Null，而不属于 Object 类型，typeof 之所以会判定为 Object 类型，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，<strong>二进制的前三位为 0 会被 typeof 判断为对象类型</strong>，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p></blockquote><p>类数组转换为数组的方法：</p><blockquote><ul><li>使用 Array.from()</li><li>使用 Array.prototype.slice.call()</li><li>使用 Array.prototype.forEach()进行属性遍历并组成新的数组</li></ul><p>// 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。</p></blockquote><p>数组转树</p><pre><code class="js">function arrayToTree(array) &#123;  let root = array[0];  array.shift();  let tree = &#123;    id: root.id,    val: root.val,    children: array.length &gt; 0 ? toTree(root.id, array) : [],  &#125;;  return tree;&#125;function toTree(parenId, array) &#123;  let children = [];  let len = array.length;  for (let i = 0; i &lt; len; i++) &#123;    let node = array[i];    if (node.parentId === parenId) &#123;      children.push(&#123;        id: node.id,        val: node.val,        children: toTree(node.id, array),      &#125;);    &#125;  &#125;  return children;&#125;</code></pre><h4 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h4><blockquote><p><strong>Set</strong></p><ol><li>成员不能重复；</li><li>只有键值，没有键名，有点类似数组；</li><li>可以遍历，方法有 add、delete、has</li></ol><p><strong>WeakSet</strong></p><ol><li>成员都是对象（引用）；</li><li>成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；</li><li>不能遍历，方法有 add、delete、has；</li></ol><p><strong>Map</strong></p><ol><li>本质上是键值对的集合，类似集合；</li><li>可以遍历，方法很多，可以跟各种数据格式转换；</li></ol><p><strong>WeakMap</strong></p><ol><li>只接收对象为键名（null 除外），不接受其他类型的值作为键名；</li><li>键名指向的对象，不计入垃圾回收机制；</li><li>不能遍历，方法同 get、set、has、delete；</li></ol></blockquote><p>造成内存泄漏的情况</p><blockquote><ol><li>意外的全局变量；</li><li>闭包；</li><li>未被清空的定时器；</li><li>未被销毁的事件监听；</li><li>DOM 引用；</li></ol></blockquote><p>数据类型的判断方法：</p><blockquote><ol><li> 使用 typeof 检测当需要判断变量是否是 number, string, boolean, function, undefined 等类型时，可以使用 typeof 进行判断。</li><li> 使用 instanceof 检测 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。</li><li> 使用 constructor 检测 constructor 本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。</li></ol></blockquote><p>什么是 promise 和 async await 以及它们的区别</p><blockquote><p><strong>Promise</strong> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的</p><p><strong>async await</strong>也是异步编程的一种解决方案，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。</p></blockquote><p>区别：</p><blockquote><ol><li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li><li>async await 与 Promise 一样，是非阻塞的。</li><li>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。</li></ol></blockquote><p>js 实现 sleep</p><pre><code class="js">function sleep(time) &#123;  return new Promise((resolve) =&gt; setTimeout(resolve, time));&#125;const t1 = +new Date();sleep(3000).then(() =&gt; &#123;  const t2 = +new Date();  console.log(t2 - t1);&#125;);</code></pre><blockquote><p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。</p><p>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭</p></blockquote><p><strong>Event Loop</strong>执行顺序</p><blockquote><ol><li>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)</li><li>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务</li><li>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行</li><li>主线程不断重复上面的第三步</li></ol></blockquote><p>宏任务 Macrotask 宏任务是指 Event Loop 在<strong>每个阶段</strong>执行的任务</p><p>微任务 Microtask 微任务是指 Event Loop 在<strong>每个阶段之间</strong>执行的任务</p><p>宏任务队列包含任务: A1, A2 , A3</p><p>微任务队列包含任务: B1, B2 , B3</p><p>执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行 B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务 A2，依次循环。</p><p>宏任务 Macrotask 队列真实包含任务：</p><blockquote><pre><code>script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</code></pre></blockquote><p>微任务 Microtask 队列真实包含任务:</p><blockquote><pre><code>process.nextTick, Promises, Object.observe, MutationObserver</code></pre></blockquote><p>执行顺序：</p><blockquote><pre><code>script(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering</code></pre></blockquote><p>示例：</p><pre><code class="js">console.time(&quot;start&quot;);setTimeout(function () &#123;  console.log(2);&#125;, 10);setImmediate(function () &#123;  console.log(1);&#125;);new Promise(function (resolve) &#123;  console.log(3);  resolve();  console.log(4);&#125;).then(function () &#123;  console.log(5);  console.timeEnd(&quot;start&quot;);&#125;);console.log(6);process.nextTick(function () &#123;  console.log(7);&#125;);console.log(8);</code></pre><p>结果：3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: XXXXms——&gt;1——&gt;2</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31、解决点击手机虚拟返回键退出应用</title>
      <link href="/2021/03/23/back/"/>
      <url>/2021/03/23/back/</url>
      
        <content type="html"><![CDATA[<p>如何解决安卓手机点击虚拟返回键退出当前应用。</p><span id="more"></span><p>一、问题描述：</p><p>最近的项目是使用Vue全家桶+HBuilder打包开发一个移动端APP。<br>在测试的时候发现，当安卓手机使用虚拟按钮的时候，点击虚拟按钮的返回键，APP会直接退出。<br>这是因为安卓手机自带back虚拟按键，如果不修改其默认事件，点一下app就退出了，<br>所以需要修改这个按键默认事件事件的代码。</p><p>二、解决办法：</p><p>在index.html中加入一个script，加上如下代码：</p><details><summary>点我展示代码</summary><pre><code class="javascript">&lt;script&gt;    document.addEventListener(&#39;plusready&#39;, function () &#123;        var first = null;        var webview = plus.webview.currentWebview();        plus.key.addEventListener(&#39;backbutton&#39;, function () &#123;            webview.canBack(function (e) &#123;                if (e.canBack) &#123;                    webview.back(); //这里不建议修改自己跳转的路径                  &#125; else &#123;                    //首次按键，提示‘再按一次退出应用’                      if (!first) &#123;                      first = new Date().getTime(); //获取第一次点击的时间戳                        plus.nativeUI.toast(&quot;再按一次退出应用&quot;, &#123;                        duration: &#39;short&#39;                      &#125;); //通过H5+ API 调用Android 上的toast 提示框                        setTimeout(function () &#123;                        first = null;                      &#125;, 1000);                    &#125; else &#123;                        // 获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次,                       if (new Date().getTime() - first &lt; 1000) &#123;                          plus.runtime.quit(); //退出应用                &#125;            &#125;          &#125;        &#125;)      &#125;);    &#125;);    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30、v-for 和 v-if 优先级</title>
      <link href="/2021/03/16/v-for-v-if/"/>
      <url>/2021/03/16/v-for-v-if/</url>
      
        <content type="html"><![CDATA[<p>v-for 和 v-if 优先级在vue2.x和vue3.x是相反的。</p><span id="more"></span><p>1、实践中，不应该将v-for和v-if放在一起</p><p>2、Vue2中，v-for的优先级是高于v-if，把他们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这样会比较浪费性能；而在Vue3中则跟Vue2完全相反，v-if的优先级是高于v-for的，所以v-if执行时，它调用的变量哈不存在，会导致异常。</p><p>3、2种场景的应用：<br>（1）为了过滤列表肿的项目（v-for=”user in users” v-if=”user.isActive”   ）。这种情况，我们可以使用计算属性，定义一个activeUsers，让其返回过滤后的列表即可（“users.filter(u =&gt; u.isActive)”）<br>  (2)为了避免渲染本应该被隐藏的列表（v-for=”user in users” v-if=”shouldShowUsers”）。此时v-if移动到容器元素上（比如ul ol）或者外面包一层template即可</p><p>4、Vue文档明确指出v-if和v-for不要同事用在同一个元素上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29、Vue-虚拟DOM</title>
      <link href="/2021/03/12/vdom/"/>
      <url>/2021/03/12/vdom/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>虚拟DOM其实就是一棵模拟JavaScript对象作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。<br>最终可以通过一系列操作使这棵树映射到真实环境上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28、vue组件化实践之插槽（二）</title>
      <link href="/2021/02/24/vue-component2/"/>
      <url>/2021/02/24/vue-component2/</url>
      
        <content type="html"><![CDATA[<p>插槽：插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用。</p><span id="more"></span><h3 id="一、匿名插槽"><a href="#一、匿名插槽" class="headerlink" title="一、匿名插槽"></a>一、匿名插槽</h3><pre><code class="js">// comp1&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;hello&lt;/comp&gt;</code></pre><h3 id="二、具名插槽"><a href="#二、具名插槽" class="headerlink" title="二、具名插槽"></a>二、具名插槽</h3><blockquote><p>内容分发到子组件指定位置</p></blockquote><pre><code class="js">// comp2&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;// 默认插槽用default做参数 具名插槽用插槽名做参数&lt;template v-slot:default&gt;具名插槽&lt;/tempalte&gt;&lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/comp&gt;</code></pre><h3 id="三、作用域插槽"><a href="#三、作用域插槽" class="headerlink" title="三、作用域插槽"></a>三、作用域插槽</h3><blockquote><p>分发内容要用到子组件中的数据</p></blockquote><pre><code class="js">&lt;div&gt;    &lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;&lt;/div&gt;// parent&lt;comp&gt;// 把v-slot的值指定为作用域上下文对象&lt;tempalte v-slot:default=&quot;slotProps&quot;&gt;    来自子组件数据：&#123;&#123;slotProps.foo&#125;&#125;&lt;/tempalte&gt;&lt;/comp&gt;</code></pre><h3 id="四、实例代码"><a href="#四、实例代码" class="headerlink" title="四、实例代码"></a>四、实例代码</h3><p>子组件代码如下：</p><pre><code class="js">// 子组件 Layout.vue&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;header&quot;&gt;      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;body&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        remark: [          &#39;好好学习，天天向上&#39;,          &#39;学习永远不晚&#39;,          &#39;学习知识要善于思考,思考,再思考&#39;,          &#39;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#39;,          &#39;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#39;,          &#39;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#39;,          &#39;三人行必有我师焉；择其善者而从之，其不善者而改之&#39;        ]      &#125;    &#125;,    computed: &#123;      footerContent() &#123;        return this.remark[new Date().getDay() - 1]       &#125;    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;.header &#123;  background-color: rgb(252, 175, 175);&#125;.body &#123;  display: flex;  background-color: rgb(144, 250, 134);  min-height: 100px;  align-items: center;  justify-content: center;&#125;.footer &#123;  background-color: rgb(114, 116, 255);&#125;&lt;/style&gt;</code></pre><p>父组件代码如下：</p><pre><code class="js">//父组件 index.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;插槽&lt;/h2&gt;    &lt;!-- 插槽 --&gt;    &lt;Layout&gt;      &lt;!-- 具名插槽 --&gt;      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;      &lt;!-- 匿名插槽 --&gt;      &lt;template&gt;content...&lt;/template&gt;      &lt;!-- 作用域插槽 --&gt;      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;    &lt;/Layout&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Layout from &#39;@/components/slots/Layout.vue&#39;    export default &#123;    components: &#123;      Layout    &#125;,  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27、vue组件化实践之组件通信（一）</title>
      <link href="/2021/02/20/vue-component/"/>
      <url>/2021/02/20/vue-component/</url>
      
        <content type="html"><![CDATA[<p>vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护性，便于多人协同开发。</p><span id="more"></span><h3 id="一、组件通信常用方式"><a href="#一、组件通信常用方式" class="headerlink" title="一、组件通信常用方式"></a>一、组件通信常用方式</h3><p>1、props</p><blockquote><p>父组件传给子组件</p></blockquote><p>父子组件交互，props和$emit</p><pre><code class="js">// childprops:&#123;msg:String&#125;// parent&lt;HelloWorld msg=&quot;hello vue&quot; /&gt;</code></pre><p>2、自定义事件</p><blockquote><p>子传父</p></blockquote><pre><code class="js">//childthis.$emit(&#39;add&#39;,good)// parent&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;</code></pre><p>3、eventBus事件总线</p><blockquote><p>任意两个组件之间的传值常用事件总线或者vuex</p></blockquote><p>4、$parent和$root</p><blockquote><p>兄弟组件之间通信可通过共同父辈搭桥，$parent或$root</p></blockquote><pre><code class="js">// brother1this.$parent.$on(&#39;foo&#39;,handle)// brother2this.$parent.$emit(&#39;foo&#39;)</code></pre><p>5、$children</p><blockquote><p>父组件可通过$children访问子组件实现父子通信</p></blockquote><pre><code class="js">// parentthis.$children[0].xx=&#39;xxx&#39;</code></pre><p>6、$attrs、$listeners</p><blockquote><p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v- bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p></blockquote><pre><code class="js">// child:未在props中声明foo&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;// parent&lt;HelloWorld foo=&quot;foo&quot;&gt;</code></pre><p>7、refs</p><blockquote><p>获取子节点引用</p></blockquote><pre><code class="js">// parent&lt;HelloWorld ref=&quot;wrap&quot;&gt;mounted()&#123;    this.$refs.wrap.xx = &quot;xxx&quot;&#125;</code></pre><p>8、provide/inject</p><blockquote><p>能够实现祖先和后代之间的传值</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26、关于v-for的key值为什么不能是index？</title>
      <link href="/2021/02/14/v-for-index/"/>
      <url>/2021/02/14/v-for-index/</url>
      
        <content type="html"><![CDATA[<p>从实际的案例发现到在使用 v-for 时，将 key 值写成了 index，出现的问题。与其使用 index 作为 key ，不如完全不写 key，因为他们的性能是一样。比如一个列表长度为 10，用 index 作为 key ，各 item 的 key 值依次就是 0-9， 然后 reverse() 一下，列表的的 key 还是 0-9。在依次 patch 这 10 个 item 的时候，sameVnode() 全部返回真（因为 tag 和 key 都一样）。再看另外一种情况，如果不写 key ， 那这 10 个 item 的 key 全部是 undefined, 在 sameVnode() 也是全部返回真（因为 tag 相同，key 也相同：key 都是 undefined）。所以得出结论，如果使用 index 作为 key，不如干脆不写 key 了，还能省下代码。</p><span id="more"></span><h3 id="一、案例-bug-复现"><a href="#一、案例-bug-复现" class="headerlink" title="一、案例 bug 复现"></a>一、案例 bug 复现</h3><p>父组件代码：</p><pre><code class="js">// 父组件&lt;Child    v-for=&quot;(item,index) in list&quot;    :key=&quot;index&quot;    :count=&quot;item.count&quot;    :name=&quot;item.name&quot;    @delete=&quot;handleDelete(index)&quot;/&gt;// datalist:[    &#123;        count:1,        name:&quot;1&quot;    &#125;,    &#123;        count:2,        name:&quot;2&quot;    &#125;,       &#123;        count:3,        name:&quot;3&quot;    &#125;,]// methodhandelDelete(index)&#123;    this.list.splice(index,1)&#125;</code></pre><p>子组件代码：</p><pre><code class="js">// 子组件&lt;div&gt;&lt;span&gt;    &#123;&#123;name&#125;&#125;&lt;/span&gt;count：&#123;&#123; innerCount &#125;&#125;&lt;button @click=&quot;$emit(&#39;delete)&quot;&gt;&lt;/button&gt;delete&lt;/button&gt;&lt;/div&gt;// propsprops:&#123;    count:&#123;        type:Number,        default:0    &#125;,    name:&#123;        type:String,        default:&#39;&#39;    &#125;&#125;// datadata()&#123;    retrun&#123;        // 子组件下面的这行代码定义了自己的状态，无法使用index作为key值        innerCount:this.count    &#125;&#125;</code></pre><p>当删除的时候，看上去是成功了，其实存在问题。加上排序也是存在问题。</p><p>将 v-for 里面的 key 换成 item 后，是正常的。</p><p>Vue 官网的描述：</p><blockquote><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p></blockquote><blockquote><p>这个默认的模式是高效的，但是只适用于不依赖子组件装填或临时 DOM 状态的列表渲染输出。</p></blockquote><h3 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h3><p>写列表渲染时，依赖子组件状态或者临时 DOM 状态的情况，如果存在删除、增加、排序这样的功能，不能将 index 作为 key 值。</p><p>这里还包括 diff 算法…(待添加)</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25、vue使用hls.js处理m3u8格式的视频</title>
      <link href="/2021/01/08/hls/"/>
      <url>/2021/01/08/hls/</url>
      
        <content type="html"><![CDATA[<p>m3u8 文件是指 UTF-8 编码格式的 m3u 文件。m3u 文件是记录了一个索引纯文本文件,打开它时播放软件并不是播放它,而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。</p><span id="more"></span><blockquote><p>HLS 与 M3U8 HLS(全称:Http Live Streaming)是由 Apple 公司定义的用于实时流传输的协议</p></blockquote><p>公司项目中使用了视频监控功能，需要在系统内显示 m3u8 格式的视频。</p><p>1、安装 hls.js 插件或者使用 CDN 引入</p><pre><code class="js">npm install hls.js --save// 或者&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;</code></pre><p>2、业务代码如下：</p><pre><code class="html">&lt;video  ref=&quot;video&quot;  id=&quot;myVideo2&quot;  class=&quot;video-js vjs-default-skin vjs-big-play-centered&quot;  autoplay=&quot;autoplay&quot;  controls  style=&quot;width: 100%; height: 280px; margin-top: 5px&quot;&gt;&lt;/video&gt;</code></pre><pre><code class="js">import Hls from &quot;hls.js&quot;;export default &#123;  data() &#123;    return &#123;      hls: null,    &#125;;  &#125;,  methods: &#123;    getStream(source) &#123;      if (Hls.isSupported()) &#123;        this.hls = new Hls();        this.hls.loadSource(source);        this.hls.attachMedia(this.$refs.video);        this.hls.on(Hls.Events.MANIFEST_PARSED, () =&gt; &#123;          this.$refs.video.play();        &#125;);        this.hls.on(Hls.Events.ERROR, (event, data) =&gt; &#123;          this.$message(&quot;视频加载失败&quot;);        &#125;);      &#125;else&#123;        this.$message(&quot;格式不支持&quot;)      &#125;    &#125;,  &#125;,  // 从接口获取的视频资源应当写在mounted里面，否则容易出现进入视频页面的时候，视频加载不出来的现象  mounted() &#123;    this.$service.get(&quot;demo/test&quot;).then((res) =&gt; &#123;      this.getStream(res.data[1].hls);    &#125;);  &#125;,&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24、CSS3：linear-gradient线性渐变和radial-gradient径向渐变的使用</title>
      <link href="/2020/08/12/css3-linear-gradient/"/>
      <url>/2020/08/12/css3-linear-gradient/</url>
      
        <content type="html"><![CDATA[<p>linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。</p><p>创建一个线性渐变，需要指定两种颜色，还可以实现不同方向（指定为一个角度）的渐变效果，如果不指定方向，默认从上到下渐变。</p><span id="more"></span><p>radial-gradient()径向渐变由它的中心定义。</p><p>为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p><h3 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h3><pre><code class="html">// html&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box&#123;     width:100px;    height:100px;    /* 线性渐变 */    /* 从上到下 由黄色变为红色变为蓝色 */    background:linear-gradient(yellow,red,blue);    /* 渐变轴为45度，从蓝色渐变到红色 */    background:linear-gradient(45deg, blue, red);    /* 从右下到左上、从蓝色渐变到红色 */    background:linear-gradient(to left top, blue, red);    /* 从下到上，从蓝色开始渐变、到高度40%位置是绿色渐变开始、最后以红色结束 */    background:linear-gradient(0deg, blue, green 40%, red); &#125;    /* 径向渐变 */    /* 中心红色 红色周围为黄色 周边为绿色  */    background-image: radial-gradient(red, yellow, green)</code></pre><h3 id="二、不同浏览器的支持"><a href="#二、不同浏览器的支持" class="headerlink" title="二、不同浏览器的支持"></a>二、不同浏览器的支持</h3><pre><code class="html">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;// css.box&#123;     &lt;!-- chrome --&gt;    background: -webkit-linear-gradient(to right, red, green);     &lt;!-- Opera --&gt;    background:-o-linear-gradient(to right,to right, red, green);     &lt;!-- Firefox --&gt;    background:-moz-linear-gradient (to right, to right, red, green);     background:linear-gradient(to right, to right, red, green); &#125;</code></pre><h3 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h3><pre><code class="css">/* linear-gradient 线性渐变 */background-image: linear-gradient(direction, color-stop1, color-stop2, ...);/* radial-gradient 径向渐变*/background-image: radial-gradient(shape size at position, start-color, ..., last-color);</code></pre><h3 id="四、实际应用"><a href="#四、实际应用" class="headerlink" title="四、实际应用"></a>四、实际应用</h3><p>如dashboard首页有四个盒子，每个盒子的背景渐变色是不同的，使用scss css预处理器的写法。</p><h4 id="1、mixin-scss"><a href="#1、mixin-scss" class="headerlink" title="1、mixin.scss"></a>1、mixin.scss</h4><pre><code class="css">/*  */@mixin cardBg($leftColor, $rightColor) &#123;  background: -webkit-linear-gradient(to right, $leftColor, $rightColor);  background: -o-linear-gradient(to right, $leftColor, $rightColor);  background: -moz-linear-gradient (to right, $leftColor, $rightColor);  background: linear-gradient(to right, $leftColor, $rightColor);&#125;</code></pre><h4 id="2、页面引入mixin-scss"><a href="#2、页面引入mixin-scss" class="headerlink" title="2、页面引入mixin.scss"></a>2、页面引入mixin.scss</h4><blockquote><p>下面的@include 是调用mixin的cardBg变量</p></blockquote><pre><code class="css">@import &#39;&#39;./mixin.scss.cardList-wrapper&#123;    box-sizing:border-box;    heitht:150px;    padding:15px 15px 0;    border-radius:6px;    cursor:pointer;    margin-bottom:25px;    box-shadow:3px 5px 15px rgba(40,40,40,0.36);    /* 第一个盒子 */    &amp;.card-item-one&#123;        @include cardBg(#5171fd,#c97afd);        &amp;:hover&#123;            box-shadow:0 5px 10px #c97afd;        &#125;    &#125;    /* 第二个盒子 */    &amp;.card-item-two &#123;      @include cardBg(#3dadf6, #737bfc);       &amp;:hover &#123;        box-shadow: 0 5px 10px #737bfc;      &#125;    &#125;    /* 第三个盒子 */    &amp;.card-item-three &#123;      @include cardBg(#ea677c, #ef9b5f);       &amp;:hover &#123;        box-shadow: 0 5px 10px #ef9b5f;      &#125;    &#125;    /* 第四个盒子 */    &amp;.card-item-four &#123;      @include cardBg(#42d79b, #a6e25f);       &amp;:hover &#123;        box-shadow: 0 5px 10px #a6e25f;      &#125;    &#125;    /* 四个盒子在hover时都会变大一些 */    &amp;:hover &#123;      transform: scale(1.03);      transition: all 0.1s ease-out;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23、百度地图动画（轨迹动画）</title>
      <link href="/2020/04/29/bmap-animate/"/>
      <url>/2020/04/29/bmap-animate/</url>
      
        <content type="html"><![CDATA[<p>百度地图动画及轨迹动画</p><span id="more"></span><h3 id="一、百度地图动画"><a href="#一、百度地图动画" class="headerlink" title="一、百度地图动画"></a>一、百度地图动画</h3><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.414, 39.915), 20); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放bmap.setTilt(20); // 设置地图初始倾斜角度var keyFrames = [  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: 0,    percentage: 0,  &#125;,  &#123;    center: new BMapGL.Point(116.307631, 40.055391),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.1,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: 0,    percentage: 0.25,  &#125;,  &#123;    center: new BMapGL.Point(116.306858, 40.057887),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.35,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -90,    percentage: 0.45,  &#125;,  &#123;    center: new BMapGL.Point(116.307904, 40.058118),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.55,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -180,    percentage: 0.75,  &#125;,  &#123;    center: new BMapGL.Point(116.308902, 40.055954),    zoom: 21,    tilt: 70,    heading: -270,    percentage: 0.85,  &#125;,  &#123;    center: new BMapGL.Point(116.307779, 40.055754),    zoom: 21,    tilt: 70,    heading: -360,    percentage: 0.95,  &#125;,  &#123;    center: new BMapGL.Point(116.307092, 40.054922),    zoom: 20,    tilt: 50,    heading: -360,    percentage: 1,  &#125;,];var opts = &#123;  duration: 10000, // 设置每次迭代动画持续时间  delay: 3000, // 设置动画延迟开始时间  interation: &quot;INFINITE&quot;, // 设置动画迭代次数&#125;;var animation = new BMapGL.ViewAnimation(keyFrames, opts); // 初始化动画实例animation.addEventListener(&quot;animationstart&quot;, function (e) &#123;  // 监听动画开始事件  console.log(&quot;start&quot;);&#125;);animation.addEventListener(&quot;animationiterations&quot;, function (e) &#123;  // 监听动画迭代事件  console.log(&quot;onanimationiterations&quot;);&#125;);animation.addEventListener(&quot;animationend&quot;, function (e) &#123;  // 监听动画结束事件  console.log(&quot;end&quot;);&#125;);animation.addEventListener(&quot;animationcancel&quot;, function (e) &#123;  // 监听动画中途被终止事件  console.log(&quot;cancel&quot;);&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.startViewAnimation(animation); // 开始播放动画&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  bmap.cancelViewAnimation(animation); // 强制停止动画&#125;);</code></pre></details><h3 id="二、百度地图轨迹动画"><a href="#二、百度地图轨迹动画" class="headerlink" title="二、百度地图轨迹动画"></a>二、百度地图轨迹动画</h3><pre><code class="js">&lt;scrip  type=&quot;text/javascript&quot;  src=&quot;https://api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js&quot;&gt;&lt;/scrip&gt;</code></pre><pre><code class="html">&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div id=&quot;tools&quot;&gt;  &lt;button id=&quot;start&quot;&gt;播放动画&lt;/button&gt;  &lt;button id=&quot;end&quot;&gt;停止播放&lt;/button&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例bmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图，设置中心点坐标和地图级别bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放var path = [  &#123;    lng: 116.297611,    lat: 40.047363,  &#125;,  &#123;    lng: 116.302839,    lat: 40.048219,  &#125;,  &#123;    lng: 116.308301,    lat: 40.050566,  &#125;,  &#123;    lng: 116.305732,    lat: 40.054957,  &#125;,  &#123;    lng: 116.304754,    lat: 40.057953,  &#125;,  &#123;    lng: 116.306487,    lat: 40.058312,  &#125;,  &#123;    lng: 116.307223,    lat: 40.056379,  &#125;,];var point = [];for (var i = 0; i &lt; path.length; i++) &#123;  point.push(new BMapGL.Point(path[i].lng, path[i].lat));&#125;var pl = new BMapGL.Polyline(point);var trackAni = new BMapGLLib.TrackAnimation(bmap, pl, &#123;  overallView: true, // 动画完成后自动调整视野到总览  tilt: 30, // 轨迹播放的角度，默认为55  duration: 20000, // 动画持续时长，默认为10000，单位ms  delay: 3000, // 动画开始的延迟，默认0，单位ms&#125;);document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.start();&#125;);document.getElementById(&quot;end&quot;).addEventListener(&quot;click&quot;, function () &#123;  trackAni.cancel(); // 强制停止动画&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22、百度地图LBS云检索</title>
      <link href="/2020/04/29/bmap/"/>
      <url>/2020/04/29/bmap/</url>
      
        <content type="html"><![CDATA[<p>百度地图自定义叠加层</p><span id="more"></span><blockquote><p>LBS 云服务提供海量位置数据的实时存储功能，JavaScript API 支持将用户上传到 LBS 云里的位置数据实时渲染成图层</p></blockquote><p>1、安装 vue-baidu-map</p><pre><code class="bash">npm install vue-baidu-map</code></pre><p>2、具体业务代码如下:</p><pre><code class="html">&lt;baidu-map  id=&quot;container&quot;  :scroll-wheel-zoom=&quot;true&quot;  :zoom=&quot;zoom&quot;  center=&quot;上海&quot;  :ak=&quot;selfKey&quot;  inertial-dragging  @ready=&quot;mapReady&quot;&gt;&lt;/baidu-map&gt;&lt;div class=&quot;menu-search&quot;&gt;  &lt;el-input placeholder=&quot;请输入站点名称&quot; v-model=&quot;site_name&quot; clearable&gt;    &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot; @click=&quot;search&quot;&gt;&lt;/el-button&gt;  &lt;/el-input&gt;&lt;/div&gt;</code></pre><details><summary>点我展开js代码</summary><pre><code class="js">&lt;script&gt;// 在组件中引入vue-baidu-mapimport BaiduMap from &quot;vue-baidu-map/components/map/Map.vue&quot;;export default&#123;    components:&#123;BaiduMap&#125;,    data()&#123;        return&#123;            site_name:&#39;&#39;,            center:&#123;lng:121.532325,lat:31.232742&#125;,            selfKey:&#39;QloR7bQpWed3VDLbtcxi2NmgUcvXxcbx&#39;,            point:&#39;&#39;,            zoom:15        &#125;    &#125;,    mounted()&#123;        this.mapReady()    &#125;,    methods:&#123;        mapReady()&#123;            var map = new BMap.Map(&quot;container&quot;)            map.centerAndZoom(new BMap.Point(this.center.lng,ths.center.lat),10)            map.enableScrollWheelZoom()                  /**       *params   q:检索关键字       *params   tags：空格分割的多字符       *params   filter:过滤条件       */            var customLayer;            customLayer = new BMap.CustomLayer(&#123;                geotableId: 183323,                q: &quot;&quot;,                tags: &quot;&quot;,                filter: &quot;&quot;,            &#125;);            map.addTileLayer(customLayer);            // 热点图层            customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);            function callback(e) &#123;                var customPoi = e.customPoi;                var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                     customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                var BMapLib = window.BMapLib;                var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                        title: customPoi.title,                        width: 200,                        height: 100,                        panel: &quot;panel&quot;,                        enableAutoPan: true,                        enableSendToPhone: false,                        searchTypes: [],                &#125;);                var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                searchInfoWindow.open(point);            &#125;        &#125;,          search() &#123;                var map = new BMap.Map(&quot;container&quot;);                map.centerAndZoom(new BMap.Point(this.center.lng, this.center.lat), 10);                map.enableScrollWheelZoom();                var customLayer;                customLayer = new BMap.CustomLayer(&#123;                    geotableId: 183323,                    q: this.site_name || &quot;新西北物流园&quot;,                    tags: &quot;&quot;,                    filter: &quot;&quot;,                &#125;);                // 添加自定义图层                map.addTileLayer(customLayer);                // var mapDom = document.getElementById(&quot;container&quot;)                // mapDom.addEventListener(&quot;click&quot;, function () &#123;                //   window.location.href = &quot;./monitor/index&quot;;                // &#125;);                // 热点图层                customLayer.addEventListener(&quot;onhotspotclick&quot;, callback);                function callback(e) &#123;                    var customPoi = e.customPoi;                    var content =                    &#39;&lt;p style=&quot;margin:0;line-height:40px;&quot;&gt;地址：&#39; +                    customPoi.address +                    &quot;&lt;br/&gt;&quot; +                    &#39;&lt;a style=&quot;color:#3398DB&quot; href=&quot;./monitor/index&quot;&gt;查看橇装站点实时监控画面&lt;/a&gt;&#39; +                    &quot;&lt;/p&gt;&quot;;                    var BMapLib = window.BMapLib;                    // console.log(&quot;BMapLib&quot;, BMapLib);                    var searchInfoWindow = new BMapLib.SearchInfoWindow(map, content, &#123;                    title: customPoi.title,                    width: 200,                    height: 100,                    panel: &quot;panel&quot;,                    enableAutoPan: true,                    enableSendToPhone: false,                    searchTypes: [],                    &#125;);                    var point = new BMap.Point(customPoi.point.lng, customPoi.point.lat);                    searchInfoWindow.open(point);                &#125;    &#125;,    &#125;&#125;&lt;/script&gt;&lt;/details&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> bmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21、v-charts的options</title>
      <link href="/2020/04/28/v-charts/"/>
      <url>/2020/04/28/v-charts/</url>
      
        <content type="html"><![CDATA[<p>v-charts 的 options 使用 getOptions()而不是使用一个变量</p><span id="more"></span><blockquote><p>使用 getOptions()是为了获取数据之后才进行渲染数据，v-chart 的 options 可以直接绑定一个变量,在请求数据的时候，更新变量，图表需要进行重新渲染</p></blockquote><p>这里的 getOptions()也可以写在 computed 里面的。</p><pre><code class="html">&lt;template&gt;    &lt;v-charts :options=&quot;getOptions()&quot;&gt;&lt;/template&gt;</code></pre><details><summary>点我展示js代码</summary><pre><code class="js"> getOptions() &#123;        return &#123;          grid: &#123;            left: 0,            right: 0,            top: 0,            bottom: 0          &#125;,          xAxis: &#123;            type: &#39;value&#39;,            show: false          &#125;,          yAxis: &#123;            type: &#39;category&#39;,            show: false          &#125;,          series: [&#123;            name: &#39;上月平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            barWidth: 10,            itemStyle: &#123;              color: &#39;#45c946&#39;            &#125;          &#125;, &#123;            name: &#39;今日平台用户数&#39;,            type: &#39;bar&#39;,            stack: &#39;总量&#39;,            data: [this.userTodayNumber],            itemStyle: &#123;              color: &#39;#eee&#39;            &#125;          &#125;, &#123;            type: &#39;custom&#39;,            stack: &#39;总量&#39;,            data: [this.userLastMonth],            renderItem: (params, api) =&gt; &#123;              const value = api.value(0)              const endPoint = api.coord([value, 0])              return &#123;                type: &#39;group&#39;,                position: endPoint,                children: [&#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,                    x: -5,                    y: -20,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;, &#123;                  type: &#39;path&#39;,                  shape: &#123;                    d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,                    x: -5,                    y: 10,                    width: 10,                    height: 10,                    layout: &#39;cover&#39;                  &#125;,                  style: &#123;                    fill: &#39;#45c946&#39;                  &#125;                &#125;]              &#125;            &#125;          &#125;]        &#125;      &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> v-charts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20、axios的封装</title>
      <link href="/2020/04/23/axios/"/>
      <url>/2020/04/23/axios/</url>
      
        <content type="html"><![CDATA[<blockquote><p>axios 基于 promise 的 http 库 特性：拦截请求和响应、取消请求、转换 json、客户端防御 XSRF</p></blockquote><span id="more"></span><p>当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。</p><p>所以记住：</p><blockquote><p>在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。</p></blockquote><pre><code class="js">service.interceptors.response.use(  (response) =&gt; &#123;    if (response.status === 200 &amp;&amp; response.data) &#123;      return response.data;    &#125; else &#123;      return Promise.reject(new Error(&quot;请求失败&quot;));    &#125;  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);</code></pre><h3 id="1、axios-的安装"><a href="#1、axios-的安装" class="headerlink" title="1、axios 的安装"></a>1、axios 的安装</h3><pre><code class="js">npm install axios</code></pre><h3 id="2、在-request-文件夹-http-js"><a href="#2、在-request-文件夹-http-js" class="headerlink" title="2、在 request 文件夹 http.js"></a>2、在 request 文件夹 http.js</h3><pre><code class="js">// http.jsimport axios from &quot;axios&quot;;import QS from &quot;qs&quot;; // 序列化post类型的数据import &#123; Toast &#125; from &quot;vant&quot;; // 引入vant组件库的toast组件</code></pre><h3 id="3、环境的切换-请求超时-post-请求头设置"><a href="#3、环境的切换-请求超时-post-请求头设置" class="headerlink" title="3、环境的切换/请求超时/post 请求头设置"></a>3、环境的切换/请求超时/post 请求头设置</h3><pre><code class="js">// 环境的切换if (process.env.NODE_ENV == &quot;development&quot;) &#123;  axios.defaults.baseURL = &quot;https://www.baidu.com&quot;;&#125; else if (process.env.NODE_ENV == &quot;debug&quot;) &#123;  axios.defaults.baseURL = &quot;https://www.ceshi.com&quot;;&#125; else if (process.env.NODE_ENV == &quot;production&quot;) &#123;  axios.defaults.baseURL = &quot;https://www.production.com&quot;;&#125;axios.defaults.timeout = 10000;axios.defaults.headers.post[&quot;Content-Type&quot;] =  &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;;</code></pre><h3 id="4、请求拦截-响应拦截"><a href="#4、请求拦截-响应拦截" class="headerlink" title="4、请求拦截 响应拦截"></a>4、请求拦截 响应拦截</h3><details><summary>点击展示代码</summary><pre><code class="js">// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from &#39;@/store/index&#39;;// 请求拦截器axios.interceptors.request.use(    config =&gt; &#123;        // 每次发送请求之前判断vuex中是否存在token        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断        const token = store.state.token;        token &amp;&amp; (config.headers.Authorization = token);        return config;    &#125;,    error =&gt; &#123;        return Promise.error(error);    &#125;)// 响应拦截器axios.interceptors.response.use(    response =&gt; &#123;        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据        // 否则的话抛出错误        if (response.status === 200) &#123;            return Promise.resolve(response);        &#125; else &#123;            return Promise.reject(response);        &#125;    &#125;,    // 服务器状态码不是2开头的的情况    // 这里可以跟你们的后台开发人员协商好统一的错误状态码    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等    // 下面列举几个常见的操作，其他需求可自行扩展    error =&gt; &#123;        if (error.response.status) &#123;            switch (error.response.status) &#123;                // 401: 未登录                // 未登录则跳转登录页面，并携带当前页面的路径                // 在登录成功后返回当前页面，这一步需要在登录页操作。                case 401:                    router.replace(&#123;                        path: &#39;/login&#39;,                        query: &#123;                            redirect: router.currentRoute.fullPath                        &#125;                    &#125;);                    break;                // 403 token过期                // 登录过期对用户进行提示                // 清除本地token和清空vuex中token对象                // 跳转登录页面                case 403:                     Toast(&#123;                        message: &#39;登录过期，请重新登录&#39;,                        duration: 1000,                        forbidClick: true                    &#125;);                    // 清除token                    localStorage.removeItem(&#39;token&#39;);                    store.commit(&#39;loginSuccess&#39;, null);                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面                    setTimeout(() =&gt; &#123;                        router.replace(&#123;                            path: &#39;/login&#39;,                            query: &#123;                                redirect: router.currentRoute.fullPath                            &#125;                        &#125;);                    &#125;, 1000);                    break;                // 404请求不存在                case 404:                    Toast(&#123;                        message: &#39;网络请求不存在&#39;,                        duration: 1500,                        forbidClick: true                    &#125;);                    break;                // 其他错误，直接抛出错误提示                default:                    Toast(&#123;                        message: error.response.data.message,                        duration: 1500,                        forbidClick: true                    &#125;);            &#125;            return Promise.reject(error.response);        &#125;    &#125;&#125;);</code></pre></details><h3 id="5、get、post-请求的封装"><a href="#5、get、post-请求的封装" class="headerlink" title="5、get、post 请求的封装"></a>5、get、post 请求的封装</h3><blockquote><p>get 方法：我们通过定义一个 get 函数，get 函数有两个参数，第一个参数表示我们要请求的 url 地址，第二个参数是我们要携带的请求参数。get 函数返回一个 promise 对象，当 axios 其请求成功时 resolve 服务器返回 值，请求失败时 reject 错误值。最后通过 export 抛出 get 函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios      .get(url, &#123;        params: params,      &#125;)      .then((res) =&gt; &#123;        resolve(res.data);      &#125;)      .catch((err) =&gt; &#123;        reject(err.data);      &#125;);  &#125;);&#125;</code></pre></details><blockquote><p>原理同 get 基本一样，但是要注意的是，post 方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过 node 的 qs 模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们 import QS from ‘qs’;的原因</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function post(url, params) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios      .post(url, QS.stringify(params))      .then((res) =&gt; &#123;        resolve(res.data);      &#125;)      .catch((err) =&gt; &#123;        reject(err.data);      &#125;);  &#125;);&#125;</code></pre></details><h3 id="6、axios-完整封装代码"><a href="#6、axios-完整封装代码" class="headerlink" title="6、axios 完整封装代码:"></a>6、axios 完整封装代码:</h3><details><summary>点击展示代码</summary><pre><code class="js">/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &quot;axios&quot;;import router from &quot;../router&quot;;import store from &quot;../store/index&quot;;import &#123; Toast &#125; from &quot;vant&quot;;/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = (msg) =&gt; &#123;  Toast(&#123;    message: msg,    duration: 1000,    forbidClick: true,  &#125;);&#125;;/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123;  router.replace(&#123;    path: &quot;/login&quot;,    query: &#123;      redirect: router.currentRoute.fullPath,    &#125;,  &#125;);&#125;;/** * 请求失败后的错误统一处理 * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123;  // 状态码判断  switch (status) &#123;    // 401: 未登录状态，跳转登录页    case 401:      toLogin();      break;    // 403 token过期    // 清除token并跳转登录页    case 403:      tip(&quot;登录过期，请重新登录&quot;);      localStorage.removeItem(&quot;token&quot;);      store.commit(&quot;loginSuccess&quot;, null);      setTimeout(() =&gt; &#123;        toLogin();      &#125;, 1000);      break;    // 404请求不存在    case 404:      tip(&quot;请求的资源不存在&quot;);      break;    default:      console.log(other);  &#125;&#125;;// 创建axios实例var instance = axios.create(&#123; timeout: 1000 * 12 &#125;);// 设置post请求头instance.defaults.headers.post[&quot;Content-Type&quot;] =  &quot;application/x-www-form-urlencoded&quot;;/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */instance.interceptors.request.use(  (config) =&gt; &#123;    // 登录流程控制中，根据本地是否存在token判断用户的登录情况    // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token    // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码    // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。    const token = store.state.token;    token &amp;&amp; (config.headers.Authorization = token);    return config;  &#125;,  (error) =&gt; Promise.error(error));// 响应拦截器instance.interceptors.response.use(  // 请求成功  (res) =&gt; (res.status === 200 ? Promise.resolve(res) : Promise.reject(res)),  // 请求失败  (error) =&gt; &#123;    const &#123; response &#125; = error;    if (response) &#123;      // 请求已发出，但是不在2xx的范围      errorHandle(response.status, response.data.message);      return Promise.reject(response);    &#125; else &#123;      // 处理断网的情况      // eg:请求超时或断网时，更新state的network状态      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明      if (!window.navigator.onLine) &#123;        store.commit(&quot;changeNetwork&quot;, false);      &#125; else &#123;        return Promise.reject(error);      &#125;    &#125;  &#125;);export default instance;</code></pre></details><h3 id="7、token-失效及接口国际化"><a href="#7、token-失效及接口国际化" class="headerlink" title="7、token 失效及接口国际化"></a>7、token 失效及接口国际化</h3><details><summary>点击展示代码</summary><pre><code class="js">/** * 是否超时 */export function isCheckTimeout() &#123;  // 当前时间戳  var currentTime = Date.now();  // 缓存时间戳  var timeStamp = getTimeStamp();  return currentTime - timeStamp &gt; TOKEN_TIMEOUT_VALUE;&#125;import axios from &quot;axios&quot;;import store from &quot;@/store&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; isCheckTimeout &#125; from &quot;@/utils/auth&quot;;const service = axios.create(&#123;  baseURL: process.env.VUE_APP_BASE_API,  timeout: 5000,&#125;);// 请求拦截器service.interceptors.request.use(  (config) =&gt; &#123;    // 在这个位置需要统一的去注入token    if (store.getters.token) &#123;      if (isCheckTimeout()) &#123;        // 登出操作        store.dispatch(&quot;user/logout&quot;);        return Promise.reject(new Error(&quot;token 失效&quot;));      &#125;      // 如果token存在 注入token      config.headers.Authorization = `Bearer $&#123;store.getters.token&#125;`;    &#125;    // 配置接口国际化    config.headers[&quot;Accept-Language&quot;] = store.getters.language;    return config; // 必须返回配置  &#125;,  (error) =&gt; &#123;    return Promise.reject(error);  &#125;);// 响应拦截器service.interceptors.response.use(  (response) =&gt; &#123;    const &#123; success, message, data &#125; = response.data;    //   要根据success的成功与否决定下面的操作    if (success) &#123;      return data;    &#125; else &#123;      // 业务错误      ElMessage.error(message); // 提示错误消息      return Promise.reject(new Error(message));    &#125;  &#125;,  (error) =&gt; &#123;    // 处理 token 超时问题    if (      error.response &amp;&amp;      error.response.data &amp;&amp;      error.response.data.code === 401    ) &#123;      // token超时      store.dispatch(&quot;user/logout&quot;);    &#125;    ElMessage.error(error.message); // 提示错误信息    return Promise.reject(error);  &#125;);export default service;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19、关于echarts官方的一个bug -- sublink跳转问题</title>
      <link href="/2020/04/20/echarts/"/>
      <url>/2020/04/20/echarts/</url>
      
        <content type="html"><![CDATA[<p>echarts 官方的一个 bug – sublink 跳转的问题。echarts版本号为4.8.0</p><span id="more"></span><p>开发百度地图 scatter 散点图时，副标题链接跳转出错（版本号为 4.8.0），在 GitHub 找到<a href="https://github.com/apache/incubator-echarts/issues/12841">issues</a>。<br>bug 介绍，点击副标题无法跳转到指定连接</p><pre><code class="js">this.options = &#123;  title: &#123;    text: &quot;我是主标题&quot;,    subtext: &quot;我是副标题，我可以跳转&quot;,    sublink: &quot;https://www.baidu.com&quot;,    left: &quot;center&quot;,  &#125;,&#125;;</code></pre><p>1、在 main.js 引入 echarts 和 vue-echarts，将 echarts 绑定到 Vue 原型，引入 vue-echarts 通过 vue.component()进行组件注册</p><blockquote><p>将 echarts 绑定到 Vue 原型上，可以减少代码量，开发过程中需要使用 echarts 里面提供的方法，如果没有全局引入的话，需要在每个使用 echarts 的页面都需要手动引入。将 vue-echarts 使用组件注册后，提供了属性绑定的方式渲染图表就不需要通过调用 echart 的方法了。</p></blockquote><h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><p>1、echarts 的绘图流程</p><pre><code class="js">// 1、引入echarts js库&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 2、DOM容器 设置宽高（注意）  --&gt;&lt;div id=&quot;charts&quot; style=&quot;width:800px;height:600px&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="js">// 3、获取渲染DOM对象const chartDom = document.getElementById(&quot;charts&quot;);// 4、初始化echarts对象const chart = echarts.init(chartDom);// 5、配置option参数  调用setOption完成渲染chart.setOption(&#123;  title: &#123;    text: &quot;Echarts 示例&quot;,  &#125;,  xAxis: &#123;    data: [&quot;食品&quot;, &quot;数码&quot;, &quot;服饰&quot;, &quot;箱包&quot;],  &#125;,  yAxis: &#123;&#125;,  // 系列： 包括图表的类型 包括：line bar pie等  series: &#123;    type: &quot;bar&quot;,    data: [&quot;100&quot;, &quot;120&quot;, &quot;40&quot;, &quot;160&quot;],  &#125;,&#125;);</code></pre><p>2、dataset: 数据集</p><blockquote><p>ECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">const chartDom = document.getElementById(&quot;chart&quot;);const chart = echarts.init(chartDom);const option = &#123;  xAxis: &#123;    type: &quot;category&quot;,  &#125;,  yAxis: &#123;&#125;,  dataset: &#123;    source: [      [&quot;1季度&quot;, 80, 100, &quot;分类1&quot;, 50],      [&quot;2季度&quot;, 81, 122, &quot;分类1&quot;, 60],      [&quot;3季度&quot;, 76, 90, &quot;分类1&quot;, 55],      [&quot;4季度&quot;, 65, 123, &quot;分类1&quot;, 70],    ],  &#125;,  // 系列  series: [    // 系列 0    &#123;      type: &quot;pie&quot;,      center: [&quot;65%&quot;, 60],      radius: 35,      encode: &#123;        itemName: 3,        value: 4,      &#125;,    &#125;,    // 系列 1    &#123;      type: &quot;line&quot;,      encode: &#123;        x: 0,        y: 2,      &#125;,    &#125;,    // 系列 2    &#123;      type: &quot;bar&quot;,      encode: &#123;        x: 0,        y: 1,      &#125;,    &#125;,  ],&#125;;chart.setOption(option);</code></pre></details><p>3、基本组件</p><blockquote><p>echarts 基本组件：title、坐标系的 X（xAxis）轴 Y(yAxis）轴、tooltip 提示框、toolbox 工具栏等</p></blockquote><p>4、定位</p><pre><code class="js">// 大多数组件都提供了定位属性，我们可以采用类似 CSS absolute 的定位属性来控制组件的位置 left right height bottom的值可以是数值或者百分比var option = &#123;  grid: &#123;    left: 120,    right: &quot;30%&quot;,    height: &quot;40%&quot;,    bottom: 100,  &#125;,&#125;;</code></pre><h2 id="echarts-常用属性"><a href="#echarts-常用属性" class="headerlink" title="echarts 常用属性"></a>echarts 常用属性</h2><p>（1）使用 ECharts 绘图后没有图像（这个问题会经常出现，一定要设置宽度高度！！！）</p><blockquote><p>ECharts 绘图后没有任何报错，但是没有图像。可以检查容器是否设置了宽高。因为 ECharts 不会设置默认宽高，如果容器没有设置宽高，则不会展示;如果使用的是 v-chart 则没有这个问题，因为 v-chart 默认了 600*400 的宽高。</p></blockquote><p>（2）使用 element-ui 的按需引入</p><blockquote><p>安装<code>vue add element</code>，后续会提示是全部引入或者按需引入，选择按需引入，在 App.vue 中会增加一些 element-ui 的示例代码，后续删除。项目目录会增加一个 plugin 文件夹</p></blockquote><blockquote><p>注意：按需引入组件后，再删除 App.vue 以及 view 文件夹内、component 文件夹内的不需要的内容。</p></blockquote><pre><code class="js">// main.jsimport &quot;./plugins/element.js&quot;;</code></pre><pre><code class="js">// element.jsimport Vue from &quot;vue&quot;;import &#123; Card, Col, Row &#125; from &quot;element-ui&quot;;Vue.use(Card);Vue.use(Col);Vue.use(Row);</code></pre><p>（3）vue 使用 echarts</p><pre><code class="js">// main.js 引入echarts 挂载到Vue实例import ECharts from &quot;echarts&quot;;Vue.prototype.$echarts = ECharts;</code></pre><p>（4）echarts 的常用属性</p><blockquote><p>1、隐藏线条 - listStyle</p></blockquote><pre><code class="js">listStyle: &#123;  width: 0;&#125;</code></pre><blockquote><p>2、隐藏数据点 - itemStyle</p></blockquote><pre><code class="js">itemStyle: &#123;  opacity: 0;&#125;</code></pre><blockquote><p>3、折线图填充面积区域颜色 - areaStyle</p></blockquote><pre><code class="js">areaStyle: &#123;  color: &quot;purple&quot;;&#125;</code></pre><blockquote><p>4、折线图平滑显示 - smooth</p></blockquote><pre><code class="js">smooth: true;</code></pre><blockquote><p>5、柱状图聚合 - stack</p></blockquote><pre><code class="js">series: [  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [100],  &#125;,  &#123;    type: &quot;bar&quot;,    stack: &quot;总量&quot;,    data: [250],  &#125;,];</code></pre><blockquote><p>6、自定义绘图(重点)</p></blockquote><pre><code class="js">&#123;  type: &#39;custom&#39;,  stack: &#39;总量&#39;,  data: [100],  renderItem: (params, api) =&gt; &#123;    //  console.log(params,api);    const value = api.value(0)    const endPoint = api.coord([value, 0])    return &#123;      type: &#39;group&#39;,      position: endPoint,      children: [&#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M1024 255.996 511.971 767.909 0 255.996 1024 255.996z&#39;,// 这里是svg里面的d          x: -5,          y: -20,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;, &#123;        type: &#39;path&#39;,        shape: &#123;          d: &#39;M0 767.909l512.029-511.913L1024 767.909 0 767.909z&#39;,          x: -5,          y: 10,          width: 10,          height: 10,          layout: &#39;cover&#39;        &#125;,        style: &#123;          fill: &#39;#45c946&#39;        &#125;      &#125;]    &#125;  &#125;&#125;</code></pre><blockquote><p>7、xAxis x 轴</p></blockquote><pre><code class="js">// 消除x轴两侧边距boundaryGap: false// 柱状图宽度barWidth: &#39;60%&#39;barWidth: 10// 条形图 type设置方法xAxis: &#123;  type: &#39;value&#39;&#125;,yAxis: &#123;  type: &#39;category&#39;&#125;</code></pre><blockquote><p>8、echarts 类目轴和非类目轴</p></blockquote><blockquote><p>类目轴的意思就是坐标轴上的展示信息是否是数据连贯，非类目轴就是除了标签类型为类目的其他坐标轴，有 时间（time），数值（value），对数（log）3 种。标签类型为类目是指 type:category</p></blockquote><p>坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样。类目轴中  boundaryGap  可以配置为  true  和  false。默认为  true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap 是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置  min  和  max  后无效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18、如何使用canvas压缩图片？</title>
      <link href="/2020/04/10/canvas/"/>
      <url>/2020/04/10/canvas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>canvas 是 HTML5 的新特性，它允许我们使用 canvas 元素在网页上通过 JavaScript 绘制图像 （可以在 HTML 页面使用多个 canvas 元素）</p></blockquote><span id="more"></span><p><strong>1、绘图流程:</strong></p><pre><code class="js">// 1、编写canvas标签，指定宽高（注意）；&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;// 2、获取canvas DOM对象；const canvas = document.getElementById(&quot;canvas&quot;);// 3、获取Canvas对象；const ctx = canvas.getContext(&quot;2d&quot;); // 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法// 4、设置绘图属性；ctx.fillStyle = &quot;red&quot;; //设置填充色// 5、调用绘图API。ctx.fillRect(0, 0, 50, 50); // 绘制矩形</code></pre><p><strong>2、canvas 路径</strong></p><p>常用的方法：</p><p>（1）moveTo(x,y)–定义线条开始坐标</p><p>（2）lineTo(x,y)–定义线条结束坐标</p><p>示例 1、绘制线段</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath(); // 开始绘制路径ctx.lineWidth = 1; // 线条宽度ctx.strokeStyle = &quot;green&quot;; // 线条填充色ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); // 绘制线段</code></pre><p>示例 2、绘制圆形</p><p>arc(x,y,r,start,stop) x 轴 y 轴 r 半径</p><pre><code class="js">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.beginPath();ctx.lineWidth = 2;ctx.strokeStyle = &quot;green&quot;; // 圆形边框色ctx.fillStyle = &quot;red&quot;; // 圆形填充色ctx.arc(95, 50, 40, 0, 2 * Math.PI);ctx.stroke();</code></pre><p>示例 3、绘制矩形 （代码见绘图流程）</p><p><strong>3、使用 canvas 压缩图片</strong></p><pre><code class="html">&lt;!--编写input标签 指定type类型为file--&gt;&lt;input type=&quot;file&quot; id=&quot;upload&quot; /&gt;</code></pre><details><summary>压缩图片js代码(点击展开)</summary><pre><code class="js">// 设置上传图片类型  上传图片的容量大小const ACCEPT = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;]; // 限定图片文件类型const MAXSIZE = 1024 * 1024 * 3; // 限定图片最大容量const MAXSIZE_STR = &quot;3MB&quot;;function convertImageToBase64(file, cb) &#123;  let reader = new FileReader();  reader.addEventListener(&quot;load&quot;, function (e) &#123;    const base64Image = e.target.result; // 获取文件内容，等同于 reader.result    cb(base64Image);    reader = null;  &#125;);  reader.readAsDataURL(file); // 读取 file 对象中的内容&#125;// 图片是否压缩的判断function compress(base64Image, cb) &#123;  let maxW = 1024;  let maxH = 1024;  const image = new Image();  image.addEventListener(&quot;load&quot;, function () &#123;    let ratio; // 压缩比    let needCompress = false; // 是否需要压缩    if (maxW &lt; image.naturalWidth) &#123;      needCompress = true;      ratio = image.naturalWidth / maxW;      maxH = image.naturalHeight / ratio;    &#125;    if (maxH &lt; image.naturalHeight) &#123;      needCompress = true;      ratio = image.naturalHeight / maxH;      maxW = image.naturalWidth / ratio;    &#125;    if (!needCompress) &#123;      maxW = image.naturalWidth;      maxH = image.naturalHeight;    &#125;    const canvas = document.createElement(&quot;canvas&quot;);    canvas.setAttribute(&quot;id&quot;, &quot;__compress__&quot;);    canvas.width = maxW;    canvas.height = maxH;    canvas.style.visibility = &quot;hidden&quot;;    document.body.append(canvas);    // canvas画布    const ctx = canvas.getContext(&quot;2d&quot;);    ctx.clearRect(0, 0, maxW, maxH);    ctx.drawImage(image, 0, 0, maxW, maxH); // 渲染图片    const compressImage = canvas.toDataURL(&quot;image/jpeg&quot;, 0.9); // 压缩图片    cb(compressImage);    const _image = new Image();    _image.src = compressImage;    document.body.appendChild(_image);    canvas.remove(); // 移除 canvas  &#125;);  image.src = base64Image; // 将图片设置到 image 的 src 属性中  document.body.appendChild(image);&#125;// 上传给服务端function uploadImage(compressImage) &#123;  console.log(&quot;upload image to server...&quot;, compressImage);&#125;const upload = document.getElementById(&quot;upload&quot;);upload.addEventListener(&quot;change&quot;, function (e) &#123;  const file = e.target.files[0];  console.log(file);  if (!file) &#123;    return;  &#125;  const &#123; type: fileType, size: fileSize &#125; = file;  // 图片类型检查  if (!ACCEPT.includes(fileType)) &#123;    alert(&quot;不支持上传该格式文件！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 图片大小检查  if (fileSize &gt; MAXSIZE) &#123;    alert(&quot;文件超出&quot; + MAXSIZE_STR + &quot;！&quot;);    upload.value = &quot;&quot;;    return;  &#125;  // 压缩文件  convertImageToBase64(file, (base64Image) =&gt;    compress(base64Image, uploadImage)  );&#125;);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17、移动端300ms延迟在IOS11中的bug</title>
      <link href="/2020/02/20/mobile/"/>
      <url>/2020/02/20/mobile/</url>
      
        <content type="html"><![CDATA[<p>在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click</p><span id="more"></span><h2 id="移动端300ms延迟在IOS11中的bug"><a href="#移动端300ms延迟在IOS11中的bug" class="headerlink" title="移动端300ms延迟在IOS11中的bug"></a>移动端300ms延迟在IOS11中的bug</h2><blockquote><p>解决方案</p></blockquote><p>1、禁用缩放 更改默认视口宽度</p><pre><code class="js">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1&quot;&gt;</code></pre><p>2、fastclick解决300ms延迟问题<br>        首先，需要安装fastclick插件</p><pre><code class="js">npm install fastclick</code></pre><p>3、在main.js文件中引入fastclick，绑定到body上</p><pre><code class="js">import FastClick from &quot;fastclick&quot;FastClick.attach(document.body);</code></pre><p>这就是常用来解决移动端300ms延迟的方法。但是这种方法在iOS11的系统中存在bug。</p><p>4、iOS11系统中出现的bug<br>    在iOS11系统下，点击input输入框的时候会出现不灵敏的现象。</p><blockquote><p>解决方案:</p></blockquote><details><summary>点我展示代码</summary><pre><code class="js">&lt;script&gt;FastClick.prototype.focus = function (targetElement) &#123;  var length;  var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;  var deviceIsIos = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;  //兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError  //这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法  if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#39;date&#39;) !== 0 &amp;&amp; targetElement.type !== &#39;time&#39; &amp;&amp; targetElement.type !== &#39;month&#39;) &#123;    length = targetElement.value.length;    // 修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘    targetElement.setSelectionRange(length, length);  &#125; else &#123;    targetElement.focus();  &#125;&#125;&lt;/script&gt;</code></pre></details><blockquote><p>注意：<br>setSelectionRange是HTMLInputElement的一个方法,用来设定input textare的当前文本的起始位置和结束位置。<br>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement/setSelectionRange">MDN文档</a>）<br>对setSelectionRange方法只能用于类型为文本、搜索、连接、电话号码、密码的输入，以及在Chrome33开始访问其余类型的属性和方法抛出异常。<br>输入类型为数字时会抛出：“不能从’HTMLInputElement’中读取’selectionStart’属性：输入元素的类型(‘number’)不支持选择（Failed to read the ‘selectionStart’ property from ‘HTMLInputElement’: The input element’s type (‘number’) does not support selection）”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16、v-cloak解决页面闪烁问题</title>
      <link href="/2020/02/12/v-cloak/"/>
      <url>/2020/02/12/v-cloak/</url>
      
        <content type="html"><![CDATA[<p>这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{ display: none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p><span id="more"></span><p>很多时候，我们页面模板中的数据是异步获取的，在网络不好的情况下，渲染页面的时候会出现页面闪烁的效果，影响用户体验，v-cloak 指令保持在元素上直到关联实例结束编译，利用它的特性，结合 CSS 的规则 [v-cloak] { display: none } 一起使用就可以隐藏掉未编译好的 Mustache 标签，直到实例准备完毕。</p><pre><code class="html">&lt;div class=&quot;#app&quot; v-cloak&gt;    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">[v-cloak] &#123;    display: none;&#125;</code></pre><blockquote><p>需要注意，虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个loading动画或者骨架屏的效果，提升用户体验。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15、解决oh-my-zsh启动时出现多行提示</title>
      <link href="/2020/02/09/oh-my-zsh/"/>
      <url>/2020/02/09/oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<p>oh-my-zsh在启动时，出现很多行提示，仔细阅读发现是2个文件夹权限的问题，修改文件夹权限，添加命令即可解决。</p><span id="more"></span><h3 id="一、修改文件夹权限"><a href="#一、修改文件夹权限" class="headerlink" title="一、修改文件夹权限"></a>一、修改文件夹权限</h3><pre><code class="js">cd /usr/local/sharesudo chmod 755 zshcd /usr/local/share/zshsudo chmod 755 site-functions</code></pre><h3 id="二、-zshrc添加命令"><a href="#二、-zshrc添加命令" class="headerlink" title="二、.zshrc添加命令"></a>二、.zshrc添加命令</h3><pre><code class="js">// 根目录下添加下面的命令cd ~sudo vi .zshrc#写在  # User configuration  之后ZSH_DISABLE_COMPFIX=&quot;true&quot; #保存并退出esc -&gt; :wq </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14、整理javascript知识(二)</title>
      <link href="/2020/01/15/javascript-simple2/"/>
      <url>/2020/01/15/javascript-simple2/</url>
      
        <content type="html"><![CDATA[<p>JavaScript的闭包、作用域、原型链</p><span id="more"></span><h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><h5 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h5><blockquote><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，<u>闭包让你可以在一个内层函数中访问到其外层函数的作用域</u>。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。— from MDN</p></blockquote><p>javascript闭包的本质源自2点：词法作用域和函数当做值传递。</p><h5 id="2、词法作用域"><a href="#2、词法作用域" class="headerlink" title="2、词法作用域"></a>2、词法作用域</h5><blockquote><p>按照代码的书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这个变量就登记在相应的数据结构中。</p></blockquote><pre><code class="js">function init()&#123;    // 局部变量    var name = &#39;jude&#39;      // 内部函数，一个闭包    function displayName()&#123;        // 父函数中声明的变量        console.log(name)    &#125;    displayName()&#125;init()</code></pre><p>name、displayName()是init()函数的一个局部变量和一个内部函数，displayName()函数没有自己的局部变量，但是它可以访问到外部函数的变量，所以displayName()可以使用父函数init()中声明的变量name。</p><h5 id="3、函数当做值传递"><a href="#3、函数当做值传递" class="headerlink" title="3、函数当做值传递"></a>3、函数当做值传递</h5><blockquote><p>即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。</p></blockquote><p>闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。</p><h3 id="4、闭包的缺点：造成内存泄漏"><a href="#4、闭包的缺点：造成内存泄漏" class="headerlink" title="4、闭包的缺点：造成内存泄漏"></a>4、闭包的缺点：造成内存泄漏</h3><blockquote><p>如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。</p></blockquote><h4 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h4><h4 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h4><blockquote><p>作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。</p></blockquote><p>作用域分为函数作用域、全局作用域</p><blockquote><p>全局作用域：代码在程序任何地方都能访问，例如window对象<br>函数作用域： 固定代码片段中才能被访问</p></blockquote><p>JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。</p><p>每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this等。</p><p>作用域最大的用处：隔离变量，不同作用域下同名变量不会有冲突。</p><h4 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h4><blockquote><p>在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。</p></blockquote><p>⼀般情况下，变量取值到创建这个变量的函数的作⽤域中取值，但是如果在当前作⽤域中没有查到值，就会向上级作⽤域去查，直到查到全局作⽤域，这么⼀个查找过程形成的链条就叫做作⽤域链。</p><h4 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h4><blockquote><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找， 如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype， 如果还没有找到就会再在构造函数的prototype的__proto__中查找， 这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13、整理javascript知识(一)</title>
      <link href="/2020/01/12/javascript-simple/"/>
      <url>/2020/01/12/javascript-simple/</url>
      
        <content type="html"><![CDATA[<p>javascript 数据类型、类型检测、类型检测函数的封装（包括纯粹对象、空对象、window 对象）。</p><span id="more"></span><h3 id="一、基础类型及类型检测"><a href="#一、基础类型及类型检测" class="headerlink" title="一、基础类型及类型检测"></a>一、基础类型及类型检测</h3><h4 id="1、基础类型"><a href="#1、基础类型" class="headerlink" title="1、基础类型"></a>1、基础类型</h4><blockquote><p>JavaScript 数据类型包括：Null、Undefined、Boolean、Number、String、Symbol、Bigint(7 种原始类型)、Object(引用类型，包括 Object/Array/Date/Function/RegExp 等)</p></blockquote><p>原始类型保存在栈内存。</p><p>引用类型保存在堆内存，不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p><p>引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p><h4 id="2、类型检测"><a href="#2、类型检测" class="headerlink" title="2、类型检测"></a>2、类型检测</h4><h5 id="1-、typeof"><a href="#1-、typeof" class="headerlink" title="(1)、typeof"></a>(1)、typeof</h5><blockquote><p>7 种原始类型可以使用 typeof 操作符检查数据类型（其中，typeof null === ‘object’）</p></blockquote><p>检查 Object 派生出来的结构类型，使用 typeof 是不行的， 会一直 === ‘object’,通常使用 instanceof 检查 Object 种类（这样还是存在误差）。</p><h5 id="（2-、instanceof"><a href="#（2-、instanceof" class="headerlink" title="（2)、instanceof"></a>（2)、instanceof</h5><blockquote><p>instanceof 运算符是用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p></blockquote><p>Tips: 检测对象不是某个构造函数的实例</p><pre><code class="js">if (!(mycar instanceof Car)) &#123;  // do something&#125;// 上面代码和下面代码完全不同，下面的代码!mycar会在instanceof之前被验证if (!mycar instanceof Car) &#123;&#125;</code></pre><h5 id="（3-、Object-prototype-toString-call"><a href="#（3-、Object-prototype-toString-call" class="headerlink" title="（3)、Object.prototype.toString().call()"></a>（3)、Object.prototype.toString().call()</h5><blockquote><p>每个对象都有一个 toString()方法，可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。</p></blockquote><p>调用 Object.prototype.toString 会返回一个由 “[object “ 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。</p><p>(看了别人翻译的es5规范，讲解这个toString（）函数，如下：)<br>当toString方法被调用的时候，执行步骤为：</p><blockquote><p>1、如果 this 值是 undefined，就返回 [object Undefined]<br>2、如果 this 的值是 null，就返回 [object Null]<br>3、让 O 成为 ToObject(this) 的结果<br>4、让 class 成为 O 的内部属性 [[Class]] 的值<br>5、最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串</p></blockquote><pre><code class="js">// 以下是11种：var number = 1; // [object Number]var string = &quot;123&quot;; // [object String]var boolean = true; // [object Boolean]var und = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123; a: 1 &#125;; // [object Object]var array = [1, 2, 3]; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a() &#123;&#125;; // [object Function]function checkType() &#123;  for (var i = 0; i &lt; arguments.length; i++) &#123;    console.log(Object.prototype.toString.call(arguments[i]));  &#125;&#125;checkType(  number,  string,  boolean,  und,  nul,  obj,  array,  date,  error,  reg,  func);// 除了以上11种，还包括console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]// 还可以这样function a() &#123;  console.log(Object.prototype.toString.call(arguments)); // [object Arguments]&#125;a();</code></pre><h5 id="（4-、封装一个-type-函数"><a href="#（4-、封装一个-type-函数" class="headerlink" title="（4)、封装一个 type 函数"></a>（4)、封装一个 type 函数</h5><p>写一个 type 函数检测各种类型的值,考虑到兼容性（IE6，null 和 undefined 会被 Obejct.prototype.toString 识别为[object Obejct]）</p><pre><code class="js">var class2type = &#123;&#125;;// 生成class2type映射&quot;Boolean Number String Function Array Date RegExp Object Error&quot;  .split(&quot; &quot;)  .map(function (item, index) &#123;    class2type[&quot;[object &quot; + item + &quot;]&quot;] = item.toLowerCase();  &#125;);function type(obj) &#123;  // 一箭双雕  if (obj == null) &#123;    return obj + &quot;&quot;;  &#125;  return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;    ? class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;    : typeof obj;&#125;</code></pre><h5 id="（5-、函数类型的检测"><a href="#（5-、函数类型的检测" class="headerlink" title="（5)、函数类型的检测"></a>（5)、函数类型的检测</h5><pre><code class="js">// type函数function isFunction(obj) &#123;  return type(obj) === &quot;function&quot;;&#125;</code></pre><h5 id="（6-、纯粹对象的检测"><a href="#（6-、纯粹对象的检测" class="headerlink" title="（6)、纯粹对象的检测"></a>（6)、纯粹对象的检测</h5><p>什么是纯粹对象？</p><blockquote><p>该对象是通过 “{}” 或 “new Object” 创建的，该对象含有零个或者多个键值对。</p></blockquote><pre><code class="js">// 上面写 type 函数时，用来存放 toString 映射结果的对象var class2type = &#123;&#125;;// 相当于 Object.prototype.toStringvar toString = class2type.toString;// 相当于 Object.prototype.hasOwnPropertyvar hasOwn = class2type.hasOwnProperty;function isPlainObject(obj) &#123;  var proto, Ctor;  // 排除掉明显不是obj的以及一些宿主对象如Window  if (!obj || toString.call(obj) !== &quot;[object Object]&quot;) &#123;    return false;  &#125;  /**   * getPrototypeOf es5 方法，获取 obj 的原型   * 以 new Object 创建的对象为例的话   * obj.__proto__ === Object.prototype   */  proto = Object.getPrototypeOf(obj);  // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true  if (!proto) &#123;    return true;  &#125;  /**   * 以下判断通过 new Object 方式创建的对象   * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor   * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数   */  Ctor = hasOwn.call(proto, &quot;constructor&quot;) &amp;&amp; proto.constructor;  // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数  return (    typeof Ctor === &quot;function&quot; &amp;&amp;    hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object)  );&#125;</code></pre><h5 id="（7-、空对象的判断"><a href="#（7-、空对象的判断" class="headerlink" title="（7)、空对象的判断"></a>（7)、空对象的判断</h5><pre><code class="js">function isEmptyObject(obj) &#123;  var name;  for (name in obj) &#123;    return false;  &#125;  return true;&#125;</code></pre><h5 id="（8-、window-对象的判断"><a href="#（8-、window-对象的判断" class="headerlink" title="（8)、window 对象的判断"></a>（8)、window 对象的判断</h5><pre><code class="js">function isWindow(obj) &#123;  return obj != null &amp;&amp; obj === obj.window;&#125;</code></pre><h5 id="（9-、数组类型的检测"><a href="#（9-、数组类型的检测" class="headerlink" title="（9)、数组类型的检测"></a>（9)、数组类型的检测</h5><pre><code class="js">// 判断Array.isArray()方法是否存在，如果存在就使用该方法，不存在就使用type函数var isArray =  Array.isArray ||  function (obj) &#123;    return type(obj) === &quot;array&quot;;  &#125;;</code></pre><h5 id="（10-、类数组的判断"><a href="#（10-、类数组的判断" class="headerlink" title="（10)、类数组的判断"></a>（10)、类数组的判断</h5><p>满足的三个条件：</p><blockquote><p>1、是数组<br>2、长度为 0<br>3、lengths 属性是大于 0 的数字类型，并且 obj[length - 1]必须存在</p></blockquote><pre><code class="js">function isArrayLike(obj) &#123;  // obj 必须有 length属性  var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length;  var typeRes = type(obj);  // 排除掉函数和 Window 对象  if (typeRes === &quot;function&quot; || isWindow(obj)) &#123;    return false;  &#125;  return (    typeRes === &quot;array&quot; ||    length === 0 ||    (typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; length - 1 in obj)  );&#125;</code></pre><p>函数库的实现，如：underscore</p><pre><code class="js">var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;var isArrayLike = function (collection) &#123;  var length = getLength(collection);  return typeof length == &quot;number&quot; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;&#125;;</code></pre><h5 id="11-、判断是不是-DOM-元素"><a href="#11-、判断是不是-DOM-元素" class="headerlink" title="(11)、判断是不是 DOM 元素"></a>(11)、判断是不是 DOM 元素</h5><pre><code class="js">var isElement = function (obj) &#123;  return !!(obj &amp;&amp; obj.nodeType === 1);&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12、下拉框select银行卡号格式处理</title>
      <link href="/2019/12/29/select/"/>
      <url>/2019/12/29/select/</url>
      
        <content type="html"><![CDATA[<p>银行卡号显示为 6217 **** 0000 的格式</p><span id="more"></span><p>以选择银行卡为例：</p><pre><code class="js">    &lt;select v-model=&quot;selected&quot; class=&quot;selected&quot;&gt;        &lt;option disabled value v-show=&quot;showBankCard&quot;&gt;请选择提现到账的银行卡&lt;/option&gt;        &lt;option            v-for=&quot;item in BankCardList&quot;            :key=&quot;item.id&quot;            v-bind:value=&quot;item.id&quot;        &gt;            &#123;&#123; item.card_no &#125;&#125;        &lt;/option&gt;    &lt;/select&gt;</code></pre><pre><code class="js">item.card_no ? item.card_no.replace(/^(\d&#123;4&#125;)\d+(\d&#123;4&#125;)$/,&quot;$1****$2&quot;):&quot;&quot;// 银行卡号显示为 6217 **** 0000 的格式。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11、二维码的生成</title>
      <link href="/2019/12/28/qrcode/"/>
      <url>/2019/12/28/qrcode/</url>
      
        <content type="html"><![CDATA[<p>使用 qrcode 生成二维码</p><span id="more"></span><p>一、下载插件 qrcode 插件</p><pre><code class="js">    npm install qrcode --save</code></pre><p>二、在 main.js 中引用</p><pre><code class="js">import QRCode from &quot;qrcode&quot;;Vue.use(QRCode);</code></pre><p>三、组件中引入 QRCode</p> <details> <summary>点我展示代码</summary> <pre><code class="html">    &lt;template&gt;        &lt;div&gt;            &lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;</code></pre><pre><code class="js">    &lt;script&gt;      import QRCode from &#39;qrcode&#39;;      mounted()&#123;          this.CreateQrcode();      &#125;,      method:&#123;          setTimeout(() =&gt; &#123;              // 获取DOM节点              let dom = document.getElementById(&#39;qrcode);              // 路由传参              const res = this.$route.params;              const lbsid = res.id;              // 二维码包含的URL 需要将URL和id做一下字符串的拼接              let url = &#39;http://*********&#39;;              let URL = url.concat(lbsid);              let qrCode = new QRCode(dom,&#123;                  width:260, // 图像宽度                  height:260,  // 图像高度                  colorDark:&quot;#000000&quot;,  // 前景色                  colorLight:&quot;#ffffff&quot;, // 背景色                  correctLevel: QRCode.CorrectLevel.H  // 容错等级              &#125;);              qrCode.clear();              qrCode.makeCode(URL);          &#125;,100)      &#125;    &lt;/script&gt;    &lt;style lang=&quot;less&quot; scoped&gt;        #qrcode &#123;            display: inline-block;            margin-top: 6rem;            img &#123;                width: 60%;                height: 60%;                background-color: #fff; //设置白色背景色                padding: 6px; // 利用padding的特性，挤出白边  &#125;&#125;    &lt;/style&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10、微信公众号网页使用popstate事件</title>
      <link href="/2019/12/23/popstate/"/>
      <url>/2019/12/23/popstate/</url>
      
        <content type="html"><![CDATA[<p>如何在h5移动端禁止某一些页面使用虚拟返回键。</p><span id="more"></span><h3 id="1、popstate事件"><a href="#1、popstate事件" class="headerlink" title="1、popstate事件"></a>1、popstate事件</h3><p>MDN上是这样介绍popstate的：<br>    当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。<br>    需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）<br>    不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会。<br>    我负责的一个项目中，在微信公众号网页的某一个页面需要禁止使用微信浏览器的返回键。</p><h3 id="2、解决方式："><a href="#2、解决方式：" class="headerlink" title="2、解决方式："></a>2、解决方式：</h3><details><summary>点我展示代码</summary><pre><code class="js">// 在禁止返回的组件的methods中写一个方法forbidBackforbidBack()&#123;    window.history.pushState(&quot;forward&quot;,null,&quot;#&quot;);    window.history.forward(1);&#125;// 监听返回键，禁止返回之前的路由if(window.history &amp;&amp; window.history.pushState)&#123;    window.addEventListener(&quot;popstate&quot;,this.forbidBack,false);    this.forbidBack();&#125;//离开页面需要销毁监听window.removeEventListener(&quot;popstate&quot;,this.forbidBack,fasle);</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9、h5扫码功能的实现</title>
      <link href="/2019/12/20/h5-scan/"/>
      <url>/2019/12/20/h5-scan/</url>
      
        <content type="html"><![CDATA[<p>使用H5 API barcode实现扫码。</p><span id="more"></span><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;div @click=&quot;handleCloseScan&quot;&gt;X&lt;/div&gt;        &lt;div class=&quot;scan&quot;&gt;            &lt;div id=&quot;bcid&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;button @click=&quot;handleStartScan&quot;&gt;扫 码&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><details><summary>点击展示js代码</summary><pre><code class="js">    &lt;script&gt;        // 扫描对象        var scan = null;        methods:&#123;            // 开始扫描            handleStartScan()&#123;                const that = this;                if(!window.plus) return;                scan = new plus.barcode.Barcode(&#39;bcid&#39;);                // 开始扫描                scan.start();                // 扫码成功之后的回调函数 type是类型 result 结果                scan.onmarked = function(type,result)&#123;                    const text = &#39;&#39;;                    switch(type)&#123;                        case plus.barcode.QR:                            type = &#39;QR&#39;;                            break;                        case plus.barcode.EAN13:                            type = &quot;EAN13&quot;;                            break;                        case plus.barcode.EAN8:                            type = &quot;EAN8&quot;;                            break;                        default:                            type = &quot;其它&quot; + type;                            break;                    &#125;                    result = result.replace(/\n/g,&quot;&quot;);                    const id = result.match(/\d+/)[0];                    that.$router.push(&#123;                        name:&#39;ComponentName&#39;,                        params: &#123;                            id:id                        &#125;                    &#125;);                    scan.close();                &#125;            &#125;,            // 关闭扫描控件            handleCloseScan()&#123;                 if(!window.plus) return;                 scan.close();                 this.$router.push(&#39;/&#39;);            &#125;        &#125;&#125;    &lt;/script&gt;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、解决Vue项目热更新打包时间过长</title>
      <link href="/2019/12/11/hot/"/>
      <url>/2019/12/11/hot/</url>
      
        <content type="html"><![CDATA[<p>维护公司一个项目的时候，发现在项目启动、热更新和打包项目的时候，时间长的“感人”。</p><span id="more"></span><p>当你改动项目的一些地方想要立即看到效果的时候，却发现热更新的编译过程却花了你很长时间，“心态崩了。。。”。</p><h3 id="1、解决Vue项目热更新打包时间过长"><a href="#1、解决Vue项目热更新打包时间过长" class="headerlink" title="1、解决Vue项目热更新打包时间过长"></a>1、解决Vue项目热更新打包时间过长</h3><p>解决方法：</p><p>1、使用html-webpack-plugin-for-multihtml插件</p><p>2、在build-webpack.dev.conf.js文件中</p><pre><code class="js">    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    // 替换成    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin-for-multihtml&#39;);</code></pre><p>3、multihtmlCache:true  解决多页热部署的关键</p><pre><code class="js">for (var pathname in pages) &#123;  // 配置生成的html文件，定义路径等  var conf = &#123;    filename: pathname + &#39;.html&#39;,    template: pages[pathname],   // 模板路径    inject: true,              // js插入位置    multihtmlCache: true,    // 解决多页热部署的关键 这里这里这里这里这里很重要！！！    // necessary to consistently work with multiple chunks via CommonsChunkPlugin    chunksSortMode: &#39;dependency&#39;  &#125;;  if (pathname in devWebpackConfig.entry) &#123;    conf.chunks = [&#39;manifest&#39;,&#39;vendor&#39;, pathname];    conf.hash = false;  &#125;  devWebpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;</code></pre><p>4、router.js中使用路由懒加载</p><p>这时候再启动项目，热更新、编译和打包的速度会大大提升。</p><h3 id="2、项目打包由4M变为1M"><a href="#2、项目打包由4M变为1M" class="headerlink" title="2、项目打包由4M变为1M"></a>2、项目打包由4M变为1M</h3><p>公司有一个H5微信公众号网页的项目，项目打包之后文件有4M；</p><p>修改webpack.prod.conf.js里的UglifyJsPlugin，这里的意思是打包后不产生后缀名为.map的文件。</p><pre><code class="javascript">webpack.prod.conf.js    new UglifyJsPlugin(&#123;      uglifyOptions: &#123;        compress: &#123;          warnings: false        &#125;      &#125;,      // sourceMap: config.build.productionSourceMap, 将这行代码注释掉。      parallel: true    &#125;)</code></pre><p>处理后打包的文件的大小为1M</p>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、markdown语法</title>
      <link href="/2019/12/05/markdown/"/>
      <url>/2019/12/05/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown语法整理</p><span id="more"></span><p>Markdown标题</p><p>使用#号标记，使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><p>1、Markdown段落</p><p>段落的换行是使用两个以上空格加上回车。</p><blockquote><p>字体:</p></blockquote><pre><code>*斜体文本*</code></pre><pre><code>_斜体文本_</code></pre><pre><code>**粗体文本**</code></pre><pre><code>__粗体文本__</code></pre><pre><code>***粗斜体文本***</code></pre><pre><code>___粗斜体文本___</code></pre><blockquote><p>分割线</p></blockquote><pre><code>**** * ******- - -----------</code></pre><blockquote><p>删除线、下划线、脚注</p></blockquote><pre><code>~~删除线~~&lt;u&gt;下划线&lt;/u&gt;[^Vue]:Vuejs是目前最流行的web开发框架之一。</code></pre><p>2、Markdown列表</p><p>Markdown 支持有序列表和无序列表。</p><p>（1）、无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>（2）、有序列表：有序列表使用数字并加上 . 号来表示。</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>（3）、列表嵌套：列表嵌套只需在子列表中的选项前面添加四个空格即可</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>4、Markdown区块</p><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>区块的嵌套</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>区块中使用列表</p></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>列表中使用区块</p></blockquote><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><pre><code>* 第一项    &gt; vuejs    &gt; JavaScript框架* 第二项</code></pre><p>5、Markdown链接和图片</p><blockquote><p>链接</p></blockquote><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><blockquote><p>图片</p></blockquote><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p>6、Markdown表格</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>我们可以设置表格的对齐方式：</p><pre><code>-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、Vue实现模糊搜索</title>
      <link href="/2019/11/13/mohu-search/"/>
      <url>/2019/11/13/mohu-search/</url>
      
        <content type="html"><![CDATA[<p>利用computed计算属性实现模糊搜索</p><span id="more"></span><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;搜索&quot; v-model=&quot;sousuo&quot;&gt;    &lt;table border=&quot;1&quot;&gt;      &lt;th&gt;编号&lt;/th&gt;      &lt;th&gt;英雄&lt;/th&gt;      &lt;th&gt;技能&lt;/th&gt;      &lt;tr v-for=&quot;(item,index) in sousuo1()&quot; :key=&quot;item.id&quot;&gt;        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;item.jn&#125;&#125;&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;  &lt;/div&gt;</code></pre><p>利用computed计算属性</p><details><summary>点我展示代码</summary><pre><code class="javascript">var app = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    sousuo: &#39;&#39;,    list: [&#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;艾希&quot;,        &quot;jn&quot;: &quot;射箭&quot;      &#125;, &#123;        &quot;id&quot;: 2,        &quot;name&quot;: &quot;狐狸&quot;,        &quot;jn&quot;: &quot;魅惑&quot;      &#125;, &#123;        &quot;id&quot;: 3,        &quot;name&quot;: &quot;猴子&quot;,        &quot;jn&quot;: &quot;棍子&quot;      &#125;, &#123;        &quot;id&quot;: 4,        &quot;name&quot;: &quot;盖伦&quot;,        &quot;jn&quot;: &quot;大宝剑&quot;      &#125;, &#123;        &quot;id&quot;: 5,        &quot;name&quot;: &quot;德邦&quot;,        &quot;jn&quot;: &quot;尖枪&quot;      &#125;, &#123;        &quot;id&quot;: 6,        &quot;name&quot;: &quot;皇子&quot;,        &quot;jn&quot;: &quot;旗子&quot;      &#125;,    ]  &#125;,  computed: &#123; //设置计算属性    Search() &#123;      if (this.sousuo) &#123;        return this.list.filter((value) =&gt; &#123; //过滤数组元素  this.list就是上面的那个死数据          return value.name.includes(this.sousuo); // 查看value.name里面包含不包含输入的字体          &#125;); //this.sousuo跟上面的输入框是双重绑定      &#125;    &#125;  &#125;,  methods: &#123;    sousuo1() &#123;      if (!this.sousuo) &#123;        return this.list;      &#125;      return this.Search    &#125;  &#125;,&#125;)</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、Vue2基础知识</title>
      <link href="/2019/09/26/vue-simple/"/>
      <url>/2019/09/26/vue-simple/</url>
      
        <content type="html"><![CDATA[<p>Vue基础知识点，包括常用指令、计算属性、侦听属性等。</p><span id="more"></span><h2 id="Vuejs响应式原理"><a href="#Vuejs响应式原理" class="headerlink" title="Vuejs响应式原理"></a>Vuejs响应式原理</h2><pre><code>编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。</code></pre><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快: 相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。</p><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h2 id="vue组件中data必须是一个函数？"><a href="#vue组件中data必须是一个函数？" class="headerlink" title="vue组件中data必须是一个函数？"></a>vue组件中data必须是一个函数？</h2><p>官网上是这样写的：</p><blockquote><p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，可能会影响到其它所有实例。</p></blockquote><p>当创建Vue实例时，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p><h2 id="v-if和v-show有什么区别？"><a href="#v-if和v-show有什么区别？" class="headerlink" title="v-if和v-show有什么区别？"></a>v-if和v-show有什么区别？</h2><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>计算属性computed：</p><p>支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><p>侦听属性watch：</p><p>不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：<br>immediate：组件加载立即触发回调函数执行</p><pre><code class="js">watch: &#123;  firstName: &#123;    handler(newName, oldName) &#123;      this.fullName = newName + &#39; &#39; + this.lastName;    &#125;,    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法    immediate: true  &#125;&#125;</code></pre><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p><pre><code class="js">watch: &#123;  obj: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    deep: true  &#125;&#125;</code></pre><p>优化：我们可以使用字符串的形式监听</p><pre><code class="js">watch: &#123;  &#39;obj.a&#39;: &#123;    handler(newName, oldName) &#123;      console.log(&#39;obj.a changed&#39;);    &#125;,    immediate: true,    // deep: true  &#125;&#125;</code></pre><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h2 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h2><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。<br>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p><h2 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h2><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><blockquote><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p></blockquote><p>v-for提升性能的原因:</p><p>key相同时，两个VNode会相同，可以避免不必要的DOM更新；而且在diff内部，也会根据key来跟踪VNode。</p><h2 id="双向数据绑定原理是什么？"><a href="#双向数据绑定原理是什么？" class="headerlink" title="双向数据绑定原理是什么？"></a>双向数据绑定原理是什么？</h2><blockquote><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><p>主要分为以下几个步骤：</p><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>①在自身实例化时往属性订阅器(dep)里面添加自己<br>②自身必须有一个update()方法<br>③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h2 id="vue-router路由页面管理"><a href="#vue-router路由页面管理" class="headerlink" title="vue-router路由页面管理"></a>vue-router路由页面管理</h2><blockquote><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote><p>包含的功能有：</p><p>1、嵌套的路由/视图表</p><p>2、模块化的、基于组件的路由配置</p><p>3、路由参数、查询、通配符</p><p>4、基于 Vue.js 过渡系统的视图过渡效果</p><p>5、细粒度的导航控制</p><p>6、带有自动激活的 CSS class 的链接</p><p>7、HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p><p>8、自定义的滚动条行为</p><blockquote><p>1、动态路由匹配</p></blockquote><p>例如：对不同ID的用户，使用同一个组件来渲染。</p><pre><code class="js">const User = &#123;  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;&#125;const router = new VueRouter(&#123;  routes: [    // 动态路径参数 以冒号开头    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)</code></pre><p>这样/user/foo 和 /user/bar 都将映射到相同的路由User。</p><p>一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;</code></pre><blockquote><p>2、编程式的导航<br>router.push({name:””,params:{}})</p></blockquote><pre><code class="js">  （1）this.$router.push  // 带参数  this.$router.push(&#123;    name:&quot;User&quot;,    params:&#123;      userId:&quot;123&quot;    &#125;  &#125;)</code></pre><p>router.push({path:””,query:””})</p><pre><code class="js">  (2) this.$router.push(&#123;    path:&quot;/user&quot;,    query:&#123;      plan:&quot;private&quot;    &#125;  &#125;)</code></pre><p>router.replace()使用方法跟router.push()很像，不会向history添加新纪录，替换掉当前的history记录。<br>router.go()在history记录中向前或者向后多少步。正数为向前多少步，负数为向后多少步</p><blockquote><p>3、滚动行为</p></blockquote><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><blockquote><p>注意：这个功能只在支持 history.pushState 的浏览器中可用。</p></blockquote><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;  if (savedPosition) &#123;    return savedPosition  &#125; else &#123;    return &#123; x: 0, y: 0 &#125;  &#125;&#125;</code></pre><blockquote><p>4、路由懒加载</p></blockquote><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名chunk，一个特殊的注释语法来提供chunk name(需要 Webpack &gt; 2.4)。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><h2 id="表单输入控制"><a href="#表单输入控制" class="headerlink" title="表单输入控制"></a>表单输入控制</h2><blockquote><p>表单修饰符：如果是简单的控制输入一定是数字或者去掉用户输入的收尾空白符，可以直接使用 Vue 提供的表单修饰符 .number 和 .trim</p></blockquote><p>1、如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><pre><code class="vue">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre><p>2、如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><pre><code class="vue">&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre><blockquote><p>change事件:给表单绑定事件，在事件处理中进行表单输入控制</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value2&quot; type=&quot;text&quot; @change=&quot;inputChange(value2)&quot; /&gt;</code></pre><pre><code class="js">methods: &#123;  inputChange: function(val) &#123;    if (!val) return &#39;&#39;    val = val.toString()    this.value2 = val.charAt(0).toUpperCase() + val.slice(1)  &#125;&#125;</code></pre><blockquote><p>filter过滤器</p></blockquote><pre><code class="html">&lt;input v-model=&quot;value1&quot;  type=&quot;text&quot; /&gt;</code></pre><pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;  if (!value) return &#39;&#39;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)</code></pre><pre><code class="js">watch: &#123;  value1(val) &#123;     this.value1 = this.$options.filters.capitalize(val);  &#125;&#125;</code></pre><blockquote><p>指令:声明一个全局指令</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// 只能输入正整数,0-9的数字Vue.directive(&#39;enterIntNumber&#39;, &#123;  inserted: function (el) &#123;    let trigger = (el, type) =&gt; &#123;      const e = document.createEvent(&#39;HTMLEvents&#39;)      e.initEvent(type, true, true)      el.dispatchEvent(e)    &#125;    el.addEventListener(&quot;keyup&quot;, function (e) &#123;      let input = e.target;      let reg = new RegExp(&#39;^\\d&#123;1&#125;\\d*$&#39;);  //正则验证是否是数字      let correctReg = new RegExp(&#39;\\d&#123;1&#125;\\d*&#39;);  //正则获取是数字的部分      let matchRes = input.value.match(reg);      if (matchRes === null) &#123;        // 若不是纯数字 把纯数字部分用正则获取出来替换掉        let correctMatchRes = input.value.match(correctReg);        if (correctMatchRes) &#123;          input.value = correctMatchRes[0];        &#125; else &#123;          input.value = &quot;&quot;;        &#125;      &#125;      trigger(input, &#39;input&#39;)    &#125;);  &#125;&#125;);</code></pre></details><pre><code class="html">&lt;!--限制输入正整数--&gt;&lt;input v-enterIntNumber placeholder=&quot;0&quot; type=&quot;number&quot;&gt;</code></pre><h1 id="Vue渲染目标元素的6种方法"><a href="#Vue渲染目标元素的6种方法" class="headerlink" title="Vue渲染目标元素的6种方法"></a>Vue渲染目标元素的6种方法</h1><p>1、直接创建Vue实例</p><details><summary>点击展示代码</summary><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- 这里直接引入cdn源码 --&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    template: &quot;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&quot;,    data()&#123;      return&#123;        message:&#39;Hello Vue.js!&#39;      &#125;    &#125;  &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></details><p>2、Vue.extend</p><blockquote><p>Vue.extend(options) 方式是使用Vue构造器的一个“子类”，其参数同Vue(options)一模一样，唯一的不同是没有 el 属性来指定挂载的DOM元素，所以这里需要通过 $mount() 方法，来手动实现挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  var app = Vue.extend(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello extend&#39;      &#125;    &#125;  &#125;)  // 注意这里 Vue.extend 方式是生成了一个 Vue 子类，所以需要 new关键字来重新创建，然后手动挂载。  new app().$mount(&#39;#app&#39;);  &lt;/script&gt;</code></pre></details><p>3.Vue.component</p><blockquote><p>Vue.component(id, [definition])方式是注册一个名称为id的全局组件，然后我们可以通过使用该组件来，实现目标元素渲染。其中definition 参数同 Vue.extend 中的参数一模一样，方法一样，需要使用$mount()方法手动挂载。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  // var app = Vue.component(&#39;hello&#39;, &#123;  //     template:&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,  //   data() &#123;  //     return &#123;  //       msg: &#39;hello component&#39;  //     &#125;  //   &#125;  // &#125;)  // new app().$mount(&#39;#app&#39;)  //1、 注册组件  Vue.component(&#39;hello&#39;, &#123;    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,    data() &#123;      return &#123;        msg: &#39;hello component&#39;      &#125;    &#125;  &#125;)  // 2、创建Vue实例  new Vue(&#123;    el: &quot;#app&quot;,    template: &#39;&lt;hello /&gt;&#39;  &#125;)  &lt;/script&gt;</code></pre><blockquote><p>仅仅注册组件式不够的，我们还要通过创建一个Vue实例，才能使用该组件。</p></blockquote></details><p>4、Vue.directive自定义指令</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;div v-hello=&quot;msg&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;  Vue.directive(&#39;hello&#39;, &#123;    bind: function(el, binding) &#123;      el.innerHTML = &quot;&lt;h1&gt;&quot; + binding.value + &quot;&lt;/h1&gt;&quot;    &#125;  &#125;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello directive 自定义指令&quot;      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>5、Vue.compile</p><blockquote><p>Vue.compile(template) 参数也就是 template 模板字符串属性，然后通过替换 Vue实例的 render 函数，来实现渲染。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;      // 参数就是template模板字符串  然后通过替换Vue实例的render函数来实现渲染  var tpl = Vue.compile(&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;&#39;)  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &quot;hello,compile&quot;      &#125;    &#125;,    render: tpl.render  &#125;)  &lt;/script&gt;</code></pre></details><p>6、render</p><blockquote><p>Vue实例在创建的过程中也会调用 render 函数，render 函数默认会传递一个参数,我们可以通过 createElement 来动态创建一个 VNode，以此来渲染目标元素</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;script&gt;  new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        msg: &#39;hello,render&#39;      &#125;    &#125;,    render: function(createElement) &#123;      return createElement(&#39;h1&#39;, this.msg)    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><h1 id="data-computed-watch"><a href="#data-computed-watch" class="headerlink" title="data/computed/watch"></a>data/computed/watch</h1><p>1、data</p><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;        &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        list: [&#123;          name: &#39;vue js&#39;,          url: &#39;https://cn.vuejs.org&#39;        &#125;, &#123;          name: &#39;github&#39;,          url: &#39;https://github.com&#39;        &#125;, &#123;          name: &#39;blog&#39;,          url: &#39;issummer.cn&#39;        &#125;]      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.list.push(&#123;          name: &#39;baidu&#39; + this.count,          url: &#39;https://www.baidu.com&#39;        &#125;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>2、computed</p><blockquote><p>computed 中的属性是需要先进行计算，然后再返回想要的数据的。当我们输出某个属性，必须依赖另外一个 data 中的属性来动态计算获得的，此时使用 computed 就非常简单了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;      &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;      &lt;ul&gt;          &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;              &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;          &lt;/li&gt;      &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        count: 1,        // 这里是后台数据        requestList: [          &#39;vuejs https://cn.vuejs.org&#39;,          &#39;github https://github.com&#39;,          &#39;blog https://issummer.cn&#39;        ]      &#125;    &#125;,    computed: &#123;      list: function() &#123;        var list = []        this.requestList.map(function(item, index) &#123;          var tempArr = item.split(&#39;-&#39;)          list.push(&#123;            name: tempArr[0],            url: tempArr[1]          &#125;)        &#125;)        return list      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.count++        this.requestList.push(&#39;blog&#39; + this.count + &#39;issummer.cn&#39;)      &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><blockquote><p>计算是可以修改的,计算属性不仅可以定义为一个函数，也可以定义为一个含有 get/set 属性的对象。当我们定义为一个函数是，Vue 内部会默认将这个函数赋值给 get 属性，一般 set 是未定义的。当我们定义 set 属性后，就可以对它进行修改了。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;    &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;  &lt;/div&gt;  &lt;script&gt;  var app = new Vue(&#123;    el: &quot;#app&quot;,    data() &#123;      return &#123;        firstName: &#39;Jude&#39;,        lastName: &#39;Summer&#39;      &#125;    &#125;,    computed: &#123;      username: &#123;        get: function() &#123;          return this.firstName + &#39; &#39; + this.lastName        &#125;,        set: function(newVal) &#123;          var names = newVal.split(&#39; &#39;);          this.firstName = names[0];          this.lastName = names[1];        &#125;      &#125;    &#125;,    methods:&#123;        changeName()&#123;            if(this.username === &#39;Jude Summer&#39;)&#123;                this.username = &quot;YQ&quot;            &#125;else&#123;                this.username = &#39;Jude Summer&#39;            &#125;        &#125;    &#125;  &#125;)  &lt;/script&gt;</code></pre></details><p>3、watch侦听器</p><blockquote><p>创建 Vue 应用时，我们还提到过 watch 这个属性，它其实是个对象，键是需要观察的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。和上面的计算属性类似，他可以监听 值/表达式 的变化来执行回调函数。</p></blockquote><details><summary>点击展示代码</summary><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;        &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;        &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    firstName: &#39;Jude&#39;,                    lastName: &#39;Summer&#39;,                    username: &#39;Jude Summer&#39;                &#125;            &#125;,            watch: &#123;                firstName: function (val, oldVal) &#123;                    this.username = val + &#39; &#39; + this.lastName;                &#125;,                lastName: function (val, oldVal) &#123;                    this.username = this.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                changeName() &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.firstName = &quot;Y&quot;;                        this.lastName = &quot;Q&quot;;                    &#125; else &#123;                        this.firstName = &quot;Jude&quot;;                        this.lastName = &quot;Summer&quot;;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 监听对象属性    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 此时无论我们如何点击按钮，都无法改变 username 的值，因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听                userinfo: function (val, oldVal) &#123;                    this.username = val.firstName + &#39; &#39; + val.lastName;                &#125;            &#125;,            methods: &#123;                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 上面的方法是无法修改username的值 因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听。实际上对于侦听的值是可以为一个对象的，它还有个 deep 属性，用来设置是否侦听内部属性的变化，而回调函数是通过 handler 来设置的     &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // depp属性用来侦听内部属性变化，回调函数是通过hander来设置                // 适用于非整体赋值  也就是适用于局部修改属性，这个时候通过设置deep属性为true，来达到侦听目的。                userinfo: &#123;                    deep: true,                    handler: function (val, oldVal) &#123;                        this.username = val.firstName + &quot; &quot; + val.lastName;                    &#125;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;    // 写成对象属性访问表达式的    当侦听对象包含很多属性，而我们只是需要监听其中的一个或某几个属性，这时如果我们通过这种方式侦听所有内部属性的变化，自然就会造成内存的浪费。那么我们可以只侦听单一内部属性的变化    &lt;script&gt;        var app = new Vue(&#123;            el: &quot;#app&quot;,            data() &#123;                return &#123;                    userinfo: &#123;                        firstName: &#39;Jude&#39;,                        lastName: &#39;Summer&#39;                    &#125;,                    username: &quot;Jude Summer&quot;                &#125;            &#125;,            watch: &#123;                // 侦听对象的某个属性                &#39;userinfo.lastName&#39;:function(val,oldVal)&#123;                    this.username = this.userinfo.firstName + &#39; &#39; + val;                &#125;            &#125;,            methods: &#123;                // 修改名字                changeName: function () &#123;                    if (this.username === &#39;Jude Summer&#39;) &#123;                        // this.userinfo.firstName = &#39;Y&#39;                        this.userinfo.lastName = &#39;Q&#39;                    &#125; else &#123;                        // this.userinfo.firstName = &quot;Jude&quot;                        this.userinfo.lastName = &quot;Summer&quot;                    &#125;                &#125;            &#125;,        &#125;)    &lt;/script&gt;</code></pre></details><h1 id="v-on对象语法"><a href="#v-on对象语法" class="headerlink" title="v-on对象语法"></a>v-on对象语法</h1><blockquote><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p></blockquote><p>通常的写法：</p><pre><code class="html">&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</code></pre><p>对象语法: </p><pre><code class="html">&lt;div v-on=&quot;&#123; mouseenter: ShowInfo, mouseleave: HideInfo &#125;&quot;&gt;  &lt;div&gt;我是title&lt;/div&gt;  &lt;div v-show=&quot;ShowWrapper&quot;&gt;我是显示的内容！&lt;/div&gt;&lt;/div&gt;</code></pre><h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><blockquote><p>有时候，我们需要将router-link渲染成某种标签，例如<code>&lt;li&gt;&lt;/li&gt;</code>使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航</p></blockquote><p>示例:</p><pre><code class="html">&lt;ul class=&quot;nav-list&quot;&gt;  &lt;router-link tag=&quot;li&quot; to=&quot;home&quot;&gt;home&lt;/router-link&gt;&lt;/ul&gt;&lt;!-- 渲染的结果为 --&gt;&lt;li&gt;home&lt;/li&gt;</code></pre><h1 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h1><blockquote><p>可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。提供具名插槽或需要接收 prop 的插槽。</p></blockquote><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div class=&quot;common-card&quot;&gt;    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;value&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt;    &lt;div class=&quot;chart&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;total&quot;&gt;      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="html">&lt;!-- 子组件 --&gt;  &lt;common-card title=&quot;今日交易用户数&quot; :value=&quot;1234567890&quot;&gt;    &lt;template&gt;      &lt;v-chart :options=&quot;getOptions()&quot; /&gt;    &lt;/template&gt;    &lt;template v-slot:footer&gt;      &lt;span&gt;退货率&lt;/span&gt;      &lt;span class=&quot;emphasis&quot;&gt;12%&lt;/span&gt;    &lt;/template&gt;  &lt;/common-card&gt;</code></pre><h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote><p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p></blockquote><blockquote><p>常用于父组件与子组件的通信<br>对象语法选项包括:</p></blockquote><p>1、type：原生构造函数的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。</p><p>2、default: any 默认值</p><p>3、required:Boolean 该prop是否是必填项</p><p>4、validator: Function 校验函数</p><pre><code class="js">  props: &#123;    // 检测类型    title: String,    // 检测类型 + 其他验证    age: &#123;      type: Number, //类型      default: 0,// 默认值      required: true,// 是否是必填项      // 校验函数      validator: function (value) &#123;        return value &gt;= 0      &#125;    &#125;  &#125;</code></pre><h1 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h1><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote><p>1、实现原理</p><blockquote><p>将用户传入的对象与 Vue 自身的options属性合并，合并后的对象将会覆盖原来的Vue.options。因为 mixin 方法修改了Vue.options属性，之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。</p></blockquote><p>注意：如果用户传入的对象与组件有相同的数据对象，将会发生合并，并且遵循组件数据优先的原则。对于钩子函数来说，如果相同，将会合并为一个数组，所以都会被调用，只是混入对象的钩子会被先调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><pre><code class="js">// vue源码 vue/src/core/global-api/mixin.jsimport &#123; mergeOptions &#125; from &#39;../util/index&#39;export function initMixin (Vue: GlobalAPI) &#123;  Vue.mixin = function (mixin: Object) &#123;    this.options = mergeOptions(this.options, mixin)    return this  &#125;&#125;</code></pre><p>2、如何理解mixin?</p><p>可以将mixin理解为数组，数组中有单个或者多个mixin，mixin的本质就是js对象，拥有Vue实例的所有属性，例如：data,created,methods等，还可以在mixin中再次嵌套mixin</p><p>注意：在组件中引入的方式为 <code>mixins:[myMixin]</code></p><p>3、mixin的实现</p><blockquote><p>当Vue在实例的时候，会调用mergeOptions函数进行options的合并</p></blockquote><details><summary>点击展示代码</summary><pre><code class="js">// vue源码 core/util/options.jsexport function mergeOptions(  parent: Object,  child: Object,  vm?: Component): Object &#123;  ...  // 如果有 child.extends 递归调用 mergeOptions 实现属性拷贝  const extendsFrom = child.extends  if (extendsFrom) &#123;    parent = mergeOptions(parent, extendsFrom, vm)  &#125;  // 如果有 child.mixins 递归调用 mergeOptions 实现属性拷贝  if (child.mixins) &#123;    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;      parent = mergeOptions(parent, child.mixins[i], vm)    &#125;  &#125;  // 申明 options 空对象，用来保存属性拷贝结果  const options = &#123;&#125;  let key  // 遍历 parent 对象，调用 mergeField 进行属性拷贝  for (key in parent) &#123;    mergeField(key)  &#125;  // 遍历 child 对象，调用 mergeField 进行属性拷贝  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123;      mergeField(key)    &#125;  &#125;  // 属性拷贝实现方法 mergeField 函数接收一个 key，首先会申明 strat 变量，如果 strats[key] 为真，就将 strats[key] 赋值给 strat。  function mergeField(key) &#123;    // 穿透赋值，默认为 defaultStrat    const strat = strats[key] || defaultStrat    options[key] = strat(parent[key], child[key], vm, key)  &#125;  return options&#125;</code></pre></details><blockquote><p>vue 中 mixins 的优先级，component &gt; mixins &gt; extends。</p></blockquote><h1 id="边界处理：inject-provide"><a href="#边界处理：inject-provide" class="headerlink" title="边界处理：inject/provide"></a>边界处理：inject/provide</h1><p>类型：</p><blockquote><p>provide：Object | () =&gt; Object</p></blockquote><blockquote><p>inject：Array<string> | { [key: string]: string | Symbol | Object }</p></blockquote><p>provide和inject需要一起使用，可以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件的层次有多深，并在其上下游关系成立的时间里始终生效。</p><p>同react的上下文特性相似</p><details><summary>点击展示代码</summary><pre><code class="js">// 父级组件提供 &#39;foo&#39;var Provider = &#123;  provide: &#123;    foo: &#39;bar&#39;  &#125;,  // ...&#125;// 子组件注入 &#39;foo&#39;var Child = &#123;  inject: [&#39;foo&#39;],  created () &#123;    console.log(this.foo) // =&gt; &quot;bar&quot;  &#125;  // ...&#125;</code></pre></details><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单的说，vuex就是一个状态管理器。</p></blockquote><p>开发过程，通常会遇到多个视图依赖同一个状态，不同视图的行为需要变更为同一状态（例如：后台管理系统的侧边栏的收缩功能。）</p><p>Vuex的核心就是store，它就是一个仓库容器，包含了驱动应用的数据源（state），不同于单纯的全局对象，vuex的状态存储是响应式的，当 Vue组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、DOMContentLoaded</title>
      <link href="/2019/08/18/DOMContentLoaded/"/>
      <url>/2019/08/18/DOMContentLoaded/</url>
      
        <content type="html"><![CDATA[<p>DOMContentLoaded顾名思义就是DOM内容加载完毕。</p><span id="more"></span><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。另一个不同的事件 load 应该仅用于检测一个完全加载的页面。 这里有一个常见的错误，就是在本应使用 DOMContentLoaded 会更加合适的情况下，却选择使用 load，所以要谨慎。<br>注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。</p><p>在Vue项目的App.vue中，我们可以这样设置字体。</p><p>1、获取HTML元素；</p><p>2、根据屏幕宽度动态计算fontSize</p><p>3、当fontSize大于50时，设置最大值为50</p><p>4、设置HTML的fontSize属性，使rem生效，1rem = fontSize + “px”</p><pre><code class="js">&lt;script&gt;// DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。  document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;    // 获取html元素    const html = document.querySelector(&#39;html&#39;)    // 根据屏幕宽度动态计算fontSize    let fontSize = window.innerWidth / 10    // 当fontSize大于50时，设置最大值为50    fontSize = fontSize &gt; 50 ? 50 : fontSize    // 设置html的fontSize属性，使rem生效，1rem = fontSize + &#39;px&#39;    html.style.fontSize = fontSize + &#39;px&#39;  &#125;)&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、如何使用CSS画三角形?</title>
      <link href="/2019/06/20/css/"/>
      <url>/2019/06/20/css/</url>
      
        <content type="html"><![CDATA[<p>三角形的画法,一般经常使用三角形作为提示框、下拉菜单等功能。</p><span id="more"></span><h2 id="一、CSS-画三角形实现方式"><a href="#一、CSS-画三角形实现方式" class="headerlink" title="一、CSS 画三角形实现方式"></a>一、CSS 画三角形实现方式</h2><p>1、HTML 结构</p><pre><code class="html">&lt;div class=&quot;item0&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item3&quot;&gt;&lt;/div&gt;</code></pre><p>2、将类名为 item 的块级元素的 width、height 设置为 0</p><pre><code class="css">.item0 &#123;  width: 0;  height: 0;&#125;</code></pre><p>3、将类名为 item 的元素的 3 个 border 的颜色设置为 transparent，箭头指向的对面 border 设置颜色；</p><pre><code class="css">.item0 &#123;  width: 0px;  height: 0px;  border-left: 50px solid transparent;  border-right: 50px solid transparent;  border-top: 50px solid transparent;  border-bottom: 80px solid blue;  background: white;&#125;</code></pre><p>上面的为方向向上的三角形<br>4、依次类推可以画出方向向左、右、下的三角形</p><pre><code class="css">.item1 &#123;  width: 0px;  height: 0px;  border-left: 50px solid transparent;  border-right: 50px solid transparent;  border-top: 80px solid green;  border-bottom: 50px solid transparent;  background: white;&#125;.item2 &#123;  width: 0px;  height: 0px;  border-left: 50px solid transparent;  border-right: 80px solid violet;  border-top: 50px solid transparent;  border-bottom: 50px solid transparent;  background: white;&#125;.item3 &#123;  width: 0px;  height: 0px;  border-left: 80px solid purple;  border-right: 50px solid transparent;  border-top: 50px solid transparent;  border-bottom: 50px solid transparent;  background: white;&#125;</code></pre><h2 id="二、网页变成灰色的方法："><a href="#二、网页变成灰色的方法：" class="headerlink" title="二、网页变成灰色的方法："></a>二、网页变成灰色的方法：</h2><pre><code class="css">html &#123;  filter: grayscale(100%);  -webkit-filter: grayscale(100%);  -moz-filter: grayscale(100%);  -ms-filter: grayscale(100%);  -o-filter: grayscale(100%);&#125;</code></pre><h2 id="三、position-定位"><a href="#三、position-定位" class="headerlink" title="三、position 定位"></a>三、position 定位</h2><blockquote><p>static: 默认值<br>relative: 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中<br>absolute: 绝对定位 相对于最近的已定位的祖先元素<br>fixed: 固定定位 相对于视窗来定位</p></blockquote><h2 id="四、浮动、清楚浮动"><a href="#四、浮动、清楚浮动" class="headerlink" title="四、浮动、清楚浮动"></a>四、浮动、清楚浮动</h2><pre><code class="css">display: table;content: &quot;&quot;;clear: both;</code></pre><h2 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h2><ul><li><p>新增选择器 document.querySelector、document.querySelectorAll</p></li><li><p>拖拽释放(Drag and drop) API</p></li><li><p>媒体播放的 video 和 audio</p></li><li><p>本地存储 localStorage 和 sessionStorage</p></li><li><p>离线应用 manifest</p></li><li><p>桌面通知 Notifications</p></li><li><p>语意化标签 article、footer、header、nav、section</p></li><li><p>增强表单控件 calendar、date、time、email、url、search</p></li><li><p>地理位置 Geolocation</p></li><li><p>多任务 webworker</p></li><li><p>全双工通信协议 websocket</p><blockquote><p>客户端和服务端双向通信</p></blockquote></li><li><p>历史管理 history</p></li><li><p>跨域资源共享(CORS) Access-Control-Allow-Origin</p></li><li><p>页面可见性改变事件 visibilitychange</p></li><li><p>跨窗口通信 PostMessage</p></li><li><p>Form Data 对象</p></li><li><p>绘画 canvas</p></li></ul><p>HTML 的语义化：</p><pre><code class="html">&lt;title&gt;      &lt;!--：页面主体内容。--&gt;&lt;hn&gt;         &lt;!--：h1~h6，分级标题，&lt;h1&gt; 与 &lt;title&gt; 协调有利于搜索引擎优化。--&gt;&lt;ul&gt;         &lt;!--：无序列表。--&gt;&lt;li&gt;         &lt;!--：有序列表。--&gt;&lt;header&gt;     &lt;!--：页眉通常包括网站标志、主导航、全站链接以及搜索框。--&gt;&lt;nav&gt;         &lt;!--：标记导航，仅对文档中重要的链接群使用。--&gt;&lt;main&gt;         &lt;!--：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。--&gt;&lt;article&gt;    &lt;!--：定义外部的内容，其中的内容独立于文档的其余部分。--&gt;&lt;section&gt;    &lt;!--：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。--&gt;&lt;aside&gt;         &lt;!--：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。--&gt;&lt;footer&gt;     &lt;!--：页脚，只有当父级是body时，才是整个页面的页脚。--&gt;&lt;small&gt;      &lt;!--：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。--&gt;&lt;strong&gt;     &lt;!--：和 em 标签一样，用于强调文本，但它强调的程度更强一些。--&gt;&lt;em&gt;         &lt;!--：将其中的文本表示为强调的内容，表现为斜体。--&gt;&lt;mark&gt;       &lt;!--：使用黄色突出显示部分文本。--&gt;&lt;figure&gt;     &lt;!--：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。--&gt;&lt;figcaption&gt;&lt;!--：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。--&gt;&lt;cite&gt;       &lt;!--：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。--&gt;&lt;blockquoto&gt;&lt;!--：定义块引用，块引用拥有它们自己的空间。--&gt;&lt;q&gt;          &lt;!--：短的引述（跨浏览器问题，尽量避免使用）。--&gt;&lt;time&gt;       &lt;!--：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。--&gt;&lt;abbr&gt;       &lt;!--：简称或缩写。--&gt;&lt;dfn&gt;       &lt;!--：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。--&gt;&lt;address&gt;    &lt;!--：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。--&gt;&lt;del&gt;        &lt;!--：移除的内容。--&gt;&lt;ins&gt;        &lt;!--：添加的内容。--&gt;&lt;code&gt;       &lt;!--：标记代码。--&gt;&lt;meter&gt;      &lt;!--：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）--&gt;&lt;progress&gt;    &lt;!--：定义运行中的进度（进程）。--&gt;</code></pre><p>语义化的优点：</p><blockquote><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于 SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与 CSS3 关系更和谐。</li></ul></blockquote><h2 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h2><p>css 的继承：</p><h3 id="无继承性的属性："><a href="#无继承性的属性：" class="headerlink" title="无继承性的属性："></a>无继承性的属性：</h3><p>1、display:规定元素应该生成的框的类型</p><p>2、文本属性：</p><p>​ vertical-align:垂直文本对齐</p><p>​ text-decoration:规定添加到文本的修饰</p><p>​ text-shadow:文本阴影效果</p><p>​ white-space:空白符处理</p><p>​ unicode-bidi:设置文本方向</p><p>3、盒子模型属性：</p><blockquote><p>width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p></blockquote><p>4、背景属性：</p><blockquote><p>backgroun、background-color、background-image、background-repeat、background-position、background-attachment</p></blockquote><p>5、定位属性：</p><blockquote><p>float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p></blockquote><p>其他。。。</p><h3 id="有继承性属性"><a href="#有继承性属性" class="headerlink" title="有继承性属性"></a>有继承性属性</h3><p>1、字体系列：</p><blockquote><p>font：组合字体</p><p>font-family：规定元素的字体系列</p><p>font-weight：设置字体的粗细</p><p>font-size：设置字体的尺寸</p><p>font-style：定义字体的风格</p></blockquote><p>2、文本系列属性：</p><blockquote><p>text-indent：文本缩进</p><p>text-align：文本水平对齐</p><p>line-height：行高</p><p>word-spacing：增加或减少单词间的空白（即字间隔）</p><p>letter-spacing：增加或减少字符间的空白（字符间距）</p><p>text-transform：控制文本大小写</p><p>direction：规定文本的书写方向</p><p>color：文本颜色 a 元素除外</p></blockquote><p>3、元素可见性</p><blockquote><p>visibility</p></blockquote><p>其他。。。</p><p>块级元素哪些属性可以继承？</p><blockquote><p>text-indent、text-align、visibility、cursor</p></blockquote><p>盒模型：</p><blockquote><p>标准盒模型：盒子总宽度/高度 =width/height + padding + border + margin。（ 即 width/height 只是 内容高度，不包含 padding 和 border 值 ）<br>IE 盒子模型：盒子总宽度/高度 =width/height + margin = (内容区宽度/高度 + padding + border) + margin。（ 即 width/height 包含了 padding 和 border 值 ）</p></blockquote><p>BFC 是什么？(边距重叠解决方案)</p><blockquote><p>BFC 是 CSS 布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。<br>父子元素和兄弟元素边距重叠，重叠原则取最大值。空元素的边距重叠是取 margin 与 padding 的最大值。</p></blockquote><p>BFC 原理？</p><blockquote><p>（1）内部的 Box 会在垂直方向，从顶部开始一个接着一个地放置；<br>（2）Box 垂直方向的距离由 margin(外边距)决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；<br>（3）每个元素的 margin Box 的左边， 与包含块 border Box 的左边相接触，（对于从左到右的格式化，否则相反）。即使存在浮动也是如此；<br>（4）BFC 在页面上是一个隔离的独立容器，外面的元素不会影响里面的元素，反之亦然。文字环绕效果，设置 float；<br>（5）BFC 的区域不会与 float Box 重叠（清浮动）;<br>（6）计算 BFC 的高度时，浮动元素也参与计算。</p></blockquote><p>CSS 在什么情况下会创建出 BFC？</p><blockquote><p>0、根元素，即 HTML 元素（最大的一个 BFC）<br>1、浮动（float 的值不为 none）<br>2、绝对定位元素（position 的值为 absolute 或 fixed）<br>3、行内块（display 为 inline-block）<br>4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性)<br>5、弹性盒（display 为 flex 或 inline-flex）<br>6、默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible）</p></blockquote><p>样式优先级：</p><blockquote><p>!important</p><p>内联 <div style=""></div> 1000</p><p>id 选择器 #content <div id="content"></div> 100</p><p>类选择器（伪类和属性选择器） .content <div class="content"></div> 10</p><p>类型选择器和伪元素选择器 div p <div></div> 1</p><p>通配符（*）、子选择器（&gt;）、相邻选择器(+) 0</p><p>继承的样式没有权值</p></blockquote><p>盒子塌陷</p><blockquote><p>本应该在父盒子内部的元素跑到了外部。</p><p>当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为 auto 时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是<strong>CSS 高度塌陷</strong>。</p></blockquote><p>解决盒子塌陷的方法：</p><blockquote><p>1、设置盒子的宽高</p><p>2、给外部的父盒子也添加浮动，让其脱离标准文档流</p><p>3、父盒子添加 overflow 属性</p><p>4、父盒子最下方引入清除浮动块 clear:both</p><p>5、after 伪元素清除浮动</p><p>6、父盒子添加 border</p><p>7、父盒子设置 padding-top</p></blockquote><p>伪类和伪元素的区别</p><blockquote><p>伪类：</p><ul><li>其核⼼就是⽤来选择 DOM 树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</li><li>⽐如:hover :active :visited :link :visited :first-child :focus :lang 等</li><li>由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。</li><li>由此可以看出，它的功能和 class 有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。</li></ul><p>伪元素：</p><ul><li>DOM 树没有定义的虚拟元素</li><li>核⼼就是需要创建通常不存在于⽂档中的元素，</li><li>⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。</li><li>伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器</li></ul></blockquote><p>总结：</p><blockquote><ul><li>伪类和伪元素都是⽤来表示⽂档树以外的”元素”。</li><li>伪类和伪元素分别⽤单冒号:和双冒号::来表示。</li><li>伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，</li><li>是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类</li><li>伪类和伪元素都不出现在源⽂件和 DOM 树中。也就是说在 html 源⽂件中是看不到伪类和伪元素的。</li><li>伪类其实就是基于普通 DOM 元素⽽产⽣的不同状态，他是 DOM 元素的某⼀特征。</li><li>伪元素能够创建在 DOM 树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</li></ul></blockquote><p>行内元素的 margin padding</p><blockquote><ul><li>水平方向：水平方向上，都有效；</li><li>垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响）</li></ul></blockquote><p>min-height 和 max-height min-width 和 max-width</p><blockquote><ol><li> max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。</li><li> min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；</li></ol></blockquote><p>布局：</p><h4 id="未知高度元素垂直居中、垂直居中的实现方式有哪些？"><a href="#未知高度元素垂直居中、垂直居中的实现方式有哪些？" class="headerlink" title="未知高度元素垂直居中、垂直居中的实现方式有哪些？"></a>未知高度元素垂直居中、垂直居中的实现方式有哪些？</h4><p>1、绝对定位+css3 transform:translate(-50%,50%)</p><pre><code class="css">.wrap &#123;  position: relative;&#125;.child &#123;  position: absolute;  top: 50%;  left: 50%;  -webkit-transform: translate(-50%, -50%);&#125;</code></pre><p>2、css 的 flex 布局</p><pre><code class="css">.wrap &#123;  display: flex;  justify-content: center;&#125;.child &#123;  align-self: center;&#125;</code></pre><p>3、table 布局</p><pre><code class="css">&lt;div  class=&quot;wrap&quot;  &gt; &lt;div  class=&quot;child&quot;  &gt; &lt;div  &gt; sadgsdgasgd&lt;/div  &gt; &lt;/div  &gt; &lt;/div  &gt; .wrap &#123;  display: table;  text-align: center;&#125;.child &#123;  background: #ccc;  display: table-cell;  vertical-align: middle;&#125;.child div &#123;  width: 300px;  height: 150px;  background: red;  margin: 0 auto;&#125;</code></pre><p>图片垂直居中的方法</p><pre><code class="html">// flex&lt;style&gt;  body &#123;    background: #999;  &#125;  .flexbox &#123;    width: 300px;    height: 250px;    background: #fff;    display: flex;    align-items: center;  &#125;  .flexbox img &#123;    width: 100px;    height: 100px;    align-items: center;  &#125;&lt;/style&gt;&lt;div class=&quot;flexbox&quot;&gt;  &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;// 绝对定位&lt;style&gt;  body &#123;    background: #ccc;  &#125;  .posdiv &#123;    width: 300px;    height: 250px;    background: #fff;    position: relative;    margin: 0 auto;  &#125;  .posdiv img &#123;    width: 100px;    position: absolute;    top: 50%;    margin-top: -50px;  &#125;&lt;/style&gt;</code></pre><p>rem 适配</p><pre><code class="js">&lt;head&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;  &lt;script&gt;    const WIDTH = 750 //设计稿尺寸    const setView = () =&gt; &#123;      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + &#39;px&#39;    &#125;    window.onorientationchange = setView    setView()  &lt;/script&gt;&lt;/head&gt;</code></pre><p>清除浮动的方法：</p><p>1、clear：both 添加了无意义的标 签，结构化比较差</p><p>2、overflow:hidden 内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素。</p><p>3、伪元素：after 伪元素清除浮动</p><pre><code class="css">.clearfix:after &#123;  content: &quot;.&quot;; /*尽量不要为空，一般写一个点*/  height: 0; /*盒子高度为0，看不见*/  display: block; /*插入伪元素是行内元素，要转化为块级元素*/  visibility: hidden; /*content有内容，将元素隐藏*/  clear: both;&#125;.clearfix &#123;  *zoom: 1; /*  *只有IE6,7识别 */&#125;</code></pre><p>4、after 伪元素空余字符法</p><pre><code class="css">.clearfix::after &#123;  content: &quot;\200B&quot;; /* content:&#39;\0200&#39;; 也可以 */  display: block;  height: 0;  clear: both;&#125;.clearfix &#123;  *zoom: 1;&#125;</code></pre><p>5、使用 before 和 after 双伪元素清除浮动</p><pre><code class="css">.clearfix:before,.clearfix:after &#123;  content: &quot;&quot;;  display: table;&#125;.clearfix:after &#123;  clear: both;&#125;.clearfix &#123;  *zoom: 1;&#125;</code></pre><p>px:绝对长度单位</p><p>em:相对长度单位 值不固定，继承父元素的字体大小 相对父元素的大小</p><p>rem：相对长度单位 相对于根元素换算</p>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、微信小程序checkbox-group</title>
      <link href="/2019/01/20/check-group/"/>
      <url>/2019/01/20/check-group/</url>
      
        <content type="html"><![CDATA[<p>checkbox-group多项选择器，内部由多个checkbox组成；<br>属性bindchange   说明checkbox-group中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]};</p><span id="more"></span><pre><code class="html">&lt;checkbox-group  class=&quot;checkbox_group&quot; bindchange=&quot;checkboxChange&quot;&gt;    &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;item&quot;&gt;        &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot;  checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot; /&gt;        &#123;&#123;item.value&#125;&#125;    &lt;/label&gt;&lt;/checkbox-group&gt;</code></pre><p>每一次修改选中项，都需要一个空数组去存放选中项。</p><details><summary>点我展示代码</summary><pre><code class="js">  checkboxChange(e) &#123;    const items = this.data.items;     const values = e.detail.value;    // 设置选中的数组为空  选中的id push到数组里面    this.data.vehicle_arr = [];    for (let i = 0, lenI = items.length; i &lt; lenI; ++i) &#123;      items[i].checked = false // 遍历items，让所有的选中状态都为false      for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123;        if (items[i].value === values[j]) &#123;          items[i].checked = true;          const List = items[i].name.toString().split();          for (let k in List) &#123;            this.data.vehicle_arr.push(List[k]);          &#125;        &#125;      &#125;    &#125;    // 选中的id    this.data.unique = [...new Set(this.data.vehicle_arr)];    this.setData(&#123;      driverarr: e.detail.value.join(&quot;,&quot;), // 多选的数组      items,    &#125;);  &#125;,</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、Hexo常用命令</title>
      <link href="/2019/01/02/hello-world/"/>
      <url>/2019/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>hexo常用命令</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><pre><code class="js">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><pre><code class="js">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成本地静态文件"><a href="#生成本地静态文件" class="headerlink" title="生成本地静态文件"></a>生成本地静态文件</h3><pre><code class="js">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!-- 打包上传发布命令 --><p>打包发布的命令行可以直接这样写：</p><pre><code class="bash">hexo g &amp;&amp; hexo d</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

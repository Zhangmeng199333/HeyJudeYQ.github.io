<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>105、typescript函数Class类型：函数重载和面向对象(三)</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：函数。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。
介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如重载与面向对象的编程等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。
函数函数的类型签名如果说变量的类型是描述了这个变量的值.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">105、typescript函数Class类型：函数重载和面向对象(三)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D"><span class="toc-text">函数的类型签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-%E7%B1%BB%E5%9E%8B"><span class="toc-text">void 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E4%B8%8E-rest-%E5%8F%82%E6%95%B0"><span class="toc-text">可选参数与 rest 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E3%80%81Generator-%E5%87%BD%E6%95%B0%E7%AD%89%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D"><span class="toc-text">异步函数、Generator 函数等类型签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D"><span class="toc-text">类与类成员的类型签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">继承、实现、抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A"><span class="toc-text">总结与预告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">扩展阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">私有构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOLID-%E5%8E%9F%E5%88%99"><span class="toc-text">SOLID 原则</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ts"><i class="tag post-item-tag">ts</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">105、typescript函数Class类型：函数重载和面向对象(三)</h1><time class="has-text-grey" datetime="2022-12-10T12:00:00.000Z">2022-12-10</time><article class="mt-2 post-content"><span id="more"></span>

<p>日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：<strong>函数</strong>。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。</p>
<p>介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如<strong>重载</strong>与<strong>面向对象的编程</strong>等。函数部分，我们主要关注其参数类型、返回值类型以及重载的应用。 Class 部分，除了类型以外，我们还会学习访问性修饰符、继承、抽象类等来自于面向对象理念的实际使用。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的类型签名"><a href="#函数的类型签名" class="headerlink" title="函数的类型签名"></a>函数的类型签名</h3><p>如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了<strong>函数入参类型与函数返回值类型</strong>，它们同样使用<code>:</code>的语法进行类型标注。我们直接看最简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在函数类型中同样存在着类型推导。比如在这个例子中，你可以不写返回值处的类型，它也能被正确推导为 number 类型。</p>
<p>在 JavaScript 中，我们称 <code>function name () &#123;&#125;</code> 这一声明函数的方式为<strong>函数声明（*Function Declaration*）</strong>。除了函数声明以外，我们还可以通过<strong>函数表达式（*Function Expression*）</strong>，即 <code>const foo = function()&#123;&#125;</code> 的形式声明一个函数。在表达式中进行类型声明的方式是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们也可以像对变量进行类型标注那样，对 <code>foo</code> 这个变量进行类型声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> foo: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>(name: string) =&gt; number</code> 看起来很眼熟，对吧？它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 TypeScript 中的<strong>函数类型签名</strong>。而实际的箭头函数，我们的类型标注也是类似的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-keyword">const</span> foo = (name: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">const</span> foo: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在方式二的声明方式中，你会发现函数类型声明混合箭头函数声明时，代码的可读性会非常差。因此，一般不推荐这么使用，要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> FuncFoo = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">const</span> foo: FuncFoo = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> name.length;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> FuncFooStruct &#123;<br>  (name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这时的 interface 被称为 <strong>Callable Interface</strong>，看起来可能很奇怪，但我们可以这么认为，interface 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型罢了。</p>
<h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 没有调用 return 语句</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 调用了 return 语句，但没有返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因和我们在原始类型与对象类型一节中讲到的：<strong>在 TypeScript 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。</strong> 相比之下，void 类型就像是 JavaScript 中的 null 一样。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数<strong>没有进行返回操作</strong>。但在上面的第二个例子中，其实更好的方式是使用 undefined ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>): <span class="hljs-title">undefined</span> </span>&#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时我们想表达的则是，这个函数<strong>进行了返回操作，但没有返回实际的值</strong>。</p>
<h3 id="可选参数与-rest-参数"><a href="#可选参数与-rest-参数" class="headerlink" title="可选参数与 rest 参数"></a>可选参数与 rest 参数</h3><p>在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 <code>?</code> 描述一个可选属性一样，在函数类型中我们也使用 <code>?</code> 描述一个可选参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 在函数逻辑中注入可选参数默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age || <span class="hljs-number">18</span>; <span class="hljs-comment">// 或使用 age ?? 18</span><br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br><br><span class="hljs-comment">// 直接为可选参数声明默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age;<br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。毕竟在 JavaScript 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用 <code>?</code> 了，因为既然都有默认值，那肯定是可选参数啦。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> inputAge = age || <span class="hljs-number">18</span>;<br>  <span class="hljs-keyword">return</span> name.length + inputAge;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在某些情况下，这里的可选参数类型也可以省略，如这里原始类型的情况可以直接从提供的默认值类型推导出来。但对于联合类型或对象类型的复杂情况，还是需要老老实实地进行标注。</p>
<p>对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：</p>
<blockquote>
<p>对于 any 类型，你可以简单理解为它包含了一切可能的类型，我们会在下一节详细介绍。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>当然，你也可以使用我们前面学习的元祖类型进行标注：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>]</span>) </span>&#123;&#125;<br><br>foo(<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (bar) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">599</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个实例中，函数的返回类型基于其入参 <code>bar</code> 的值，并且从其内部逻辑中我们知道，当 <code>bar</code> 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。</p>
<p>要想实现与入参关联的返回值类型，我们可以使用 TypeScript 提供的<strong>函数重载签名（*Overload Signature*）</strong>，将以上的例子使用重载改写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar: <span class="hljs-literal">true</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-literal">false</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (bar) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">599</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> res1 = func(<span class="hljs-number">599</span>); <span class="hljs-comment">// number</span><br><span class="hljs-keyword">const</span> res2 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// string</span><br><span class="hljs-keyword">const</span> res3 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure>

<p>这里我们的三个 <code>function func</code> 其实具有不同的意义：</p>
<ul>
<li><code>function func(foo: number, bar: true): string</code>，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。</li>
<li><code>function func(foo: number, bar?: false): number</code>，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。</li>
<li><code>function func(foo: number, bar?: boolean): string | number</code>，函数的实现签名，会包含重载签名的所有可能情况。</li>
</ul>
<p>基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。</p>
<p>这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。</p>
<blockquote>
<p>你可以试着为第一个重载声明的 bar 参数也加上可选符号，然后就会发现第一个函数调用错误地匹配到了第一个重载声明。</p>
</blockquote>
<p>实际上，TypeScript 中的重载更像是伪重载，<strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。而在如 C++ 等语言中，重载体现在多个<strong>名称一致但入参不同的函数实现上</strong>，这才是更广义上的函数重载。</p>
<h3 id="异步函数、Generator-函数等类型签名"><a href="#异步函数、Generator-函数等类型签名" class="headerlink" title="异步函数、Generator 函数等类型签名"></a>异步函数、Generator 函数等类型签名</h3><p>对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">asyncGenFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">AsyncIterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>其中，Generator 函数与异步 Generator 函数现在已经基本不再使用，这里仅做了解即可。而对于异步函数（即标记为 async 的函数），其返回值必定为一个 Promise 类型，而 Promise 内部包含的类型则通过泛型的形式书写，即 <code>Promise&lt;T&gt;</code>（关于泛型我们会在后面进行详细了解）。</p>
<p>在函数这一节中，我们主要关注函数的类型标注。因为 TypeScript 中的函数实际上相比 JavaScript 也只是多在重载这一点上，我们需要着重掌握的仍然是类型标注。但在 Class 中，我们的学习重点其实更侧重于其语法与面向对象的编程理念。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="类与类成员的类型签名"><a href="#类与类成员的类型签名" class="headerlink" title="类与类成员的类型签名"></a>类与类成员的类型签名</h3><p>一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有<strong>构造函数</strong>、<strong>属性</strong>、<strong>方法</strong>和<strong>访问符（*Accessor*）</strong>，我们也只需要关注这三个部分即可。这里我要说明一点，有的同学可能认为装饰器也是 Class 的结构，但我个人认为它并不是 Class 携带的逻辑，不应该被归类在这里。</p>
<blockquote>
<p>而对于这些结构的具体意义以及 Class 的入门语法，你可以阅读阮一峰老师的 ES6 标准入门。</p>
</blockquote>
<p>属性的类型标注类似于变量，而构造函数、方法、存取器的类型编标注类似于函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">propA</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span>+A`</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">propA</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-built_in">this</span>.prop = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>+A`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>唯一需要注意的是，setter 方法<strong>不允许进行返回值的类型标注</strong>，你可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致，这里我们不再赘述。</p>
<p>就像函数可以通过<strong>函数声明</strong>与<strong>函数表达式</strong>创建一样，类也可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建。很明显上面的写法即是类声明，而使用类表达式的语法则是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> Foo = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 TypeScript 中我们能够为 Class 成员添加这些修饰符：<code>public</code> / <code>private</code> / <code>protected</code> / <code>readonly</code>。除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）。</p>
<p>这些修饰符应用的位置在成员命名前：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> prop: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prop = inputProp;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span> and <span class="hljs-subst">$&#123;addon&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> <span class="hljs-title">propA</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.prop&#125;</span>+A`</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">set</span> <span class="hljs-title">propA</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-built_in">this</span>.propA = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>+A`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们通常不会为构造函数添加修饰符，而是让它保持默认的 public。在扩展阅读中我们会讲到 private 修饰构造函数的场景。</p>
</blockquote>
<p>如果没有其他语言学习经验，你可能不太理解 public / private / protected 的意义，我们简单做个解释。</p>
<ul>
<li>public：此类成员在<strong>类、类的实例、子类</strong>中都能被访问。</li>
<li>private：此类成员仅能在<strong>类的内部</strong>被访问。</li>
<li>protected：此类成员仅能在<strong>类与子类中</strong>被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即<strong>不允许再访问受保护的成员</strong>。</li>
</ul>
<p>当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以<strong>在构造函数中对参数应用访问性修饰符</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> arg1: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">private</span> arg2: <span class="hljs-built_in">boolean</span></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Foo(<span class="hljs-string">&quot;linbudu&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">staticHandler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">instanceHandler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 <code>Foo.staticHandler</code> 这种形式进行访问。我们可以查看编译到 ES5 及以下 target 的 JavaScript 代码（ES6 以上就原生支持静态成员了），来进一步了解它们的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Foo = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  Foo.staticHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  Foo.prototype.instanceHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  <span class="hljs-keyword">return</span> Foo;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>从中我们可以看到，<strong>静态成员直接被挂载在函数体上</strong>，而<strong>实例成员挂载在原型上</strong>，这就是二者的最重要差异：<strong>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）</strong>。而原型对象上的实例成员则会<strong>沿着原型链进行传递</strong>，也就是能够被继承。</p>
<p>而对于静态成员和实例成员的使用时机，其实并不需要非常刻意地划分。比如我会用<strong>类 + 静态成员</strong>来收敛变量与 utils 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identifier = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">makeUHappy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Utils.studyWithU();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">studyWithU</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br>Utils.makeUHappy();<br></code></pre></td></tr></table></figure>

<h3 id="继承、实现、抽象类"><a href="#继承、实现、抽象类" class="headerlink" title="继承、实现、抽象类"></a>继承、实现、抽象类</h3><p>既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>对于这里的两个类，比较严谨的称呼是 <strong>基类（*Base*）</strong> 与 <strong>派生类（*Derived*）</strong>。当然，如果你觉得叫父类与子类更容易理解也没问题。关于基类与派生类，我们需要了解的主要是<strong>派生类对基类成员的访问与覆盖操作</strong>。</p>
<p>基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。我们在上面其实已经介绍过，派生类中可以访问到使用 <code>public</code> 或 <code>protected</code> 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但我们仍然可以通过 super 访问到基类中的方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.print();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在派生类中覆盖基类方法时，我们并不能确保派生类的这一方法能覆盖基类方法，万一基类中不存在这个方法呢？所以，TypeScript 4.3 新增了 <code>override</code> 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">printWithLove</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>  override <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里 TS 将会给出错误，因为<strong>尝试覆盖的方法并未在基类中声明</strong>。通过这一关键字我们就能确保首先这个方法在基类中存在，同时标识这个方法在派生类中被覆盖了。</p>
<p>除了基类与派生类以外，还有一个比较重要的概念：<strong>抽象类</strong>。抽象类是对类结构与方法的抽象，简单来说，<strong>一个抽象类描述了一个类中应当有哪些成员（属性、方法等）</strong>，<strong>一个抽象方法描述了这一方法在实际实现中的结构</strong>。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的<strong>入参类型</strong>与<strong>返回值类型</strong>。</p>
<p>抽象类使用 abstract 关键字声明：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsFoo</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> absProp: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>(): <span class="hljs-title">string</span>;<br>  <span class="hljs-title">abstract</span> <span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。我们可以实现（implements）一个抽象类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-title">implements</span> <span class="hljs-title">AbsFoo</span> </span>&#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;linbudu&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 TypeScript 中<strong>无法声明静态的抽象成员</strong>。</p>
<p>对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的。interface 不仅可以声明函数结构，也可以声明类的结构：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> FooStruct &#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>(): <span class="hljs-title">string</span>;<br>  <span class="hljs-title">absMethod</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span>;<br>&#125;<br><br><span class="hljs-title">class</span> <span class="hljs-title">Foo</span> <span class="hljs-title">implements</span> <span class="hljs-title">FooStruct</span> &#123;<br>  <span class="hljs-attr">absProp</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">absGetter</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;linbudu&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">absMethod</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，我们让类去实现了一个接口。这里接口的作用和抽象类一样，都是<strong>描述这个类的结构</strong>。除此以外，我们还可以使用 <strong>Newable Interface</strong> 来描述一个类的结构（类似于描述函数结构的 <strong>Callable Interface</strong>）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">interface</span> FooStruct &#123;<br>  <span class="hljs-keyword">new</span> (): Foo;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> NewableFoo: FooStruct;<br><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> NewableFoo();<br></code></pre></td></tr></table></figure>

<h2 id="总结与预告"><a href="#总结与预告" class="headerlink" title="总结与预告"></a>总结与预告</h2><p>在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类，实际上我们了解的更多是新的语法，如访问性修饰符 <code>public</code> / <code>private</code> / <code>protected</code> ，操作修饰符 <code>readonly</code> ，静态成员 static ，抽象类 abstract ，以及 override 等在 JavaScript（ECMAScript）中不存在或实现并不完全的能力。</p>
<p>对于函数与类，你需要更多地实际使用才能掌握得更好。不妨继续对你手上的 JavaScript 进行改造，让函数与类都能披上类型的铠甲，获得完整的类型能力。</p>
<p>在下一节，我们将要接触的就是 JavaScript 中完全没有类似概念的新朋友了，它们是 TypeScript 类型编程最基础的一部分，包括了 any 、 unknown 、never 内置类型，以及类型断言等概念，这些类型工具会是你以后玩转类型编程时最常打交道的一部分。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来好像没什么问题，但是当你想要实例化这个类时，一行美丽的操作就会出现：<strong>类的构造函数被标记为私有，且只允许在类内部访问</strong>。</p>
<p>那这就很奇怪了，我们要一个不能实例化的类有啥用？摆设吗？</p>
<p>还真不是，有些场景下私有构造函数确实有奇妙的用法，比如像我一样把类作为 utils 方法时，此时 Utils 类内部全部都是静态成员，我们也并不希望真的有人去实例化这个类。此时就可以使用私有构造函数来阻止它被错误地实例化：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identifier = <span class="hljs-string">&quot;linbudu&quot;</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">makeUHappy</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者在一个类希望把实例化逻辑通过方法来实现，而不是通过 new 的形式时，也可以使用私有构造函数来达成目的。</p>
<p>你可能会想到，既然有私有构造函数，那没道理没有受保护的构造函数（<code>protected</code>）啊？还真有。但这里我想留给你自己去探寻，你可以先查找下这么做的意义，再想想，什么场景下我们非用它不可？</p>
<h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><p>SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。</p>
<p>S，<strong>单一功能原则</strong>，<strong>一个类应该仅具有一种职责</strong>，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和写操作也应当被视为两种不同的职责，并被分配到两个类中。更进一步，对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来。</p>
<p>O，<strong>开放封闭原则</strong>，<strong>一个类应该是可扩展但不可修改的</strong>。即假设我们的业务中支持通过微信、支付宝登录，原本在一个 login 方法中进行 if else 判断，假设后面又新增了抖音登录、美团登录，难道要再加 else if 分支（或 switch case）吗？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> LoginType &#123;<br>  WeChat,<br>  TaoBao,<br>  TikTok,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: LoginType</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.WeChat) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.TikTok) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === LoginType.TaoBao) &#123;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invalid Login Type!&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然不，基于开放封闭原则，我们应当将登录的基础逻辑抽离出来，不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> handler(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChatLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaoBaoLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TikTokLoginHandler</span> <span class="hljs-title">implements</span> <span class="hljs-title">LoginHandler</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> handlerMap: Record&lt;LoginType, LoginHandler&gt; = &#123;<br>    [LoginType.TaoBao]: <span class="hljs-keyword">new</span> TaoBaoLoginHandler(),<br>    [LoginType.TikTok]: <span class="hljs-keyword">new</span> TikTokLoginHandler(),<br>    [LoginType.WeChat]: <span class="hljs-keyword">new</span> WeChatLoginHandler(),<br>  &#125;;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: LoginType</span>)</span> &#123;<br>    Login.handlerMap[<span class="hljs-keyword">type</span>].handler();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>L，<strong>里式替换原则</strong>，<strong>一个派生类可以在程序的任何一处对其基类进行替换</strong>。这也就意味着，子类完全继承了父类的一切，对父类进行了功能地扩展（而非收窄）。</p>
<p>I，<strong>接口分离原则</strong>，<strong>类的实现方应当只需要实现自己需要的那部分接口</strong>。比如微信登录支持指纹识别，支付宝支持指纹识别和人脸识别，这个时候微信登录的实现类应该不需要实现人脸识别方法才对。这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对。</p>
<p>D，<strong>依赖倒置原则</strong>，这是实现开闭原则的基础，它的核心思想即是<strong>对功能的实现应该依赖于抽象层</strong>，即不同的逻辑通过实现不同的抽象类。还是登录的例子，我们的登录提供方法应该基于共同的登录抽象类实现（LoginHandler），最终调用方法也基于这个抽象类，而不是在一个高阶登录方法中去依赖多个低阶登录提供方。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/12/12/106.ref/" title="106、ref小技巧"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 106、ref小技巧</span></a><a class="button is-default" href="/2022/12/07/104-ts/" title="104、typescript字面量类型和枚举(二)"><span class="has-text-weight-semibold">下一页: 104、typescript字面量类型和枚举(二)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>110、稀土掘金小册-记账本（一） react hooks</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="React 早期的写法以 Class 类组件为主，附带一些纯用于展示的函数组件，但是函数组件是不能控制自身的状态的。
直到 16.8 版本出来之后，引入了全新的 Hooks 写法，这让之前的类写法就显得 比较累赘，函数组件的写法开始流行起来。函数组件引入了多种钩子函数如 useEffect、useState、useRef、useCallback、useMemo、useReducer 等等，通过这些钩子函数来管理函数组件的各自状态。


正文本章节我会通过一个请求，带大家入门整个 React Hook 知识体系。首先我们需要创建一个空项目，由于本实验采用的是 Vite 2.0 作为脚手架工具，所以我们的 Node 版本必须要在 12.0.0 以上，目前我的版本是 12.6.0。
我们通过指令新建一个联手项目，.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">110、稀土掘金小册-记账本（一） react hooks</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useState"><span class="toc-text">useState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useEffect"><span class="toc-text">useEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook"><span class="toc-text">自定义 Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86-useEffect"><span class="toc-text">重新认识 useEffect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/react"><i class="tag post-item-tag">react</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">110、稀土掘金小册-记账本（一） react hooks</h1><time class="has-text-grey" datetime="2022-12-30T12:00:00.000Z">2022-12-30</time><article class="mt-2 post-content"><p><code>React</code> 早期的写法以 <code>Class</code> 类组件为主，附带一些纯用于展示的函数组件，但是函数组件是不能控制自身的状态的。</p>
<p>直到 16.8 版本出来之后，引入了全新的 <code>Hooks</code> 写法，这让之前的类写法就显得 比较累赘，函数组件的写法开始流行起来。函数组件引入了多种钩子函数如 <code>useEffect</code>、<code>useState</code>、<code>useRef</code>、<code>useCallback</code>、<code>useMemo</code>、<code>useReducer</code> 等等，通过这些钩子函数来管理函数组件的各自状态。</p>
<span id="more"></span>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本章节我会通过一个请求，带大家入门整个 <code>React Hook</code> 知识体系。首先我们需要创建一个空项目，由于本实验采用的是 <code>Vite 2.0</code> 作为脚手架工具，所以我们的 <code>Node</code> 版本必须要在 <code>12.0.0</code> 以上，目前我的版本是 <code>12.6.0</code>。</p>
<p>我们通过指令新建一个联手项目，如下所示：</p>
<pre><code class="bash"># npm 6.x
npm init @vitejs/app hooks-demo --template react

# npm 7+, 需要额外的双横线：
npm init @vitejs/app hooks-demo -- --template react

# yarn
yarn create @vitejs/app hooks-demo --template react
</code></pre>
<p>根据你的需求，选择上述三个其中一个。新建之后项目目录如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a994cd755bb34164ba5abff2c88af997~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<pre><code class="bash">npm install
npm run dev
</code></pre>
<p>如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b82ef228cba417bb1f6f910c2406abf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>看到如上述所示代表项目已经启动成功了。</p>
<h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>接下来我们清空 <code>App.jsx</code>，添加如下代码：</p>
<pre><code class="js">import React, &#123; useState &#125; from &quot;react&quot;;

function App() &#123;
  const [data, setData] = useState([1, 2, 3, 4, 5]);
  return (
    &lt;div className=&quot;App&quot;&gt;
      &#123;data.map((item, index) =&gt; (
        &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;
      ))&#125;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>函数内声明变量，可以通过 <code>useState</code> 方法，它接受一个参数，可以为默认值，也可以为一个函数。上述我们先分析默认值的情况，默认给一个数组 <code>[1, 2, 3, 4, 5]</code>，<code>data</code> 参数便可以直接在 <code>JSX</code> 模板中使用。</p>
<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>此时，我们通过 <code>useEffect</code> 副作用，请求一个接口数据，如下所示：</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;
// 模拟数据接口，3 秒钟返回数据。
const getList = () =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve([6, 7, 8, 9, 10]);
    &#125;, 3000);
  &#125;);
&#125;;

function App() &#123;
  const [data, setData] = useState([1, 2, 3, 4, 5]);

  useEffect(() =&gt; &#123;
    (async () =&gt; &#123;
      const data = await getList();
      console.log(&quot;data&quot;, data);
      setData(data);
    &#125;)();
  &#125;);
  return (
    &lt;div className=&quot;App&quot;&gt;
      &#123;data.map((item, index) =&gt; (
        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;
      ))&#125;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>函数组件默认进来之后，会执行 <code>useEffect</code> 中的回调函数，但是当 <code>setData</code> 执行之后，<code>App</code> 组件再次刷新，刷新之后会再次执行 <code>useEffect</code> 的回调函数，这便会形成一个可怕的死循环，回调函数会一直被这样执行下去。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3187ae7425542beb62f3b207e27acb0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>所以这里引出 <code>useEffect</code> 的第二个参数。它是一个数组，数组内接收回调函数内使用到的状态参数，一旦在组件内改变了状态参数，则会触发副作用 <code>useEffect</code> 的回调函数执行。</p>
<p>所以我们如果传一个空数组 <code>[]</code>，则该副作用只会在组件渲染的时候，执行一次，如下所示：</p>
<pre><code class="js">useEffect(() =&gt; &#123;
  (async () =&gt; &#123;
    const data = await getList();
    console.log(&quot;data&quot;, data);
    setData(data);
  &#125;)();
&#125;, []);
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1c917ab81e41d19dbbf0ea5d31c4ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>执行一次之后，副作用不再被触发。</p>
<p>此时我们需要给请求一个 <code>query</code> 参数，如下所示：</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;

const getList = (query) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;query&quot;, query);
      resolve([6, 7, 8, 9, 10]);
    &#125;, 3000);
  &#125;);
&#125;;

function App() &#123;
  const [data, setData] = useState([1, 2, 3, 4, 5]);
  const [query, setQuery] = useState(&quot;&quot;);

  useEffect(() =&gt; &#123;
    (async () =&gt; &#123;
      const data = await getList(query);
      console.log(&quot;data&quot;, data);
      setData(data);
    &#125;)();
  &#125;, [query]);
  return (
    &lt;div className=&quot;App&quot;&gt;
      &#123;data.map((item, index) =&gt; (
        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;
      ))&#125;
      &lt;input
        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入搜索值&quot;
      /&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>此时我们改变 <code>query</code> 的值，副作用函数便会被执行，如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef93bf033594ba0b2272f59a99e2447~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>所以，如果你的接口有查询参数，可以将参数设置在 <code>useEffect</code> 的第二个参数的数组值中，这样改变查询变量的时候，副作用便会再次触发执行，相应的函数也会重新带着最新的参数，获取接口数据。</p>
<h4 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h4><p>我们可以将上述的请求，抽离成一个自定义 <code>hook</code>，方便在多个地方调用，新建 <code>useApi.js</code> 如下所示：</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;
// 模拟请求
const getList = (query) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;query&quot;, query);
      resolve([6, 7, 8, 9, 10]);
    &#125;, 3000);
  &#125;);
&#125;;
// 自定义 hook
const useApi = () =&gt; &#123;
  const [data, setData] = useState([1, 2, 3, 4, 5]);
  const [query, setQuery] = useState(&quot;&quot;);

  useEffect(() =&gt; &#123;
    (async () =&gt; &#123;
      const data = await getList();
      console.log(&quot;data&quot;, data);
      setData(data);
    &#125;)();
  &#125;, [query]);

  return [&#123; data &#125;, setQuery];
&#125;;

export default useApi;
</code></pre>
<p>如上述所示，最终将 <code>data</code> 数据，和设置请求参数的方法抛出，在 <code>App.jsx</code> 中做如下改动：</p>
<pre><code class="js">import React from &quot;react&quot;;
import useApi from &quot;./useApi&quot;;

function App() &#123;
  const [&#123; data &#125;, setQuery] = useApi();
  return (
    &lt;div className=&quot;App&quot;&gt;
      &#123;data.map((item, index) =&gt; (
        &lt;span key=&#123;index&#125;&gt;&#123;item&#125;&lt;/span&gt;
      ))&#125;
      &lt;input
        onChange=&#123;(e) =&gt; setQuery(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入搜索值&quot;
      /&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>我们查看浏览器展示结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae7372c75f23457eb8d114c2bb5d56a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>上述这类自定义 <code>Hook</code> 的使用，在开发中也非常常见，比如有一个请求公共数据的接口，在多个页面中被重复使用，你便可通过自定义 <code>Hook</code> 的形式，将请求逻辑提取出来公用，这也是之前 <code>Class</code> 类组件所不能做到的。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>我们修改 <code>App.jsx</code>，在内部新增一个子组件，子组件接收父组件传进来的一个对象，作为子组件的 <code>useEffect</code> 的第二个依赖参数。</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;

function Child(&#123; data &#125;) &#123;
  useEffect(() =&gt; &#123;
    console.log(&quot;查询条件：&quot;, data);
  &#125;, [data]);

  return &lt;div&gt;子组件&lt;/div&gt;;
&#125;

function App() &#123;
  const [name, setName] = useState(&quot;&quot;);
  const [phone, setPhone] = useState(&quot;&quot;);
  const [kw, setKw] = useState(&quot;&quot;);

  const data = &#123;
    name,
    phone,
  &#125;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入姓名&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入电话&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入关键词&quot;
      /&gt;
      &lt;Child data=&#123;data&#125; /&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>当我们修改姓名和电话的时候，观察子组件是否监听到依赖的变化，执行 <code>useEffect</code> 内的回调函数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c533fa2d7a44f491734454089b3b84~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>此时，上述的结果是我们预期的，我们只监听了 <code>name</code> 和 <code>phone</code> 两个参数，但是我们修改关键词输入框，会得到下面的结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40462facac94aea91209bb5cbc1cedc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>子组件并没有监听 <code>kw</code> 的变化，但是结果却是子组件也被触发渲染了。原因其实是我们在父组件重新 <code>setKw</code> 之后，<code>data</code> 值和未作修改 <code>kw</code> 前的值已经不一样了。你可能会说，<code>data</code> 的值并没有变化，为什么说它已经不一样了呢？详细的分析我们放在后续部分，我们此时可以通过 <code>useMemo</code> 将 <code>data</code> 包装一下，告诉 <code>data</code> 它需要监听的值。</p>
<pre><code class="js">import React, &#123; useEffect, useState, useMemo &#125; from &quot;react&quot;;

function Child(&#123; data &#125;) &#123;
  useEffect(() =&gt; &#123;
    console.log(&quot;查询条件：&quot;, data);
  &#125;, [data]);

  return &lt;div&gt;子组件&lt;/div&gt;;
&#125;

function App() &#123;
  const [name, setName] = useState(&quot;&quot;);
  const [phone, setPhone] = useState(&quot;&quot;);
  const [kw, setKw] = useState(&quot;&quot;);

  const data = useMemo(
    () =&gt; (&#123;
      name,
      phone,
    &#125;),
    [name, phone]
  );

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入姓名&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入电话&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入关键词&quot;
      /&gt;
      &lt;Child data=&#123;data&#125; /&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6a5ab0f6784e8bb1d45a7d2b5eb883~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>这便是 <code>useMemo</code> 的作用，它相当于把父组件需要传递的参数做了一个标记，无论父组件其他状态更新任何值，都不会影响要传递给子组件的对象。</p>
<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>同理，<code>useCallback</code> 也是和 <code>useMemo</code> 有类似的功能，比如我们传递一个函数给子组件，如下所示：</p>
<pre><code class="js">import React, &#123; useEffect, useState, useCallback &#125; from &quot;react&quot;;

function Child(&#123; callback &#125;) &#123;
  useEffect(() =&gt; &#123;
    callback();
  &#125;, [callback]);

  return &lt;div&gt;子组件&lt;/div&gt;;
&#125;

function App() &#123;
  const [name, setName] = useState(&quot;&quot;);
  const [phone, setPhone] = useState(&quot;&quot;);
  const [kw, setKw] = useState(&quot;&quot;);

  const callback = () =&gt; &#123;
    console.log(&quot;我是callback&quot;);
  &#125;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setName(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入姓名&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setPhone(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入电话&quot;
      /&gt;
      &lt;input
        onChange=&#123;(e) =&gt; setKw(e.target.value)&#125;
        type=&quot;text&quot;
        placeholder=&quot;请输入关键词&quot;
      /&gt;
      &lt;Child callback=&#123;callback&#125; /&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>当我们修改任何状态值，都会触发子组件的回调函数执行，但是 <code>callback</code> 没有作任何变化。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a9b334d4514959aa7cebe0006257a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>此时，我们给要传递的函数，包裹一层 <code>useCallback</code>，如下所示：</p>
<pre><code class="js">const callback = useCallback(() =&gt; &#123;
  console.log(&quot;我是callback&quot;);
&#125;, []);
</code></pre>
<p>无论修改其他任何属性，都不会触发子组件的副作用：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1742b2a340c24cd4b439d17547265e48~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<blockquote>
<p>useCallback 的第二个参数同 <code>useEffect</code> 和 <code>useMemo</code> 的第二个参数，它是用于监听你需要监听的变量，如在数组内添加 <code>name</code>、<code>phone</code>、<code>kw</code> 等参数，当改变其中有个，都会触发子组件副作用的执行。</p>
</blockquote>
<p>所以，<code>useMemo</code> 和 <code>useCallback</code>，都能为「重复渲染」这个问题，提供很好的帮助。</p>
<h2 id="重新认识-useEffect"><a href="#重新认识-useEffect" class="headerlink" title="重新认识 useEffect"></a>重新认识 useEffect</h2><p>上述很多现象，都是因为你没有很好地去理解 <code>React Hooks</code> 函数组件写法的渲染机制。通过一个小例子，我们来重新认识 <code>useEffect</code>。</p>
<p>我们将上述 <code>App.jsx</code> 作如下修改：</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;

function App() &#123;
  const [count, setCount] = useState(0);

  const handleClick = () =&gt; &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + count);
    &#125;, 3000);
  &#125;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;
      &lt;button onClick=&#123;handleClick&#125;&gt;展示点击次数&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>我们作下列几个动作：</p>
<p>1、点击增加按钮两次，将 <code>count</code> 增加到 2。</p>
<p>2、点击「展示点击次数」。</p>
<p>3、在 <code>console.log</code> 执行之前，也就是 3 秒内，再次点击新增按钮 2 次，将 <code>count</code> 增加到 4。</p>
<p>按照正常的思路，浏览器应该打印出 <code>点击次数: 4</code>，我们来查看浏览器的展示效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1975c7d4488e4c9a854606cb4dfa1009~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>点击「展示点击次数」按钮，3 秒后，我们看到的结果是 <code>点击次数: 2</code>，这与我们的预期有出入。</p>
<p>函数组件 <code>App</code>，在每一次渲染都会被调用，而每一次调用都会形成一个独立的上下文，可以理解成一个快照。每一次渲染形成的快照，都是互相独立的。</p>
<p>默认进来的时候，形成一个快照，此时 <code>count</code> 为 0；当我们点击新增按钮第一次，执行 <code>setCount</code>，函数组件被刷新一次，此时的快照中，<code>count</code> 为 1；再次点击按钮，再次生成快照，此时的 <code>count</code> 为 2，此时点击 「展示点击次数」按钮，在这份快照中，我们的 <code>count</code> 参数就是 2。所以我们后面无论怎么新增 <code>count</code>，最终输出的结果 <code>count</code> 就是 2。</p>
<p>我们用一份伪代码来解释，大致如下：</p>
<pre><code class="js">// 默认初始化
function App() &#123;
  const count = 0; // useState 返回默认值
  // ...
  function handleClick() &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + count);
    &#125;, 3000);
  &#125;
  // ...
&#125;

// 第一次点击
function App() &#123;
  const count = 1; // useState 返回值
  // ...
  function handleClick() &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + count);
    &#125;, 3000);
  &#125;
  // ...
&#125;

// 第二次点击
function App() &#123;
  const count = 2; // useState 返回值
  // ...
  function handleAlertClick() &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + count);
    &#125;, 3000);
  &#125;
  // ...
&#125;
</code></pre>
<p>上述代码中，第二次点击的快照中，<code>console.log(&#39;点击次数: &#39; + count);</code> 取的便是 <code>const count = 2</code>。</p>
<p>同理，我们可以直到，每次渲染函数组件时，<code>useEffect</code> 都是新的，都是不一样的。我们对上面的写法稍作改动。</p>
<pre><code class="js">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;

function App() &#123;
  const [count, setCount] = useState(0);

  useEffect(() =&gt; &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + count);
    &#125;, 3000);
  &#125;);

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击&#123;count&#125;次&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bef605a7a9c45f19f950be4e94a0c31~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>每一次点击，都会重新执行 <code>useEffect</code> 内的回调，并且 <code>count</code> 值也是当时的快照的一个常量值。</p>
<p>这和之前的类组件是不同的，我们改成类组件的实现形式如下：</p>
<pre><code class="js">import React from &quot;react&quot;;

export default class App extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      count: 0,
    &#125;;
  &#125;
  componentDidUpdate() &#123;
    setTimeout(() =&gt; &#123;
      console.log(&quot;点击次数: &quot; + this.state.count);
    &#125;, 3000);
  &#125;

  render() &#123;
    return (
      &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;
        点击&#123;this.state.count&#125;次
      &lt;/button&gt;
    );
  &#125;
&#125;
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c175d79f67284e59ad4e9794e2ff2355~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>类组件，声明之后，会在内部生成一个实例 <code>instance</code>，所有的数据都会存在类的上下文中，所以 <code>this.state.count</code> 会一直指向最新的 <code>count</code> 值。</p>
<p>说到这里，大家应该对 <code>React Hooks</code> 的函数组件写法有了新的认识。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>行文至此，希望让同学们能好好地阅读和学习本章节的内容，以及课后对 <code>React Hooks</code> 的拓展。更好的理解它，有助于写出可维护、可拓展的代码，技术本身是服务于业务需求的，但是你不能很好的利用技术的特点，那业务也很难达到做满意的效果。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/01/03/111-react/" title="111、稀土掘金小册-记账本（二）react vite"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 111、稀土掘金小册-记账本（二）react vite</span></a><a class="button is-default" href="/2022/12/20/109-css/" title="109、CSS代码片段：布局、视觉、动画"><span class="has-text-weight-semibold">下一页: 109、CSS代码片段：布局、视觉、动画</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
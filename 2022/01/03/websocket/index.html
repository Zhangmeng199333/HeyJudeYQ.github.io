<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>49、websocket实现客户端和服务端的通信</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。


一、websocket特点：
1、建立在 TCP 协议之上，服务器端的实现比较容易。2、与 HTTP 协议有着良好的兼容性，默认端口也是80和443。并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。3、数据格式比较轻量，性能开销小，通信高效。4、可以发送文本，也可以发送二进制数据。5、没有同源限制，客户端可以与任意服务器通信。6、全双工(通信允许数据在两个方向上同时传输，它在能力上.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">49、websocket实现客户端和服务端的通信</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81websocket%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">一、websocket特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-text">二、心跳机制</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/websocket"><i class="tag post-item-tag">websocket</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">49、websocket实现客户端和服务端的通信</h1><time class="has-text-grey" datetime="2022-01-03T12:00:00.000Z">2022-01-03</time><article class="mt-2 post-content"><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。传统的http协议，通信只能由客户端发起。websocket实现了客户端和服务端的双向平等对话，websocket最大的特点：服务器可以主动向用户推送信息，客户端也可以主动向服务端发送信息。</p>
<span id="more"></span>

<h2 id="一、websocket特点："><a href="#一、websocket特点：" class="headerlink" title="一、websocket特点："></a>一、websocket特点：</h2><blockquote>
<p>1、建立在 TCP 协议之上，服务器端的实现比较容易。<br>2、与 HTTP 协议有着良好的兼容性，默认端口也是80和443。并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>3、数据格式比较轻量，性能开销小，通信高效。<br>4、可以发送文本，也可以发送二进制数据。<br>5、没有同源限制，客户端可以与任意服务器通信。<br>6、全双工(通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合,例如指 A→B 的同时 B→A ，是瞬时同步的)<br>7、协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
</blockquote>
<p>初始化websocket<br>1、创建websocket实例，参数为url<br>2、连接 websocket.onopen<br>3、server响应数据触发 websocket.onmessage<br>4、关闭websocket，websocket.onclose</p>
<pre><code class="js">// 构造函数 参数为url
const wsurl = &quot;ws://localhost:8080&quot;;
var ws = new Websocket(wsurl);

// 连接状态readState 1  准备好发送和接受数据了
ws.onopen = function()&#123;
  ws.send(&#39;hello server! websocket is open now!&#39;)
&#125;

// 通过客户端的事件   发送信息给服务端
ws.send(&#39;hello websocket&#39;);

// 发生错误
ws.onerror = function(event)&#123;
  console.log(&quot;websocket error observed&quot;,event)
&#125;

// readState CLOSED  关闭websocket
ws.onclose = function(event)&#123;
  let status_code = event.status;
  let msg = event.msg;
  console.log(&quot;websocket is closed now&quot;)
&#125;

// 响应数据的接收
ws.onmessage = function(event)&#123;
  let data = event.data;
&#125;
</code></pre>
<ul>
<li>路由改变，需要断开websocket连接，节省服务器开支。</li>
</ul>
<h2 id="二、心跳机制"><a href="#二、心跳机制" class="headerlink" title="二、心跳机制"></a>二、心跳机制</h2><blockquote>
<p>websocket在连接关闭的情况下触发onclose事件，连接异常触发onerror事件。网络状态不好的情况，onclose事件的触发灵敏度不高，可能会造成断网很久触发onclose事件，客户端又出现重新连接，客户端实时界面不友好。</p>
</blockquote>
<p>为了解决上面的情况，使用心跳重连机制，客户端在websocket连接成功后，执行心跳函数，首先向服务器发送’ping‘信息，服务器收到信息会返回’pong’信息。一定时间内，客户端收到服务器返回的信息，则表示连接正常，重置心跳函数；客户端在一定时间内没有收到心跳函数，表明没有连接成功，客户端关闭websocket,再执行重连操作。</p>
<p>解决方式：</p>
<details>
<summary>点我展示代码</summary>

<pre><code class="js">import &#123; mapActions, mapState &#125; from &#39;vuex&#39;;
export default &#123;
    name: &#39;Websocket&#39;,
    data() &#123;
        return &#123;
            // 是否正在重连
            lockReconnect: false,
            socket: null,
            reconnectTimeout: null,
            timeout: 10 * 1000,
            timer: null,
            serverTimer: null
        &#125;;
    &#125;,
    computed: &#123;
        ...mapState([&#39;userInfo&#39;]),
        wsuri() &#123;
            return `$&#123;process.env.VUE_APP_WEBSOCKET_URI&#125;$&#123;this.userInfo.tenantId&#125;;$&#123;this.userInfo.userId&#125;`;
        &#125;
    &#125;,
    async mounted() &#123;
        await this.getUserInfo();
        this.initWebSocket();
    &#125;,
    destroyed() &#123;
        this.socket.close();
    &#125;,
    methods: &#123;
        ...mapActions([&#39;getUserInfo&#39;]),
        start(ws) &#123;
            this.reset();
            this.timer = setTimeout(() =&gt; &#123;
                // console.log(&#39;发送心跳,后端收到后，返回一个心跳消息&#39;)
                // onmessage拿到返回的心跳就说明连接正常
                ws.send(&#39;ping&#39;);
                this.serverTimer = setTimeout(() =&gt; &#123;
                    // 如果超过一定时间还没响应(响应后触发重置)，说明后端断开了
                    ws.close();
                &#125;, this.timeout);
            &#125;, this.timeout);
        &#125;,
        reset() &#123;
            this.serverTimer &amp;&amp; clearTimeout(this.serverTimer);
            this.timer &amp;&amp; clearTimeout(this.timer);
        &#125;,
        reconnect() &#123;
            console.log(&#39;尝试重连&#39;);
            if (this.lockReconnect) &#123;
                return;
            &#125;
            this.lockReconnect = true;
            this.reconnectTimeout &amp;&amp; clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = setTimeout(() =&gt; &#123;
                this.initWebSocket();
                this.lockReconnect = false;
            &#125;, 4 * 1000);
        &#125;,
        // 初始化websocket
        initWebSocket() &#123;
            try &#123;
                if (&#39;WebSocket&#39; in window) &#123;
                    this.socket = new WebSocket(this.wsuri);
                &#125; else &#123;
                    console.log(&#39;您的浏览器不支持websocket&#39;);
                &#125;
                this.socket.onopen = this.websocketOnOpen;
                this.socket.onerror = this.websocketOnError;
                this.socket.onmessage = this.websocketOnMessage;
                this.socket.onclose = this.websocketClose;
            &#125; catch (e) &#123;
                this.reconnect();
            &#125;
        &#125;,
        websocketOnOpen() &#123;
            console.log(&#39;WebSocket连接成功&#39;, this.socket.readyState);
            this.start(this.socket);
            this.websocketSend();
        &#125;,
        websocketOnError(e) &#123;
            console.log(&#39;WebSocket连接发生错误&#39;, e);
            this.reconnect();
        &#125;,
        websocketOnMessage(e) &#123;
            if (e.data === &#39;pong&#39;) &#123;
                // 消息获取成功，重置心跳
                this.start(this.socket);
            &#125;
        &#125;,
        websocketClose(e) &#123;
            console.log(&#39;connection closed (&#39; + e.code + &#39;)&#39;);
            this.reconnect();
        &#125;,
        websocketSend() &#123;
            this.socket.send(&#39;ping&#39;);
        &#125;
    &#125;
&#125;;
</code></pre>
</details>



</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/13/count-to/" title="50、CountTo:数字动态滚动"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 50、CountTo:数字动态滚动</span></a><a class="button is-default" href="/2022/01/01/hook/" title="48、用hook处理组件内定时器"><span class="has-text-weight-semibold">下一页: 48、用hook处理组件内定时器</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
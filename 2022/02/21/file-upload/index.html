<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>55、大文件断点续传</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="关于大文件断点续传的问题,解决方案是Blob.prototype.slice方法，和数组的slice方法类似，使用slice方法可以返回源文件的切片。按照要求将源文件切位n个切片，将多个切片同时上传，源文件由一个大文件转换成n个小切片同时上传，可以大大减少上传时间。需要注意的是上传到服务端的切片可能位置会发生改变，需要将切片的位置记录下来。


一、服务端（Node.js）服务端需要做的是：接受n个切片，并将这些切片在上传后合并。
需要注意的是：
1、合并切片的时间: 即n个切片什么时候上传完成

前端上传的切片中带有切片的个数，服务端接受到切片的总数后自动合并2、怎么合并切片使用node.js的读写流(readStream/writeStream)，将所有切片的流传输到最终文件的流里。

服务端：

se.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">55、大文件断点续传</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88Node-js%EF%BC%89"><span class="toc-text">一、服务端（Node.js）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">二、客户端</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/vue"><i class="tag post-item-tag">vue</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">55、大文件断点续传</h1><time class="has-text-grey" datetime="2022-02-20T16:00:00.000Z">2022-02-21</time><article class="mt-2 post-content"><p>关于大文件断点续传的问题,解决方案是Blob.prototype.slice方法，和数组的slice方法类似，使用slice方法可以返回源文件的切片。按照要求将源文件切位n个切片，将多个切片同时上传，源文件由一个大文件转换成n个小切片同时上传，可以大大减少上传时间。<br>需要注意的是上传到服务端的切片可能位置会发生改变，需要将切片的位置记录下来。</p>
<span id="more"></span>

<h2 id="一、服务端（Node-js）"><a href="#一、服务端（Node-js）" class="headerlink" title="一、服务端（Node.js）"></a>一、服务端（Node.js）</h2><p>服务端需要做的是：接受n个切片，并将这些切片在上传后合并。</p>
<p>需要注意的是：</p>
<p>1、合并切片的时间: 即n个切片什么时候上传完成</p>
<blockquote>
<p>前端上传的切片中带有切片的个数，服务端接受到切片的总数后自动合并<br>2、怎么合并切片<br>使用node.js的读写流(readStream/writeStream)，将所有切片的流传输到最终文件的流里。</p>
</blockquote>
<p>服务端：</p>
<blockquote>
<p>server<br>-index.js<br>-controller.js</p>
</blockquote>
<details>
<summary>点我展示代码</summary>

<pre><code class="js">// index.js
const Controller = require(&quot;./controller&quot;);
const http = require(&quot;http&quot;);
const server = http.createServer();

const controller = new Controller();

server.on(&quot;request&quot;, async (req, res) =&gt; &#123;
  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
  // 解决跨域   
  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);
  if (req.method === &quot;OPTIONS&quot;) &#123;
    res.status = 200;
    res.end();
    return;
  &#125;
//   验证上传文件是否已上传
  if (req.url === &quot;/verify&quot;) &#123;
    await controller.handleVerifyUpload(req, res);
    return;
  &#125;
    // 合并切片
  if (req.url === &quot;/merge&quot;) &#123;
    await controller.handleMerge(req, res);
    return;
  &#125;
  if (req.url === &quot;/&quot;) &#123;
    await controller.handleFormData(req, res);
  &#125;
&#125;);

server.listen(3001, () =&gt; console.log(&quot;正在监听 3001 端口&quot;));
</code></pre>
<pre><code class="js">// controller.js
// 处理前端传来的FormData
const multiparty = require(&quot;multiparty&quot;);
const path = require(&quot;path&quot;);
const fse = require(&quot;fs-extra&quot;);

const extractExt = filename =&gt;
  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名
const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录

const pipeStream = (path, writeStream) =&gt;
  new Promise(resolve =&gt; &#123;
    //   创建可读流
    const readStream = fse.createReadStream(path);
    readStream.on(&quot;end&quot;, () =&gt; &#123;
      fse.unlinkSync(path);
      resolve();
    &#125;);
    readStream.pipe(writeStream);
  &#125;);

// 合并切片
const mergeFileChunk = async (filePath, fileHash, size) =&gt; &#123;
  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);
  const chunkPaths = await fse.readdir(chunkDir);
  // 根据切片下标进行排序
  // 否则直接读取目录的获得的顺序可能会错乱
  chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);
  await Promise.all(
    chunkPaths.map((chunkPath, index) =&gt;
      pipeStream(
        path.resolve(chunkDir, chunkPath),
        // 指定位置创建可写流
        fse.createWriteStream(filePath, &#123;
          start: index * size,
          end: (index + 1) * size
        &#125;)
      )
    )
  );
  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录
&#125;;

const resolvePost = req =&gt;
  new Promise(resolve =&gt; &#123;
    let chunk = &quot;&quot;;
    req.on(&quot;data&quot;, data =&gt; &#123;
      chunk += data;
    &#125;);
    req.on(&quot;end&quot;, () =&gt; &#123;
      resolve(JSON.parse(chunk));
    &#125;);
  &#125;);

// 返回已经上传切片名
const createUploadedList = async fileHash =&gt;
  fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))
    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))
    : [];

module.exports = class &#123;
  // 合并切片
  async handleMerge(req, res) &#123;
    const data = await resolvePost(req);
    const &#123; fileHash, filename, size &#125; = data;
    const ext = extractExt(filename);
    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);
    await mergeFileChunk(filePath, fileHash, size);
    res.end(
      JSON.stringify(&#123;
        code: 0,
        message: &quot;file merged success&quot;
      &#125;)
    );
  &#125;
  // 处理切片
  async handleFormData(req, res) &#123;
    const multipart = new multiparty.Form();
    //下面multipart.parse的回调中 fields 参数保存了FormData中的文件
    multipart.parse(req, async (err, fields, files) =&gt; &#123;
      if (err) &#123;
        console.error(err);
        res.status = 500;
        res.end(&quot;process file chunk failed&quot;);
        return;
      &#125;
      const [chunk] = files.chunk;
      const [hash] = fields.hash;
      const [fileHash] = fields.fileHash;
      const [filename] = fields.filename;
      const filePath = path.resolve(
        UPLOAD_DIR,
        `$&#123;fileHash&#125;$&#123;extractExt(filename)&#125;`
      );
      const chunkDir = path.resolve(UPLOAD_DIR, fileHash);

      // 文件存在直接返回
      if (fse.existsSync(filePath)) &#123;
        res.end(&quot;file exist&quot;);
        return;
      &#125;

      // 切片目录不存在，创建切片目录
      if (!fse.existsSync(chunkDir)) &#123;
        await fse.mkdirs(chunkDir);
      &#125;
      // fs-extra 专用方法，类似 fs.rename 并且跨平台
      // fs-extra 的 rename 方法 windows 平台会有权限问题
      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835
      await fse.move(chunk.path, path.resolve(chunkDir, hash));
      res.end(&quot;received file chunk&quot;);
    &#125;);
  &#125;
  // 验证是否已上传/已上传切片下标
  async handleVerifyUpload(req, res) &#123;
    const data = await resolvePost(req);
    const &#123; fileHash, filename &#125; = data;
    const ext = extractExt(filename);
    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);
    if (fse.existsSync(filePath)) &#123;
      res.end(
        JSON.stringify(&#123;
          shouldUpload: false
        &#125;)
      );
    &#125; else &#123;
      res.end(
        JSON.stringify(&#123;
          shouldUpload: true,
          uploadedList: await createUploadedList(fileHash)
        &#125;)
      );
    &#125;
  &#125;
&#125;;
</code></pre>
</details>


<h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><p>前端使用Vue+elementUI展示界面，当点击上传按钮时，slice方法将源文件做切片处理，将切片放入数组中返回，使用 hash+index 给每个切片做标识，用于上传完成后合并切片。<br>调用uploadChunks上传所有的切片，将切片、切片hash、切片名filename放入FormData中，使用promise.all并发上传所有切片。</p>
<p>断点续传原理在于前后端需要记住已经上传的切片，继续上传的时候就可以跳过之前已经上传的部分。</p>
<p>实现的方案：</p>
<blockquote>
<p>服务端保存已经上传的切片hash，前端每次上传前都向服务端获取已经上传的切片。</p>
</blockquote>
<p>这里也可以在前端使用localStorage记录已经上传的切片的hash，但是存在问题，就是换一个浏览器就失去已经上传的切片的hash了。</p>
<p>客户端、服务端都需要生成文件和切片的hash，根据文件内容生成hash。使用spark-md5根据文件内容计算出文件的hash值。</p>
<p>当文件比较大的时候，读取文件内容计算hash是非常耗时的，会引起UI阻塞，导致页面假死，解决方式是使用web-worker在worker线程计算hash。</p>
<p>实例化web-worker，参数是一个js文件路径不能跨域，需要单独创建一个hash.js文件放在public中，在worker中不允许访问dom，使用importScripts函数导入外部脚本spark-md5</p>
<pre><code class="js">// hash.js
self.importScripts(&quot;/spark-md5.min.js&quot;); // 导入脚本

// 生成文件 hash
self.onmessage = e =&gt; &#123;
  const &#123; fileChunkList &#125; = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index =&gt; &#123;
    const reader = new FileReader();
    reader.readAsArrayBuffer(fileChunkList[index].file);
    reader.onload = e =&gt; &#123;
      count++;
      spark.append(e.target.result);
      if (count === fileChunkList.length) &#123;
        self.postMessage(&#123;
          percentage: 100,
          hash: spark.end()
        &#125;);
        self.close();
      &#125; else &#123;
        percentage += 100 / fileChunkList.length;
        self.postMessage(&#123;
          percentage
        &#125;);
        loadNext(count);
      &#125;
    &#125;;
  &#125;;
  loadNext(0);
&#125;;
</code></pre>
<p>1、template</p>
<details>
<summary>点我展示代码</summary>

<pre><code class="html">    &lt;div&gt;
      &lt;input
        type=&quot;file&quot;
        :disabled=&quot;status !== Status.wait&quot;
        @change=&quot;handleFileChange&quot;
      /&gt;
      &lt;el-button @click=&quot;handleUpload&quot; :disabled=&quot;uploadDisabled&quot;
        &gt;上传&lt;/el-button
      &gt;
      &lt;el-button @click=&quot;handleResume&quot; v-if=&quot;status === Status.pause&quot;
        &gt;恢复&lt;/el-button
      &gt;
      &lt;el-button
        v-else
        :disabled=&quot;status !== Status.uploading || !container.hash&quot;
        @click=&quot;handlePause&quot;
        &gt;暂停&lt;/el-button
      &gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;!-- &lt;div&gt;计算文件 hash&lt;/div&gt;
      &lt;el-progress :percentage=&quot;hashPercentage&quot;&gt;&lt;/el-progress&gt; --&gt;
      &lt;div&gt;总进度&lt;/div&gt;
      &lt;el-progress :percentage=&quot;fakeUploadPercentage&quot;&gt;&lt;/el-progress&gt;
    &lt;/div&gt;
    &lt;el-table :data=&quot;data&quot;&gt;
      &lt;el-table-column
        prop=&quot;hash&quot;
        label=&quot;切片hash&quot;
        align=&quot;center&quot;
      &gt;&lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;大小(KB)&quot; align=&quot;center&quot; width=&quot;120&quot;&gt;
        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;
          &#123;&#123; row.size | transformByte &#125;&#125;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;进度&quot; align=&quot;center&quot;&gt;
        &lt;template v-slot=&quot;&#123; row &#125;&quot;&gt;
          &lt;el-progress
            :percentage=&quot;row.percentage&quot;
            color=&quot;#909399&quot;
          &gt;&lt;/el-progress&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
</code></pre>
</details>


<p>2、js部分：设置切片大小 考虑到通用性，简单封装了XMLHttpRequest, 实际使用可以隐藏掉hash进度条</p>
<details>
<summary>点我展示代码</summary>

<pre><code class="js">&lt;script&gt;
const SIZE = 100 * 1024 * 1024; // 切片大小

const Status = &#123;
  wait: &quot;wait&quot;,
  pause: &quot;pause&quot;,
  uploading: &quot;uploading&quot;
&#125;;


export default &#123;
  name: &quot;app&quot;,
  filters: &#123;
    transformByte(val) &#123;
      return Number((val / 1024).toFixed(0));
    &#125;
  &#125;,
  data: () =&gt; (&#123;
    Status,
    container: &#123;
      file: null,
      hash: &quot;&quot;,
      worker: null
    &#125;,
    hashPercentage: 0,
    data: [],
    requestList: [],
    status: Status.wait,
    // 当暂停时会取消 xhr 导致进度条后退
    // 为了避免这种情况，需要定义一个假的进度条
    fakeUploadPercentage: 0
  &#125;),
  computed: &#123;
    uploadDisabled() &#123;
      return (
        !this.container.file ||
        [Status.pause, Status.uploading].includes(this.status)
      );
    &#125;,
    uploadPercentage() &#123;
      if (!this.container.file || !this.data.length) return 0;
      const loaded = this.data
        .map(item =&gt; item.size * item.percentage)
        .reduce((acc, cur) =&gt; acc + cur);
      return parseInt((loaded / this.container.file.size).toFixed(2));
    &#125;
  &#125;,
  watch: &#123;
    uploadPercentage(now) &#123;
      if (now &gt; this.fakeUploadPercentage) &#123;
        this.fakeUploadPercentage = now;
      &#125;
    &#125;
  &#125;,
  methods: &#123;
    // 暂停
    handlePause() &#123;
      this.status = Status.pause;
      this.resetData();
    &#125;,
    resetData() &#123;
      this.requestList.forEach(xhr =&gt; xhr?.abort());
      this.requestList = [];
      if (this.container.worker) &#123;
        this.container.worker.onmessage = null;
      &#125;
    &#125;,
    async handleResume() &#123;
      this.status = Status.uploading;
      const &#123; uploadedList &#125; = await this.verifyUpload(
        this.container.file.name,
        this.container.hash
      );
      await this.uploadChunks(uploadedList);
    &#125;,
    // xhr
    request(&#123;
      url,
      method = &quot;post&quot;,
      data,
      headers = &#123;&#125;,
      onProgress = e =&gt; e,
      requestList
    &#125;) &#123;
      return new Promise(resolve =&gt; &#123;
        const xhr = new XMLHttpRequest();
        xhr.upload.onprogress = onProgress;
        xhr.open(method, url);
        Object.keys(headers).forEach(key =&gt;
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e =&gt; &#123;
          // 将请求成功的 xhr 从列表中删除
          if (requestList) &#123;
            const xhrIndex = requestList.findIndex(item =&gt; item === xhr);
            requestList.splice(xhrIndex, 1);
          &#125;
          resolve(&#123;
            data: e.target.response
          &#125;);
        &#125;;
        // 暴露当前 xhr 给外部
        requestList?.push(xhr);
      &#125;);
    &#125;,
    // 生成文件切片
    createFileChunk(file, size = SIZE) &#123;
      const fileChunkList = [];
      let cur = 0;
      while (cur &lt; file.size) &#123;
        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);
        cur += size;
      &#125;
      return fileChunkList;
    &#125;,
    // 生成文件 hash（web-worker）
    calculateHash(fileChunkList) &#123;
      return new Promise(resolve =&gt; &#123;
        this.container.worker = new Worker(&quot;/hash.js&quot;);
        this.container.worker.postMessage(&#123; fileChunkList &#125;);
        this.container.worker.onmessage = e =&gt; &#123;
          const &#123; percentage, hash &#125; = e.data;
          this.hashPercentage = percentage;
          if (hash) &#123;
            resolve(hash);
          &#125;
        &#125;;
      &#125;);
    &#125;,
    handleFileChange(e) &#123;
      const [file] = e.target.files;
      if (!file) return;
      this.resetData();
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
    &#125;,
    async handleUpload() &#123;
      if (!this.container.file) return;
      this.status = Status.uploading;
      const fileChunkList = this.createFileChunk(this.container.file);
      this.container.hash = await this.calculateHash(fileChunkList);

      const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(
        this.container.file.name,
        this.container.hash
      );
      if (!shouldUpload) &#123;
        this.$message.success(&quot;秒传：上传成功&quot;);
        this.status = Status.wait;
        return;
      &#125;

      this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;
        fileHash: this.container.hash,
        index,
        hash: this.container.hash + &quot;-&quot; + index,
        chunk: file,
        size: file.size,
        percentage: uploadedList.includes(index) ? 100 : 0
      &#125;));

      await this.uploadChunks(uploadedList);
    &#125;,
    // 上传切片，同时过滤已上传的切片
    async uploadChunks(uploadedList = []) &#123;
      const requestList = this.data
        .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))
        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;
          const formData = new FormData();
          formData.append(&quot;chunk&quot;, chunk);
          formData.append(&quot;hash&quot;, hash);
          formData.append(&quot;filename&quot;, this.container.file.name);
          formData.append(&quot;fileHash&quot;, this.container.hash);
          return &#123; formData, index &#125;;
        &#125;)
        .map(async (&#123; formData, index &#125;) =&gt;
          this.request(&#123;
            url: &quot;http://localhost:3001&quot;,
            data: formData,
            onProgress: this.createProgressHandler(this.data[index]),
            requestList: this.requestList
          &#125;)
        );
      await Promise.all(requestList);
      // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时
      // 合并切片
      if (uploadedList.length + requestList.length === this.data.length) &#123;
        await this.mergeRequest();
      &#125;
    &#125;,
    // 通知服务端合并切片
    async mergeRequest() &#123;
      await this.request(&#123;
        url: &quot;http://localhost:3001/merge&quot;,
        headers: &#123;
          &quot;content-type&quot;: &quot;application/json&quot;
        &#125;,
        data: JSON.stringify(&#123;
          size: SIZE,
          fileHash: this.container.hash,
          filename: this.container.file.name
        &#125;)
      &#125;);
      this.$message.success(&quot;上传成功&quot;);
      this.status = Status.wait;
    &#125;,
    // 根据 hash 验证文件是否曾经已经被上传过
    // 没有才进行上传
    async verifyUpload(filename, fileHash) &#123;
      const &#123; data &#125; = await this.request(&#123;
        url: &quot;http://localhost:3001/verify&quot;,
        headers: &#123;
          &quot;content-type&quot;: &quot;application/json&quot;
        &#125;,
        data: JSON.stringify(&#123;
          filename,
          fileHash
        &#125;)
      &#125;);
      return JSON.parse(data);
    &#125;,
    // 用闭包保存每个 chunk 的进度数据
    createProgressHandler(item) &#123;
      return e =&gt; &#123;
        item.percentage = parseInt(String((e.loaded / e.total) * 100));
      &#125;;
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
</details></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/02/23/http/" title="56、HTTP的请求方法、状态码"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 56、HTTP的请求方法、状态码</span></a><a class="button is-default" href="/2022/01/24/image-host/" title="54、个人GitHub图床使用webp格式的图片"><span class="has-text-weight-semibold">下一页: 54、个人GitHub图床使用webp格式的图片</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
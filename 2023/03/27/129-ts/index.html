<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>129、any、unknown类型和类型断言</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

any 类型any 主打的就是一个“任意”，而在类型层面，我们也可以这么理解，any 类型 &amp;#x3D; string + number + boolean + 任意对象类型 + 拥有任意参数类型与任意返回值类型的函数类型 + …，它就是无所不包的，因此，在我们不知道对一个变量提供何种类型时，就可以使用 any 类型来作为临时性的过渡方案。
为什么 any 只是临时过度？既然 any 类型能表示所有类型，那它还能带给我们精确的类型提示吗？当然不能，实际上使用了 any 类型，就意味着告诉类型检查系统，这个变量我给它开白名单了，你放过它吧，它想干啥就干啥。这是相当危险的行为，也和我们选择 TypeScript 的原因相悖，因为使用了 any 类型之后，要想代码能够正常运行，你其实又相当于恢复到之前使用 J.."><meta name="generator" content="Hexo 4.2.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">129、any、unknown类型和类型断言</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#any-类型"><span class="toc-text">any 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-any-只是临时过度？"><span class="toc-text">为什么 any 只是临时过度？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unknown-类型"><span class="toc-text">unknown 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型断言"><span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ts"><i class="tag post-item-tag">ts</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">129、any、unknown类型和类型断言</h1><time class="has-text-grey" datetime="2023-03-27T12:00:00.000Z">2023-03-27</time><article class="mt-2 post-content"><a id="more"></a>

<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>any 主打的就是一个“任意”，而在类型层面，我们也可以这么理解，any 类型 &#x3D; string + number + boolean + 任意对象类型 + 拥有任意参数类型与任意返回值类型的函数类型 + …，它就是无所不包的，因此，在我们不知道对一个变量提供何种类型时，就可以使用 any 类型来作为临时性的过渡方案。</p>
<h3 id="为什么-any-只是临时过度？"><a href="#为什么-any-只是临时过度？" class="headerlink" title="为什么 any 只是临时过度？"></a>为什么 any 只是临时过度？</h3><p>既然 any 类型能表示所有类型，那它还能带给我们精确的类型提示吗？当然不能，实际上使用了 any 类型，就意味着告诉类型检查系统，这个变量我给它开白名单了，你放过它吧，它想干啥就干啥。<br>这是相当危险的行为，也和我们选择 TypeScript 的原因相悖，因为使用了 any 类型之后，要想代码能够正常运行，你其实又相当于恢复到之前使用 JavaScript。</p>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>any 类型 &#x3D; 万能类型 + 放弃类型检查，其中「万能类型」是我们想要的，能不能只要这个部分，而不要「放弃类型检查」这个危险的行为呢？当然！考虑到 any 类型的危险性，TypeScript 中还提供了一个功能类似的家伙：unknown 类型，用于表示万能类型的同时，保留类型检查。</p>
<p>万能类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>myFunc(&#123;&#125;)<br>myFunc([])<br>myFunc(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<p>看起来都没报错，和 any 类型一样好用。但如果我们尝试在这个函数内使用参数呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  param.forEach(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;&#125;) <span class="hljs-comment">// X “param”的类型为“未知”。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在我们尝试使用一个 unknown 类型的变量时，类型检查系统阻止了我们，它要求我们先为这个变量提供一个具体的类型后才能使用。而我们这里调用了 forEach 方法，很明显，我们希望它是一个数组类型！但此时在代码中，param 的类型已经被固定为 unknown，此时我们应该如何修改一个变量的类型？</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>能够修改一个变量的类型——无论是 TS 自己推导的，还是你手动标注的。一旦你为这个变量提供了类型，或者是赋值之后，这个变量的类型就已经固定了，我们无法再对它进行修改。而现在有了类型断言，我们现在可以指着这个变量告诉 TS，这个类型看起来是一个字符串，其实它是一个数字！</p>
<p>上面的例子，如果要将 unknown 类型的变量断言到数组类型，我们可以这么写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;&#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>我们将参数类型断言到了一个成员类型为 unknown 的数组类型，而在后面的使用过程中，我们可能需要对数组成员进一步操作：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = element + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>虽然我们心里希望 element 是数字类型，但是 TS 可猜不到。此时，你可以考虑将 param 的类型一步到位的完善，也可以在后续使用时一步步完善：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = element + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-params">function</span> <span class="hljs-params">myFunc</span>(<span class="hljs-params">param: unknown</span>) &#123;</span><br><span class="hljs-function">  ;(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = (<span class="hljs-params">element <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span></span>) + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>这两种方式使用起来并没有明显的差异，但第二种一步步断言的方式更能体现类型断言的意义：一个变量最开始是未知的类型，但随着后续的一步步使用，我们通过类型断言慢慢地完善这个类型的轮廓，最后完成对初始类型的定义。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>any 类型和 unknown 类型都能提供万能类型的作用，但不同之处在于，使用 any 类型后就丧失了类型检查的保护，可以对变量进行任意操作。而使用 unknown 类型时，虽然我们每进行一次操作都需要进行类型断言，断言到当前我们预期的类型，但这却能实现类型信息反向补全的功能，为最终我们的具体类型埋下伏笔。虽然 any 类型的使用过程中也可以通过类型断言保障，但毕竟缺少了类型告警，我们很容易就忽略掉了。</p>
<p>上面我们了解的是初始提供 any &#x2F; unknown 类型，然后通过类型断言将其断言到预期类型的操作。实际上，还有一个更常见的场景是将一个拥有具体类型的变量断言到 any &#x2F; unknown 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">'jude'</span><br><br>;(str <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).handler().result.prop <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>为什么我们需要这么做？因为很多时候，你面临的项目中并不会是完全没有类型定义的，这些变量可能最开始也是被维护者精心设计了类型的，但随着项目的不断迭代和维护者的更替，它们才日渐年久失修，导致你在使用这些变量时需要面对大量的类型报错。所以这个时候我们就可以请出类型断言，先将其断言到一个万能类型，然后就重复我们上面学习的，随着一步步调用不断完善类型，然后最后回头补全的过程。</p>
<p>某些时候 TypeScript 的类型分析会显得不那么符合直觉，比如这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IUser &#123;<br>  name: <span class="hljs-built_in">string</span><br>  job?: IJob<br>&#125;<br><br><span class="hljs-keyword">interface</span> IJob &#123;<br>  title: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> user: IUser = &#123;<br>  name: <span class="hljs-string">'foo'</span>,<br>  job: &#123;<br>    title: <span class="hljs-string">'bar'</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; name, job = &#123;&#125; &#125; = user<br><br><span class="hljs-keyword">const</span> &#123; title &#125; = job <span class="hljs-comment">// 类型“&#123;&#125;”上不存在属性“title”。</span><br></code></pre></td></tr></table></figure>

<p>由于我们在第一次解构赋值时，为 job 提供了一个空对象作为默认值，TypeScript 会认为此时 job 的类型就是一个空对象，所以我们在第二次解构赋值时，就无法从 job 上获得 title 属性了。要解决这个问题，我们可以在第一次解构赋值时将这个空对象断言到预期的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; name, job = &#123;&#125; <span class="hljs-keyword">as</span> IJob &#125; = user<br><br><span class="hljs-keyword">const</span> &#123; title &#125; = job<br></code></pre></td></tr></table></figure>

<p>原始类型和对象类型标注能够对应到 JavaScript 中的数据类型，any 与 unknown 类型是全新的概念，赋予了我们描述“任意类型”的能力，而 unknown 则是为了解决 any 类型过于无拘无束的特点而诞生的。同时，由于某些变量可能在交到我们手里时就已经获得了自己的初始类型，要使用 any 和 unknown 作为新的变量类型，我们就需要类型断言的帮助，它的作用当然就是将变量类型断言到一个新的类型。通过配合 unknown 类型和类型断言，我们就能够在描述任意类型的同时，确保代码中实际逻辑的安全。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/29/130-ts/" title="130、类型别名、联合类型、交叉类型"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 130、类型别名、联合类型、交叉类型</span></a><a class="button is-default" href="/2023/03/22/128-vue/" title="128、map和forEach"><span class="has-text-weight-semibold">下一页: 128、map和forEach</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen" target="_blank" rel="noopener">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>129、any、unknown、never类型和类型断言</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

any 类型any 主打的就是一个“任意”，而在类型层面，我们也可以这么理解，any 类型 &amp;#x3D; string + number + boolean + 任意对象类型 + 拥有任意参数类型与任意返回值类型的函数类型 + …，它就是无所不包的，因此，在我们不知道对一个变量提供何种类型时，就可以使用 any 类型来作为临时性的过渡方案。
为什么 any 只是临时过度？既然 any 类型能表示所有类型，那它还能带给我们精确的类型提示吗？当然不能，实际上使用了 any 类型，就意味着告诉类型检查系统，这个变量我给它开白名单了，你放过它吧，它想干啥就干啥。这是相当危险的行为，也和我们选择 TypeScript 的原因相悖，因为使用了 any 类型之后，要想代码能够正常运行，你其实又相当于恢复到之前使用 J.."><meta name="generator" content="Hexo 4.2.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">129、any、unknown、never类型和类型断言</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#any-类型"><span class="toc-text">any 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-any-只是临时过度？"><span class="toc-text">为什么 any 只是临时过度？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unknown-类型"><span class="toc-text">unknown 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型断言"><span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#never-类型"><span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型断言（附加）"><span class="toc-text">类型断言（附加）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双重断言"><span class="toc-text">双重断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非空断言"><span class="toc-text">非空断言</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ts"><i class="tag post-item-tag">ts</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">129、any、unknown、never类型和类型断言</h1><time class="has-text-grey" datetime="2023-03-27T12:00:00.000Z">2023-03-27</time><article class="mt-2 post-content"><a id="more"></a>

<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>any 主打的就是一个“任意”，而在类型层面，我们也可以这么理解，any 类型 &#x3D; string + number + boolean + 任意对象类型 + 拥有任意参数类型与任意返回值类型的函数类型 + …，它就是无所不包的，因此，在我们不知道对一个变量提供何种类型时，就可以使用 any 类型来作为临时性的过渡方案。</p>
<h3 id="为什么-any-只是临时过度？"><a href="#为什么-any-只是临时过度？" class="headerlink" title="为什么 any 只是临时过度？"></a>为什么 any 只是临时过度？</h3><p>既然 any 类型能表示所有类型，那它还能带给我们精确的类型提示吗？当然不能，实际上使用了 any 类型，就意味着告诉类型检查系统，这个变量我给它开白名单了，你放过它吧，它想干啥就干啥。<br>这是相当危险的行为，也和我们选择 TypeScript 的原因相悖，因为使用了 any 类型之后，要想代码能够正常运行，你其实又相当于恢复到之前使用 JavaScript。</p>
<p>any 类型的主要意义，其实就是为了表示一个无拘无束的“任意类型”，它能兼容所有类型，也能够被所有类型兼容。这一作用其实也意味着类型世界给你开了一个外挂，无论什么时候，你都可以使用 any 类型跳过类型检查。当然，运行时出了问题就需要你自己负责了。</p>
<blockquote>
<p>any 的本质是类型系统中的顶级类型，即 Top Type。</p>
</blockquote>
<h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p>any 类型 &#x3D; 万能类型 + 放弃类型检查，其中「万能类型」是我们想要的，能不能只要这个部分，而不要「放弃类型检查」这个危险的行为呢？当然！考虑到 any 类型的危险性，TypeScript 中还提供了一个功能类似的家伙：unknown 类型，用于表示万能类型的同时，保留类型检查。</p>
<p>万能类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>myFunc(&#123;&#125;)<br>myFunc([])<br>myFunc(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<p>看起来都没报错，和 any 类型一样好用。但如果我们尝试在这个函数内使用参数呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  param.forEach(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;&#125;) <span class="hljs-comment">// X “param”的类型为“未知”。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在我们尝试使用一个 unknown 类型的变量时，类型检查系统阻止了我们，它要求我们先为这个变量提供一个具体的类型后才能使用。而我们这里调用了 forEach 方法，很明显，我们希望它是一个数组类型！但此时在代码中，param 的类型已经被固定为 unknown，此时我们应该如何修改一个变量的类型？</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>能够修改一个变量的类型——无论是 TS 自己推导的，还是你手动标注的。一旦你为这个变量提供了类型，或者是赋值之后，这个变量的类型就已经固定了，我们无法再对它进行修改。而现在有了类型断言，我们现在可以指着这个变量告诉 TS，这个类型看起来是一个字符串，其实它是一个数字！</p>
<p>上面的例子，如果要将 unknown 类型的变量断言到数组类型，我们可以这么写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;&#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>我们将参数类型断言到了一个成员类型为 unknown 的数组类型，而在后面的使用过程中，我们可能需要对数组成员进一步操作：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = element + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>虽然我们心里希望 element 是数字类型，但是 TS 可猜不到。此时，你可以考虑将 param 的类型一步到位的完善，也可以在后续使用时一步步完善：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">param: unknown</span>) </span>&#123;<br>  ;<span class="hljs-function">(<span class="hljs-params">param <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = element + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-params">function</span> <span class="hljs-params">myFunc</span>(<span class="hljs-params">param: unknown</span>) &#123;</span><br><span class="hljs-function">  ;(<span class="hljs-params">param <span class="hljs-keyword">as</span> unknown[]</span>).<span class="hljs-params">forEach</span>(<span class="hljs-params">(<span class="hljs-params">element</span>) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    element = (<span class="hljs-params">element <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span></span>) + 1</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>这两种方式使用起来并没有明显的差异，但第二种一步步断言的方式更能体现类型断言的意义：一个变量最开始是未知的类型，但随着后续的一步步使用，我们通过类型断言慢慢地完善这个类型的轮廓，最后完成对初始类型的定义。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>any 类型和 unknown 类型都能提供万能类型的作用，但不同之处在于，使用 any 类型后就丧失了类型检查的保护，可以对变量进行任意操作。而使用 unknown 类型时，虽然我们每进行一次操作都需要进行类型断言，断言到当前我们预期的类型，但这却能实现类型信息反向补全的功能，为最终我们的具体类型埋下伏笔。虽然 any 类型的使用过程中也可以通过类型断言保障，但毕竟缺少了类型告警，我们很容易就忽略掉了。</p>
<p>上面我们了解的是初始提供 any &#x2F; unknown 类型，然后通过类型断言将其断言到预期类型的操作。实际上，还有一个更常见的场景是将一个拥有具体类型的变量断言到 any &#x2F; unknown 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">'jude'</span><br><br>;(str <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).handler().result.prop <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>为什么我们需要这么做？因为很多时候，你面临的项目中并不会是完全没有类型定义的，这些变量可能最开始也是被维护者精心设计了类型的，但随着项目的不断迭代和维护者的更替，它们才日渐年久失修，导致你在使用这些变量时需要面对大量的类型报错。所以这个时候我们就可以请出类型断言，先将其断言到一个万能类型，然后就重复我们上面学习的，随着一步步调用不断完善类型，然后最后回头补全的过程。</p>
<p>某些时候 TypeScript 的类型分析会显得不那么符合直觉，比如这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IUser &#123;<br>  name: <span class="hljs-built_in">string</span><br>  job?: IJob<br>&#125;<br><br><span class="hljs-keyword">interface</span> IJob &#123;<br>  title: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> user: IUser = &#123;<br>  name: <span class="hljs-string">'foo'</span>,<br>  job: &#123;<br>    title: <span class="hljs-string">'bar'</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; name, job = &#123;&#125; &#125; = user<br><br><span class="hljs-keyword">const</span> &#123; title &#125; = job <span class="hljs-comment">// 类型“&#123;&#125;”上不存在属性“title”。</span><br></code></pre></td></tr></table></figure>

<p>由于我们在第一次解构赋值时，为 job 提供了一个空对象作为默认值，TypeScript 会认为此时 job 的类型就是一个空对象，所以我们在第二次解构赋值时，就无法从 job 上获得 title 属性了。要解决这个问题，我们可以在第一次解构赋值时将这个空对象断言到预期的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> &#123; name, job = &#123;&#125; <span class="hljs-keyword">as</span> IJob &#125; = user<br><br><span class="hljs-keyword">const</span> &#123; title &#125; = job<br></code></pre></td></tr></table></figure>

<p>原始类型和对象类型标注能够对应到 JavaScript 中的数据类型，any 与 unknown 类型是全新的概念，赋予了我们描述“任意类型”的能力，而 unknown 则是为了解决 any 类型过于无拘无束的特点而诞生的。同时，由于某些变量可能在交到我们手里时就已经获得了自己的初始类型，要使用 any 和 unknown 作为新的变量类型，我们就需要类型断言的帮助，它的作用当然就是将变量类型断言到一个新的类型。通过配合 unknown 类型和类型断言，我们就能够在描述任意类型的同时，确保代码中实际逻辑的安全。</p>
<p>any 类型的万能性也导致我们经常滥用它，比如类型不兼容了就 any 一下，类型不想写了也 any 一下，不确定可能会是啥类型还是 any 一下。此时的 TypeScript 就变成了令人诟病的 AnyScript。为了避免这一情况，我们要记住以下小 tips ：</p>
<blockquote>
<p>如果是类型不兼容报错导致你使用 any，考虑用类型断言替代，我们下面就会开始介绍类型断言的作用。<br>如果是类型太复杂导致你不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型。如你需要调用 foo.bar.baz()，就可以先将 foo 断言为一个具有 bar 方法的类型。<br>如果你是想表达一个未知类型，更合理的方式是使用 unknown。</p>
</blockquote>
<p>unknown 类型和 any 类型有些类似，一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> unknownVar: unknown = <span class="hljs-string">'jude'</span><br><br>unknownVar = <span class="hljs-literal">false</span><br>unknownVar = <span class="hljs-string">'jude'</span><br>unknownVar = &#123;<br>  site: <span class="hljs-string">'baidu'</span><br>&#125;<br><br>unknownVar = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> val1: <span class="hljs-built_in">string</span> = unknownVar <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">const</span> val2: <span class="hljs-built_in">number</span> = unknownVar <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">const</span> val3: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125; = unknownVar <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">const</span> val4: &#123;&#125; = unknownVar <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">const</span> val5: <span class="hljs-built_in">any</span> = unknownVar<br><span class="hljs-keyword">const</span> val6: unknown = unknownVar<br></code></pre></td></tr></table></figure>

<p>unknown 和 any 的一个主要差异体现在赋值给别的变量时，any 就像是 “我身化万千无处不在” ，所有类型都把它当自己人。而 unknown 就像是 “我虽然身化万千，但我坚信我在未来的某一刻会得到一个确定的类型” ，只有 any 和 unknown 自己把它当自己人。简单地说，any 放弃了所有的类型检查，而 unknown 并没有。这一点也体现在对 unknown 类型的变量进行属性访问时：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> unknownVar: unknown<br><br>unknownVar.foo() <span class="hljs-comment">// 报错：对象类型为 unknown</span><br></code></pre></td></tr></table></figure>

<p>要对 unknown 类型进行属性访问，需要进行类型断言,即“虽然这是一个未知的类型，但我跟你保证它在这里就是这个类型！”</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> unknownVar: unknown<br>;<span class="hljs-function">(<span class="hljs-params">unknownVar <span class="hljs-keyword">as</span> &#123; foo: (<span class="hljs-params"></span>) =&gt; &#123;&#125; &#125;</span>).<span class="hljs-params">foo</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>在类型未知的情况下，更推荐使用 unknown 标注。这相当于你使用额外的心智负担保证了类型在各处的结构，后续重构为具体类型时也可以获得最初始的类型信息，同时还保证了类型检查的存在。当然，unknown 用起来很麻烦，一堆类型断言写起来可不太好看。归根结底，到底用哪个完全取决于你自己。</p>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p>如果说，any 与 unknown 是比原始类型、对象类型等更广泛的类型，也就是说它们更上层一些，就像 string 字符串类型比 ‘jude’ 字符串字面量更上层一些，即 any&#x2F;unknown -&gt; 原始类型、对象类型 -&gt; 字面量类型</p>
<p>是否存在比字面量类型更底层一些的类型？<br>这里的上层与底层，其实即意味着包含类型信息的多少。any 类型包括了任意的类型，字符串类型包括任意的字符串字面量类型，而字面量类型只表示一个精确的值类型。如要还要更底层，也就是再少一些类型信息，那就只能什么都没有了。<br>而内置类型 never 就是这么一个“什么都没有”的类型。此前我们已经了解了另一个“什么都没有”的类型，void。但相比于 void ，never 还要更加空白一些。</p>
<p>举例说明 never 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> UnionWithNever = <span class="hljs-string">'jude'</span> | <span class="hljs-number">599</span> | <span class="hljs-literal">true</span> | <span class="hljs-built_in">void</span> | never <span class="hljs-comment">// never会被无视掉，void仍然存在</span><br></code></pre></td></tr></table></figure>

<p>void 作为类型表示一个空类型，就像没有返回值的函数使用 void 来作为返回值类型标注一样，void 类型就像 JavaScript 中的 null 一样代表“这里有类型，但是个空类型”。</p>
<p>而 never 才是一个“什么都没有”的类型，它甚至不包括空的类型，严格来说，never 类型不携带任何的类型信息，因此会在联合类型中被直接移除，比如我们看 void 和 never 的类型兼容性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> v1: never<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> v2: <span class="hljs-built_in">void</span><br><br>v1 = v2 <span class="hljs-comment">// X 类型 void 不能赋值给类型 never</span><br><br>v2 = v1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>never 类型被称为 Bottom Type，是整个类型系统层级中最底层的类型。</p>
</blockquote>
<p>和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。<br>通常我们不会显式地声明一个 never 类型，它主要被类型检查所使用。但在某些情况下使用 never 确实是符合逻辑的，比如一个只负责抛出错误的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">justThrow</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在类型流的分析中，一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">justThrow</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">input: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (input &gt; <span class="hljs-number">1</span>) &#123;<br>    justThrow()<br>    <span class="hljs-comment">// 等同于 return 语句后的代码，即 Dead Code</span><br>    <span class="hljs-keyword">const</span> name = <span class="hljs-string">'jude'</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以显式利用它来进行类型检查，即上面在联合类型中 never 类型神秘消失的原因。假设，我们需要对一个联合类型的每个类型分支进行不同处理：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> strOrNumOrBool: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'string'</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'str!'</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'number'</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'num!'</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'boolean'</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bool!'</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown input type: <span class="hljs-subst">$&#123;strOrNumOrBool&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们希望这个变量的每一种类型都需要得到妥善处理，在最后可以抛出一个错误，但这是运行时才会生效的措施，是否能在类型检查时就分析出来？</p>
<p>实际上，由于 TypeScript 强大的类型分析能力，每经过一个 if 语句处理，strOrNumOrBool 的类型分支就会减少一个（因为已经被对应的 typeof 处理过）。而在最后的 else 代码块中，它的类型只剩下了 never 类型，即一个无法再细分、本质上并不存在的虚空类型。在这里，我们可以利用只有 never 类型能赋值给 never 类型这一点，来巧妙地分支处理检查：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'string'</span>) &#123;<br>  <span class="hljs-comment">// 一定是字符串！</span><br>  strOrNumOrBool.charAt(<span class="hljs-number">1</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'number'</span>) &#123;<br>  strOrNumOrBool.toFixed()<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">'boolean'</span>) &#123;<br>  strOrNumOrBool === <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">const</span> _exhaustiveCheck: never = strOrNumOrBool<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown input type: <span class="hljs-subst">$&#123;_exhaustiveCheck&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设某个粗心的同事新增了一个类型分支，strOrNumOrBool 变成了 strOrNumOrBoolOrFunc，却忘记新增对应的处理分支，此时在 else 代码块中就会出现将 Function 类型赋值给 never 类型变量的类型错误。这实际上就是利用了类型分析能力与 never 类型只能赋值给 never 类型这一点，来确保联合类型变量被妥善处理。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = []<br><br>arr.push(<span class="hljs-string">'jude'</span>) <span class="hljs-comment">// 类型“string”的参数不能赋给类型“never”的参数。</span><br></code></pre></td></tr></table></figure>

<p>此时这个未标明类型的数组被推导为了 never[] 类型，这种情况仅会在你启用了 strictNullChecks 配置，同时禁用了 noImplicitAny 配置时才会出现。解决的办法也很简单，为这个数组声明一个具体类型即可。</p>
<h2 id="类型断言（附加）"><a href="#类型断言（附加）" class="headerlink" title="类型断言（附加）"></a>类型断言（附加）</h2><p>类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 as NewType，你可以将 any &#x2F; unknown 类型断言到一个具体的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> unknownVar: unknown<br>;<span class="hljs-function">(<span class="hljs-params">unknownVar <span class="hljs-keyword">as</span> &#123; foo: (<span class="hljs-params"></span>) =&gt; &#123;&#125; &#125;</span>).<span class="hljs-params">foo</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>还可以 as 到 any 来为所欲为，跳过所有的类型检查：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">'jude'</span>(<br>  <span class="hljs-comment">// 跳过检查</span><br>  str <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span><br>)<br>  .func()<br>  .foo().prop<br></code></pre></td></tr></table></figure>

<p>也可以在联合类型中断言一个具体的分支：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">union: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> ((union <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).includes(<span class="hljs-string">'jude'</span>)) &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((union <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>).toFixed() === <span class="hljs-string">'599'</span>) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IFoo &#123;<br>  name: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> obj: &#123;<br>  foo: IFoo<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; foo = &#123;&#125; <span class="hljs-keyword">as</span> IFoo &#125; = obj<br></code></pre></td></tr></table></figure>

<p>这里从 {} 字面量类型断言为了 IFoo 类型，即为解构赋值默认值进行了预期的类型断言。当然，更严谨的方式应该是定义为 Partial<IFoo> 类型，即 IFoo 的属性均为可选的。<br>除了使用 as 语法以外，你也可以使用 &lt;&gt; 语法。它虽然书写更简洁，但效果一致，只是在 TSX 中尖括号断言并不能很好地被分析出来。你也可以通过 TypeScript ESLint 提供的 consistent-type-assertions 规则来约束断言风格。</p>
<h2 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h2><p>如果在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">'jude'</span><br><br><span class="hljs-comment">// 从 X 类型 到 Y 类型的断言可能是错误的，blabla</span><br>;<span class="hljs-function">(<span class="hljs-params">str <span class="hljs-keyword">as</span> &#123; handler: (<span class="hljs-params"></span>) =&gt; &#123;&#125; &#125;</span>).<span class="hljs-params">handler</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>此时它会提醒你先断言到 unknown 类型，再断言到预期类型，就像这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">'jude'</span><br><br>;<span class="hljs-function">(<span class="hljs-params">str <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> &#123; handler: (<span class="hljs-params"></span>) =&gt; &#123;&#125; &#125;</span>).<span class="hljs-params">handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 使用尖括号断言</span><br><span class="hljs-function">;(<span class="hljs-params">&lt;&#123; handler: (<span class="hljs-params"></span>) =&gt; &#123;&#125; &#125;&gt;(<span class="hljs-params">&lt;unknown&gt;str</span>)</span>).<span class="hljs-params">handler</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>这是因为你的断言类型和原类型的差异太大，需要先断言到一个通用的类，即 any &#x2F; unknown。这一通用类型包含了所有可能的类型，因此断言到它和从它断言到另一个类型差异不大。</p>
<h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h2><p>非空断言其实是类型断言的简化，它使用 ! 语法，即 obj!.func()!.prop 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> foo: &#123;<br>  func?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    prop?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br><br>foo.func().prop.toFixed()<br></code></pre></td></tr></table></figure>

<p>此时，func 在 foo 中不一定存在，prop 在 func 调用结果中不一定存在，且可能为 null，我们就会收获两个类型报错。如果不管三七二十一地坚持调用，想要解决掉类型报错就可以使用非空断言：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">foo.func!().prop!.toFixed()<br></code></pre></td></tr></table></figure>

<p>其应用位置类似于可选链：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">foo.func?.().prop?.toFixed()<br></code></pre></td></tr></table></figure>

<blockquote>
<p>但不同的是，非空断言的运行时仍然会保持调用链，因此在运行时可能会报错。而可选链则会在某一个部分收到 undefined 或 null 时直接短路掉，不会再发生后面的调用。</p>
</blockquote>
<p>非空断言的常见场景还有 document.querySelector、Array.find 方法等：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> element = (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#id'</span>)!;<br><br><span class="hljs-keyword">const</span> target = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">599</span>].find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === <span class="hljs-number">599</span>)!;<br></code></pre></td></tr></table></figure>

<p>为什么说非空断言是类型断言的简写？因为上面的非空断言实际上等价于以下的类型断言操作：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">;(<br>  (<br>    foo.func <span class="hljs-keyword">as</span> () =&gt; &#123;<br>      prop?: <span class="hljs-built_in">number</span><br>    &#125;<br>  )().prop <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span><br>).toFixed()<br></code></pre></td></tr></table></figure>

<p>可以通过 non-nullable-type-assertion-style 规则来检查代码中是否存在类型断言能够被简写为非空断言的情况。</p>
<p>类型断言还有一种用法是作为代码提示的辅助工具，比如对于以下这个稍微复杂的接口:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IStruct &#123;<br>  foo: <span class="hljs-built_in">string</span><br>  bar: &#123;<br>    barPropA: <span class="hljs-built_in">string</span><br>    barPropB: <span class="hljs-built_in">number</span><br>    barMethod: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span><br>    baz: &#123;<br>      handler: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 假设你想要基于这个结构随便实现一个对象，你可能会使用类型标注：</span><br><span class="hljs-keyword">const</span> obj: IStruct = &#123;&#125;<br><span class="hljs-comment">//这个时候等待你的是一堆类型报错，你必须规规矩矩地实现整个接口结构才可以。但如果使用类型断言，我们可以在保留类型提示的前提下，不那么完整地实现这个结构：</span><br><span class="hljs-comment">// 这个例子是不会报错的</span><br><span class="hljs-keyword">const</span> obj = &lt;IStruct&gt;&#123;<br>  bar: &#123;<br>    baz: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/29/130-ts/" title="130、类型别名、联合类型、交叉类型"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 130、类型别名、联合类型、交叉类型</span></a><a class="button is-default" href="/2023/03/22/128-vue/" title="128、map和forEach"><span class="has-text-weight-semibold">下一页: 128、map和forEach</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen" target="_blank" rel="noopener">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>125、el-table触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="el-table 的在数据量比较大的情况下，会卡顿，因为数据量太大，渲染速度跟不上。可以通过触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller 这些方案解决。


一、触底加载&amp;lt;template&amp;gt;
  &amp;lt;!-- 触底加载 --&amp;gt;
  &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;el-table
      v-el-table-infinite-scroll=&amp;quot;load&amp;quot;
      height=&amp;quot;480&amp;quot;
      :data=&amp;quot;tableData&amp;quot;
      border
      style=&amp;quot;width: 80.."><meta name="generator" content="Hexo 7.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">125、el-table触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%A7%A6%E5%BA%95%E5%8A%A0%E8%BD%BD"><span class="toc-text">一、触底加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AF%B7%E6%B1%82%E5%8A%A8%E7%94%BB%E5%B8%A7"><span class="toc-text">二、 定时器请求动画帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">三、虚拟列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81vxe-table"><span class="toc-text">四、vxe-table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81vue-virtual-scroller"><span class="toc-text">五、vue-virtual-scroller</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/vue2"><i class="tag post-item-tag">vue2</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">125、el-table触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller</h1><time class="has-text-grey" datetime="2023-03-16T12:00:00.000Z">2023-03-16</time><article class="mt-2 post-content"><p>el-table 的在数据量比较大的情况下，会卡顿，因为数据量太大，渲染速度跟不上。可以通过触底加载、定时器和请求动画帧、虚拟列表、vxe-table、vue-virtual-scroller 这些方案解决。</p>
<span id="more"></span>

<h2 id="一、触底加载"><a href="#一、触底加载" class="headerlink" title="一、触底加载"></a>一、触底加载</h2><pre><code class="html">&lt;template&gt;
  &lt;!-- 触底加载 --&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;el-table
      v-el-table-infinite-scroll=&quot;load&quot;
      height=&quot;480&quot;
      :data=&quot;tableData&quot;
      border
      style=&quot;width: 80%&quot;
      v-loading=&quot;loading&quot;
      element-loading-text=&quot;数据量太大啦，客官稍后...&quot;
      element-loading-spinner=&quot;el-icon-loading&quot;
      element-loading-background=&quot;rgba(255, 255, 255, 0.5)&quot;
      :header-cell-style=&quot;&#123;
        height: &#39;24px&#39;,
        lineHeight: &#39;24px&#39;,
        color: &#39;#606266&#39;,
        background: &#39;#F5F5F5&#39;,
        fontWeight: &#39;bold&#39;,
      &#125;&quot;
    &gt;
      &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt;
      &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot;&gt;&lt;/el-table-column&gt;
      &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot;&gt;&lt;/el-table-column&gt;
      &lt;el-table-column prop=&quot;value&quot; label=&quot;对应值&quot;&gt;&lt;/el-table-column&gt;
    &lt;/el-table&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">&lt;script&gt;
function averageFn(arr) &#123;
  let i = 0;
  let result = [];
  while (i &lt; arr.length) &#123;
    // 一次截取10个用于分堆
    result.push(arr.slice(i, i + 10));
    // 这10个截取完，再准备截取下10个
    i = i + 10;
  &#125;
  return result;
&#125;
export default &#123;
  data() &#123;
    return &#123;
      allTableData: [],
      tableData: [],
      loading: false,
    &#125;;
  &#125;,
  // 第一步，请求大量数据时候，转成二维数组，分堆分组分块存储
  async created() &#123;
    this.loading = true;
    const res = await axios.get(&quot;XXXX&quot;);
    this.allTableData = averageFn(res.data.data);
    // this.originalAllTableData = this.allTableData // 也可以存一份原始值，留作备用，都行的
    this.loading = false;
    this.load();
  &#125;,
  methods: &#123;
    async load() &#123;
      console.log(&quot;自动多次执行之，首次执行会根据高度去计算要执行几次合适&quot;);
      // 第四步，触底加载相当于把二维数组的每一项取出来用，用完时return停止即可
      if (this.allTableData.length == 0) &#123;
        console.log(&quot;没数据啦&quot;);
        return;
      &#125;
      // 第二步，加载的时候，把二维数组的第一项取出来，拼接到要展示的表格数据中去
      let arr = this.allTableData[0];
      this.tableData = this.tableData.concat(arr);
      // 第三步，拼接展示以后，再把二维数组的第一项的数据删除即可
      this.allTableData.shift();
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="二、-定时器请求动画帧"><a href="#二、-定时器请求动画帧" class="headerlink" title="二、 定时器请求动画帧"></a>二、 定时器请求动画帧</h2><pre><code class="html">&lt;div v-if=&quot;activeName == &#39;aaa&#39;&quot;&gt;
  &lt;el-button
    style=&quot;margin-bottom: 12px&quot;
    size=&quot;small&quot;
    type=&quot;primary&quot;
    :loading=&quot;loading&quot;
    @click=&quot;plan&quot;
    &gt;点击请求加载&lt;/el-button
  &gt;
  &lt;el-table
    height=&quot;300&quot;
    :data=&quot;arr&quot;
    border
    style=&quot;width: 80%&quot;
    :header-cell-style=&quot;&#123;
            height: &#39;24px&#39;,
            lineHeight: &#39;24px&#39;,
            color: &#39;#606266&#39;,
            background: &#39;#F5F5F5&#39;,
            fontWeight: &#39;bold&#39;,
          &#125;&quot;
  &gt;
    &lt;el-table-column type=&quot;index&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;value&quot; label=&quot;对应值&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">function averageFn(arr) &#123;
  let i = 0; // 从第0个开始
  let result = []; // 定义结果，结果是二维数组
  while (i &lt; arr.length) &#123;
    // 从原始数组的第一项开始遍历
    result.push(arr.slice(i, i + 10)); // 一次截取10个用于分堆
    i = i + 10;
  &#125;
  return result;
&#125;

  async created() &#123;
    await this.getData()
  &#125;,
  methods: &#123;
    //
    async getData() &#123;
      for (let i = 0; i &lt; 100000; i++) &#123;
        await this.list.push(&#123; name: &#39;aaa&#39;, index: i &#125;)
      &#125;
    &#125;,
    /**
     * 请求动画帧
     * */
    async plan() &#123;
      this.loading = true;
      const res = await axios.get(&quot;xxxxx&quot;);
      this.loading = false;
      // 1. 将大数据量分堆
      let twoDArr = averageFn(res.data.data);
      // 2. 定义一个函数，专门用来做赋值渲染（使用二维数组中的每一项）
      const use2DArrItem = (page) =&gt; &#123;
        // 4. 从第一项，取到最后一项
        if (page &gt; twoDArr.length - 1) &#123;
          console.log(&quot;每一项都获取完了&quot;);
          return;
        &#125;
        // 5. 使用请求动画帧的方式
        requestAnimationFrame(() =&gt; &#123;
          // 6. 取出一项，就拼接一项（concat也行）
          this.arr = [...this.arr, ...twoDArr[page]];
          // 7. 这一项搞定，继续下一项
          page = page + 1;
          // 8. 直至完毕（递归调用，注意结束条件）
          use2DArrItem(page);
        &#125;);
      &#125;;
      // 3. 从二维数组中的第一项，第一堆开始获取并渲染（数组的第一项即索引为0）
      use2DArrItem(0);
    &#125;,
  &#125;,
</code></pre>
<h2 id="三、虚拟列表"><a href="#三、虚拟列表" class="headerlink" title="三、虚拟列表"></a>三、虚拟列表</h2><pre><code class="html">&lt;template&gt;
  &lt;!-- 虚拟列表容器，类似“窗口”，窗口的高度取决于一次展示几条数据
            比如窗口只能看到10条数据，一条40像素，10条400像素
            故，窗口的高度为400像素，注意要开定位和滚动条 --&gt;
  &lt;div
    class=&quot;virtualListWrap&quot;
    ref=&quot;virtualListWrap&quot;
    @scroll=&quot;handleScroll&quot;
    :style=&quot;&#123; height: itemHeight * count + &#39;px&#39; &#125;&quot;
  &gt;
    &lt;!-- 占位dom元素，其高度为所有的数据的总高度 --&gt;
    &lt;div
      class=&quot;placeholderDom&quot;
      :style=&quot;&#123; height: allListData.length * itemHeight + &#39;px&#39; &#125;&quot;
    &gt;&lt;/div&gt;
    &lt;!-- 内容区，展示10条数据，注意其定位的top值是变化的 --&gt;
    &lt;div class=&quot;contentList&quot; :style=&quot;&#123; top: topVal &#125;&quot;&gt;
      &lt;!-- 每一条（项）数据 --&gt;
      &lt;div
        v-for=&quot;(item, index) in showListData&quot;
        :key=&quot;index&quot;
        class=&quot;itemClass&quot;
        :style=&quot;&#123; height: itemHeight + &#39;px&#39; &#125;&quot;
      &gt;
        &#123;&#123; item.name &#125;&#125;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 加载中部分 --&gt;
    &lt;div class=&quot;loadingBox&quot; v-show=&quot;loading&quot;&gt;
      &lt;i class=&quot;el-icon-loading&quot;&gt;&lt;/i&gt;
      &amp;nbsp;&amp;nbsp;&lt;span&gt;loading...........&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">&lt;script&gt;
function throttle(fn, wait) &#123;
  var pre = Date.now();
  return function () &#123;
    var context = this;
    var args = arguments;
    var now = Date.now();
    if (now - pre &gt;= wait) &#123;
      fn.apply(context, args);
      pre = Date.now();
    &#125;
  &#125;;
&#125;
import axios from &quot;axios&quot;;
export default &#123;
  data() &#123;
    return &#123;
      allListData: [], // 所有的数据，比如这个数组存放了十万条数据
      itemHeight: 40, // 每一条（项）的高度，比如40像素
      count: 10, // 一屏展示几条数据
      start: 0, // 开始位置的索引
      end: 10, // 结束位置的索引
      topVal: 0, // 父元素滚动条滚动，更改子元素对应top定位的值，确保联动
      loading: false,
    &#125;;
  &#125;,
  computed: &#123;
    // 从所有的数据allListData中截取需要展示的数据showListData
    showListData: function () &#123;
      return this.allListData.slice(this.start, this.end);
    &#125;,
  &#125;,
  async created() &#123;
    this.loading = true;
    const res = await axios.get(&quot;xxxxxx&quot;);
    this.allListData = res.data.data;
    this.loading = false;
  &#125;,
  methods: &#123;
    handleScroll() &#123;
      throttle(this.s(), 500);
    &#125;,
    s() &#123;
      /**
       * 获取在垂直方向上，滚动条滚动了多少像素距离Element.scrollTop
       *
       * 滚动的距离除以每一项的高度，即为滚动到了多少项，当然，要取个整数
       * 例：滚动4米，一步长0.8米，滚动到第几步，4/0.8 = 第5步（取整好计算）
       *
       * 又因为我们一次要展示10项，所以知道了起始位置项，再加上结束位置项，
       * 就能得出区间了【起始位置, 起始位置 + size项数】==【起始位置, 结束位置】
       * */
      const scrollTop = this.$refs.virtualListWrap.scrollTop;
      this.start = Math.floor(scrollTop / this.itemHeight);
      this.end = this.start + this.count;
      /**
       * 动态更改定位的top值，确保联动，动态展示相应内容
       * */
      this.topVal = this.$refs.virtualListWrap.scrollTop + &quot;px&quot;;
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<pre><code class="css">&lt;style scoped lang=&quot;less&quot;&gt;
// 虚拟列表容器盒子
.virtualListWrap &#123;
  box-sizing: border-box;
  width: 240px;
  border: solid 1px #000000;
  // 开启滚动条
  overflow-y: auto;
  // 开启相对定位
  position: relative;

  .contentList &#123;
    width: 100%;
    height: auto;
    // 搭配使用绝对定位
    position: absolute;
    top: 0;
    left: 0;

    .itemClass &#123;
      box-sizing: border-box;
      width: 100%;
      height: 40px;
      line-height: 40px;
      text-align: center;
    &#125;

    // 奇偶行改一个颜色
    .itemClass:nth-child(even) &#123;
      background: #c7edcc;
    &#125;

    .itemClass:nth-child(odd) &#123;
      background: pink;
    &#125;
  &#125;

  .loadingBox &#123;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.64);
    color: green;
    display: flex;
    justify-content: center;
    align-items: center;
  &#125;
&#125;
&lt;/style&gt;
</code></pre>
<h2 id="四、vxe-table"><a href="#四、vxe-table" class="headerlink" title="四、vxe-table"></a>四、vxe-table</h2><pre><code class="html">&lt;template&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;vxe-table
      border
      show-overflow
      ref=&quot;xTable1&quot;
      height=&quot;300&quot;
      :row-config=&quot;&#123; isHover: true &#125;&quot;
      :loading=&quot;loading&quot;
    &gt;
      &lt;vxe-column type=&quot;seq&quot;&gt;&lt;/vxe-column&gt;
      &lt;vxe-column field=&quot;id&quot; title=&quot;ID&quot;&gt;&lt;/vxe-column&gt;
      &lt;vxe-column field=&quot;name&quot; title=&quot;名字&quot;&gt;&lt;/vxe-column&gt;
      &lt;vxe-column field=&quot;value&quot; title=&quot;对应值&quot;&gt;&lt;/vxe-column&gt;
    &lt;/vxe-table&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">&lt;script&gt;
import axios from &quot;axios&quot;;
export default &#123;
  data() &#123;
    return &#123;
      loading: false,
    &#125;;
  &#125;,
  async created() &#123;
    this.loading = true;
    const res = await axios.get(&quot;xxxxxxx&quot;);
    this.loading = false;
    this.render(res.data.data);
  &#125;,
  methods: &#123;
    render(data) &#123;
      this.$nextTick(() =&gt; &#123;
        const $table = this.$refs.xTable1;
        $table.loadData(data);
      &#125;);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h2 id="五、vue-virtual-scroller"><a href="#五、vue-virtual-scroller" class="headerlink" title="五、vue-virtual-scroller"></a>五、vue-virtual-scroller</h2><pre><code class="html">&lt;template&gt;
  &lt;div class=&quot;main-container&quot;&gt;
    &lt;DynamicScroller
      class=&quot;scroller&quot;
      :min-item-size=&quot;54&quot;
      :items=&quot;list&quot;
      :item-size=&quot;30&quot;
      key-field=&quot;index&quot;
      v-slot=&quot;&#123; item &#125;&quot;
    &gt;
      &lt;div class=&quot;user&quot;&gt;&#123;&#123; item.index + 1 &#125;&#125; -- &#123;&#123; item.name &#125;&#125;&lt;/div&gt;
      &lt;!-- &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;
        &lt;div class=&quot;user&quot;&gt;
          &#123;&#123; item.index + 1 &#125;&#125; -- &#123;&#123; item.name &#125;&#125;
        &lt;/div&gt;
      &lt;/template&gt; --&gt;
    &lt;/DynamicScroller&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">&lt;script&gt;
export default &#123;
  props: &#123;
    list: Array,
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<pre><code class="css">&lt;style scoped&gt;
/* .main-container &#123;
  height: 200px;
&#125; */

.scroller &#123;
  height: 300px;
  overflow: scroll;
&#125;

.user &#123;
  height: 30px;
  padding: 0 12px;
  display: flex;
  align-items: center;
&#125;
&lt;/style&gt;
</code></pre>
<p>父组件使用：</p>
<pre><code class="html">&lt;div
  style=&quot;height: 200px;width: 300px;margin:20px;border: 1px solid #333;overflow: auto;&quot;
&gt;
  &lt;v-table :list=&quot;list&quot; v-if=&quot;activeName == &#39;eee&#39;&quot;&gt;&lt;/v-table&gt;
&lt;/div&gt;
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/17/126-vue/" title="126、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(三)"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 126、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(三)</span></a><a class="button is-default" href="/2023/03/12/124-vue/" title="124、vue2利用require.context批量引入实现自动注册"><span class="has-text-weight-semibold">下一页: 124、vue2利用require.context批量引入实现自动注册</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
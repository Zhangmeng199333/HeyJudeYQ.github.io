<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>130、类型别名、联合类型、交叉类型</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

在 TypeScript 中，类型别名起到的就是变量的作用，它可以存储一个类型，后续你可以直接引用它即可。
1234type Handler = () =&amp;gt; voidconst handler1: Handler = () =&amp;gt; &amp;#123;&amp;#125;const handler2: Handler = () =&amp;gt; &amp;#123;&amp;#125;

也可以使用类型别名来替换接口，实现对对象类型的复用：
12345678910type User = &amp;#123;  userName: string  userAge: number  userMarried: boolean  userJob?: string&amp;#125;const user: User = &amp;#123;  /* ... */&amp;.."><meta name="generator" content="Hexo 4.2.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">130、类型别名、联合类型、交叉类型</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#联合类型"><span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字面量类型"><span class="toc-text">字面量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#联合类型和交叉类型"><span class="toc-text">联合类型和交叉类型</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/ts"><i class="tag post-item-tag">ts</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">130、类型别名、联合类型、交叉类型</h1><time class="has-text-grey" datetime="2023-03-29T12:00:00.000Z">2023-03-29</time><article class="mt-2 post-content"><a id="more"></a>

<p>在 TypeScript 中，类型别名起到的就是变量的作用，它可以存储一个类型，后续你可以直接引用它即可。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Handler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">const</span> handler1: Handler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br><span class="hljs-keyword">const</span> handler2: Handler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>也可以使用类型别名来替换接口，实现对对象类型的复用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> User = &#123;<br>  userName: <span class="hljs-built_in">string</span><br>  userAge: <span class="hljs-built_in">number</span><br>  userMarried: <span class="hljs-built_in">boolean</span><br>  userJob?: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> user: User = &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上，类型别名也可以像函数一样接受参数并返回计算结果(例如：泛型)，<br>在类型层面，或逻辑可以由联合类型实现，与逻辑可以由交叉类型实现。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>语法：A | B |C</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PossibleTypes = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span><br></code></pre></td></tr></table></figure>

<p>它所表示的或逻辑，只要你的变量满足其中一个类型成员，就可以被认为满足这个类型，因此你的变量可以在后续被赋值为其它的类型成员：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> foo: PossibleTypes = <span class="hljs-string">'jude'</span><br><br>foo = <span class="hljs-number">599</span><br>foo = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>联合类型对其中的类型成员并没有限制，你可以混合原始类型，字面量类型，函数类型，对象类型等等。在实际应用中，最常见的应该是字面量联合类型，它表示一组精确的字面量类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Status = <span class="hljs-string">'success'</span> | <span class="hljs-string">'failure'</span><br><span class="hljs-keyword">type</span> Code = <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure>

<h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>字面量类型是什么？先类比到原始类型 string，我们知道被标记为 string 类型的变量只能被赋值为字符串，换句话说，所有的字符串值都属于 string 类型。那么这就显得过于宽泛了，如果我们希望将变量类型约束在几个特定的字符串值之间呢？就比如上面的类型别名 Status，就能表达“这个变量是字符串类型”和“这个变量只能是’success’和’failure’两个字符串”这两个概念。而组成 Status 的这两个“值”，其实就是字面量类型，比如你也可以用字面量类型来作为类型标注：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> fixedStr: <span class="hljs-string">'jude'</span> = <span class="hljs-string">'jude'</span> <span class="hljs-comment">// 值只能是 'jude'</span><br><span class="hljs-keyword">const</span> fixedNum: <span class="hljs-number">599</span> = <span class="hljs-number">599</span> <span class="hljs-comment">// 值只能是 599</span><br></code></pre></td></tr></table></figure>

<p>如果你感觉字面量类型和实际值不好区分，其实只要注意它们出现的位置即可，一个同样的字符串，只要出现在类型标注的位置，那指的当然就是类型啦。</p>
<p>字面量类型是和原始类型以及对象类型对应的——是的，包括对象类型，我们来看完整的示例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> literalString: <span class="hljs-string">'jude'</span> = <span class="hljs-string">'jude'</span><br><span class="hljs-keyword">const</span> literalNumber: <span class="hljs-number">599</span> = <span class="hljs-number">599</span><br><span class="hljs-keyword">const</span> literalBoolean: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">const</span> literalObject: &#123; name: <span class="hljs-string">'jude'</span> &#125; = &#123; name: <span class="hljs-string">'jude'</span> &#125;<br><span class="hljs-keyword">const</span> literalArray: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>

<p>为什么需要字面量类型？</p>
<blockquote>
<p>因为字面量联合类型相比它们对应的原始类型，能够提供更精确的类型信息与类型提示</p>
</blockquote>
<p>除了基于字面量类型的小范围精确标注，我们也可以使用由接口组成的联合类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> VisitorUser &#123;&#125;<br><span class="hljs-keyword">interface</span> CommonUser &#123;&#125;<br><span class="hljs-keyword">interface</span> VIPUser &#123;&#125;<br><span class="hljs-keyword">interface</span> AdminUser &#123;&#125;<br><br><span class="hljs-keyword">type</span> User = VisitorUser | CommonUser | VIPUser | AdminUser<br><br><span class="hljs-keyword">const</span> user: User = &#123;<br>  <span class="hljs-comment">// ...任意实现一个组成的对象类型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="联合类型和交叉类型"><a href="#联合类型和交叉类型" class="headerlink" title="联合类型和交叉类型"></a>联合类型和交叉类型</h2><p>既然能够将联合类型关联到按位或，那么从按位与逻辑到交叉类型就更好理解了，类似于按位或 || 到联合类型的 |，交叉类型的 &amp; 也脱胎自按位与 &amp;&amp;，我们同样可以使用类型别名来表示一个交叉类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> UserBasicInfo &#123;&#125;<br><span class="hljs-keyword">interface</span> UserJobInfo &#123;&#125;<br><span class="hljs-keyword">interface</span> UserFamilyInfo &#123;&#125;<br><span class="hljs-keyword">interface</span> UsUserBasicInfo &amp; UserJobInfo &amp; UserFamilyInfo;<br></code></pre></td></tr></table></figure>

<p>类型别名 UserInfo 表示，你需要实现 UserBasicInfo、UserJobInfo、UserFamilyInfo 这三个对象类型的所有属性，才能认为是实现了 UserInfo 类型。交叉类型的本质，其实就是表示一个<em>同时满足</em>这些子类型成员的类型，所以如果你交叉两个对象类型，可以理解为是一个新的类型内部合并了这两个对象类型。</p>
<p>交叉原始类型会怎样？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Test = <span class="hljs-built_in">string</span> &amp; <span class="hljs-built_in">number</span> <span class="hljs-comment">// never 类型</span><br></code></pre></td></tr></table></figure>

<p>交叉类型的关键点：同时满足</p>
<p>联合类型和交叉类型可同时使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 伪代码  先交叉再联合：只要实现任意一个交叉类型即可</span><br><span class="hljs-keyword">type</span> User = (FE &amp; React &amp; Vue) | (Sing &amp; Rap)<br><span class="hljs-comment">// 先联合再交叉:只要这些联合类型存在交集，交集中的类型就可以认为是同时实现了所有联合类型。</span><br><span class="hljs-keyword">type</span> Union = (<span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>) &amp; (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>) <span class="hljs-comment">// 1|2</span><br></code></pre></td></tr></table></figure>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/04/02/131-ts/" title="131、泛型"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 131、泛型</span></a><a class="button is-default" href="/2023/03/27/129-ts/" title="129、any、unknown、never类型和类型断言"><span class="has-text-weight-semibold">下一页: 129、any、unknown、never类型和类型断言</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen" target="_blank" rel="noopener">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
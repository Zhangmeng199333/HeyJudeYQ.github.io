<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>127、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(四)-响应式系统</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

一、响应式数据和副作用函数副作用函数是指那些产生副作用的函数：
123function effect() &amp;#123;  document.body.innerText = &amp;#x27;hello vue3&amp;#x27;&amp;#125;

执行 effect 函数时，它会设置 body 的文本内容，这种更改可以被其他任何函数读取或设置。因此，effect 的执行会直接或间接影响其他函数的执行，这就是它产生副作用的地方。副作用很容易产生，比如修改一个全局变量：
123456// 全局变量let val = 1function effect() &amp;#123;  val = 2 // 更改全局变量，产生副作用&amp;#125;

理解了副作用函数后，我们再来看看响应式数据是什么。设想在一个副作用函数中读取了某个对象的属性.."><meta name="generator" content="Hexo 7.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">127、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(四)-响应式系统</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%92%8C%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">一、响应式数据和副作用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0"><span class="toc-text">二、基本响应式数据实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E5%AE%8C%E5%96%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">三、设计完善响应式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">四、分支切换与清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B5%8C%E5%A5%97%E7%9A%84-effect-%E4%B8%8E-effect-%E6%A0%88"><span class="toc-text">五、嵌套的 effect 与 effect 栈</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/vue3"><i class="tag post-item-tag">vue3</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">127、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(四)-响应式系统</h1><time class="has-text-grey" datetime="2023-03-20T12:00:00.000Z">2023-03-20</time><article class="mt-2 post-content"><span id="more"></span>

<h2 id="一、响应式数据和副作用函数"><a href="#一、响应式数据和副作用函数" class="headerlink" title="一、响应式数据和副作用函数"></a>一、响应式数据和副作用函数</h2><p>副作用函数是指那些产生副作用的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行 effect 函数时，它会设置 body 的文本内容，这种更改可以被其他任何函数读取或设置。<br>因此，effect 的执行会直接或间接影响其他函数的执行，这就是它产生副作用的地方。<br>副作用很容易产生，比如修改一个全局变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  val = <span class="hljs-number">2</span> <span class="hljs-comment">// 更改全局变量，产生副作用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>理解了副作用函数后，我们再来看看响应式数据是什么。设想在一个副作用函数中读取了某个对象的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;hello world&#x27;</span> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在执行effect函数时会读取 obj.text</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码，effect 函数会设置 body 元素的 innerText 属性，其值为 obj.text。当 obj.text 值发生变化时，我们希望 effect 函数会重新执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span> <span class="hljs-comment">// 修改 obj.text 的值，并希望副作用函数重新执行</span><br></code></pre></td></tr></table></figure>

<p>当 obj.text 值改变时，我们希望副作用函数能自动重新执行。如果这可以实现，那么对象 obj 就可以被称为响应式数据。<br>但显然，现在我们无法实现这一点，因为 obj 仅仅是一个普通对象，当我们改变它的值时，除了值本身之外，不会有任何其他反应。</p>
<h2 id="二、基本响应式数据实现"><a href="#二、基本响应式数据实现" class="headerlink" title="二、基本响应式数据实现"></a>二、基本响应式数据实现</h2><p>为了使 obj 成为响应式数据，我们可以从以下两点出发：</p>
<blockquote>
<p>1、执行副作用函数 effect 时，会触发 obj.text 的读取操作。<br>2、当修改 obj.text 的值时，会触发 obj.text 的设置操作。</p>
</blockquote>
<p>如果我们能拦截对象的读取和设置操作，这个问题就简单了。</p>
<blockquote>
<p>1、读取 obj.text 时，将副作用函数 effect 存储到一个“桶”中。<br>2、在设置 obj.text 时，从“桶”中取出副作用函数 effect 并执行。</p>
</blockquote>
<p>在 ES2015 之前，我们可以使用 Object.defineProperty 函数，这是 Vue.js 2 的实现方式。<br>在 ES2015+ 中，我们可以使用代理对象 Proxy，这是 Vue3 的实现方式。</p>
<p>用 Proxy 来实现响应式数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存储副作用函数的桶</span><br><span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><br><span class="hljs-comment">// 原始数据</span><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;hello world&#x27;</span> &#125;<br><span class="hljs-comment">// 代理原始数据</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 添加副作用函数 effect 到桶中</span><br>    bucket.<span class="hljs-title function_">add</span>(effect)<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal<br>    <span class="hljs-comment">// 取出并执行桶中的副作用函数</span><br>    bucket.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>())<br>    <span class="hljs-comment">// 返回 true 表示设置成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>首先，我们创建一个用于存储副作用函数的 Set 类型的桶 bucket。<br>然后，定义原始数据 data，并创建其代理对象 obj，我们为代理对象设置了 get 和 set 拦截器，以拦截读取和设置操作。<br>读取属性时，我们把副作用函数 effect 添加到桶中。<br>设置属性时，我们先更新原始数据，然后重新执行桶中的副作用函数。这样就实现了响应式数据。<br>测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 副作用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span><br>&#125;<br><br><span class="hljs-comment">// 触发读取</span><br><span class="hljs-title function_">effect</span>()<br><br><span class="hljs-comment">// 1秒后修改响应式数据</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  obj.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span><br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>在浏览器中运行以上代码，我们将得到预期的结果。<br>但当前的实现仍有<code>不足</code>，比如我们是直接通过函数名 effect 获取副作用函数，这种硬编码方式缺乏灵活性。<br>副作用函数的名字是可以任意命名的，我们可以把副作用函数命名为 myEffect，或者甚至用一个匿名函数。<br>因此，我们需要找到去除这种硬编码的方法。</p>
<h2 id="三、设计完善响应式系统"><a href="#三、设计完善响应式系统" class="headerlink" title="三、设计完善响应式系统"></a>三、设计完善响应式系统</h2><p>实现步骤如下：</p>
<blockquote>
<p>1、读取操作时，将副作用函数收集到“桶”中。<br>2、设置操作时，从“桶”中取出并执行副作用函数。</p>
</blockquote>
<p>为了解决硬编码副作用函数名（effect）的问题，我们提供一个注册副作用函数的机制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储被注册的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-comment">// effect 函数用于注册副作用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect</span><br>  activeEffect = fn<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，我们定义了一个全局变量 activeEffect，用于存储被注册的副作用函数。<br>然后定义了 effect 函数，这个函数用于注册副作用函数，接受一个参数 fn，也就是我们要注册的副作用函数。<br>使用 effect 函数的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-comment">// 一个匿名的副作用函数</span><br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span><br>  &#125;<br>)<br></code></pre></td></tr></table></figure>

<p>我们传递一个匿名的副作用函数作为 effect 函数的参数。<br>当 effect 函数执行时，会先将匿名副作用函数 fn 赋值给全局变量 activeEffect，然后执行注册的副作用函数 fn，触发响应式数据 obj.text 的读取操作，同时触发 Proxy 的 get 拦截函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 如果存在 activeEffect，将其收集到“桶”中</span><br>    <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>      bucket.<span class="hljs-title function_">add</span>(activeEffect)<br>    &#125;<br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    target[key] = newVal<br>    bucket.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述代码，由于副作用函数已经存储在 activeEffect 中，因此在 get 拦截函数中，我们将 activeEffect 收集到“桶”中。<br>这样，响应系统就不再依赖副作用函数的名字了。<br>但是如果我们进行更深入测试，尝试设置响应式数据 obj 上的一个不存在的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-comment">// 匿名副作用函数</span><br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effect run&#x27;</span>) <span class="hljs-comment">// 会打印 2 次</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span><br>  &#125;<br>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 副作用函数中并没有读取 notExist 属性的值</span><br>  obj.<span class="hljs-property">notExist</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span><br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>这段代码中，匿名副作用函数读取了 obj.text，从而和这个字段建立了响应联系。<br>接着，我们启动一个定时器，1 秒后为 obj 添加新的 notExist 属性。<br>理论上，由于副作用函数并未读取 obj.notExist，因此这个字段并未与副作用建立响应联系。<br>因此，当定时器内的语句执行时，不应触发副作用函数的重新执行。<br>然而，运行上述代码，我们发现在定时器触发后，副作用函数却重新执行了。<br>这是因为我们的”桶”数据结构的设计存在问题。只要触发了 obj 对象的 get 操作就会收集副作用进桶。<br>因此，我们需要重新设计“桶”的数据结构，使得副作用函数与被操作的字段之间建立联系。<br>首先，让我们更仔细地观察以下的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>1、被操作（读取）的代理对象 obj；<br>2、被操作（读取）的字段名 text；<br>3、使用 effect 函数注册的副作用函数 effectFn。</p>
</blockquote>
<p>如果我们用 target 表示代理对象所代理的原始对象，用 key 表示被操作的字段名，用 effectFn 表示被注册的副作用函数。<br>我们可以为这三个角色建立如下关系：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">target<br>└── key<br>    └── effectFn<br><br></code></pre></td></tr></table></figure>

<p>这是一种树形结构。例如，如果有两个副作用函数同时读取同一个对象的属性值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  obj.<span class="hljs-property">text</span><br>&#125;)<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>  obj.<span class="hljs-property">text</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>那么关系如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">target<br>└── text<br>    ├── effectFn1<br>    └── effectFn2<br><br></code></pre></td></tr></table></figure>

<p>如果一个副作用函数中读取了同一个对象的两个不同属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn</span>(<span class="hljs-params"></span>) &#123;<br>  obj.<span class="hljs-property">text1</span><br>  obj.<span class="hljs-property">text2</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>那么关系如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">target<br>└── text1<br>    └── effectFn<br>└── text2<br>    └── effectFn<br><br></code></pre></td></tr></table></figure>

<p>如果在不同的副作用函数中读取了两个不同对象的不同属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  obj1.<span class="hljs-property">text1</span><br>&#125;)<br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>  obj2.<span class="hljs-property">text2</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>那么关系如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">target1<br>└── text1<br>    └── effectFn1<br>target2<br>└── text2<br>    └── effectFn2<br></code></pre></td></tr></table></figure>

<p>通过建立这个树型数据结构，我们就可以解决前面提到的问题。<br>例如，如果我们设置了 obj2.text2 的值，就只会触发 effectFn2 函数重新执行，并不会触发 effectFn1 函数。</p>
<p>接下来，我们将尝试用代码实现新的“桶”。首先，用 WeakMap 替换 Set 作为桶的数据结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建用于存储副作用函数的桶</span><br><span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br></code></pre></td></tr></table></figure>

<p>修改 get&#x2F;set 拦截器的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>    <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span> target[key]<br>    <span class="hljs-comment">// 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt; effects</span><br>    <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-comment">// 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span><br>    <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>      bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()))<br>    &#125;<br>    <span class="hljs-comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，</span><br>    <span class="hljs-comment">// 里面存储着所有与当前 key 相关联的副作用函数：effects</span><br>    <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 如果 deps 不存在，同样新建一个 Set 并与 key 关联</span><br>    <span class="hljs-keyword">if</span> (!deps) &#123;<br>      depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))<br>    &#125;<br>    <span class="hljs-comment">// 最后将当前激活的副作用函数添加到“桶”里</span><br>    deps.<span class="hljs-title function_">add</span>(activeEffect)<br><br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal<br>    <span class="hljs-comment">// 根据 target 从桶中取得 depsMap，它是 key --&gt; effects</span><br>    <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>    <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 根据 key 取得所有副作用函数 effects</span><br>    <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 执行副作用函数</span><br>    effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>())<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们可以看到数据结构的构建方式。我们使用了 WeakMap、Map 和 Set：</p>
<blockquote>
<p>WeakMap 由 target –&gt; Map 构成；<br>Map 由 key –&gt; Set 构成。</p>
</blockquote>
<p>WeakMap 的键是原始对象 target，值是一个 Map 实例。<br>而 Map 的键是原始对象 target 的 key，值是一个由副作用函数组成的 Set。</p>
<p>我们可以称 Set 数据结构中存储的副作用函数集合为 key 的依赖集合<br>使用 WeakMap 的原因在于其键为弱引用，不影响垃圾回收器的工作。一旦 key 被垃圾回收器回收，那么对应的键和值就无法访问。<br>因此，WeakMap 常用于存储只有当 key 所引用的对象存在时（没有被回收）才有价值的信息。<br>例如上面场景，如果 target 对象没有任何引用，它会被垃圾回收器回收。如果使用 Map 可能会导致内存泄露。<br>下面这段代码展示了 WeakMap 和 Map 的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">const</span> weakmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br>;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> foo = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br>  <span class="hljs-keyword">const</span> bar = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;<br><br>  map.<span class="hljs-title function_">set</span>(foo, <span class="hljs-number">1</span>)<br>  weakmap.<span class="hljs-title function_">set</span>(bar, <span class="hljs-number">2</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure>

<p>当该函数表达式执行完毕后，对于对象 foo 来说，它仍然作为 map 的 key 被引用着，因此垃圾回收器（garbage collector）不会把它从内存中移除<br>而对于对象 bar 来说，由于 WeakMap 的 key 是弱引用，它不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就会把对象 bar 从内存中移除。</p>
<p>最后我们优化前面响应式代码，将收集副作用函数到“桶”以及触发副作用函数的逻辑分别封装到 track 和 trigger 函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span><br>    <span class="hljs-title function_">track</span>(target, key)<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal<br>    <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>    <span class="hljs-title function_">trigger</span>(target, key)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 在 get 拦截函数内调用 track 函数追踪变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()))<br>  &#125;<br>  <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!deps) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))<br>  &#125;<br>  deps.<span class="hljs-title function_">add</span>(activeEffect)<br>&#125;<br><br><span class="hljs-comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过将这些逻辑封装到 track 和 trigger 函数中，我们可以使代码更加灵活</p>
<h2 id="四、分支切换与清理"><a href="#四、分支切换与清理" class="headerlink" title="四、分支切换与清理"></a>四、分支切换与清理</h2><p>定义一个简单的响应式数据和副作用函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;hello world&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;)<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">ok</span> ? obj.<span class="hljs-property">text</span> : <span class="hljs-string">&#x27;not&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>在 effectFn 内部，存在一个三元表达式，根据 obj.ok 的值的不同，代码会执行不同的分支。<br>当 obj.ok 的值发生变化时，代码执行的分支也会随之变化，这就是我们所说的“分支切换”。<br>分支切换可能会导致副作用函数的遗留。<br>以上面的代码为例，obj.ok 的初始值为 true，此时会读取 obj.text 的值，所以当 effectFn 函数执行时，会触发 obj.ok 和 obj.text 两个属性的读取操作，此时副作用函数 effectFn 与响应式数据的联系如下图所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">data<br>├── ok<br>│   └── effectFn<br>└── text<br>    └── effectFn<br><br></code></pre></td></tr></table></figure>

<p>可以看到，副作用函数 effectFn 被 data.ok 和 data.text 所对应的依赖集合收集。<br>当 obj.ok 的值修改为 false，触发副作用函数重新执行后，此时不会读取 obj.text，只会触发 obj.ok 的读取操作。<br>理想情况下，副作用函数 effectFn 不应该被 obj.text 所对应的依赖集合收集。</p>
<p>但是，根据前面的实现，我们还做不到这一点。<br>换言之，当我们将 obj.ok 的值修改为 false 并触发副作用函数重新执行后，整个依赖关系仍然保持不变，这就产生了副作用函数的遗留。<br>遗留的副作用函数可能会导致不必要的更新。例如，在上面的代码中，当我们将 obj.ok 从 true 修改为 false 后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">ok</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>这将触发更新，即副作用函数重新执行。但由于此时 obj.ok 的值为 false，所以不再读取 obj.text 的值。<br>换句话说，无论 obj.text 的值如何变化，document.body.innerText 的值始终都是 ‘not’。<br>理想的情况是，无论 obj.text 的值怎么变，都不需要重新执行副作用函数。但如果我们尝试修改 obj.text 的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这仍然会导致副作用函数重新执行，即使 document.body.innerText 的值并不需要改变。<br>解决此问题思路在于：</p>
<blockquote>
<p>每次执行副作用函数前，我们将其从相关联的依赖集合中移除，函数执行完后再重新建立联系，新的联系中则不包含遗留的副作用函数。<br>重新设计副作用函数，使其具有一个 deps 属性，用于存储与其相关联的依赖集合:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储正在执行的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 将 effectFn 设为当前活动的副作用函数</span><br>    activeEffect = effectFn<br>    <span class="hljs-title function_">fn</span>()<br>  &#125;<br>  <span class="hljs-comment">// 用 effectFn.deps 存储与此副作用函数相关的所有依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = []<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何收集 effectFn.deps 数组中的依赖集合。我们需要在 track 函数中完成收集过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()))<br>  &#125;<br>  <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!deps) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))<br>  &#125;<br>  <span class="hljs-comment">// 把当前激活的副作用函数添加到依赖集合 deps 中</span><br>  deps.<span class="hljs-title function_">add</span>(activeEffect)<br>  <span class="hljs-comment">// deps 就是一个与当前副作用函数存在联系的依赖集合</span><br>  <span class="hljs-comment">// 将其添加到 activeEffect.deps 数组中</span><br>  activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(deps) <span class="hljs-comment">// 新增</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 track 函数中，我们将当前执行的副作用函数 activeEffect 添加到依赖集合 deps 中，然后把依赖集合 deps 添加到 activeEffect.deps 数组中</p>
<p>我们在每次执行副作用函数时，根据 effectFn.deps 获取所有相关联的依赖集合，将副作用函数从依赖集合中移除：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn) <span class="hljs-comment">// 执行清除操作</span><br>    activeEffect = effectFn<br>    <span class="hljs-title function_">fn</span>()<br>  &#125;<br>  effectFn.<span class="hljs-property">deps</span> = []<br>  <span class="hljs-title function_">effectFn</span>()<br>&#125;<br><br><span class="hljs-comment">// 实现 cleanup 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params">effectFn</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; effectFn.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> deps = effectFn.<span class="hljs-property">deps</span>[i]<br>    deps.<span class="hljs-title function_">delete</span>(effectFn) <span class="hljs-comment">// 将 effectFn 从依赖集合中移除</span><br>  &#125;<br>  effectFn.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <span class="hljs-comment">// 重置 effectFn.deps 数组</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>cleanup 函数接受副作用函数作为参数，遍历其 effectFn.deps 数组，该数组中每个元素都是一个依赖集合，然后从这些集合中移除该副作用函数，并最后清空 effectFn.deps 数组。至此，我们已经可以避免副作用函数产生遗留。</p>
<p>但是，我们可能会遇到无限循环执行的问题。问题出在 trigger 函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-comment">// 问题出在下面这句代码 执行 effects 里面副作用函数会先清除再收集，相当于在遍历时候删除元素又添加元素，遍历永远在执行</span><br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了避免无限执行，我们可以构造一个新的 Set 集合并遍历它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(effects) <span class="hljs-comment">// 新建一个集合并遍历</span><br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> <span class="hljs-title function_">effectFn</span>())<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们创建了一个新的集合 effectsToRun，遍历它而不是直接遍历 effects 集合，从而避免无限执行。</p>
<h2 id="五、嵌套的-effect-与-effect-栈"><a href="#五、嵌套的-effect-与-effect-栈" class="headerlink" title="五、嵌套的 effect 与 effect 栈"></a>五、嵌套的 effect 与 effect 栈</h2><p>effect 能够被嵌套使用，例如，以下代码中 effectFn1 中嵌套了 effectFn2，执行 effectFn1 会触发 effectFn2 的执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;)<br>  <span class="hljs-comment">/* ... */</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>实际上，Vue.js 的渲染函数本身就在一个 effect 中执行。例如，对于如下定义的 Foo 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Foo 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Foo</span> = &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">/* ... */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要在 effect 中执行 Foo 组件的渲染函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">render</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>当组件被嵌套时，例如 Foo 组件渲染了 Bar 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Bar 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Bar</span> = &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;,<br><br><span class="hljs-comment">// Foo 组件渲染了 Bar 组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Foo</span> = &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Bar</span> /&gt;</span></span> <span class="hljs-comment">// jsx 语法</span><br>  &#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这时就会出现嵌套的 effect，类似于以下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">render</span>()<br>  <span class="hljs-comment">// 嵌套</span><br>  <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">Bar</span>.<span class="hljs-title function_">render</span>()<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>如果 effect 不支持嵌套，会导致问题。例如，以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原始数据</span><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span> &#125;<br><span class="hljs-comment">// 代理对象</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;)<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">let</span> temp1, temp2<br><br><span class="hljs-comment">// effectFn1 嵌套了 effectFn2</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effectFn1 执行&#x27;</span>)<br><br>  <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effectFn2 执行&#x27;</span>)<br>    <span class="hljs-comment">// 在 effectFn2 中读取 obj.bar 属性</span><br>    temp2 = obj.<span class="hljs-property">bar</span><br>  &#125;)<br>  <span class="hljs-comment">// 在 effectFn1 中读取 obj.foo 属性</span><br>  temp1 = obj.<span class="hljs-property">foo</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述代码，effectFn1 内部嵌套了 effectFn2，effectFn1 的执行应导致 effectFn2 的执行。<br>注意：我们在 effectFn2 中读取了字段 obj.bar，在 effectFn1 中读取了字段 obj.foo，并且 effectFn2 的执行先于对字段 obj.foo 的读取操作。<br>理想情况下，副作用函数与对象属性之间的联系如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">data<br>  └── foo<br>    └── effectFn1<br>  └── bar<br>    └── effectFn2<br><br></code></pre></td></tr></table></figure>

<p>三次打印的结果分别是 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;effectFn1 执行&#x27;</span><br><span class="hljs-string">&#x27;effectFn2 执行&#x27;</span><br><span class="hljs-string">&#x27;effectFn2 执行&#x27;</span><br></code></pre></td></tr></table></figure>

<p>前两次分别是副作用函数 effectFn1 与 effectFn2 初始执行的打印结果，到这一步是正常的。<br>问题出在第三行打印。我们修改了字段 obj.foo 的值，发现 effectFn1 并没有重新执行，反而使得 effectFn2 重新执行了，这显然不符合预期。<br>问题的根源在于我们使用全局变量 activeEffect 来存储当前激活的 effect 函数，当 effect 函数被嵌套调用时，内层 effect 的执行会覆盖 activeEffect 的值，且无法恢复至原先的状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储当前激活的 effect 函数</span><br><span class="hljs-keyword">let</span> activeEffect<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn)<br>    <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span><br>    activeEffect = effectFn<br>    <span class="hljs-title function_">fn</span>()<br>  &#125;<br>  <span class="hljs-comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = []<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决方法是使用一个副作用函数栈 effectStack。<br>执行 effect 函数时，将当前函数压入栈中；执行完毕后，再将其从栈中弹出，保持 activeEffect 始终指向栈顶的 effect 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储当前激活的 effect 函数</span><br><span class="hljs-keyword">let</span> activeEffect<br><span class="hljs-comment">// effect 栈</span><br><span class="hljs-keyword">const</span> effectStack = [] <span class="hljs-comment">// 新增</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn)<br>    <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span><br>    activeEffect = effectFn<br>    <span class="hljs-comment">// 在调用副作用函数之前将当前副作用函数压入栈中</span><br>    effectStack.<span class="hljs-title function_">push</span>(effectFn) <span class="hljs-comment">// 新增</span><br>    <span class="hljs-title function_">fn</span>()<br>    <span class="hljs-comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值</span><br>    effectStack.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 新增</span><br>    activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] <span class="hljs-comment">// 新增</span><br>  &#125;<br>  <span class="hljs-comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = []<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们我们引入了 effectStack 数组作为栈，用于存储嵌套的 effect 函数， activeEffect 没有变化，它仍然指向当前正在执行的副作用函数。<br>不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的是外层副作用函数，而栈顶存储的则是内层副作用函数，</p>
<p>当内层副作用函数 effectFn2 执行完毕后，它会被弹出栈，并将副作用函数 effectFn1 设置为 activeEffect<br>我们可以保证响应式数据只收集直接读取其值的 effect 函数，避免了混乱。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/22/128-vue/" title="128、map和forEach"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 128、map和forEach</span></a><a class="button is-default" href="/2023/03/17/126-vue/" title="126、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(三)"><span class="has-text-weight-semibold">下一页: 126、《Vuejs设计与实现》- 霍春阳：vue.js 3设计思路(三)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
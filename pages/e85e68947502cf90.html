<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>对象的新增方法</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article id="page"><h1>对象的新增方法</h1><h1 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h1><p>本章介绍 Object 对象的新增方法。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span> <span class="hljs-comment">//true</span><br><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">Object</span>.is(+<span class="hljs-number">0</span>, <span class="hljs-number">-0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Object</span>, <span class="hljs-string">'is'</span>, &#123;<br>  value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x === y) &#123;<br>      <span class="hljs-comment">// 针对+0 不等于 -0的情况</span><br>      <span class="hljs-keyword">return</span> x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y;<br>    &#125;<br>    <span class="hljs-comment">// 针对NaN的情况</span><br>    <span class="hljs-keyword">return</span> x !== x &amp;&amp; y !== y;<br>  &#125;,<br>  configurable: <span class="hljs-literal">true</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>  writable: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source1, source2);<br>target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span><br></code></pre></td></tr></table></figure>

<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source1, source2);<br>target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span><br></code></pre></td></tr></table></figure>

<p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Object</span>.assign(obj) === obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.assign(<span class="hljs-number">2</span>) <span class="hljs-comment">// "object"</span><br></code></pre></td></tr></table></figure>

<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">Object</span>.assign(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Object</span>.assign(obj, <span class="hljs-literal">undefined</span>) === obj <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.assign(obj, <span class="hljs-literal">null</span>) === obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> v1 = <span class="hljs-string">'abc'</span>;<br><span class="hljs-keyword">const</span> v2 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> v3 = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);<br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &#123;[[PrimitiveValue]]: true&#125;</span><br><span class="hljs-built_in">Object</span>(<span class="hljs-number">10</span>)  <span class="hljs-comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span><br><span class="hljs-built_in">Object</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(&#123;<span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span>&#125;,<br>  <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">'invisible'</span>, &#123;<br>    enumerable: <span class="hljs-literal">false</span>,<br>    value: <span class="hljs-string">'hello'</span><br>  &#125;)<br>)<br><span class="hljs-comment">// &#123; b: 'c' &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span> &#125;, &#123; [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'c'</span>)]: <span class="hljs-string">'d'</span> &#125;)<br><span class="hljs-comment">// &#123; a: 'b', Symbol(c): 'd' &#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);<br><br>obj1.a.b = <span class="hljs-number">2</span>;<br>obj2.a.b <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-string">'c'</span>, <span class="hljs-attr">d</span>: <span class="hljs-string">'e'</span> &#125; &#125;<br><span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-string">'hello'</span> &#125; &#125;<br><span class="hljs-built_in">Object</span>.assign(target, source)<br><span class="hljs-comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<p><strong>（3）数组的处理</strong></p>
<p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-comment">// [4, 5, 3]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>（4）取值函数的处理</strong></p>
<p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> source = &#123;<br>  <span class="hljs-keyword">get</span> foo() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target, source)<br><span class="hljs-comment">// &#123; foo: 1 &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><code>Object.assign</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x, y) &#123;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">this</span>, &#123;x, y&#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(SomeClass.prototype, &#123;<br>  someMethod(arg1, arg2) &#123;<br>    ···<br>  &#125;,<br>  anotherMethod() &#123;<br>    ···<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 等同于下面的写法</span><br>SomeClass.prototype.someMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>&#123;<br>  ···<br>&#125;;<br>SomeClass.prototype.anotherMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  ···<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<p><strong>（3）克隆对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">origin</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, origin);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">origin</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> originProto = <span class="hljs-built_in">Object</span>.getPrototypeOf(origin);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">Object</span>.create(originProto), origin);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> merge =<br>  (target, ...sources) =&gt; <span class="hljs-built_in">Object</span>.assign(target, ...sources);<br></code></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> merge =<br>  (...sources) =&gt; <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, ...sources);<br></code></pre></td></tr></table></figure>

<p><strong>（5）为属性指定默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> DEFAULTS = &#123;<br>  logLevel: <span class="hljs-number">0</span>,<br>  outputFormat: <span class="hljs-string">'html'</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processContent</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  options = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);<br>  <span class="hljs-built_in">console</span>.log(options);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> DEFAULTS = &#123;<br>  url: &#123;<br>    host: <span class="hljs-string">'example.com'</span>,<br>    port: <span class="hljs-number">7070</span><br>  &#125;,<br>&#125;;<br><br>processContent(&#123; <span class="hljs-attr">url</span>: &#123;<span class="hljs-attr">port</span>: <span class="hljs-number">8000</span>&#125; &#125;)<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   url: &#123;port: 8000&#125;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  foo: <span class="hljs-number">123</span>,<br>  <span class="hljs-keyword">get</span> bar() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span> &#125;<br>&#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)<br><span class="hljs-comment">// &#123; foo:</span><br><span class="hljs-comment">//    &#123; value: 123,</span><br><span class="hljs-comment">//      writable: true,</span><br><span class="hljs-comment">//      enumerable: true,</span><br><span class="hljs-comment">//      configurable: true &#125;,</span><br><span class="hljs-comment">//   bar:</span><br><span class="hljs-comment">//    &#123; get: [Function: get bar],</span><br><span class="hljs-comment">//      set: undefined,</span><br><span class="hljs-comment">//      enumerable: true,</span><br><span class="hljs-comment">//      configurable: true &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOwnPropertyDescriptors</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)) &#123;<br>    result[key] = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> source = &#123;<br>  <span class="hljs-keyword">set</span> foo(value) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> target1 = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.assign(target1, source);<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="hljs-string">'foo'</span>)<br><span class="hljs-comment">// &#123; value: undefined,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> source = &#123;<br>  <span class="hljs-keyword">set</span> foo(value) &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> target2 = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperties(target2, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source));<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="hljs-string">'foo'</span>)<br><span class="hljs-comment">// &#123; get: undefined,</span><br><span class="hljs-comment">//   set: [Function: set foo],</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true &#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shallowMerge = <span class="hljs-function">(<span class="hljs-params">target, source</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.defineProperties(<br>  target,<br>  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)<br>);<br></code></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj),<br>  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">const</span> shallowClone = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.create(<br>  <span class="hljs-built_in">Object</span>.getPrototypeOf(obj),<br>  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)<br>);<br></code></pre></td></tr></table></figure>

<p>上面代码会克隆对象<code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  __proto__: prot,<br>  foo: <span class="hljs-number">123</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(prot);<br>obj.foo = <span class="hljs-number">123</span>;<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.assign(<br>  <span class="hljs-built_in">Object</span>.create(prot),<br>  &#123;<br>    foo: <span class="hljs-number">123</span>,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(<br>  prot,<br>  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(&#123;<br>    foo: <span class="hljs-number">123</span>,<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mix = <span class="hljs-function">(<span class="hljs-params">object</span>) =&gt;</span> (&#123;<br>  <span class="hljs-keyword">with</span>: <span class="hljs-function">(<span class="hljs-params">...mixins</span>) =&gt;</span> mixins.reduce(<br>    (c, mixin) =&gt; <span class="hljs-built_in">Object</span>.create(<br>      c, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(mixin)<br>    ), object)<br>&#125;);<br><br><span class="hljs-comment">// multiple mixins example</span><br><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">'a'</span>&#125;;<br><span class="hljs-keyword">let</span> b = &#123;<span class="hljs-attr">b</span>: <span class="hljs-string">'b'</span>&#125;;<br><span class="hljs-keyword">let</span> c = &#123;<span class="hljs-attr">c</span>: <span class="hljs-string">'c'</span>&#125;;<br><span class="hljs-keyword">let</span> d = mix(c).with(a, b);<br><br>d.c <span class="hljs-comment">// "c"</span><br>d.b <span class="hljs-comment">// "b"</span><br>d.a <span class="hljs-comment">// "a"</span><br></code></pre></td></tr></table></figure>

<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>
<h2 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// es5 的写法</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<br>&#125;;<br>obj.__proto__ = someOtherObj;<br><br><span class="hljs-comment">// es6 的写法</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(someOtherObj);<br>obj.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure>

<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>, &#123;<br>  <span class="hljs-keyword">get</span>() &#123;<br>    <span class="hljs-keyword">let</span> _thisObj = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getPrototypeOf(_thisObj);<br>  &#125;,<br>  <span class="hljs-keyword">set</span>(proto) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">this</span> === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isObject(<span class="hljs-keyword">this</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isObject(proto)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> status = <span class="hljs-built_in">Reflect</span>.setPrototypeOf(<span class="hljs-keyword">this</span>, proto);<br>    <span class="hljs-keyword">if</span> (!status) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>();<br>    &#125;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(value) === value;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(&#123; <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span> &#125;)<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 格式</span><br><span class="hljs-built_in">Object</span>.setPrototypeOf(object, prototype)<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setPrototypeOf</span>(<span class="hljs-params">obj, proto</span>) </span>&#123;<br>  obj.__proto__ = proto;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> proto = &#123;&#125;;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(obj, proto);<br><br>proto.y = <span class="hljs-number">20</span>;<br>proto.z = <span class="hljs-number">40</span>;<br><br>obj.x <span class="hljs-comment">// 10</span><br>obj.y <span class="hljs-comment">// 20</span><br>obj.z <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure>

<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-number">1</span>, &#123;&#125;) === <span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-string">'foo'</span>, &#123;&#125;) === <span class="hljs-string">'foo'</span> <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-literal">true</span>, &#123;&#125;) === <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-literal">undefined</span>, &#123;&#125;)<br><span class="hljs-comment">// TypeError: Object.setPrototypeOf called on null or undefined</span><br><br><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-literal">null</span>, &#123;&#125;)<br><span class="hljs-comment">// TypeError: Object.setPrototypeOf called on null or undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br></code></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> rec = <span class="hljs-keyword">new</span> Rectangle();<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype<br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Object</span>.setPrototypeOf(rec, <span class="hljs-built_in">Object</span>.prototype);<br><span class="hljs-built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>如果参数不是对象，会被自动转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 等同于 Object.getPrototypeOf(Number(1))</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span><br><br><span class="hljs-comment">// 等同于 Object.getPrototypeOf(String('foo'))</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-string">'foo'</span>)<br><span class="hljs-comment">// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;</span><br><br><span class="hljs-comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span><br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-number">1</span>) === <span class="hljs-built_in">Number</span>.prototype <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-string">'foo'</span>) === <span class="hljs-built_in">String</span>.prototype <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-literal">true</span>) === <span class="hljs-built_in">Boolean</span>.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-literal">null</span>)<br><span class="hljs-comment">// TypeError: Cannot convert undefined or null to object</span><br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-literal">undefined</span>)<br><span class="hljs-comment">// TypeError: Cannot convert undefined or null to object</span><br></code></pre></td></tr></table></figure>

<h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-built_in">Object</span>.keys(obj)<br><span class="hljs-comment">// ["foo", "baz"]</span><br></code></pre></td></tr></table></figure>

<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;keys, values, entries&#125; = <span class="hljs-built_in">Object</span>;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> keys(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">// 'a', 'b', 'c'</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> values(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 1, 2, 3</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> entries(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log([key, value]); <span class="hljs-comment">// ['a', 1], ['b', 2], ['c', 3]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-built_in">Object</span>.values(obj)<br><span class="hljs-comment">// ["bar", 42]</span><br></code></pre></td></tr></table></figure>

<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-number">100</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">7</span>: <span class="hljs-string">'c'</span> &#125;;<br><span class="hljs-built_in">Object</span>.values(obj)<br><span class="hljs-comment">// ["b", "c", "a"]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;, &#123;<span class="hljs-attr">p</span>: &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">42</span>&#125;&#125;);<br><span class="hljs-built_in">Object</span>.values(obj) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;, &#123;<span class="hljs-attr">p</span>:<br>  &#123;<br>    value: <span class="hljs-number">42</span>,<br>    enumerable: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><span class="hljs-built_in">Object</span>.values(obj) <span class="hljs-comment">// [42]</span><br></code></pre></td></tr></table></figure>

<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.values(&#123; [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-number">123</span>, <span class="hljs-attr">foo</span>: <span class="hljs-string">'abc'</span> &#125;);<br><span class="hljs-comment">// ['abc']</span><br></code></pre></td></tr></table></figure>

<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.values(<span class="hljs-string">'foo'</span>)<br><span class="hljs-comment">// ['f', 'o', 'o']</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.values(<span class="hljs-number">42</span>) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.values(<span class="hljs-literal">true</span>) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure>

<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-built_in">Object</span>.entries(obj)<br><span class="hljs-comment">// [ ["foo", "bar"], ["baz", 42] ]</span><br></code></pre></td></tr></table></figure>

<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.entries(&#123; [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-number">123</span>, <span class="hljs-attr">foo</span>: <span class="hljs-string">'abc'</span> &#125;);<br><span class="hljs-comment">// [ [ 'foo', 'abc' ] ]</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<br>    <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(k)&#125;</span>: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(v)&#125;</span>`</span><br>  );<br>&#125;<br><span class="hljs-comment">// "one": 1</span><br><span class="hljs-comment">// "two": 2</span><br></code></pre></td></tr></table></figure>

<p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));<br>map <span class="hljs-comment">// Map &#123; foo: "bar", baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>

<p>自己实现<code>Object.entries</code>方法，非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Generator函数的版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">entries</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>    <span class="hljs-keyword">yield</span> [key, obj[key]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 非Generator函数的版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">entries</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> arr = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>    arr.push([key, obj[key]]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.fromEntries([<br>  [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>],<br>  [<span class="hljs-string">'baz'</span>, <span class="hljs-number">42</span>]<br>])<br><span class="hljs-comment">// &#123; foo: "bar", baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>

<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">const</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>],<br>  [<span class="hljs-string">'baz'</span>, <span class="hljs-number">42</span>]<br>]);<br><br><span class="hljs-built_in">Object</span>.fromEntries(entries)<br><span class="hljs-comment">// &#123; foo: "bar", baz: 42 &#125;</span><br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>).set(<span class="hljs-string">'bar'</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">Object</span>.fromEntries(map)<br><span class="hljs-comment">// &#123; foo: true, bar: false &#125;</span><br></code></pre></td></tr></table></figure>

<p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.fromEntries(<span class="hljs-keyword">new</span> URLSearchParams(<span class="hljs-string">'foo=bar&amp;baz=qux'</span>))<br><span class="hljs-comment">// &#123; foo: "bar", baz: "qux" &#125;</span><br></code></pre></td></tr></table></figure>
</article><div id="paginator"></div></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen" target="_blank" rel="noopener">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Reflect</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article id="page"><h1>Reflect</h1><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<a id="more"></a>
<p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">Object</span>.defineProperty(target, property, attributes);<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-string">'assign'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.has(<span class="hljs-built_in">Object</span>, <span class="hljs-string">'assign'</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Proxy</span>(target, &#123;<br>  <span class="hljs-keyword">set</span>: function(target, name, value, receiver) &#123;<br>    <span class="hljs-keyword">var</span> success = <span class="hljs-built_in">Reflect</span>.set(target, name, value, receiver);<br>    <span class="hljs-keyword">if</span> (success) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'property '</span> + name + <span class="hljs-string">' on '</span> + target + <span class="hljs-string">' set to '</span> + value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> success;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> loggedObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;<br>  <span class="hljs-keyword">get</span>(target, name) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'get'</span>, target, name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, name);<br>  &#125;,<br>  deleteProperty(target, name) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'delete'</span> + name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, name);<br>  &#125;,<br>  has(target, name) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'has'</span> + name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.has(target, name);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 老写法</span><br><span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有 13 个静态方法。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>
<h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span>,<br>  <span class="hljs-keyword">get</span> baz() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo + <span class="hljs-keyword">this</span>.bar;<br>  &#125;,<br>&#125;<br><br><span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">'foo'</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">'bar'</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">'baz'</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span>,<br>  <span class="hljs-keyword">get</span> baz() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo + <span class="hljs-keyword">this</span>.bar;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> myReceiverObject = &#123;<br>  foo: <span class="hljs-number">4</span>,<br>  bar: <span class="hljs-number">4</span>,<br>&#125;;<br><br><span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">'baz'</span>, myReceiverObject) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">'foo'</span>) <span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">Reflect</span>.get(<span class="hljs-literal">false</span>, <span class="hljs-string">'foo'</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">set</span> bar(value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo = value;<br>  &#125;,<br>&#125;<br><br>myObject.foo <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">Reflect</span>.set(myObject, <span class="hljs-string">'foo'</span>, <span class="hljs-number">2</span>);<br>myObject.foo <span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">Reflect</span>.set(myObject, <span class="hljs-string">'bar'</span>, <span class="hljs-number">3</span>)<br>myObject.foo <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">4</span>,<br>  <span class="hljs-keyword">set</span> bar(value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo = value;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> myReceiverObject = &#123;<br>  foo: <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-built_in">Reflect</span>.set(myObject, <span class="hljs-string">'bar'</span>, <span class="hljs-number">1</span>, myReceiverObject);<br>myObject.foo <span class="hljs-comment">// 4</span><br>myReceiverObject.foo <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = &#123;<br>  a: <span class="hljs-string">'a'</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> handler = &#123;<br>  <span class="hljs-keyword">set</span>(target, key, value, receiver) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>);<br>    <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver)<br>  &#125;,<br>  defineProperty(target, key, attribute) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'defineProperty'</span>);<br>    <span class="hljs-built_in">Reflect</span>.defineProperty(target, key, attribute);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(p, handler);<br>obj.a = <span class="hljs-string">'A'</span>;<br><span class="hljs-comment">// set</span><br><span class="hljs-comment">// defineProperty</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = &#123;<br>  a: <span class="hljs-string">'a'</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> handler = &#123;<br>  <span class="hljs-keyword">set</span>(target, key, value, receiver) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>);<br>    <span class="hljs-built_in">Reflect</span>.set(target, key, value)<br>  &#125;,<br>  defineProperty(target, key, attribute) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'defineProperty'</span>);<br>    <span class="hljs-built_in">Reflect</span>.defineProperty(target, key, attribute);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(p, handler);<br>obj.a = <span class="hljs-string">'A'</span>;<br><span class="hljs-comment">// set</span><br></code></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-number">1</span>, <span class="hljs-string">'foo'</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-literal">false</span>, <span class="hljs-string">'foo'</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>&#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-string">'foo'</span> <span class="hljs-keyword">in</span> myObject <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.has(myObject, <span class="hljs-string">'foo'</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> &#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-keyword">delete</span> myObj.foo;<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.deleteProperty(myObj, <span class="hljs-string">'foo'</span>);<br></code></pre></td></tr></table></figure>

<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>
<p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-comment">// new 的写法</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Greeting(<span class="hljs-string">'张三'</span>);<br><br><span class="hljs-comment">// Reflect.construct 的写法</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Reflect</span>.construct(Greeting, [<span class="hljs-string">'张三'</span>]);<br></code></pre></td></tr></table></figure>

<p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p>
<h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = <span class="hljs-keyword">new</span> FancyThing();<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;<br></code></pre></td></tr></table></figure>

<p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-number">1</span>) <span class="hljs-comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span><br><span class="hljs-built_in">Reflect</span>.getPrototypeOf(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;&#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.setPrototypeOf(myObj, <span class="hljs-built_in">Array</span>.prototype);<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.setPrototypeOf(myObj, <span class="hljs-built_in">Array</span>.prototype);<br><br>myObj.length <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Reflect</span>.setPrototypeOf(&#123;&#125;, <span class="hljs-literal">null</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">Reflect</span>.setPrototypeOf(<span class="hljs-built_in">Object</span>.freeze(&#123;&#125;), <span class="hljs-literal">null</span>)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-number">1</span>, &#123;&#125;)<br><span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">Reflect</span>.setPrototypeOf(<span class="hljs-number">1</span>, &#123;&#125;)<br><span class="hljs-comment">// TypeError: Reflect.setPrototypeOf called on non-object</span><br></code></pre></td></tr></table></figure>

<p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-literal">null</span>, &#123;&#125;)<br><span class="hljs-comment">// TypeError: Object.setPrototypeOf called on null or undefined</span><br><br><span class="hljs-built_in">Reflect</span>.setPrototypeOf(<span class="hljs-literal">null</span>, &#123;&#125;)<br><span class="hljs-comment">// TypeError: Reflect.setPrototypeOf called on non-object</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>
<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ages = [<span class="hljs-number">11</span>, <span class="hljs-number">33</span>, <span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">96</span>];<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-keyword">const</span> youngest = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> oldest = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> type = <span class="hljs-built_in">Object</span>.prototype.toString.call(youngest);<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">const</span> youngest = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.min, <span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> oldest = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.max, <span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> type = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Object</span>.prototype.toString, youngest, []);<br></code></pre></td></tr></table></figure>

<h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyDate</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">/*…*/</span><br>&#125;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.defineProperty(MyDate, <span class="hljs-string">'now'</span>, &#123;<br>  value: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Date</span>.now()<br>&#125;);<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">'now'</span>, &#123;<br>  value: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Date</span>.now()<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>
<p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;<br>  defineProperty(target, prop, descriptor) &#123;<br>    <span class="hljs-built_in">console</span>.log(descriptor);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.defineProperty(target, prop, descriptor);<br>  &#125;<br>&#125;);<br><br>p.foo = <span class="hljs-string">'bar'</span>;<br><span class="hljs-comment">// &#123;value: "bar", writable: true, enumerable: true, configurable: true&#125;</span><br><br>p.foo <span class="hljs-comment">// "bar"</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p>
<h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(myObject, <span class="hljs-string">'hidden'</span>, &#123;<br>  value: <span class="hljs-literal">true</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>&#125;);<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-keyword">var</span> theDescriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="hljs-string">'hidden'</span>);<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">var</span> theDescriptor = <span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="hljs-string">'hidden'</span>);<br></code></pre></td></tr></table></figure>

<p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = &#123;&#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.isExtensible(myObject) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.isExtensible(myObject) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.isExtensible(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Reflect</span>.isExtensible(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.preventExtensions(myObject) <span class="hljs-comment">// Object &#123;&#125;</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.preventExtensions(myObject) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5 环境</span><br><span class="hljs-built_in">Object</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br><br><span class="hljs-comment">// ES6 环境</span><br><span class="hljs-built_in">Object</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.preventExtensions(<span class="hljs-number">1</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span>,<br>  [<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'baz'</span>)]: <span class="hljs-number">3</span>,<br>  [<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'bing'</span>)]: <span class="hljs-number">4</span>,<br>&#125;;<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject)<br><span class="hljs-comment">// ['foo', 'bar']</span><br><br><span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject)<br><span class="hljs-comment">//[Symbol(baz), Symbol(bing)]</span><br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-built_in">Reflect</span>.ownKeys(myObject)<br><span class="hljs-comment">// ['foo', 'bar', Symbol(baz), Symbol(bing)]</span><br></code></pre></td></tr></table></figure>

<p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p>
<h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = observable(&#123;<br>  name: <span class="hljs-string">'张三'</span>,<br>  age: <span class="hljs-number">20</span><br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;person.name&#125;</span>, <span class="hljs-subst">$&#123;person.age&#125;</span>`</span>)<br>&#125;<br><br>observe(print);<br>person.name = <span class="hljs-string">'李四'</span>;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 李四, 20</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> queuedObservers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><br><span class="hljs-keyword">const</span> observe = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> queuedObservers.add(fn);<br><span class="hljs-keyword">const</span> observable = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;<span class="hljs-keyword">set</span>&#125;);<br><br>function <span class="hljs-keyword">set</span>(target, key, value, receiver) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);<br>  queuedObservers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>
</article><div id="paginator"></div></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen" target="_blank" rel="noopener">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" target="_blank" rel="noopener" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>32、javascript -- 对象</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？


在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是：原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。
一、字符串方法// 将字符串的字母转换成小写
const str = &amp;quot;Hello world&amp;quot;;
arr = str.split(&amp;quot;&amp;quot;).map(function (item) &amp;#123;
  return (item + &amp;quot;&amp;quot;).toLowerCase();
&amp;#125;);
lowerStr = arr.join(&amp;.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">32、javascript -- 对象</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">一、字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">js 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E3%80%81Map%E3%80%81WeakSet-%E5%92%8C-WeakMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Set、Map、WeakSet 和 WeakMap 的区别</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/js"><i class="tag post-item-tag">js</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">32、javascript -- 对象</h1><time class="has-text-grey" datetime="2021-04-13T16:00:00.000Z">2021-04-14</time><article class="mt-2 post-content"><p>对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p>
<span id="more"></span>

<p>在 JS 中，除了原始类型那么其他的都是对象类型了。<br>对象类型和原始类型不同的是：<br>原始类型存储的是值，对象类型存储的是地址（指针）。<br>当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，<br>但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p>
<h2 id="一、字符串方法"><a href="#一、字符串方法" class="headerlink" title="一、字符串方法"></a>一、字符串方法</h2><pre><code class="js">// 将字符串的字母转换成小写
const str = &quot;Hello world&quot;;
arr = str.split(&quot;&quot;).map(function (item) &#123;
  return (item + &quot;&quot;).toLowerCase();
&#125;);
lowerStr = arr.join(&quot;&quot;);
console.log(lowerStr);

// 挑出大写字母
const str = &quot;Permission is &quot;;
reg = /[A-Z]/g;
console.log(str.match(reg).join(&quot;&quot;));
</code></pre>
<h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><p>基本数据类型：</p>
<blockquote>
<p>Number，String，Boolean，null，undefined，symbol，bigint</p>
</blockquote>
<p>引用数据类型:</p>
<blockquote>
<p>object function</p>
</blockquote>
<blockquote>
<p>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基 本类型值和执行代码的空间。</p>
<p>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p>
</blockquote>
<p>基本数据类型和引用数据类型的区别：</p>
<blockquote>
<ol>
<li>堆比栈空间大，栈比堆运行速度快。</li>
<li>堆内存是无序存储，可以根据引用直接获取。</li>
<li>基础数据类型比较稳定，而且相对来说占用的内存小。</li>
<li>引用数据类型大小是动态的，而且是无限的。</li>
</ol>
</blockquote>
<p>Object.assign()：合并对象 Object.assign(target, …sources)</p>
<blockquote>
<ol>
<li>Object.assign 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖。</li>
<li>后续的 source 会覆盖前面的 source 的同名属性。</li>
<li>Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</li>
</ol>
</blockquote>
<p>Constructor:</p>
<blockquote>
<p>创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。</p>
</blockquote>
<p>map 和 forEach 区别</p>
<p>相同点：</p>
<blockquote>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）</li>
<li>匿名函数中的 this 都是指向 window</li>
<li>只能遍历数组</li>
</ol>
</blockquote>
<p>不同点：</p>
<blockquote>
<ol>
<li>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</li>
<li>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</li>
</ol>
</blockquote>
<p>for…of:</p>
<blockquote>
<p>es6 新增的一个遍历方法，但<strong>只限于迭代器(iterator)</strong>, 所以普通的对象用 for..of 遍历<br>是会报错的。</p>
<p>包括 Array, Map, Set, String, TypedArray, arguments 对象</p>
</blockquote>
<p>indexOf str.indexOf(searchValue [, fromIndex]) searchValue：要被查找的字符串值。</p>
<blockquote>
<p>查找的字符串 searchValue 的<strong>第一次</strong>出现的索引，如果没有找到，则返回-1。</p>
<p>若被查找的字符串 searchValue 是一个空字符串，则返回 fromIndex。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样。</p>
<p>如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）</p>
<p>严格区分大小写</p>
<p>在使用 indexOf 检索数组时，用‘===’去匹配，意味着会检查数据类型</p>
</blockquote>
<p>Iframe 的优缺点？</p>
<p>优点：</p>
<blockquote>
<ol>
<li>iframe 能够原封不动的把嵌入的网页展现出来。</li>
<li>如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li>
<li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。</li>
<li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>iframe 会阻塞主页面的 onload 事件；</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。</li>
<li>iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</li>
<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。</li>
<li>很多的移动设备无法完全显示框架，设备兼容性差。</li>
<li>iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。</li>
</ol>
</blockquote>
<p>作用域：</p>
<blockquote>
<p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p>
</blockquote>
<p>js 的 arguments 相关问题</p>
<blockquote>
<p>在 js 中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js 会把所传的参数全部存到一个叫 arguments 的对象里面。它是一个<strong>类数组数据由来</strong></p>
<p>Javascrip 中每个函数都会有一个 Arguments 对象实例 arguments，引用着函数的实参。它是寄生在 js 函数当中的，不能显式创建，arguments 对象只有函数开始时才可用</p>
</blockquote>
<p>instanceof 原理：判断实例属于什么类型</p>
<pre><code class="js">// 实现方法
function new_instance_of(leftVaule, rightVaule) &#123;
  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
  leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
  while (true) &#123;
    if (leftVaule === null) &#123;
      return false;
    &#125;
    if (leftVaule === rightProto) &#123;
      return true;
    &#125;
    leftVaule = leftVaule.__proto__;
  &#125;
&#125;
</code></pre>
<p>数组去重：</p>
<p>1、es6 Set 方法</p>
<pre><code class="js">function unique(arr) &#123;
  return Array.from(new Set(arr));
&#125;
// 无法去除 &#123;&#125; 空对象

// 简写
[...new Set(arr)];
</code></pre>
<p>2、es5 利用 for 循环嵌套，然后 splice 去重</p>
<pre><code class="js">function unique(arr) &#123;
  for (var i = 0; i &lt; arr.length; i++) &#123;
    for (var j = i + 1; j &lt; arr.length; j++) &#123;
      if (arr[i] == arr[j]) &#123;
        //第一个等同于第二个，splice方法删除第二个
        arr.splice(j, 1);
        j--;
      &#125;
    &#125;
  &#125;
  return arr;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr)); //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了
</code></pre>
<p>3、indexOf</p>
<pre><code class="js">function unique(arr) &#123;
  if (!Array.isArray(arr)) &#123;
    console.log(&quot;type error!&quot;);
    return;
  &#125;
  var array = [];
  for (var i = 0; i &lt; arr.length; i++) &#123;
    if (array.indexOf(arr[i]) === -1) &#123;
      array.push(arr[i]);
    &#125;
  &#125;
  return array;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重
</code></pre>
<p>4、sort</p>
<pre><code class="js">function unique(arr) &#123;
  if (!Array.isArray(arr)) &#123;
    console.log(&quot;type error!&quot;);
    return;
  &#125;
  arr = arr.sort();
  var arrry = [arr[0]];
  for (var i = 1; i &lt; arr.length; i++) &#123;
    if (arr[i] !== arr[i - 1]) &#123;
      arrry.push(arr[i]);
    &#125;
  &#125;
  return arrry;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重
</code></pre>
<p>5、includes</p>
<pre><code class="js">function unique(arr) &#123;
  if (!Array.isArray(arr)) &#123;
    console.log(&quot;type error!&quot;);
    return;
  &#125;
  var array = [];
  for (var i = 0; i &lt; arr.length; i++) &#123;
    if (!array.includes(arr[i])) &#123;
      //includes 检测数组是否有某个值
      array.push(arr[i]);
    &#125;
  &#125;
  return array;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重
</code></pre>
<p>6、<strong>hasOwnProperty</strong>:利用 hasOwnProperty 判断是否存在对象属性</p>
<pre><code class="js">function unique(arr) &#123;
  var obj = &#123;&#125;;
  return arr.filter(function (item, index, arr) &#123;
    return obj.hasOwnProperty(typeof item + item)
      ? false
      : (obj[typeof item + item] = true);
  &#125;);
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了
</code></pre>
<p>7、filter</p>
<pre><code class="js">function unique(arr) &#123;
  return arr.filter(function (item, index, arr) &#123;
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  &#125;);
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]
</code></pre>
<p>8、递归去重</p>
<pre><code class="js">function unique(arr) &#123;
  var array = arr;
  var len = array.length;

  array.sort(function (a, b) &#123;
    //排序后更加方便去重
    return a - b;
  &#125;);

  function loop(index) &#123;
    if (index &gt;= 1) &#123;
      if (array[index] === array[index - 1]) &#123;
        array.splice(index, 1);
      &#125;
      loop(index - 1); //递归loop，然后数组去重
    &#125;
  &#125;
  loop(len - 1);
  return array;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]
</code></pre>
<p>9、Map 数据结构去重</p>
<blockquote>
<p>创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</p>
</blockquote>
<pre><code class="js">function arrayNonRepeatfy(arr) &#123;
  let map = new Map();
  let array = new Array(); // 数组用于返回结果
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (map.has(arr[i])) &#123;
      // 如果有该key值
      map.set(arr[i], true);
    &#125; else &#123;
      map.set(arr[i], false); // 如果没有该key值
      array.push(arr[i]);
    &#125;
  &#125;
  return array;
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]
</code></pre>
<p>10、<strong>利用 reduce+includes</strong></p>
<pre><code class="js">function unique(arr) &#123;
  return arr.reduce(
    (prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]),
    []
  );
&#125;
var arr = [
  1,
  1,
  &quot;true&quot;,
  &quot;true&quot;,
  true,
  true,
  15,
  15,
  false,
  false,
  undefined,
  undefined,
  null,
  null,
  NaN,
  NaN,
  &quot;NaN&quot;,
  0,
  0,
  &quot;a&quot;,
  &quot;a&quot;,
  &#123;&#125;,
  &#123;&#125;,
];
console.log(unique(arr));
// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]
</code></pre>
<p>null 和 undefined 的区别</p>
<blockquote>
<p>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p>
</blockquote>
<p>undefined:</p>
<ol>
<li>声明了一个变量，但没有赋值</li>
<li>访问对象上不存在的属性</li>
<li>函数定义了形参，但没有传递实参</li>
<li>使用 void 对表达式求值</li>
</ol>
<p>null:空值</p>
<blockquote>
<p><strong>表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。</strong> 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
</blockquote>
<p>typeof null 为什么是 object？</p>
<blockquote>
<p>null 有属于自己的类型 Null，而不属于 Object 类型，typeof 之所以会判定为 Object 类型，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，<strong>二进制的前三位为 0 会被 typeof 判断为对象类型</strong>，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p>
</blockquote>
<p>类数组转换为数组的方法：</p>
<blockquote>
<ul>
<li>使用 Array.from()</li>
<li>使用 Array.prototype.slice.call()</li>
<li>使用 Array.prototype.forEach()进行属性遍历并组成新的数组</li>
</ul>
<p>// 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。</p>
</blockquote>
<p>数组转树</p>
<pre><code class="js">function arrayToTree(array) &#123;
  let root = array[0];
  array.shift();
  let tree = &#123;
    id: root.id,
    val: root.val,
    children: array.length &gt; 0 ? toTree(root.id, array) : [],
  &#125;;
  return tree;
&#125;

function toTree(parenId, array) &#123;
  let children = [];
  let len = array.length;
  for (let i = 0; i &lt; len; i++) &#123;
    let node = array[i];
    if (node.parentId === parenId) &#123;
      children.push(&#123;
        id: node.id,
        val: node.val,
        children: toTree(node.id, array),
      &#125;);
    &#125;
  &#125;
  return children;
&#125;
</code></pre>
<h4 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h4><blockquote>
<p><strong>Set</strong></p>
<ol>
<li>成员不能重复；</li>
<li>只有键值，没有键名，有点类似数组；</li>
<li>可以遍历，方法有 add、delete、has</li>
</ol>
<p><strong>WeakSet</strong></p>
<ol>
<li>成员都是对象（引用）；</li>
<li>成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；</li>
<li>不能遍历，方法有 add、delete、has；</li>
</ol>
<p><strong>Map</strong></p>
<ol>
<li>本质上是键值对的集合，类似集合；</li>
<li>可以遍历，方法很多，可以跟各种数据格式转换；</li>
</ol>
<p><strong>WeakMap</strong></p>
<ol>
<li>只接收对象为键名（null 除外），不接受其他类型的值作为键名；</li>
<li>键名指向的对象，不计入垃圾回收机制；</li>
<li>不能遍历，方法同 get、set、has、delete；</li>
</ol>
</blockquote>
<p>造成内存泄漏的情况</p>
<blockquote>
<ol>
<li>意外的全局变量；</li>
<li>闭包；</li>
<li>未被清空的定时器；</li>
<li>未被销毁的事件监听；</li>
<li>DOM 引用；</li>
</ol>
</blockquote>
<p>数据类型的判断方法：</p>
<blockquote>
<ol>
<li> 使用 typeof 检测当需要判断变量是否是 number, string, boolean, function, undefined 等类型时，可以使用 typeof 进行判断。</li>
<li> 使用 instanceof 检测 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。</li>
<li> 使用 constructor 检测 constructor 本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。</li>
</ol>
</blockquote>
<p>什么是 promise 和 async await 以及它们的区别</p>
<blockquote>
<p><strong>Promise</strong> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的</p>
<p><strong>async await</strong>也是异步编程的一种解决方案，他遵循的是 Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。</p>
</blockquote>
<p>区别：</p>
<blockquote>
<ol>
<li>Promise 的出现解决了传统 callback 函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而 async await 代码看起来会简洁些，使得异步代码看起来像同步代码，await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</li>
<li>async await 与 Promise 一样，是非阻塞的。</li>
<li>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数。</li>
</ol>
</blockquote>
<p>js 实现 sleep</p>
<pre><code class="js">function sleep(time) &#123;
  return new Promise((resolve) =&gt; setTimeout(resolve, time));
&#125;

const t1 = +new Date();
sleep(3000).then(() =&gt; &#123;
  const t2 = +new Date();
  console.log(t2 - t1);
&#125;);
</code></pre>
<blockquote>
<p>优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。</p>
<p>缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭</p>
</blockquote>
<p><strong>Event Loop</strong>执行顺序</p>
<blockquote>
<ol>
<li>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)</li>
<li>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务</li>
<li>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
</blockquote>
<p>宏任务 Macrotask 宏任务是指 Event Loop 在<strong>每个阶段</strong>执行的任务</p>
<p>微任务 Microtask 微任务是指 Event Loop 在<strong>每个阶段之间</strong>执行的任务</p>
<p>宏任务队列包含任务: A1, A2 , A3</p>
<p>微任务队列包含任务: B1, B2 , B3</p>
<p>执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行 B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务 A2，依次循环。</p>
<p>宏任务 Macrotask 队列真实包含任务：</p>
<blockquote>
<pre><code>script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering
</code></pre>
</blockquote>
<p>微任务 Microtask 队列真实包含任务:</p>
<blockquote>
<pre><code>process.nextTick, Promises, Object.observe, MutationObserver
</code></pre>
</blockquote>
<p>执行顺序：</p>
<blockquote>
<pre><code>script(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering
</code></pre>
</blockquote>
<p>示例：</p>
<pre><code class="js">console.time(&quot;start&quot;);

setTimeout(function () &#123;
  console.log(2);
&#125;, 10);

setImmediate(function () &#123;
  console.log(1);
&#125;);

new Promise(function (resolve) &#123;
  console.log(3);
  resolve();
  console.log(4);
&#125;).then(function () &#123;
  console.log(5);
  console.timeEnd(&quot;start&quot;);
&#125;);

console.log(6);

process.nextTick(function () &#123;
  console.log(7);
&#125;);

console.log(8);
</code></pre>
<p>结果：3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: XXXXms——&gt;1——&gt;2</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/04/28/time/" title="33、时间格式化"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 33、时间格式化</span></a><a class="button is-default" href="/2021/03/23/back/" title="31、解决点击手机虚拟返回键退出应用"><span class="has-text-weight-semibold">下一页: 31、解决点击手机虚拟返回键退出应用</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>39、堆和栈、变量复制、深拷贝与浅拷贝</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="栈（stack）：主要存放的是基本类型的变量和对象的应用，其优势是存储速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。   
堆（heap）：用于引用类型（复杂数据类型：如数组对象、object对象）分配空间，运行时动态分配内存，存储速度较慢。


JavaScript中，内存分为三种类型：代码空间、栈空间、堆空间，其中代码空间用于存放可执行代码。
一、堆栈内存空间1、栈内存空间
用栈作为数据结构在内存中所申请的空间。

2、栈的特点：1、后进先出，最后添加进栈的元素最先出
2、访问栈底元素，必须拿掉它上面的元素

js7种基本数据类型变量保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。
3、闭包
闭包中的基本数据类型变量是保存在堆内存里的，当.."><meta name="generator" content="Hexo 7.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">39、堆和栈、变量复制、深拷贝与浅拷贝</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">一、堆栈内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A0%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">1、栈内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">2、栈的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-text">3、闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">二、堆内存空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">1、二叉堆的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2、引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、栈内存空间与堆内存的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%98%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-text">三、变量复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">1、基本数据类型的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">2、引用类型的复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">四、深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">1、浅拷贝：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Object-asign"><span class="toc-text">1.1 Object.asign()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.2 扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Array-prototype-concat-Array-ptototype-slice"><span class="toc-text">1.3 Array.prototype.concat()&#x2F;Array.ptototype.slice()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">2、深拷贝：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%951%EF%BC%9A"><span class="toc-text">2.1 深拷贝方法1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%952%EF%BC%9A"><span class="toc-text">2.2 深拷贝方法2：</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/js"><i class="tag post-item-tag">js</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">39、堆和栈、变量复制、深拷贝与浅拷贝</h1><time class="has-text-grey" datetime="2021-05-24T16:00:00.000Z">2021-05-25</time><article class="mt-2 post-content"><p>栈（stack）：主要存放的是基本类型的变量和对象的应用，其优势是存储速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。   </p>
<p>堆（heap）：用于引用类型（复杂数据类型：如数组对象、object对象）分配空间，运行时动态分配内存，存储速度较慢。</p>
<span id="more"></span>

<p>JavaScript中，内存分为三种类型：代码空间、栈空间、堆空间，其中代码空间用于存放可执行代码。</p>
<h2 id="一、堆栈内存空间"><a href="#一、堆栈内存空间" class="headerlink" title="一、堆栈内存空间"></a>一、堆栈内存空间</h2><h3 id="1、栈内存空间"><a href="#1、栈内存空间" class="headerlink" title="1、栈内存空间"></a>1、栈内存空间</h3><blockquote>
<p>用栈作为数据结构在内存中所申请的空间。</p>
</blockquote>
<h3 id="2、栈的特点："><a href="#2、栈的特点：" class="headerlink" title="2、栈的特点："></a>2、栈的特点：</h3><p>1、后进先出，最后添加进栈的元素最先出</p>
<p>2、访问栈底元素，必须拿掉它上面的元素</p>
<p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5631876df7b34b1cbe19f10ff5fe7b1a~tplv-k3u1fbpfcp-watermark.awebp"></image></p>
<p>js7种基本数据类型变量保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过值来访问，属于被频繁使用的数据。</p>
<h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><blockquote>
<p>闭包中的基本数据类型变量是保存在堆内存里的，当函数执行完弹出调用栈后，返回内部函数的一个应用，这时候函数的变量就会转移到堆上，因此内部函数依然能访问到上一层函数的变量。</p>
</blockquote>
<h2 id="二、堆内存空间"><a href="#二、堆内存空间" class="headerlink" title="二、堆内存空间"></a>二、堆内存空间</h2><blockquote>
<p>用堆作为数据结构在内存中所申请的空间。<br>通常情况下，我们所说的堆数据结构指的就是二叉堆。</p>
</blockquote>
<h3 id="1、二叉堆的特点："><a href="#1、二叉堆的特点：" class="headerlink" title="1、二叉堆的特点："></a>1、二叉堆的特点：</h3><p>1、它是一颗完全二叉树</p>
<p>2、二叉堆不是最小堆就是最大堆</p>
<h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><blockquote>
<p>引用数据类型存储在堆内存中，引用数据类型占据空间大、大小不固定，如果存储在栈中，将影响程序的运行性能。<br>引用数据类型会在栈中存储一个指针，这个指针指向堆内存空间中该实体的起始地址。<br>当解释器寻找引用值时，会先检索其在栈中的地址，取得地址后，从堆中获得实体。</p>
</blockquote>
<pre><code class="js">// 基本数据类型-栈内存
let name = &quot;大白&quot;;
// 基本数据类型-栈内存
let age = 20;
// 基本数据类型-栈内存
let info = null;
// 对象指针存放在栈内存中，指针指向的对象放在堆内存中
let msgObj = &#123;msg: &quot;测试&quot;, id: 5&#125;;
// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中
let ages = [19, 22, 57]
</code></pre>
<p>上面代码中：</p>
<pre><code>1、创建了两个变量msgObj、ages，它们的值都是引用类型(object、array)
2、堆内存空间采用二叉堆作为数据结构，msgObj与ages的具体值会存在堆内存空间中
3、存储完成后，堆内存空间会返回这两个值的引用地址(指针)
4、拿到引用地址后，这个引用地址会和它的变量名对应起来，存放在栈内存空间中
5、在查找变量msgObj与ages的具体值时，会先从栈内存空间中获取它的引用地址
6、获取到引用地址后，通过引用地址在堆内存空间的二叉堆中查找到对应的值。
</code></pre>
<p>堆内存空间中的object，表示的是存储在空间中的其他对象的引用值</p>
<p><image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18fbd5bf395a42e5b6757c84a4768be7~tplv-k3u1fbpfcp-watermark.awebp"></image></p>
<h3 id="3、栈内存空间与堆内存的区别"><a href="#3、栈内存空间与堆内存的区别" class="headerlink" title="3、栈内存空间与堆内存的区别"></a>3、栈内存空间与堆内存的区别</h3><blockquote>
<p>堆内存空间：相当于一个采用二叉堆作为数据结构的容器。<br>堆内存：指的是一个引用类型的具体值<br>堆内存存在于堆内存空间中</p>
</blockquote>
<h2 id="三、变量复制"><a href="#三、变量复制" class="headerlink" title="三、变量复制"></a>三、变量复制</h2><h3 id="1、基本数据类型的复制"><a href="#1、基本数据类型的复制" class="headerlink" title="1、基本数据类型的复制"></a>1、基本数据类型的复制</h3><p>下面代码中，name、alias都是基本类型，值存储在栈内存，分别有各自独立的栈空间，因此修改了alias的值，name是不受影响的。</p>
<pre><code class="js">let name =&#39;jude&#39;
let alias = name
alias = &#39;summer&#39;

console.log(name) // jude
console.log(alias) // summer
</code></pre>
<p>相当于复制前是这样的：</p>
<blockquote>
<p>name | jude</p>
</blockquote>
<p>复制后：</p>
<blockquote>
<p>alias | jude<br>name  | jude</p>
</blockquote>
<p>修改后:</p>
<blockquote>
<p>alias | summer<br>name  | jude</p>
</blockquote>
<h3 id="2、引用类型的复制"><a href="#2、引用类型的复制" class="headerlink" title="2、引用类型的复制"></a>2、引用类型的复制</h3><p>下面代码中，info、book都是引用类型，它们引用存在栈内存，值存在堆内存，它们的值指向同一块堆内存，栈内存中会复制一份相同的引用。</p>
<pre><code class="js">let book = &#123;title:&#39;book&#39;,id:1&#125;
let info = book
info.title = &#39;javascript&#39;
console.log(book.title) // javascript
</code></pre>
<h2 id="四、深拷贝与浅拷贝"><a href="#四、深拷贝与浅拷贝" class="headerlink" title="四、深拷贝与浅拷贝"></a>四、深拷贝与浅拷贝</h2><h3 id="1、浅拷贝："><a href="#1、浅拷贝：" class="headerlink" title="1、浅拷贝："></a>1、浅拷贝：</h3><blockquote>
<p>引用数据类型在复制时，改了其中一个数据的值，另一个数据的值也会跟着改变，这种拷贝方式我们称为浅拷贝。</p>
</blockquote>
<h4 id="1-1-Object-asign"><a href="#1-1-Object-asign" class="headerlink" title="1.1 Object.asign()"></a>1.1 Object.asign()</h4><blockquote>
<p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
</blockquote>
<pre><code class="js">let obj1 = &#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;,sports:&#39;basketball&#39; &#125;;
let obj2 = Object.assign(&#123;&#125;, obj1);
obj2.person.name = &quot;wade&quot;;
obj2.sports = &#39;football&#39;
console.log(obj1); // &#123; person: &#123; name: &#39;wade&#39;, age: 41 &#125;, sports: &#39;basketball&#39; &#125;
</code></pre>
<h4 id="1-2-扩展运算符"><a href="#1-2-扩展运算符" class="headerlink" title="1.2 扩展运算符"></a>1.2 扩展运算符</h4><pre><code class="js">let obj1 = &#123; name: &#39;Kobe&#39;, address:&#123;x:100,y:100&#125;&#125;
let obj2= &#123;... obj1&#125;
obj1.address.x = 200;
obj1.name = &#39;wade&#39;
console.log(&#39;obj2&#39;,obj2) // obj2 &#123; name: &#39;Kobe&#39;, address: &#123; x: 200, y: 100 &#125; &#125;
</code></pre>
<h4 id="1-3-Array-prototype-concat-Array-ptototype-slice"><a href="#1-3-Array-prototype-concat-Array-ptototype-slice" class="headerlink" title="1.3 Array.prototype.concat()&#x2F;Array.ptototype.slice()"></a>1.3 Array.prototype.concat()&#x2F;Array.ptototype.slice()</h4><pre><code class="js">let arr = [1, 3, &#123;
    username: &#39;kobe&#39;
&#125;];
let arr2 = arr.concat();    
arr2[2].username = &#39;wade&#39;;
console.log(arr); //[ 1, 3, &#123; username: &#39;wade&#39; &#125; ]


let arr = [1, 3, &#123;
    username: &#39; kobe&#39;
&#125;];
let arr3 = arr.slice();
arr3[2].username = &#39;wade&#39;
console.log(arr); // [ 1, 3, &#123; username: &#39;wade&#39; &#125; ]
</code></pre>
<h3 id="2、深拷贝："><a href="#2、深拷贝：" class="headerlink" title="2、深拷贝："></a>2、深拷贝：</h3><blockquote>
<p>引用类型复制到新的变量后，二者是独立的，不会因为一个的改变而影响到另一个<br>实际上就是重新在堆内存中开辟一块新的空间，把原对象的数据拷贝到这个新地址空间里来</p>
</blockquote>
<h4 id="2-1-深拷贝方法1："><a href="#2-1-深拷贝方法1：" class="headerlink" title="2.1 深拷贝方法1："></a>2.1 深拷贝方法1：</h4><blockquote>
<p>将对象转一遍JSON，缺点是只能转化一般常见的数据，function、undefined、正则等类型无法通过这种方法变回来。</p>
</blockquote>
<pre><code class="js">const data = &#123; name: &quot;jude&quot; &#125;;
const obj = JSON.parse(JSON.stringify(data));
obj.age = 20;
console.log(&quot;data = &quot;, data);// data = &#123; name:&quot;jude&quot;&#125;
console.log(&quot;obj = &quot;, obj);// obj = &#123;name:&#39;jude&#39;,age:20&#125;
</code></pre>
<h4 id="2-2-深拷贝方法2："><a href="#2-2-深拷贝方法2：" class="headerlink" title="2.2 深拷贝方法2："></a>2.2 深拷贝方法2：</h4><blockquote>
<p>手动去写循环遍历</p>
</blockquote>
<pre><code class="js">const data = [&#123; name: &quot;jude&quot; &#125;];
let obj = data.map(item =&gt; item);
obj.push(&#123; name: &quot;summer&quot; &#125;);
console.log(&quot;data = &quot;, data);// data = [&#123;name:&#39;jude&#39;&#125;]
console.log(&quot;obj = &quot;, obj);// obj = [&#123;name:&#39;jude&#39;,name:&#39;summer&#39;&#125;]
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/06/20/40-egg/" title="40、初识egg.js"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 40、初识egg.js</span></a><a class="button is-default" href="/2021/05/19/38-resize/" title="38、Vue项目中的window.resize"><span class="has-text-weight-semibold">下一页: 38、Vue项目中的window.resize</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>vue基础知识</title><meta name="description" content="🐯 🐯 🐯 🐯 🐯"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Vue基础知识点，包括常用指令、计算属性、侦听属性等。


Vuejs响应式原理编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。
收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）
通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。

vue优点轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
双向数据绑定：保留了angular的特点，在数据操作方面更为简单；
组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；
视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码.."><meta name="generator" content="Hexo 6.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">vue基础知识</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuejs%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">Vuejs响应式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%BC%98%E7%82%B9"><span class="toc-text">vue优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">vue组件中data必须是一个函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">v-if和v-show有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nextTick%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">$nextTick是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for-key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">v-for key的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">双向数据绑定原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86"><span class="toc-text">vue-router路由页面管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">表单输入控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue%E6%B8%B2%E6%9F%93%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">Vue渲染目标元素的6种方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#data-computed-watch"><span class="toc-text">data&#x2F;computed&#x2F;watch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-on%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-text">v-on对象语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#axios%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">axios的封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#router-link"><span class="toc-text">router-link</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#v-slot"><span class="toc-text">v-slot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#props"><span class="toc-text">props</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mixin-%E6%B7%B7%E5%85%A5"><span class="toc-text">mixin 混入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%EF%BC%9Ainject-provide"><span class="toc-text">边界处理：inject&#x2F;provide</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex"><span class="toc-text">vuex</span></a></div><div class="column is-9"><header class="my-4"><a href="/tags/vue"><i class="tag post-item-tag">vue</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">vue基础知识</h1><time class="has-text-grey" datetime="2019-09-26T12:00:00.000Z">2019-09-26</time><article class="mt-2 post-content"><p>Vue基础知识点，包括常用指令、计算属性、侦听属性等。</p>
<span id="more"></span>

<h2 id="Vuejs响应式原理"><a href="#Vuejs响应式原理" class="headerlink" title="Vuejs响应式原理"></a>Vuejs响应式原理</h2><pre><code>编译组件：对特殊标记的部分（比如双大括号部分）进行替换为相应的数据值。
收集依赖：对于编译阶段依赖的数据进行监听（这个都是通过 watcher 对象实现的）
通知更新：当步骤2中监听的数据发生变化时，会通知 watcher 进行重新计算，触发关联视图更新。
</code></pre>
<h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p>
<p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p>
<p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p>
<p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p>
<p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p>
<p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p>
<p>运行速度更快: 相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p>
<h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。</p>
<p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p>
<p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p>
<p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<h2 id="vue组件中data必须是一个函数？"><a href="#vue组件中data必须是一个函数？" class="headerlink" title="vue组件中data必须是一个函数？"></a>vue组件中data必须是一个函数？</h2><p>官网上是这样写的：</p>
<blockquote>
<p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，如果 Vue 没有这条规则，可能会影响到其它所有实例。</p>
</blockquote>
<p>当创建Vue实例时，data必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p>
<h2 id="v-if和v-show有什么区别？"><a href="#v-if和v-show有什么区别？" class="headerlink" title="v-if和v-show有什么区别？"></a>v-if和v-show有什么区别？</h2><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p>
<p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p>
<p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p>
<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>计算属性computed：</p>
<p>支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<p>侦听属性watch：</p>
<p>不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：<br>immediate：组件加载立即触发回调函数执行</p>
<pre><code class="js">watch: &#123;
  firstName: &#123;
    handler(newName, oldName) &#123;
      this.fullName = newName + &#39; &#39; + this.lastName;
    &#125;,
    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法
    immediate: true
  &#125;
&#125;
</code></pre>
<p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p>
<pre><code class="js">watch: &#123;
  obj: &#123;
    handler(newName, oldName) &#123;
      console.log(&#39;obj.a changed&#39;);
    &#125;,
    immediate: true,
    deep: true
  &#125;
&#125;
</code></pre>
<p>优化：我们可以使用字符串的形式监听</p>
<pre><code class="js">watch: &#123;
  &#39;obj.a&#39;: &#123;
    handler(newName, oldName) &#123;
      console.log(&#39;obj.a changed&#39;);
    &#125;,
    immediate: true,
    // deep: true
  &#125;
&#125;
</code></pre>
<p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p>
<h2 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h2><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。<br>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p>
<h2 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h2><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p>
<blockquote>
<p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
</blockquote>
<p>v-for提升性能的原因:</p>
<p>key相同时，两个VNode会相同，可以避免不必要的DOM更新；而且在diff内部，也会根据key来跟踪VNode。</p>
<h2 id="双向数据绑定原理是什么？"><a href="#双向数据绑定原理是什么？" class="headerlink" title="双向数据绑定原理是什么？"></a>双向数据绑定原理是什么？</h2><blockquote>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
</blockquote>
<p>主要分为以下几个步骤：</p>
<p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
<p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>①在自身实例化时往属性订阅器(dep)里面添加自己<br>②自身必须有一个update()方法<br>③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<h2 id="vue-router路由页面管理"><a href="#vue-router路由页面管理" class="headerlink" title="vue-router路由页面管理"></a>vue-router路由页面管理</h2><blockquote>
<p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
</blockquote>
<p>包含的功能有：</p>
<p>1、嵌套的路由/视图表</p>
<p>2、模块化的、基于组件的路由配置</p>
<p>3、路由参数、查询、通配符</p>
<p>4、基于 Vue.js 过渡系统的视图过渡效果</p>
<p>5、细粒度的导航控制</p>
<p>6、带有自动激活的 CSS class 的链接</p>
<p>7、HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p>
<p>8、自定义的滚动条行为</p>
<blockquote>
<p>1、动态路由匹配</p>
</blockquote>
<p>例如：对不同ID的用户，使用同一个组件来渲染。</p>
<pre><code class="js">const User = &#123;
  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;
&#125;
const router = new VueRouter(&#123;
  routes: [
    // 动态路径参数 以冒号开头
    &#123; path: &#39;/user/:id&#39;, component: User &#125;
  ]
&#125;)
</code></pre>
<p>这样/user/foo 和 /user/bar 都将映射到相同的路由User。</p>
<p>一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p>
<pre><code class="js">const User = &#123;
  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;
&#125;
</code></pre>
<blockquote>
<p>2、编程式的导航<br>router.push({name:””,params:{}})</p>
</blockquote>
<pre><code class="js">  （1）this.$router.push
  // 带参数
  this.$router.push(&#123;
    name:&quot;User&quot;,
    params:&#123;
      userId:&quot;123&quot;
    &#125;
  &#125;)
</code></pre>
<p>router.push({path:””,query:””})</p>
<pre><code class="js">  (2) this.$router.push(&#123;
    path:&quot;/user&quot;,
    query:&#123;
      plan:&quot;private&quot;
    &#125;
  &#125;)
</code></pre>
<p>router.replace()使用方法跟router.push()很像，不会向history添加新纪录，替换掉当前的history记录。<br>router.go()在history记录中向前或者向后多少步。正数为向前多少步，负数为向后多少步</p>
<blockquote>
<p>3、滚动行为</p>
</blockquote>
<p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<blockquote>
<p>注意：这个功能只在支持 history.pushState 的浏览器中可用。</p>
</blockquote>
<pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  if (savedPosition) &#123;
    return savedPosition
  &#125; else &#123;
    return &#123; x: 0, y: 0 &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>4、路由懒加载</p>
</blockquote>
<p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名chunk，一个特殊的注释语法来提供chunk name(需要 Webpack &gt; 2.4)。</p>
<pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)
const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)
const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)
</code></pre>
<h2 id="表单输入控制"><a href="#表单输入控制" class="headerlink" title="表单输入控制"></a>表单输入控制</h2><blockquote>
<p>表单修饰符：如果是简单的控制输入一定是数字或者去掉用户输入的收尾空白符，可以直接使用 Vue 提供的表单修饰符 .number 和 .trim</p>
</blockquote>
<p>1、如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p>
<pre><code class="vue">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;
</code></pre>
<p>2、如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p>
<pre><code class="vue">&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
<blockquote>
<p>change事件:给表单绑定事件，在事件处理中进行表单输入控制</p>
</blockquote>
<pre><code class="html">&lt;input v-model=&quot;value2&quot; type=&quot;text&quot; @change=&quot;inputChange(value2)&quot; /&gt;
</code></pre>
<pre><code class="js">methods: &#123;
  inputChange: function(val) &#123;
    if (!val) return &#39;&#39;
    val = val.toString()
    this.value2 = val.charAt(0).toUpperCase() + val.slice(1)
  &#125;
&#125;
</code></pre>
<blockquote>
<p>filter过滤器</p>
</blockquote>
<pre><code class="html">&lt;input v-model=&quot;value1&quot;  type=&quot;text&quot; /&gt;
</code></pre>
<pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;
  if (!value) return &#39;&#39;
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
&#125;)
</code></pre>
<pre><code class="js">watch: &#123;
  value1(val) &#123;
     this.value1 = this.$options.filters.capitalize(val);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>指令:声明一个全局指令</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="js">// 只能输入正整数,0-9的数字
Vue.directive(&#39;enterIntNumber&#39;, &#123;
  inserted: function (el) &#123;
    let trigger = (el, type) =&gt; &#123;
      const e = document.createEvent(&#39;HTMLEvents&#39;)
      e.initEvent(type, true, true)
      el.dispatchEvent(e)
    &#125;
    el.addEventListener(&quot;keyup&quot;, function (e) &#123;
      let input = e.target;
      let reg = new RegExp(&#39;^\\d&#123;1&#125;\\d*$&#39;);  //正则验证是否是数字
      let correctReg = new RegExp(&#39;\\d&#123;1&#125;\\d*&#39;);  //正则获取是数字的部分
      let matchRes = input.value.match(reg);
      if (matchRes === null) &#123;
        // 若不是纯数字 把纯数字部分用正则获取出来替换掉
        let correctMatchRes = input.value.match(correctReg);
        if (correctMatchRes) &#123;
          input.value = correctMatchRes[0];
        &#125; else &#123;
          input.value = &quot;&quot;;
        &#125;
      &#125;
      trigger(input, &#39;input&#39;)
    &#125;);
  &#125;
&#125;);
</code></pre>
</details>

<pre><code class="html">&lt;!--限制输入正整数--&gt;
&lt;input v-enterIntNumber placeholder=&quot;0&quot; type=&quot;number&quot;&gt;
</code></pre>
<h1 id="Vue渲染目标元素的6种方法"><a href="#Vue渲染目标元素的6种方法" class="headerlink" title="Vue渲染目标元素的6种方法"></a>Vue渲染目标元素的6种方法</h1><p>1、直接创建Vue实例</p>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;vue&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  
  &lt;!-- 这里直接引入cdn源码 --&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
  var app = new Vue(&#123;
    el: &quot;#app&quot;,
    template: &quot;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&quot;,
    data()&#123;
      return&#123;
        message:&#39;Hello Vue.js!&#39;
      &#125;
    &#125;
  &#125;);
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
</details>

<p>2、Vue.extend</p>
<blockquote>
<p>Vue.extend(options) 方式是使用Vue构造器的一个“子类”，其参数同Vue(options)一模一样，唯一的不同是没有 el 属性来指定挂载的DOM元素，所以这里需要通过 $mount() 方法，来手动实现挂载。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
  var app = Vue.extend(&#123;
    el: &quot;#app&quot;,
    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,
    data() &#123;
      return &#123;
        msg: &#39;hello extend&#39;
      &#125;
    &#125;
  &#125;)
  // 注意这里 Vue.extend 方式是生成了一个 Vue 子类，所以需要 new关键字来重新创建，然后手动挂载。
  new app().$mount(&#39;#app&#39;);
  &lt;/script&gt;
</code></pre>
</details>

<p>3.Vue.component</p>
<blockquote>
<p>Vue.component(id, [definition])方式是注册一个名称为id的全局组件，然后我们可以通过使用该组件来，实现目标元素渲染。其中definition 参数同 Vue.extend 中的参数一模一样，方法一样，需要使用$mount()方法手动挂载。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
  // var app = Vue.component(&#39;hello&#39;, &#123;
  //     template:&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,
  //   data() &#123;
  //     return &#123;
  //       msg: &#39;hello component&#39;
  //     &#125;
  //   &#125;
  // &#125;)
  // new app().$mount(&#39;#app&#39;)
  //1、 注册组件
  Vue.component(&#39;hello&#39;, &#123;
    template: &#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&#39;,
    data() &#123;
      return &#123;
        msg: &#39;hello component&#39;
      &#125;
    &#125;
  &#125;)
  // 2、创建Vue实例
  new Vue(&#123;
    el: &quot;#app&quot;,
    template: &#39;&lt;hello /&gt;&#39;
  &#125;)
  &lt;/script&gt;
</code></pre>
<blockquote>
<p>仅仅注册组件式不够的，我们还要通过创建一个Vue实例，才能使用该组件。</p>
</blockquote>
</details>

<p>4、Vue.directive自定义指令</p>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;
    &lt;div v-hello=&quot;msg&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
  Vue.directive(&#39;hello&#39;, &#123;
    bind: function(el, binding) &#123;
      el.innerHTML = &quot;&lt;h1&gt;&quot; + binding.value + &quot;&lt;/h1&gt;&quot;
    &#125;
  &#125;)
  new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        msg: &quot;hello directive 自定义指令&quot;
      &#125;
    &#125;
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>

<p>5、Vue.compile</p>
<blockquote>
<p>Vue.compile(template) 参数也就是 template 模板字符串属性，然后通过替换 Vue实例的 render 函数，来实现渲染。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
      // 参数就是template模板字符串  然后通过替换Vue实例的render函数来实现渲染
  var tpl = Vue.compile(&#39;&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;&#39;)
  new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        msg: &quot;hello,compile&quot;
      &#125;
    &#125;,
    render: tpl.render
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>

<p>6、render</p>
<blockquote>
<p>Vue实例在创建的过程中也会调用 render 函数，render 函数默认会传递一个参数,我们可以通过 createElement 来动态创建一个 VNode，以此来渲染目标元素</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
  new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        msg: &#39;hello,render&#39;
      &#125;
    &#125;,
    render: function(createElement) &#123;
      return createElement(&#39;h1&#39;, this.msg)
    &#125;
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>


<h1 id="data-computed-watch"><a href="#data-computed-watch" class="headerlink" title="data/computed/watch"></a>data/computed/watch</h1><p>1、data</p>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;
        &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script&gt;
  var app = new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        count: 1,
        list: [&#123;
          name: &#39;vue js&#39;,
          url: &#39;https://cn.vuejs.org&#39;
        &#125;, &#123;
          name: &#39;github&#39;,
          url: &#39;https://github.com&#39;
        &#125;, &#123;
          name: &#39;blog&#39;,
          url: &#39;issummer.cn&#39;
        &#125;]
      &#125;
    &#125;,
    methods: &#123;
      addItem() &#123;
        this.count++
        this.list.push(&#123;
          name: &#39;baidu&#39; + this.count,
          url: &#39;https://www.baidu.com&#39;
        &#125;)
      &#125;
    &#125;
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>

<p>2、computed</p>
<blockquote>
<p>computed 中的属性是需要先进行计算，然后再返回想要的数据的。当我们输出某个属性，必须依赖另外一个 data 中的属性来动态计算获得的，此时使用 computed 就非常简单了。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;
      &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt;
      &lt;ul&gt;
          &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;
              &lt;a :href=&quot;item.url&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;
          &lt;/li&gt;
      &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script&gt;
  var app = new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        count: 1,
        // 这里是后台数据
        requestList: [
          &#39;vuejs https://cn.vuejs.org&#39;,
          &#39;github https://github.com&#39;,
          &#39;blog https://issummer.cn&#39;
        ]
      &#125;
    &#125;,
    computed: &#123;
      list: function() &#123;
        var list = []
        this.requestList.map(function(item, index) &#123;
          var tempArr = item.split(&#39;-&#39;)
          list.push(&#123;
            name: tempArr[0],
            url: tempArr[1]
          &#125;)
        &#125;)
        return list
      &#125;
    &#125;,
    methods: &#123;
      addItem() &#123;
        this.count++
        this.requestList.push(&#39;blog&#39; + this.count + &#39;issummer.cn&#39;)
      &#125;
    &#125;
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>

<blockquote>
<p>计算是可以修改的,计算属性不仅可以定义为一个函数，也可以定义为一个含有 get/set 属性的对象。当我们定义为一个函数是，Vue 内部会默认将这个函数赋值给 get 属性，一般 set 是未定义的。当我们定义 set 属性后，就可以对它进行修改了。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;
    &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;
  &lt;/div&gt;
  &lt;script&gt;
  var app = new Vue(&#123;
    el: &quot;#app&quot;,
    data() &#123;
      return &#123;
        firstName: &#39;Jude&#39;,
        lastName: &#39;Summer&#39;
      &#125;
    &#125;,
    computed: &#123;
      username: &#123;
        get: function() &#123;
          return this.firstName + &#39; &#39; + this.lastName
        &#125;,
        set: function(newVal) &#123;
          var names = newVal.split(&#39; &#39;);
          this.firstName = names[0];
          this.lastName = names[1];
        &#125;
      &#125;
    &#125;,
    methods:&#123;
        changeName()&#123;
            if(this.username === &#39;Jude Summer&#39;)&#123;
                this.username = &quot;YQ&quot;
            &#125;else&#123;
                this.username = &#39;Jude Summer&#39;
            &#125;
        &#125;
    &#125;
  &#125;)
  &lt;/script&gt;
</code></pre>
</details>

<p>3、watch侦听器</p>
<blockquote>
<p>创建 Vue 应用时，我们还提到过 watch 这个属性，它其实是个对象，键是需要观察的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。和上面的计算属性类似，他可以监听 值/表达式 的变化来执行回调函数。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="html">    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;changeName&quot;&gt;改变姓名&lt;/button&gt;
        &lt;h2&gt;&#123;&#123; username &#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var app = new Vue(&#123;
            el: &quot;#app&quot;,
            data() &#123;
                return &#123;
                    firstName: &#39;Jude&#39;,
                    lastName: &#39;Summer&#39;,
                    username: &#39;Jude Summer&#39;
                &#125;
            &#125;,
            watch: &#123;
                firstName: function (val, oldVal) &#123;
                    this.username = val + &#39; &#39; + this.lastName;
                &#125;,
                lastName: function (val, oldVal) &#123;
                    this.username = this.firstName + &#39; &#39; + val;
                &#125;
            &#125;,
            methods: &#123;
                changeName() &#123;
                    if (this.username === &#39;Jude Summer&#39;) &#123;
                        this.firstName = &quot;Y&quot;;
                        this.lastName = &quot;Q&quot;;
                    &#125; else &#123;
                        this.firstName = &quot;Jude&quot;;
                        this.lastName = &quot;Summer&quot;;
                    &#125;
                &#125;
            &#125;,
        &#125;)

    &lt;/script&gt;
    // 监听对象属性
    &lt;script&gt;
        var app = new Vue(&#123;
            el: &quot;#app&quot;,
            data() &#123;
                return &#123;
                    userinfo: &#123;
                        firstName: &#39;Jude&#39;,
                        lastName: &#39;Summer&#39;
                    &#125;,
                    username: &quot;Jude Summer&quot;
                &#125;
            &#125;,
            watch: &#123;
                // 此时无论我们如何点击按钮，都无法改变 username 的值，因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听
                userinfo: function (val, oldVal) &#123;
                    this.username = val.firstName + &#39; &#39; + val.lastName;
                &#125;
            &#125;,
            methods: &#123;
                changeName: function () &#123;
                    if (this.username === &#39;Jude Summer&#39;) &#123;
                        this.userinfo.firstName = &#39;Y&#39;
                        this.userinfo.lastName = &#39;Q&#39;
                    &#125; else &#123;
                        this.userinfo.firstName = &quot;Jude&quot;
                        this.userinfo.lastName = &quot;Summer&quot;
                    &#125;
                &#125;
            &#125;,
        &#125;)
    &lt;/script&gt;
    // 上面的方法是无法修改username的值 因为 watch 侦听器默认只是侦听该对象本身的赋值操作，也就是直接对 this.userinfo 进行赋值操作时的变化，并未对其内部属性进行侦听。实际上对于侦听的值是可以为一个对象的，它还有个 deep 属性，用来设置是否侦听内部属性的变化，而回调函数是通过 handler 来设置的
     &lt;script&gt;
        var app = new Vue(&#123;
            el: &quot;#app&quot;,
            data() &#123;
                return &#123;
                    userinfo: &#123;
                        firstName: &#39;Jude&#39;,
                        lastName: &#39;Summer&#39;
                    &#125;,
                    username: &quot;Jude Summer&quot;
                &#125;
            &#125;,
            watch: &#123;
                // depp属性用来侦听内部属性变化，回调函数是通过hander来设置
                // 适用于非整体赋值  也就是适用于局部修改属性，这个时候通过设置deep属性为true，来达到侦听目的。
                userinfo: &#123;
                    deep: true,
                    handler: function (val, oldVal) &#123;
                        this.username = val.firstName + &quot; &quot; + val.lastName;
                    &#125;
                &#125;
            &#125;,
            methods: &#123;
                // 修改名字
                changeName: function () &#123;
                    if (this.username === &#39;Jude Summer&#39;) &#123;
                        this.userinfo.firstName = &#39;Y&#39;
                        this.userinfo.lastName = &#39;Q&#39;
                    &#125; else &#123;
                        this.userinfo.firstName = &quot;Jude&quot;
                        this.userinfo.lastName = &quot;Summer&quot;
                    &#125;
                &#125;
            &#125;,
        &#125;)
    &lt;/script&gt;
    // 写成对象属性访问表达式的    当侦听对象包含很多属性，而我们只是需要监听其中的一个或某几个属性，这时如果我们通过这种方式侦听所有内部属性的变化，自然就会造成内存的浪费。那么我们可以只侦听单一内部属性的变化
    &lt;script&gt;
        var app = new Vue(&#123;
            el: &quot;#app&quot;,
            data() &#123;
                return &#123;
                    userinfo: &#123;
                        firstName: &#39;Jude&#39;,
                        lastName: &#39;Summer&#39;
                    &#125;,
                    username: &quot;Jude Summer&quot;
                &#125;
            &#125;,
            watch: &#123;
                // 侦听对象的某个属性
                &#39;userinfo.lastName&#39;:function(val,oldVal)&#123;
                    this.username = this.userinfo.firstName + &#39; &#39; + val;
                &#125;
            &#125;,
            methods: &#123;
                // 修改名字
                changeName: function () &#123;
                    if (this.username === &#39;Jude Summer&#39;) &#123;
                        // this.userinfo.firstName = &#39;Y&#39;
                        this.userinfo.lastName = &#39;Q&#39;
                    &#125; else &#123;
                        // this.userinfo.firstName = &quot;Jude&quot;
                        this.userinfo.lastName = &quot;Summer&quot;
                    &#125;
                &#125;
            &#125;,
        &#125;)
    &lt;/script&gt;
</code></pre>
</details>

<h1 id="v-on对象语法"><a href="#v-on对象语法" class="headerlink" title="v-on对象语法"></a>v-on对象语法</h1><blockquote>
<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>
</blockquote>
<p>通常的写法：</p>
<pre><code class="html">&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;
</code></pre>
<p>对象语法: </p>
<pre><code class="html">&lt;div v-on=&quot;&#123; mouseenter: ShowInfo, mouseleave: HideInfo &#125;&quot;&gt;
  &lt;div&gt;我是title&lt;/div&gt;
  &lt;div v-show=&quot;ShowWrapper&quot;&gt;我是显示的内容！&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h1><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><blockquote>
<p>有时候，我们需要将router-link渲染成某种标签，例如<code>&lt;li&gt;&lt;/li&gt;</code>使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航</p>
</blockquote>
<p>示例:</p>
<pre><code class="html">&lt;ul class=&quot;nav-list&quot;&gt;
  &lt;router-link tag=&quot;li&quot; to=&quot;home&quot;&gt;home&lt;/router-link&gt;
&lt;/ul&gt;
&lt;!-- 渲染的结果为 --&gt;
&lt;li&gt;home&lt;/li&gt;
</code></pre>
<h1 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h1><blockquote>
<p>可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。提供具名插槽或需要接收 prop 的插槽。</p>
</blockquote>
<pre><code class="html">&lt;!-- 父组件 --&gt;
&lt;template&gt;
    &lt;div class=&quot;common-card&quot;&gt;
    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;
    &lt;div class=&quot;value&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/div&gt;
    &lt;div class=&quot;chart&quot;&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;total&quot;&gt;
      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="html">&lt;!-- 子组件 --&gt;
  &lt;common-card title=&quot;今日交易用户数&quot; :value=&quot;1234567890&quot;&gt;
    &lt;template&gt;
      &lt;v-chart :options=&quot;getOptions()&quot; /&gt;
    &lt;/template&gt;
    &lt;template v-slot:footer&gt;
      &lt;span&gt;退货率&lt;/span&gt;
      &lt;span class=&quot;emphasis&quot;&gt;12%&lt;/span&gt;
    &lt;/template&gt;
  &lt;/common-card&gt;
</code></pre>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote>
<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p>
</blockquote>
<blockquote>
<p>常用于父组件与子组件的通信<br>对象语法选项包括:</p>
</blockquote>
<p>1、type：原生构造函数的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。</p>
<p>2、default: any 默认值</p>
<p>3、required:Boolean 该prop是否是必填项</p>
<p>4、validator: Function 校验函数</p>
<pre><code class="js">  props: &#123;
    // 检测类型
    title: String,
    // 检测类型 + 其他验证
    age: &#123;
      type: Number, //类型
      default: 0,// 默认值
      required: true,// 是否是必填项
      // 校验函数
      validator: function (value) &#123;
        return value &gt;= 0
      &#125;
    &#125;
  &#125;
</code></pre>
<h1 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h1><blockquote>
<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>
</blockquote>
<p>1、实现原理</p>
<blockquote>
<p>将用户传入的对象与 Vue 自身的options属性合并，合并后的对象将会覆盖原来的Vue.options。因为 mixin 方法修改了Vue.options属性，之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。</p>
</blockquote>
<p>注意：如果用户传入的对象与组件有相同的数据对象，将会发生合并，并且遵循组件数据优先的原则。对于钩子函数来说，如果相同，将会合并为一个数组，所以都会被调用，只是混入对象的钩子会被先调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<pre><code class="js">// vue源码 vue/src/core/global-api/mixin.js
import &#123; mergeOptions &#125; from &#39;../util/index&#39;

export function initMixin (Vue: GlobalAPI) &#123;
  Vue.mixin = function (mixin: Object) &#123;
    this.options = mergeOptions(this.options, mixin)
    return this
  &#125;
&#125;
</code></pre>
<p>2、如何理解mixin?</p>
<p>可以将mixin理解为数组，数组中有单个或者多个mixin，mixin的本质就是js对象，拥有Vue实例的所有属性，例如：data,created,methods等，还可以在mixin中再次嵌套mixin</p>
<p>注意：在组件中引入的方式为 <code>mixins:[myMixin]</code></p>
<p>3、mixin的实现</p>
<blockquote>
<p>当Vue在实例的时候，会调用mergeOptions函数进行options的合并</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="js">// vue源码 core/util/options.js
export function mergeOptions(
  parent: Object,
  child: Object,
  vm?: Component
): Object &#123;
  ...
  // 如果有 child.extends 递归调用 mergeOptions 实现属性拷贝
  const extendsFrom = child.extends
  if (extendsFrom) &#123;
    parent = mergeOptions(parent, extendsFrom, vm)
  &#125;
  // 如果有 child.mixins 递归调用 mergeOptions 实现属性拷贝
  if (child.mixins) &#123;
    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;
      parent = mergeOptions(parent, child.mixins[i], vm)
    &#125;
  &#125;
  // 申明 options 空对象，用来保存属性拷贝结果
  const options = &#123;&#125;
  let key
  // 遍历 parent 对象，调用 mergeField 进行属性拷贝
  for (key in parent) &#123;
    mergeField(key)
  &#125;
  // 遍历 child 对象，调用 mergeField 进行属性拷贝
  for (key in child) &#123;
    if (!hasOwn(parent, key)) &#123;
      mergeField(key)
    &#125;
  &#125;
  // 属性拷贝实现方法 mergeField 函数接收一个 key，首先会申明 strat 变量，如果 strats[key] 为真，就将 strats[key] 赋值给 strat。
  function mergeField(key) &#123;
    // 穿透赋值，默认为 defaultStrat
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  &#125;
  return options
&#125;
</code></pre>
</details>

<blockquote>
<p>vue 中 mixins 的优先级，component &gt; mixins &gt; extends。</p>
</blockquote>
<h1 id="边界处理：inject-provide"><a href="#边界处理：inject-provide" class="headerlink" title="边界处理：inject/provide"></a>边界处理：inject/provide</h1><p>类型：</p>
<blockquote>
<p>provide：Object | () =&gt; Object</p>
</blockquote>
<blockquote>
<p>inject：Array<string> | { [key: string]: string | Symbol | Object }</p>
</blockquote>
<p>provide和inject需要一起使用，可以允许一个祖先组件向其所有子孙后代注入一个依赖，不管组件的层次有多深，并在其上下游关系成立的时间里始终生效。</p>
<p>同react的上下文特性相似</p>
<details>
<summary>点击展示代码</summary>

<pre><code class="js">// 父级组件提供 &#39;foo&#39;
var Provider = &#123;
  provide: &#123;
    foo: &#39;bar&#39;
  &#125;,
  // ...
&#125;

// 子组件注入 &#39;foo&#39;
var Child = &#123;
  inject: [&#39;foo&#39;],
  created () &#123;
    console.log(this.foo) // =&gt; &quot;bar&quot;
  &#125;
  // ...
&#125;
</code></pre>
</details>

<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单的说，vuex就是一个状态管理器。</p>
</blockquote>
<p>开发过程，通常会遇到多个视图依赖同一个状态，不同视图的行为需要变更为同一状态（例如：后台管理系统的侧边栏的收缩功能。）</p>
<p>Vuex的核心就是store，它就是一个仓库容器，包含了驱动应用的数据源（state），不同于单纯的全局对象，vuex的状态存储是响应式的，当 Vue组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2019/11/13/mohu-search/" title="Vue实现模糊搜索"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Vue实现模糊搜索</span></a><a class="button is-default" href="/2019/08/18/DOMContentLoaded/" title="DOMContentLoaded"><span class="has-text-weight-semibold">下一页: DOMContentLoaded</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
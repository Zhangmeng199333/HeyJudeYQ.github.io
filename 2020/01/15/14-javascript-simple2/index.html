<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>14、整理javascript知识(二)</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="在 JavaScript 中，作用域是指变量在代码中可访问的范围。理解 JavaScript 的作用域和作用域链对于编写高质量的代码至关重要。本文将详细介绍 JavaScript 中的词法作用域、作用域链和闭包的概念，并探讨它们在实际开发中的应用场景。


一、闭包1、什么是闭包？
一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。— from MDN

闭包是指函数和其词法环境的组合。它可以访问其词法作用域中定义的变量，即使在函数外部也可以访问这些变量。闭包.."><meta name="generator" content="Hexo 7.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">14、整理javascript知识(二)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-text">一、闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-text">1、什么是闭包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2、词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E5%BD%93%E5%81%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">3、函数当做值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%97%AD%E5%8C%85%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">4、闭包的缺点：造成内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">二、作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1、作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">2、作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">三、原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/js"><i class="tag post-item-tag">js</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">14、整理javascript知识(二)</h1><time class="has-text-grey" datetime="2020-01-14T16:00:00.000Z">2020-01-15</time><article class="mt-2 post-content"><p>在 JavaScript 中，作用域是指变量在代码中可访问的范围。理解 JavaScript 的作用域和作用域链对于编写高质量的代码至关重要。本文将详细介绍 JavaScript 中的词法作用域、作用域链和闭包的概念，并探讨它们在实际开发中的应用场景。</p>
<span id="more"></span>

<h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h3><blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，<u>闭包让你可以在一个内层函数中访问到其外层函数的作用域</u>。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。— from MDN</p>
</blockquote>
<p>闭包是指函数和其词法环境的组合。它可以访问其词法作用域中定义的变量，即使在函数外部也可以访问这些变量。闭包在 JavaScript 中常用于创建私有变量和实现模块化开发。</p>
<p>javascript 闭包的本质源自 2 点：词法作用域和函数当做值传递。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count++<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">createCounter</span>()<br><span class="hljs-title function_">counter</span>() <span class="hljs-comment">// 输出: 1</span><br><span class="hljs-title function_">counter</span>() <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure>

<p>闭包的应用场景：<br>私有变量：闭包提供了一种实现私有变量的机制，可以隐藏变量并提供访问控制。<br>模块化开发：通过创建闭包，可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。<br>延迟执行：通过使用闭包，可以延迟执行函数，实现异步操作和事件处理。</p>
<h3 id="2、词法作用域"><a href="#2、词法作用域" class="headerlink" title="2、词法作用域"></a>2、词法作用域</h3><p>词法作用域是 JavaScript 中最常见的作用域类型。它是在代码编写阶段确定的，而不是在代码执行阶段确定的。在词法作用域中，变量的访问权限是由它们在代码中的位置决定的。</p>
<!-- > 按照代码的书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这个变量就登记在相应的数据结构中。 -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 局部变量</span><br>  <span class="hljs-keyword">var</span> outerName = <span class="hljs-string">&#x27;jude&#x27;</span><br>  <span class="hljs-comment">// 内部函数，一个闭包</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerName = <span class="hljs-string">&#x27;summer&#x27;</span><br>    <span class="hljs-comment">// 父函数中声明的变量</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerName + innerName)<br>  &#125;<br>  <span class="hljs-title function_">displayName</span>()<br>&#125;<br><span class="hljs-title function_">init</span>() <span class="hljs-comment">// jude summer</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，函数 displayName 内部可以访问外部函数 init 中定义的变量 outerName，这是因为它们处于词法作用域中。词法作用域确保了变量在代码编写阶段就能够正确地被访问。</p>
<p>name、displayName()是 init()函数的一个局部变量和一个内部函数，displayName()函数没有自己的局部变量，但是它可以访问到外部函数的变量，所以 displayName()可以使用父函数 init()中声明的变量 outerName。</p>
<p>词法作用域的应用场景：<br>1、变量访问控制：词法作用域使得我们可以控制变量的可见性和访问权限，避免命名冲突和变量污染。<br>2、模块化开发：通过使用函数和闭包，可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。<br>3、函数嵌套：函数嵌套是 JavaScript 中常见的编程模式，词法作用域确保了内部函数可以访问外部函数的变量，实现了信息的隐藏和封装。</p>
<h3 id="3、函数当做值传递"><a href="#3、函数当做值传递" class="headerlink" title="3、函数当做值传递"></a>3、函数当做值传递</h3><blockquote>
<p>即所谓的 first class 对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。</p>
</blockquote>
<p>闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。</p>
<h3 id="4、闭包的缺点：造成内存泄漏"><a href="#4、闭包的缺点：造成内存泄漏" class="headerlink" title="4、闭包的缺点：造成内存泄漏"></a>4、闭包的缺点：造成内存泄漏</h3><blockquote>
<p>如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。所以闭包不要乱用，少打包一点东西到堆内存。</p>
</blockquote>
<h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><h3 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h3><blockquote>
<p>作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。</p>
</blockquote>
<p>作用域分为函数作用域、全局作用域</p>
<blockquote>
<p>全局作用域：代码在程序任何地方都能访问，例如 window 对象<br>函数作用域： 固定代码片段中才能被访问</p>
</blockquote>
<p>JavaScript 引擎会把内存分为函数调用栈、全局作用域和堆，其中堆用于放一些动态的对象，调用栈每一个栈帧放一个函数的执行上下文，里面有一个 local 变量环境用于放内部声明的一些变量，如果是对象，会在堆上分配空间，然后把引用保存在栈帧的 local 环境中。全局作用域也是一样，只不过一般用于放静态的一些东西，有时候也叫静态域。</p>
<p>每个栈帧的执行上下文包含函数执行需要访问的所有环境，包括 local 环境、作用域链、this 等。</p>
<p>作用域最大的用处：隔离变量，不同作用域下同名变量不会有冲突。</p>
<h3 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h3><p>作用域链是 JavaScript 中用于查找变量的一种机制。它由当前作用域和所有父级作用域的变量对象组成。当访问一个变量时，JavaScript 引擎会首先在当前作用域的变量对象中查找，如果找不到，则沿着作用域链向上查找，直到找到变量或者到达全局作用域。</p>
<blockquote>
<p>在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。</p>
</blockquote>
<p>⼀般情况下，变量取值到创建这个变量的函数的作⽤域中取值，但是如果在当前作⽤域中没有查到值，就会向上级作⽤域去查，直到查到全局作⽤域，这么⼀个查找过程形成的链条就叫做作⽤域链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> globalVariable = <span class="hljs-string">&#x27;Global&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVariable = <span class="hljs-string">&#x27;Hello&#x27;</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> innerVariable = <span class="hljs-string">&#x27;World&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVariable + <span class="hljs-string">&#x27; &#x27;</span> + outerVariable + <span class="hljs-string">&#x27; &#x27;</span> + innerVariable)<br>  &#125;<br><br>  <span class="hljs-title function_">inner</span>()<br>&#125;<br><br><span class="hljs-title function_">outer</span>() <span class="hljs-comment">// 输出: Global Hello World</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，函数 inner 内部可以访问全局作用域中定义的变量 globalVariable，以及外部函数 outer 中定义的变量 outerVariable，这是因为 JavaScript 引擎按照作用域链的顺序查找变量。</p>
<p>作用域链的应用场景</p>
<p>作用域链在 JavaScript 中有多种应用场景，包括：<br>1、变量查找：作用域链决定了变量的查找顺序，使得 JavaScript 可以正确地找到并访问变量。<br>2、闭包：通过创建闭包，内部函数可以访问外部函数的变量，实现了信息的保留和共享。<br>3、模块化开发：作用域链的特性使得我们可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><blockquote>
<p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找， 如果没有找到，则会去它的<strong>proto</strong>隐式原型上查找，即它的构造函数的 prototype， 如果还没有找到就会再在构造函数的 prototype 的<strong>proto</strong>中查找， 这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p>
</blockquote>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><blockquote>
<p>作用域、作用域链和闭包是 JavaScript 中重要的概念，它们相互关联，共同构建了 JavaScript 的变量访问和代码组织机制。理解这些概念的原理和应用场景对于编写高质量的 JavaScript 代码至关重要。</p>
</blockquote>
<p>通过词法作用域，我们可以控制变量的可见性和访问权限，实现模块化的代码组织，避免命名冲突和变量污染。</p>
<p>作用域链决定了变量的查找顺序，使得 JavaScript 可以正确地找到并访问变量。同时，作用域链的特性也为闭包的创建提供了基础，通过闭包，我们可以创建私有变量，实现模块化的代码组织以及延迟执行函数等。</p>
<p>深入理解作用域、作用域链和闭包，能够帮助我们更好地编写可维护、高效的 JavaScript 代码。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/02/09/15-oh-my-zsh/" title="15、解决oh-my-zsh启动时出现多行提示"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 15、解决oh-my-zsh启动时出现多行提示</span></a><a class="button is-default" href="/2020/01/12/13-javascript-simple/" title="13、整理javascript知识(一)"><span class="has-text-weight-semibold">下一页: 13、整理javascript知识(一)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>axios的封装</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
axios 基于promise的http库  特性：拦截请求和响应、取消请求、转换json、客户端防御XSRF


当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。
所以记住：

在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。

service.interceptors.response.use(
  (response) =&amp;gt; &amp;#123;
    if (response.status === 200 &amp;amp;&amp;amp; response.data) &amp;#123;
      return response.data;
    &amp;#125; else &amp;#123;
      retur.."><meta name="generator" content="Hexo 6.0.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">HeyJudeYQ's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">axios的封装</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81axios%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">1、axios的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9C%A8request%E6%96%87%E4%BB%B6%E5%A4%B9http-js"><span class="toc-text">2、在request文件夹http.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%87%E6%8D%A2-%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6-post%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE"><span class="toc-text">3、环境的切换&#x2F;请求超时&#x2F;post请求头设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA-%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA"><span class="toc-text">4、请求拦截 响应拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81get%E3%80%81post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">5、get、post请求的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81axios%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81"><span class="toc-text">6、axios完整封装代码:</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/axios"><i class="tag post-item-tag">axios</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">axios的封装</h1><time class="has-text-grey" datetime="2020-04-23T12:00:00.000Z">2020-04-23</time><article class="mt-2 post-content"><blockquote>
<p>axios 基于promise的http库  特性：拦截请求和响应、取消请求、转换json、客户端防御XSRF</p>
</blockquote>
<span id="more"></span>
<p>当后端接口报了 500 错误时被 axios 拦截了但确并未返回一个 promise，导致业务代码中未捕获此错误。</p>
<p>所以记住：</p>
<blockquote>
<p>在每个 promise 链条中必须返回 promise，否则调用结果可能和你预期不一样。</p>
</blockquote>
<pre><code class="js">service.interceptors.response.use(
  (response) =&gt; &#123;
    if (response.status === 200 &amp;&amp; response.data) &#123;
      return response.data;
    &#125; else &#123;
      return Promise.reject(new Error(&quot;请求失败&quot;));
    &#125;
  &#125;,
  (error) =&gt; &#123;
    return Promise.reject(error);
  &#125;
);
</code></pre>
<h3 id="1、axios的安装"><a href="#1、axios的安装" class="headerlink" title="1、axios的安装"></a>1、axios的安装</h3><pre><code class="js">npm install axios
</code></pre>
<h3 id="2、在request文件夹http-js"><a href="#2、在request文件夹http-js" class="headerlink" title="2、在request文件夹http.js"></a>2、在request文件夹http.js</h3><pre><code class="js">// http.js
import axios from &quot;axios&quot;
import QS from &quot;qs&quot;   // 序列化post类型的数据
import &#123; Toast &#125; from &quot;vant&quot;  // 引入vant组件库的toast组件
</code></pre>
<h3 id="3、环境的切换-请求超时-post请求头设置"><a href="#3、环境的切换-请求超时-post请求头设置" class="headerlink" title="3、环境的切换/请求超时/post请求头设置"></a>3、环境的切换/请求超时/post请求头设置</h3><pre><code class="js">// 环境的切换
if (process.env.NODE_ENV == &#39;development&#39;) &#123;    
    axios.defaults.baseURL = &#39;https://www.baidu.com&#39;;&#125; 
else if (process.env.NODE_ENV == &#39;debug&#39;) &#123;    
    axios.defaults.baseURL = &#39;https://www.ceshi.com&#39;;
&#125; 
else if (process.env.NODE_ENV == &#39;production&#39;) &#123;    
    axios.defaults.baseURL = &#39;https://www.production.com&#39;;
&#125;

axios.defaults.timeout = 10000;

axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;;
</code></pre>
<h3 id="4、请求拦截-响应拦截"><a href="#4、请求拦截-响应拦截" class="headerlink" title="4、请求拦截 响应拦截"></a>4、请求拦截 响应拦截</h3><details>
<summary>点击展示代码</summary>

<pre><code class="js">// 先导入vuex,因为我们要使用到里面的状态对象
// vuex的路径根据自己的路径去写
import store from &#39;@/store/index&#39;;

// 请求拦截器
axios.interceptors.request.use(    
    config =&gt; &#123;        
        // 每次发送请求之前判断vuex中是否存在token        
        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况
        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 
        const token = store.state.token;        
        token &amp;&amp; (config.headers.Authorization = token);        
        return config;    
    &#125;,    
    error =&gt; &#123;        
        return Promise.error(error);    
    &#125;
)

// 响应拦截器
axios.interceptors.response.use(    
    response =&gt; &#123;   
        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     
        // 否则的话抛出错误
        if (response.status === 200) &#123;            
            return Promise.resolve(response);        
        &#125; else &#123;            
            return Promise.reject(response);        
        &#125;    
    &#125;,    
    // 服务器状态码不是2开头的的情况
    // 这里可以跟你们的后台开发人员协商好统一的错误状态码    
    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等
    // 下面列举几个常见的操作，其他需求可自行扩展
    error =&gt; &#123;            
        if (error.response.status) &#123;            
            switch (error.response.status) &#123;                
                // 401: 未登录
                // 未登录则跳转登录页面，并携带当前页面的路径
                // 在登录成功后返回当前页面，这一步需要在登录页操作。                
                case 401:                    
                    router.replace(&#123;                        
                        path: &#39;/login&#39;,                        
                        query: &#123; 
                            redirect: router.currentRoute.fullPath 
                        &#125;
                    &#125;);
                    break;
                // 403 token过期
                // 登录过期对用户进行提示
                // 清除本地token和清空vuex中token对象
                // 跳转登录页面                
                case 403:
                     Toast(&#123;
                        message: &#39;登录过期，请重新登录&#39;,
                        duration: 1000,
                        forbidClick: true
                    &#125;);
                    // 清除token
                    localStorage.removeItem(&#39;token&#39;);
                    store.commit(&#39;loginSuccess&#39;, null);
                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 
                    setTimeout(() =&gt; &#123;                        
                        router.replace(&#123;                            
                            path: &#39;/login&#39;,                            
                            query: &#123; 
                                redirect: router.currentRoute.fullPath 
                            &#125;                        
                        &#125;);                    
                    &#125;, 1000);                    
                    break; 

                // 404请求不存在
                case 404:
                    Toast(&#123;
                        message: &#39;网络请求不存在&#39;,
                        duration: 1500,
                        forbidClick: true
                    &#125;);
                    break;
                // 其他错误，直接抛出错误提示
                default:
                    Toast(&#123;
                        message: error.response.data.message,
                        duration: 1500,
                        forbidClick: true
                    &#125;);
            &#125;
            return Promise.reject(error.response);
        &#125;
    &#125;    
&#125;);
</code></pre>
</details>

<h3 id="5、get、post请求的封装"><a href="#5、get、post请求的封装" class="headerlink" title="5、get、post请求的封装"></a>5、get、post请求的封装</h3><blockquote>
<p>get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="js">/**
 * get方法，对应get请求
 * @param &#123;String&#125; url [请求的url地址]
 * @param &#123;Object&#125; params [请求时携带的参数]
 */
export function get(url, params)&#123;    
    return new Promise((resolve, reject) =&gt;&#123;        
        axios.get(url, &#123;            
            params: params        
        &#125;).then(res =&gt; &#123;
            resolve(res.data);
        &#125;).catch(err =&gt;&#123;
            reject(err.data)        
    &#125;)    
&#125;);
&#125;
</code></pre>
</details>

<blockquote>
<p>原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因</p>
</blockquote>
<details>
<summary>点击展示代码</summary>

<pre><code class="js">/** 
 * post方法，对应post请求 
 * @param &#123;String&#125; url [请求的url地址] 
 * @param &#123;Object&#125; params [请求时携带的参数] 
 */
export function post(url, params) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
         axios.post(url, QS.stringify(params))
        .then(res =&gt; &#123;
            resolve(res.data);
        &#125;)
        .catch(err =&gt;&#123;
            reject(err.data)
        &#125;)
    &#125;);
&#125;
</code></pre>
</details>

<h3 id="6、axios完整封装代码"><a href="#6、axios完整封装代码" class="headerlink" title="6、axios完整封装代码:"></a>6、axios完整封装代码:</h3><details>
<summary>点击展示代码</summary>

<pre><code class="js">/**
 * axios封装
 * 请求拦截、响应拦截、错误统一处理
 */
import axios from &#39;axios&#39;;
import router from &#39;../router&#39;;
import store from &#39;../store/index&#39;;
import &#123; Toast &#125; from &#39;vant&#39;;

/** 
 * 提示函数 
 * 禁止点击蒙层、显示一秒后关闭
 */
const tip = msg =&gt; &#123;    
    Toast(&#123;        
        message: msg,        
        duration: 1000,        
        forbidClick: true    
    &#125;);
&#125;

/** 
 * 跳转登录页
 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面
 */
const toLogin = () =&gt; &#123;
    router.replace(&#123;
        path: &#39;/login&#39;,        
        query: &#123;
            redirect: router.currentRoute.fullPath
        &#125;
    &#125;);
&#125;

/** 
 * 请求失败后的错误统一处理 
 * @param &#123;Number&#125; status 请求失败的状态码
 */
const errorHandle = (status, other) =&gt; &#123;
    // 状态码判断
    switch (status) &#123;
        // 401: 未登录状态，跳转登录页
        case 401:
            toLogin();
            break;
        // 403 token过期
        // 清除token并跳转登录页
        case 403:
            tip(&#39;登录过期，请重新登录&#39;);
            localStorage.removeItem(&#39;token&#39;);
            store.commit(&#39;loginSuccess&#39;, null);
            setTimeout(() =&gt; &#123;
                toLogin();
            &#125;, 1000);
            break;
        // 404请求不存在
        case 404:
            tip(&#39;请求的资源不存在&#39;); 
            break;
        default:
            console.log(other);   
        &#125;&#125;

// 创建axios实例
var instance = axios.create(&#123;    timeout: 1000 * 12&#125;);
// 设置post请求头
instance.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;
/** 
 * 请求拦截器 
 * 每次请求前，如果存在token则在请求头中携带token 
 */ 
instance.interceptors.request.use(    
    config =&gt; &#123;        
        // 登录流程控制中，根据本地是否存在token判断用户的登录情况        
        // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token        
        // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码        
        // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。        
        const token = store.state.token;        
        token &amp;&amp; (config.headers.Authorization = token);        
        return config;    
    &#125;,    
    error =&gt; Promise.error(error)
)

// 响应拦截器
instance.interceptors.response.use(    
    // 请求成功
    res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res),    
    // 请求失败
    error =&gt; &#123;
        const &#123; response &#125; = error;
        if (response) &#123;
            // 请求已发出，但是不在2xx的范围 
            errorHandle(response.status, response.data.message);
            return Promise.reject(response);
        &#125; else &#123;
            // 处理断网的情况
            // eg:请求超时或断网时，更新state的network状态
            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏
            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明
            if (!window.navigator.onLine) &#123;
               store.commit(&#39;changeNetwork&#39;, false);
            &#125; else &#123;
                return Promise.reject(error);
            &#125;
        &#125;
    &#125;);

export default instance;
</code></pre>
</details></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/04/28/time/" title="时间格式化"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 时间格式化</span></a><a class="button is-default" href="/2020/04/20/echarts/" title="关于echarts官方的一个bug -- sublink跳转问题"><span class="has-text-weight-semibold">下一页: 关于echarts官方的一个bug -- sublink跳转问题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/HeyJudeYQ"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> HeyJudeYQ 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>